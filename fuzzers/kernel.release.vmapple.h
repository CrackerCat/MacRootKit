/*
   This file has been generated by IDA.
   It contains local type definitions from
   the type library 'kernel.release.vmapple'
*/

#define __int8 char
#define __int16 short
#define __int32 int
#define __int64 long long

struct mach_header_64;
struct mach_msg_header_t;
struct mach_msg_type_descriptor_t;
struct ccdigest_state;
struct ccdigest_ctx;
struct sysctl_oid;
struct sysctl_req;
struct OSMetaClass;
struct OSMetaClassBase;
struct OSMetaClassBase_vtbl;
struct OSSerialize;
struct OSObject;
struct OSArray;
struct OSData;
struct IORPCMessageMach;
struct OSSymbol;
struct OSDictionary;
struct OSDictionary::dictEntry;
struct OSBoolean;
struct OSCollectionIterator;
struct OSKext;
struct kmod_info;
struct kmod_reference;
struct OSSet;
struct segment_command_64;
struct OSNumber;
struct OSOrderedSet;
struct OSOrderedSet::ExpansionData;
struct OSSerializer;
struct OSAction;
struct IOConditionLock;
struct IORegistryIterator;
struct IORegistryEntry;
struct IONotifier;
struct IOCatalogue;
struct IOPMPowerSource;
struct IOService;
struct IOService::ExpansionData;
struct IOInterruptSource;
struct IOInterruptController;
struct IOInterruptVector;
struct IOSharedInterruptController;
struct IOSharedInterruptController::ExpansionData;
struct IOInterruptController::ExpansionData;
struct IOReportChannelList;
struct IOWorkLoop;
struct IOEventSource;
struct IOEventSource::ExpansionData;
struct IOCommandGate;
struct IOCommandGate::ExpansionData;
struct IOWorkLoop::ExpansionData;
struct IODeviceMemory;
struct IOMemoryMap;
struct IOUserClient;
struct IOUserClient::ExpansionData;
struct IOPMPowerState;
struct IOPowerConnection;
struct IOPMPowerSourceList;
struct IOPMGR;
struct ml_processor_info;
struct IOCommandPool;
struct IOCommandPool::ExpansionData;
struct IOCommand;
struct IODMAEventSource;
struct IODMAController;
struct IODMACommand;
struct IOMapper;
struct IOFilterInterruptEventSource;
struct IOInterruptEventSource;
struct IOInterruptEventSource::ExpansionData;
struct IOFilterInterruptEventSource::ExpansionData;
struct IOTimerEventSource;
struct IOTimerEventSource::ExpansionData;
struct IODMACommand::SegmentOptions;
struct IOBufferMemoryDescriptor;
struct IOVirtualRange;
struct IOPhysicalRange;
struct IOBufferMemoryDescriptor::ExpansionData;
struct IOInterleavedMemoryDescriptor;
struct IODMAMapSpecification;
struct IODMAMapPageList;
struct upl_page_info;
struct IOMemoryCursor;
struct IONaturalMemoryCursor;
struct IOBigMemoryCursor;
struct IOLittleMemoryCursor;
struct IOMultiMemoryDescriptor;
struct IORangeAllocator;
struct IOSubMemoryDescriptor;
struct IOPlatformExpert;
struct IOPMrootDomain;
struct IOPlatformExpert::ExpansionData;
struct PE_Video;
struct IONVRAMController;
struct IODTPlatformExpert;
struct IODTNVRAM;
struct IODTPlatformExpert::ExpansionData;
struct IOPlatformExpertDevice;
struct IOPlatformExpertDevice::ExpansionData;
struct IOPlatformDevice;
struct IOPlatformDevice::ExpansionData;
struct IOPlatformIO;
struct IONVRAMDescriptor;
struct PassthruInterruptController;
struct IOKitDiagnostics;
struct IOKitDiagnosticsClient;
struct IOExternalMethodArguments;
struct IOExternalMethodDispatch;
struct IOExternalMethod;
struct IOExternalAsyncMethod;
struct IOExternalTrap;
struct IOSharedDataQueue;
struct IODataQueue;
struct _IODataQueueMemory;
struct _IODataQueueEntry;
struct IOSharedDataQueue::ExpansionData;
struct IORTC;
struct IORTC::ExpansionData;
struct IOWatchDogTimer;
struct IOWatchDogTimer::ExpansionData;
struct PE_state;
union int16x4_t;
union uint16x4_t;
union float16x4_t;
struct firehose_chunk_s;
struct dispatch_gate_s;
struct ccchacha20poly1305_ctx;
struct ppl_iommu_desc;
struct vnode_attr;
struct sockopt;
struct socket;
struct sockaddr;
struct vfs_context;
struct componentname;
struct kauth_acl;
struct launch_constraint_data;
struct flock;
struct sbuf;
struct mac_policy_ops;
struct mac_policy_conf;
struct tty;
struct session;
struct pgrp;
struct internal_state;
struct os_reason;
struct vnode;
struct turnstile;
struct priority_queue_entry_sched;
struct workq_threadreq_s;
struct knote;
struct knote_lock_ctx;
struct kqworkloop;
struct uthread;
struct smrq_slink;
struct exception_action;
struct label;
struct proc_ident;
struct vfs_attr;
struct attrlist;
struct file_lease;
struct nameidata;
struct vnode_resolve;
struct fileproc_guard;
struct fileglob;
struct fileproc;
struct smrq_link;
struct namecache;
struct cs_blob;
struct semid_kernel;
struct pipe;
struct pr_usrreqs_old;
struct protosw_old;
struct socket_filter;
struct recv_msg_elem;
struct pr_usrreqs;
struct ifnet;
struct mbuf;
struct domain;
struct protosw;
struct pshminfo;
struct pseminfo;
struct msqid_kernel;
struct msg;
struct shmid_kernel;
struct sem;
struct uio;
struct sysctl_req_0;
struct sysctl_oid_0;
struct vfsconf;
struct vfsops;
struct mount;
struct zone_view;
struct image_params;
struct devfsmount;
struct kaudit_record;
struct wait4_nocancel_args;
struct waitid_nocancel_args;
struct select_nocancel_args;
struct OSObject_0;
struct devnode;
struct kalloc_type_view;
struct kalloc_type_var_view;
struct doc_tombstone;
struct dtrace_ptss_page_entry;
struct lockf;
struct buf;
struct cfil_info;
struct soflow_db;
struct flow_divert_pcb;
struct socket_filter_entry;
struct mac_audit_record;
struct mac_audit_record_list_t;
struct ull;
struct thread_group;
struct thread_call;
struct ipc_object;
struct ucred_rw;
struct DeviceTreeNodeProperty;
struct OSValueObject<PMAssertStruct>;
struct IOSKRegion;
struct IOSKArena;
struct IOSKMapper;
struct IOHistogramSegmentConfig;
struct processor;
struct IODTNVRAMPlatformNotifier;
struct IODTNVRAM_0;
struct vm_object;
struct memory_object_pager_ops;
struct memory_object;
struct IOCommandPool_0;
struct IOUserUserClient;
struct IOServiceStateNotificationDispatchSource_IVars;
struct IODispatchSource_IVars;
struct CEQueryContext;
struct CERuntime;
struct ccdigest_info_0;
struct SHA512_CTX;
struct static_tree_desc_s;
struct mach_header_64_0;
struct log_queue_entry;
struct os_log_fmt_hdr_s;
struct priority_queue_entry_stable;
struct smrh_traits;
struct smr_pcpu;
struct __block_descriptor_withcopydispose;
struct osLogDataHeader;
struct zone_stats;
struct zone;
struct ipc_kmsg;
struct OSClassDescription;
struct IOPStrings;
struct IOExternalMethodArguments_0;
struct OSAction_0;
struct IOUCFilterPolicy;
struct IOPMCompletionQueue;
struct IOPMRequestQueue;
struct IOPMWorkQueue;
struct OSOrderedSet_0;
struct PMSettingObject;
struct IOPMAOTMetrics;
struct IOTimerEventSource_0;
struct PMAssertionsTracker;
struct PMTraceWorker;
struct IOPMPowerStateQueue;
struct IOPMrootDomain_0;
struct IOCommandGate_0;
struct IOUserClientCounter;
struct IOUserClientProcessEntry;
struct IOWorkLoopDependency;
struct IOWorkLoopCounter;
struct KextNode;
struct ClassNode;
struct IOEventSourceCounter;
struct IOWorkLoop_0;
struct OSCollectionIterator_0;
struct OSBoolean_0;
struct OSDextStatistics;
struct OSKext_0;
struct OSNumber_0;
struct IOUserServerCheckInToken;
struct IOSharedInterruptController_0;
struct IOInterruptVector_0;
struct IOInterruptController_0;
struct IOInterruptSource_0;
struct IOPMRequest;
struct IOPMActions;
struct IOServiceStateChangeVars;
struct OSUserMetaClass;
struct _IOMemoryDescriptorMixedData;
struct IOPhysicalRange_0;
struct IOVirtualRange_0;
struct IOAddressSegment;
struct vm_page;
struct IODMACommand_0;
struct IOMapper_0;
struct upl;
struct _vm_map;
struct IOMemoryMap_0;
struct IOMemoryEntry;
struct IOMemoryReference;
struct IOMemoryDescriptor_0;
struct OSSet_0;
struct IOSimpleReporter;
struct IOInterruptAccountingReporter_0;
struct OSArray_0;
struct OSData_0;
struct OSString_0;
struct OSSymbol_0;
struct OSDictionary_0;
struct IORegistryEntry_0;
struct IOService_0;
struct IOUserServer;
struct IODispatchQueue_IVars;
struct IODispatchQueue;
struct OSSerialize_0;
struct OSMetaClass_0;
struct dtrace_module_symbols;
struct modctl;
struct arm_saved_state64;
struct arm_saved_state;
struct user_ucontext32;
struct user_ucontext64;
struct __packet_compl;
struct __flow;
struct ext_ref;
struct m_tag;
struct if_tcp_ecn_stat;
struct if_link_status;
struct llentries;
struct lltable;
struct llentry;
struct nexus_ifnet_ops;
struct dlil_threading_info;
struct ifmultiaddr;
struct ifclassq;
struct ifnet_demux_desc;
struct kev_msg;
struct ifnet_stat_increment_param;
struct eventhandler_entry;
struct eventhandler_list;
struct ifnet_llreach_info;
struct rt_reach_info;
struct radix_mask;
struct rt_metrics;
struct rtentry;
struct ifaddr;
struct __packet_opt;
struct __kern_slot_desc;
struct __user_quantum;
struct __kern_buflet_ext;
struct kern_pbufpool_u_bft_bkt;
struct kern_pbufpool_u_bkt;
struct skmem_bufctl_bkt;
struct skmem_mag;
struct skmem_magtype;
struct sksegment_bkt;
struct skmem_region_params;
struct skmem_region;
struct sksegment;
struct skmem_slab;
struct skmem_bufctl;
struct skmem_obj_info;
struct skmem_cache;
struct kern_pbufpool;
struct __kern_quantum;
struct __kern_packet;
struct in6_ifextra;
struct in_ifextra;
struct tcpstat_local;
struct ip_msource;
struct in_multi;
struct nexus_mib_filter;
struct nx_cfg_req;
struct nxbind;
struct nx_port_info;
struct netif_nexus_advisory;
struct sk_nexusadv;
struct kern_slot_prop;
struct __user_channel_schema;
struct ch_info;
struct nexus_pkt_stats;
struct __kern_channel_event;
struct chreq;
struct nexus_upipe_adapter;
struct skmem_arena_mmap_info;
struct skmem_arena;
struct slot_ctx;
struct __slot_desc;
struct __user_channel_ring;
struct __kern_channel_ring;
struct nexus_adapter;
struct kern_channel;
struct nxctl;
struct kern_nexus_provider;
struct kern_nexus;
struct nxprov_params;
struct kern_nexus_domain_provider;
struct ifnet_traffic_descriptor_common;
struct netif_flowtable_ops;
struct netif_flowtable;
struct netif_agent_flow;
struct netif_queue;
struct netif_llink;
struct netif_qset;
struct netif_flow;
struct netif_filter;
struct mit_cfg_tbl;
struct nx_netif_mit;
struct nexus_netif_adapter;
struct nxdom;
struct nx_netif;
struct kern_nexus_netif_llink_qset_init;
struct kern_nexus_netif_llink_init;
struct tcphdr;
struct ip6_hdr;
struct ip;
struct flow_stats;
struct flow_route;
struct kern_flow_demux_pattern;
struct flow_entry;
struct __nx_stats_fsw;
struct flow_route_id_bucket;
struct flow_route_bucket;
struct flow_mgr;
struct nx_flowswitch;
struct ip6_msource;
struct in6_multi;
struct flow_owner_bucket;
struct flow_entry_id_tree;
struct flow_owner;
struct ns_flow_info;
struct ipf;
struct fsw_ip_frag_mgr;
struct nxctl_traffic_rule_inet;
struct nxctl_traffic_rule_type;
struct sockaddr_dl;
struct nexus_controller;
struct nexus_attr;
struct _bucket;
struct cuckoo_hashtable;
struct nstat_counts;
struct domain_old;
struct protons_token;
struct ns_token;
struct vnodeop_desc;
struct cl_writebehind;
struct cl_readahead;
struct shared_file_mapping_slide_np;
struct secpolicy;
struct inpcbporthead;
struct inpcbhead;
struct inpcbinfo;
struct inpcb;
struct soflow_hash_head;
struct udpstat_local;
struct soflow_hash_entry;
struct tracker_hash_entry;
struct unpcb;
struct iovec;
struct pshm_mobj;
struct internal_pshminfo;
struct section_64_0;
struct mptcp_subf_auth_entry;
struct mptsub;
struct mptopt;
struct mppcbinfo;
struct mppcb;
struct mptses;
struct mptcb;
struct ip6_rthdr;
struct ip6_dest;
struct ip6_hbh;
struct flow_divert_group;
struct cs_hash;
struct mcache;
struct smr;
struct locklist;
struct sockaddr_ctl;
struct kctl;
struct mythread_state_flavor_t;
struct stackshot_thread_waitinfo;
struct auditinfo_addr;
struct au_tid_addr;
struct secashead;
struct icmp6_filter;
struct radix_node_head;
struct nd6_prproxy_solsrc;
struct soltgt_key_s;
struct nd6_prproxy_soltgt;
struct if_llreach;
struct mld_ifinfo;
struct in6_addrpolicy;
struct ipf_pktopts;
struct ipf_filter;
struct ipfilter;
struct pf_anchor_node;
struct pf_anchor;
struct pf_pooladdr;
struct pf_pool;
struct pf_rule;
struct pf_ruleset;
struct pfr_ktable;
struct pf_addr;
struct pfi_dynaddr;
struct pfi_kif;
struct ip_out_args;
struct ip6_exthdrs;
struct flow_divert_trie_node;
struct icmp;
struct conninfo_tcp;
struct dummynet_event;
struct dn_flow_queue;
struct dn_flow_set;
struct dn_pipe;
struct dn_heap_entry;
struct igmp_ifinfo;
struct ptrlist_t;
struct heap;
struct netem;
struct flowq;
struct fq_codel_classq_group;
struct cfil_crypto_state;
struct content_filter;
struct pfr_kentry;
struct pf_esp_hdr;
struct pf_grev1_hdr;
struct pf_app_state;
struct pf_statelist;
struct pf_state_key;
struct pf_state_scrub;
struct pf_state_peer;
struct pf_state;
struct hook_desc;
struct netagent_client;
struct netagent_token;
struct netagent_wrapper;
struct ether_addr;
struct nstat_tcp_descriptor;
struct necp_flow_defunct;
struct necp_arena_info;
struct necp_client_flow;
struct necp_client_assertion;
struct necp_client;
struct necp_client_flow_registration;
struct necp_domain_filter;
struct if_clone;
struct nstat_generic_shadow;
struct nstat_tu_shadow;
struct nstat_procdetails;
struct nstat_src;
struct nstat_control_state;
struct nstat_provider;
struct devtimer_s;
struct LAG_s;
struct multicast_entry;
struct bondport_s;
struct ifbond_s;
struct fake_llink;
struct ifvlan;
struct vlan_parent;
struct ifnet_filter;
struct if_proto;
struct proto_hash_entry;
struct mac_nat_entry;
struct bstp_port;
struct bridge_iflist;
struct bridge_rtnode;
struct _bridge_rtnode_list;
struct bridge_softc;
struct bpf_insn;
struct bpf_if;
struct bpf_d;
struct devfs_vnode_event;
struct cpx;
struct fs_event_watcher;
struct kfs_event;
struct cl_direct_read_lock;
struct wrap_timer_call;
struct kmod_info_0;
struct dtrace_procdesc;
struct lucid_context;
struct crypto_ctx;
struct nfs_gss_svc_ctx;
struct nfsm_chain;
struct nfsrv_descript;
struct nfsrv_uc_arg;
struct nfs_user_stat_node;
struct nfs_export;
struct select_set;
struct arm_neon_saved_state64;
struct arm_neon_saved_state;
struct pset_node;
struct sched_clutch_root;
struct processor_set;
struct vm_map_store;
struct vm_map_entry;
struct _rtclock_data_;
struct arm_kernel_saved_state;
struct dyld_uuid_info_64;
union vm_shared_region_slide_info_entry;
struct vm_shared_region_slide_info;
struct lck_tktlock_pv_info;
struct perfcontrol_cpu_counters;
struct perfcontrol_thread_data;
struct perfcontrol_work_interval_instance;
struct perfcontrol_work_interval;
struct perfcontrol_max_runnable_latency;
struct thread_group_data;
struct going_on_core;
struct going_off_core;
struct nlist_64;
struct page_table_ops;
struct page_table_level_info;
struct page_table_attr;
struct cpu_data;
struct zone_expand;
struct upl_io_completion;
struct _vector_upl;
struct ccentropy_ctx;
struct ccrng_schedule_ctx;
struct ccdrbg_info;
struct queue_entry_0;
struct vm_deferred_reclamation_metadata_s;
struct purgeable_q;
struct vm_map_corpse_footprint_header;
struct vm_object_fault_info;
struct c_slot;
struct c_segment;
struct ipc_voucher_attr_manager;
struct ipc_eventlink_base;
union zone_or_view;
struct zone_magazine;
struct zone_cache;
struct workload_config_entry;
struct workload_config_hashhead;
struct sched_clutch_bucket;
struct sched_clutch;
struct thread_call_group;
struct ipc_importance_elem;
struct gpu_energy_data;
struct task_power_info;
struct recount_plan;
struct ledger_callback;
struct entry_template;
struct ledger_template;
struct bt_hash;
struct affinity_space;
struct mach_service_port_info;
struct kern_coredump_callback_config;
struct kdp_output_stage;
struct kdp_hw_shmem_dbg_buf_elm;
struct user64_dyld_uuid_info;
struct os_log_s;
struct __Reply__mach_gss_init_sec_context_v3_t;
struct IONotifier_0;
struct IOInterruptSourcePrivate;
struct OSIterator_0;
struct firehose_push_reply_s;
struct kmod_reference_0;
struct devdirent;
struct _ps_mac_policy_extension;
struct IORegistryIterator_0;
struct IOSKMemoryBuffer;
struct IOSKRegion::Segment;
struct IOSKRegion::ArenaEntry;
struct workload_config;
struct IOPerfControlClient::WorkUpdateArgs;
struct IOPerfControlClient::WorkEndArgs;
struct IOPerfControlClient::WorkBeginArgs;
struct IOPerfControlClient::WorkSubmitArgs;
struct IOPerfControlClient::PerfControllerInterface::WorkState;
struct IOPerfControlClient::IOPerfControlClientShared;
struct IOWatchDogTimer::ExpansionData_0;
struct libkern::bounded_array<OSArray *,2UL,os_detail::panic_trapping_policy>;
struct IOStateNotificationListener;
struct libkern::bounded_array<IOExternalTrap,2UL,os_detail::panic_trapping_policy>;
struct libkern::bounded_array<IOExternalTrap,1UL,os_detail::panic_trapping_policy>;
struct IORTC::ExpansionData_0;
struct IOReportLegend;
struct IOHistogramReporter;
struct IOStateReporter;
struct IOSharedDataQueue_0;
struct IOSharedDataQueue::ExpansionData_0;
struct IOMachPort;
struct iocpu_platform_action_entry;
struct IOCPUInterruptController::ExpansionData;
struct IOCPU::ExpansionData;
struct IOPlatformDevice::ExpansionData_0;
struct IODTPlatformExpert::ExpansionData_0;
struct IOGuardPageMemoryDescriptor;
struct IOGeneralMemoryDescriptor::serialize::SerData;
struct IOLittleMemoryCursor_0;
struct IOBigMemoryCursor_0;
struct IONaturalMemoryCursor_0;
struct IOFilterInterruptEventSource_0;
struct IOFilterInterruptEventSource::ExpansionData_0;
struct IODMAEventSource_0;
struct IODMAController_0;
struct IOInterruptEventSource::ExpansionData_0;
struct IOCommandPool::ExpansionData_0;
struct IOPolledFilePollers;
struct IOPolledInterface::ExpansionData;
struct IOPMPowerSource_0;
struct IOCatalogue_0;
struct IOPlatformExpertDevice::ExpansionData_0;
struct IOWorkGroup;
struct IOEventLink;
struct IOServiceStateNotificationDispatchSource;
struct IOServiceNotificationDispatchSource;
struct IODataQueueDispatchSource;
struct _IODataQueueEntry_0;
struct _IODataQueueMemory_0;
struct IOInterruptDispatchSource;
struct StorageSignedFunctionPointer<void (*)(Block_byref *),(ptrauth_key)0>;
struct StorageSignedFunctionPointer<void (*)(Block_byref *,Block_byref *),(ptrauth_key)0>;
struct StorageSignedFunctionPointer<void (*)(void *,___),(ptrauth_key)0>;
struct StorageSignedFunctionPointer<void (*)(const void *),(ptrauth_key)0>;
struct StorageSignedFunctionPointer<void (*)(void *,const void *),(ptrauth_key)0>;
struct _TrustCacheQueryToken;
struct _TrustCacheMutableRuntime;
struct _TrustCacheModuleBase;
struct _TrustCache;
struct _img4_cstr;
struct CEAccelerationElement;
struct __SC_GenericBlob;
struct _img4_nonce;
struct sha1_ctxt;
struct gz_header_s;
struct core_analytics_serialized_event_s;
struct object;
struct OSSerializer_0;
struct OSValueObject<void *>;
struct OSValueObject<void (*)(unsigned int,int,const void *,unsigned int,void *)>;
struct OSDextCrash;
struct OSKextSavedMutableSegment;
struct IOUserClient::ExpansionData_0;
struct OSOrderedSet::ExpansionData_0;
struct IOPlatformExpert::ExpansionData_0;
struct IOTimerEventSource::ExpansionData_0;
struct IOPMrootDomain::PMNotifySuspendedStruct;
struct IOWorkLoop::ExpansionData_0;
struct IOCommandGate::ExpansionData_0;
struct IOEventSource::ExpansionData_0;
struct IOInterruptController::ExpansionData_0;
struct IOSharedInterruptController::ExpansionData_0;
struct libkern::bounded_array_ref<IODispatchQueue *,os_detail::panic_trapping_policy>;
struct IOBufferMemoryDescriptor::ExpansionData_0;
struct IOService::ExpansionData_0;
struct _lck_grp_;
struct sdt_probe;
struct dtrace_helper_provider;
struct dtrace_dstate_percpu;
struct dtrace_dynvar;
struct dtrace_format;
struct dtrace_speculation;
struct dtrace_state;
struct dtrace_provider;
struct dtrace_helper_action;
struct dtrace_difv;
struct fasttrap_machtp;
struct fasttrap_provider;
struct fasttrap_proc;
struct dtrace_probe;
struct mcontext32;
struct mcontext64;
struct packet_id;
struct os_channel_event_packet_transmit_status;
struct __CodeDirectory;
struct user_msghdr;
struct mb_class_stat;
struct mleak_trace_stat;
struct mleak_stat;
struct mcl_slab;
struct mcache_audit;
struct mcache_bkttype;
struct mcache_bkt;
struct mcache_obj;
struct __SC_Scatter;
struct __BlobIndex;
struct __SC_SuperBlob;
struct time_value;
struct log_stream_t;
struct stackshot_config;
struct _TrustCacheTypeConfig;
struct memorystatus_memlimit_properties;
struct memorystatus_internal_properties;
struct memorystatus_kernel_stats;
struct memorystatus_internal_probabilities;
struct pidlist_entry;
struct _ps_port_action;
union workq_threadreq_param_s;
struct mpsc_daemon_queue;
struct kd_callback;
struct au_sentry;
struct bsm_fcntl_cmd;
struct symptoms_advisory;
struct cqrq_throttle;
struct fq_if_bitmap_ops;
struct pbuf;
struct rsrcfork_header;
struct apple_double_entry;
struct attr_entry;
struct fsioc_graft_fs;
struct secure_boot_cryptex_args;
struct attrreference;
struct _vnode_authorize_context;
struct dtrace_cpu;
struct fasttrap_id;
struct dtrace_helper_probedesc;
struct cyc_omni_handler;
struct sdt_argdesc;
struct sdt_probedesc;
struct dtrace_sdt_def;
struct fbt_probe;
struct dtrace_invop_hdlr;
struct dtrace_string;
struct dof_provider;
struct dof_sec;
struct dtrace_helptrace;
struct dtrace_aggkey;
struct dtrace_aggbuffer;
struct dtrace_enabling;
struct dtrace_predicate;
struct dtrace_preddesc;
struct dtrace_actdesc;
struct dtrace_toxrange;
struct dtrace_hashbucket;
struct dtrace_hash;
struct dtrace_mops;
struct dtrace_meta;
struct dtrace_dynhash;
struct dtrace_ecb;
struct classq_pkt;
struct gss_cfx_mic_token_desc_struct;
struct pv_entry;
union thread_rr_state;
struct vm_extmod_statistics;
struct arm_neon_state;
struct arm_legacy_debug_state;
struct arm_kernel_context;
struct ml_topology_cluster_0;
struct ml_topology_cpu_0;
struct page_free_entry;
struct pmap_io_filter_entry;
struct pmap_io_range;
struct _TrustCache_0;
struct tt_free_entry;
struct pmap_reserved_page;
struct upl_page_info_0;
struct vm_packing_params;
struct entropy_health_test;
struct entropy_health_stats;
struct ccentropy_rng_ctx;
struct micro_snapshot_buffer;
struct __Request__io_registry_entry_get_property_bin_buf_t;
struct submap_map;
struct kmem_list_head;
struct vm_info_region_64;
struct vm_info_region;
struct ipc_info_port;
struct ipc_info_space_basic;
struct ipc_info_space;
struct mach_zone_info_data;
union kalloc_type_views;
struct workload_phase_entry;
struct stackshot_thread_turnstileinfo_v2;
struct thread_watchlist;
struct _vm_object_query_data_;
union hw_lck_ptr;
struct cond_swi_var64;
struct gate;
struct lockgroup_info;
struct ipc_kobject_ops;
struct bt_library;
struct arcade_register;
struct mach_port_guard_info;
struct stackshot_thread_waitinfo_v2;
struct OSData::ExpansionData_0;
struct vm_allocation_site;
struct ppl_iommu_seg_0;
struct kmod_info_1;
struct rusage_info_v6;
struct workload_config_ctx;
struct mach_msg_mac_trailer_t;
struct _OSEntitlementsInterface;
struct _img4_buff;
struct _img4_dgst;
struct _img4_runtime;
struct CEQueryOperation;
struct _img4_firmware_execution_context;
struct _img4_chip_instance;
struct _apple_encrypted_archive;
struct ccmode_xts_0;
struct internal_state_0;
struct logmem_s;
struct _loaded_kext_summary_header;
struct _IORecursiveLock_0;
struct sdt_provider;
struct fasttrap_bucket;
struct dtrace_statvar;
struct dtrace_buffer;
struct dtrace_argdesc;
struct dtrace_probedesc;
struct dtrace_action;
struct dtrace_difo;
struct fasttrap_tracepoint;
struct fasttrap_probe;
struct dtrace_mstate;
struct xcArg;
struct user32_siginfo;
struct user64_siginfo;
struct _dbuf_array;
struct _load_result;
struct ull_bucket;
struct _trust_cache_offsets;
struct memorystatus_properties_entry_v1;
struct memorystatus_priority_entry;
struct memstat_bucket;
struct jetsam_snapshot_entry;
struct jetsam_snapshot;
struct user_siginfo;
struct _psfa_action;
struct ktriage_strings;
struct net_perf;
struct mptcp_subflow_event_entry;
struct cqrq_stat_sc;
struct cqrq_purge_sc;
struct fq_codel_sched_data;
struct nstat_msg_add_src;
struct attr_info;
struct apple_double_header;
struct attr_header;
struct fasttrap_probe_spec;
struct fasttrap_tracepoint_spec;
struct profile_probe;
struct profile_probe_percpu;
struct machtrace_sysent;
struct systrace_sysent;
struct blmeta;
struct cpu_core;
struct lockstat_probe;
struct dtrace_probekey;
struct dtrace_match_cond;
struct dof_optdesc;
struct dof_actdesc;
struct dof_difohdr;
struct dof_probedesc;
struct dof_ecbdesc;
struct dof_probe;
struct dof_hdr;
struct dtrace_rechdr;
struct dtrace_helper_provdesc;
struct cpu_data_entry;
struct arm_context;
struct pt_desc;
struct pmap_tlb_flush_range;
struct entropy_cpu_data;
struct ccrng_crypto_ctx;
struct ccentropy_info;
struct ccrng_schedule_info;
struct arm_debug_aggregate_state;
struct mach_memory_info;
struct mach_vm_reclaim_entry_v1_s;
struct task_watcher;
struct mach_msg_security_trailer_t;
struct routine_descriptor_1;
struct mach_port_options;
struct ipc_voucher_attr_recipe_data;
struct mach_voucher_attr_recipe_data;
struct ipc_notify_nsenders;
struct ivac_entry_s;
struct _IODataQueueAppendix;
struct ml_processor_info_0;
struct _TrustCacheInterface;
struct _img4_interface;
struct _coretrust;
struct parser_state;
struct OSTaggedSharedPtr<const OSMetaClassBase,OSCollection>_0;
struct OSSymbol_1;
struct dtrace_aggregation;
struct kern_pbufpool_0;
struct _pktsched_pkt_;
struct tracker_hash_entry_short;
struct mptcp_flow;
struct pktchain_elm;
struct wrap_thread_call;
struct dtrace_module_uuids_list;
struct dtrace_ecbdesc;
struct arm_unified_thread_state;
struct __Reply__io_service_wait_quiet_with_options_t;
struct __Reply__io_registry_entry_get_property_bin_buf_t;
struct __Reply__io_registry_entry_get_properties_bin_buf_t;
struct __Reply__io_device_tree_entry_exists_with_name_t;
struct __Reply__io_registry_entry_from_path_ool_t;
struct __Reply__io_registry_entry_get_path_ool_t;
struct __Reply__io_service_add_notification_bin_64_t;
struct __Reply__io_service_add_notification_bin_t;
struct __Reply__io_service_match_property_table_bin_t;
struct __Reply__io_service_get_matching_services_bin_t;
struct __Reply__io_service_get_matching_service_bin_t;
struct __Reply__io_registry_entry_get_property_bin_t;
struct __Reply__io_registry_entry_get_properties_bin_t;
struct __Reply__io_server_version_t;
struct __Reply__io_service_set_authorization_id_t;
struct __Reply__io_service_get_authorization_id_t;
struct __Reply__io_service_get_matching_service_ool_t;
struct __Reply__io_service_get_matching_service_t;
struct __Reply__io_connect_method_var_output_t;
struct __Reply__io_registry_entry_get_registry_entry_id_t;
struct __Reply__io_service_add_notification_ool_64_t;
struct __Reply__io_service_add_interest_notification_64_t;
struct __Reply__io_service_add_notification_64_t;
struct __Reply__io_connect_set_notification_port_64_t;
struct __Reply__io_connect_async_method_t;
struct __Reply__io_connect_method_t;
struct __Reply__io_connect_unmap_memory_from_task_t;
struct __Reply__io_connect_map_memory_into_task_t;
struct __Reply__io_service_open_extended_t;
struct __Reply__io_object_get_bundle_identifier_t;
struct __Reply__io_object_get_superclass_t;
struct __Reply__io_service_add_notification_ool_t;
struct __Reply__io_service_match_property_table_ool_t;
struct __Reply__io_service_get_matching_services_ool_t;
struct __Reply__io_service_get_state_t;
struct __Reply__io_registry_entry_get_property_recursively_t;
struct __Reply__io_registry_entry_get_location_in_plane_t;
struct __Reply__io_connect_unmap_memory_t;
struct __Reply__io_connect_get_notification_semaphore_t;
struct __Reply__io_service_acknowledge_notification_t;
struct __Reply__io_service_add_interest_notification_t;
struct __Reply__io_service_add_notification_t;
struct __Reply__io_async_method_structureI_structureO_t;
struct __Reply__io_async_method_scalarI_structureI_t;
struct __Reply__io_async_method_scalarI_structureO_t;
struct __Reply__io_async_method_scalarI_scalarO_t;
struct __Reply__io_service_match_property_table_t;
struct __Reply__io_registry_entry_get_name_in_plane_t;
struct __Reply__io_service_request_probe_t;
struct __Reply__io_catalog_reset_t;
struct __Reply__io_catalog_module_loaded_t;
struct __Reply__io_catalog_get_gen_count_t;
struct __Reply__io_catalog_get_data_t;
struct __Reply__io_catalog_terminate_t;
struct __Reply__io_catalog_send_data_t;
struct __Reply__io_iterator_is_valid_t;
struct __Reply__io_registry_entry_create_iterator_t;
struct __Reply__io_service_wait_quiet_t;
struct __Reply__io_service_get_busy_state_t;
struct __Reply__io_object_get_retain_count_t;
struct __Reply__io_registry_entry_in_plane_t;
struct __Reply__io_registry_entry_set_properties_t;
struct __Reply__io_registry_get_root_entry_t;
struct __Reply__io_registry_entry_get_path_t;
struct __Reply__io_connect_method_structureI_structureO_t;
struct __Reply__io_connect_method_scalarI_structureI_t;
struct __Reply__io_connect_method_scalarI_structureO_t;
struct __Reply__io_connect_method_scalarI_scalarO_t;
struct __Reply__io_connect_set_properties_t;
struct __Reply__io_connect_add_client_t;
struct __Reply__io_connect_map_memory_t;
struct __Reply__io_connect_set_notification_port_t;
struct __Reply__io_connect_get_service_t;
struct __Reply__io_service_close_t;
struct __Reply__io_registry_entry_get_parent_iterator_t;
struct __Reply__io_registry_entry_get_child_iterator_t;
struct __Reply__io_registry_entry_get_property_bytes_t;
struct __Reply__io_registry_entry_get_properties_t;
struct __Reply__io_registry_entry_get_name_t;
struct __Reply__io_registry_entry_from_path_t;
struct __Reply__io_registry_iterator_exit_entry_t;
struct __Reply__io_registry_iterator_enter_entry_t;
struct __Reply__io_registry_create_iterator_t;
struct __Reply__io_registry_entry_get_property_t;
struct __Reply__io_service_get_matching_services_t;
struct __Reply__io_iterator_reset_t;
struct __Reply__io_iterator_next_t;
struct __Reply__io_object_conforms_to_t;
struct __Reply__io_object_get_class_t;
struct __Reply___map_exec_lockdown_t;
struct __Reply__purgable_control_t;
struct __Reply__map_64_t;
struct __Reply__make_memory_entry_64_t;
struct __Reply__region_64_t;
struct __Reply__region_info_64_t;
struct __Reply__region_recurse_64_t;
struct __Reply__region_recurse_t;
struct __Reply__mapped_pages_info_t;
struct __Reply__region_info_t;
struct __Reply__map_page_query_t;
struct __Reply__make_memory_entry_t;
struct __Reply___task_wire_t;
struct __Reply__remap_t;
struct __Reply__machine_attribute_t;
struct __Reply__map_t;
struct __Reply__behavior_set_t;
struct __Reply__msync_t;
struct __Reply__read_overwrite_t;
struct __Reply__copy_t;
struct __Reply__write_t;
struct __Reply__read_list_t;
struct __Reply__read_t;
struct __Reply__inherit_t;
struct __Reply__protect_t;
struct __Reply__deallocate_t;
struct __Reply__allocate_t;
struct __Reply__region_t;
struct __Reply__thread_get_exception_ports_info_t;
struct __Reply__thread_raise_exception_t;
struct __Reply__thread_convert_thread_state_t;
struct __Reply__thread_swap_mach_voucher_t;
struct __Reply__thread_set_mach_voucher_t;
struct __Reply__thread_get_mach_voucher_t;
struct __Reply__thread_set_policy_t;
struct __Reply__thread_policy_get_t;
struct __Reply__thread_policy_set_t;
struct __Reply__thread_policy_t;
struct __Reply__thread_swap_exception_ports_t;
struct __Reply__thread_get_exception_ports_from_user_t;
struct __Reply__thread_set_exception_ports_t;
struct __Reply__thread_info_t;
struct __Reply__thread_set_special_port_t;
struct __Reply__thread_get_special_port_from_user_t;
struct __Reply__thread_depress_abort_from_user_t;
struct __Reply__thread_abort_safely_t;
struct __Reply__thread_abort_t;
struct __Reply__thread_resume_t;
struct __Reply__thread_suspend_t;
struct __Reply__thread_set_state_from_user_t;
struct __Reply__thread_get_state_to_user_t;
struct __Reply__act_set_state_from_user_t;
struct __Reply__act_get_state_to_user_t;
struct __Reply__thread_terminate_from_user_t;
struct __Reply__task_map_kcdata_object_64_t;
struct __Reply__task_test_async_upcall_propagation_t;
struct __Reply__task_set_corpse_forking_behavior_t;
struct __Reply__task_test_sync_upcall_t;
struct __Reply__task_get_exception_ports_info_t;
struct __Reply__task_dyld_process_info_notify_deregister_t;
struct __Reply__task_identity_token_get_task_port_t;
struct __Reply__task_create_identity_token_t;
struct __Reply__task_dyld_process_info_notify_register_t;
struct __Reply__mach_task_is_self_t;
struct __Reply__task_set_exc_guard_behavior_t;
struct __Reply__task_get_exc_guard_behavior_t;
struct __Reply__task_inspect_t;
struct __Reply__task_map_corpse_info_64_t;
struct dyld_kernel_process_info;
struct __Reply__task_register_dyld_get_process_state_t;
struct __Reply__task_register_dyld_set_dyld_state_t;
struct __Reply__task_register_dyld_shared_cache_image_info_t;
struct __Reply__task_get_dyld_image_infos_t;
struct __Reply__task_unregister_dyld_image_infos_t;
struct __Reply__task_register_dyld_image_infos_t;
struct __Reply__task_map_corpse_info_t;
struct __Reply__task_generate_corpse_t;
struct __Reply__task_swap_mach_voucher_t;
struct __Reply__task_set_mach_voucher_t;
struct __Reply__task_get_mach_voucher_t;
struct __Reply__task_purgable_info_t;
struct __Reply__task_resume2_mig_t;
struct __Reply__task_suspend2_mig_t;
struct __Reply__task_set_phys_footprint_limit_t;
struct __Reply__task_set_state_t;
struct __Reply__task_get_state_t;
struct __Reply__task_policy_get_t;
struct __Reply__task_policy_set_t;
struct __Reply__semaphore_destroy_t;
struct __Reply__semaphore_create_t;
struct __Reply__task_swap_exception_ports_t;
struct __Reply__task_get_exception_ports_from_user_t;
struct __Reply__task_set_exception_ports_t;
struct __Reply__thread_create_running_from_user_t;
struct __Reply__thread_create_from_user_t;
struct __Reply__task_set_special_port_from_user_t;
struct __Reply__task_get_special_port_from_user_t;
struct __Reply__task_resume_t;
struct __Reply__task_suspend_t;
struct __Reply__task_set_info_t;
struct __Reply__task_info_from_user_t;
struct __Reply__mach_ports_lookup_t;
struct __Reply__mach_ports_register_t;
struct __Reply__task_threads_from_user_t;
struct __Reply__task_terminate_t;
struct __Reply__processor_set_tasks_with_flavor_t;
struct __Reply__processor_set_info_t;
struct __Reply__processor_set_stack_usage_t;
struct __Reply__processor_set_threads_t;
struct __Reply__processor_set_tasks_t;
struct __Reply__processor_set_statistics_t;
struct __Reply__processor_get_assignment_t;
struct __Reply__processor_assign_t;
struct __Reply__processor_control_t;
struct __Reply__processor_info_t;
struct __Reply__processor_exit_from_user_t;
struct __Reply__processor_start_from_user_t;
struct __Reply__arcade_register_new_upcall_t;
struct __Reply__task_restartable_ranges_synchronize_t;
struct __Reply__task_restartable_ranges_register_t;
struct __Reply__mach_memory_entry_ownership_from_user_t;
struct __Reply__mach_memory_entry_access_tracking_t;
struct __Reply__mach_memory_entry_purgable_control_t;
struct __Reply__mach_voucher_debug_info_t;
struct __Reply__mach_voucher_attr_command_t;
struct __Reply__mach_voucher_extract_all_attr_recipes_t;
struct __Reply__mach_voucher_extract_attr_recipe_t;
struct __Reply__mach_voucher_extract_attr_content_t;
struct __Reply__mach_vm_deferred_reclamation_buffer_update_reclaimable_bytes_t;
struct __Reply__mach_vm_deferred_reclamation_buffer_synchronize_t;
struct __Reply__mach_vm_deferred_reclamation_buffer_init_t;
struct __Reply__mach_vm_remap_new_external_t;
struct __Reply__mach_vm_page_range_query_t;
struct __Reply__mach_vm_page_info_t;
struct __Reply__mach_vm_purgable_control_external_t;
struct __Reply___mach_make_memory_entry_t;
struct __Reply__mach_vm_region_t;
struct __Reply__mach_vm_region_recurse_t;
struct __Reply__mach_vm_page_query_t;
struct __Reply__mach_vm_remap_external_t;
struct __Reply__mach_vm_machine_attribute_t;
struct __Reply__mach_vm_map_external_t;
struct __Reply__mach_vm_behavior_set_t;
struct __Reply__mach_vm_msync_t;
struct __Reply__mach_vm_read_overwrite_t;
struct __Reply__mach_vm_copy_t;
struct __Reply__mach_vm_write_t;
struct __Reply__mach_vm_read_list_t;
struct __Reply__mach_vm_read_t;
struct __Reply__mach_vm_inherit_t;
struct __Reply__mach_vm_protect_t;
struct __Reply__mach_vm_deallocate_t;
struct __Reply__mach_vm_allocate_external_t;
struct __Reply__mach_port_assert_attributes_t;
struct __Reply__mach_port_get_service_port_info_t;
struct __Reply__mach_port_is_connection_for_service_t;
struct __Reply__mach_port_kobject_description_from_user_t;
struct __Reply__mach_port_swap_guard_t;
struct __Reply__mach_port_guard_with_flags_t;
struct __Reply__mach_port_special_reply_port_reset_link_t;
struct __Reply__mach_port_space_basic_info_t;
struct __Reply__mach_port_unguard_t;
struct __Reply__mach_port_guard_t;
struct __Reply__mach_port_destruct_t;
struct __Reply__mach_port_construct_t;
struct __Reply__mach_port_kobject_from_user_t;
struct __Reply__mach_port_set_context_t;
struct __Reply__mach_port_get_context_from_user_t;
struct __Reply__mach_port_extract_member_t;
struct __Reply__mach_port_insert_member_t;
struct __Reply__mach_port_dnrequest_info_t;
struct __Reply__mach_port_space_info_from_user_t;
struct __Reply__mach_port_get_srights_t;
struct __Reply__task_set_port_space_t;
struct __Reply__mach_port_allocate_full_t;
struct __Reply__mach_port_allocate_qos_t;
struct __Reply__mach_port_set_attributes_t;
struct __Reply__mach_port_get_attributes_from_user_t;
struct __Reply__mach_port_set_seqno_t;
struct __Reply__mach_port_extract_right_t;
struct __Reply__mach_port_insert_right_t;
struct __Reply__mach_port_request_notification_t;
struct __Reply__mach_port_move_member_t;
struct __Reply__mach_port_get_set_status_from_user_t;
struct __Reply__mach_port_set_mscount_t;
struct __Reply__mach_port_peek_t;
struct __Reply__mach_port_mod_refs_t;
struct __Reply__mach_port_get_refs_t;
struct __Reply__mach_port_deallocate_t;
struct __Reply__mach_port_destroy_t;
struct __Reply__mach_port_allocate_t;
struct __Reply__mach_port_allocate_name_t;
struct __Reply__mach_port_type_t;
struct __Reply__mach_port_names_t;
struct __Reply__mach_zone_get_btlog_records_t;
struct __Reply__mach_zone_get_zlog_zones_t;
struct __Reply__mach_zone_info_for_largest_zone_t;
struct __Reply__mach_zone_info_for_zone_t;
struct __Reply__host_set_multiuser_config_flags_t;
struct __Reply__mach_memory_info_t;
struct __Reply__host_set_atm_diagnostic_flag_t;
struct __Reply__host_create_mach_voucher_t;
struct __Reply__mach_zone_force_gc_t;
struct __Reply__mach_zone_info_t;
struct __Reply__host_statistics64_from_user_t;
struct __Reply__host_lockgroup_info_t;
struct __Reply__host_request_notification_t;
struct __Reply__host_statistics_from_user_t;
struct __Reply__mach_memory_object_memory_entry_64_t;
struct __Reply__processor_set_default_t;
struct __Reply__host_virtual_physical_table_info_t;
struct __Reply__kmod_get_info_t;
struct __Reply__host_get_clock_service_t;
struct __Reply__host_get_io_main_t;
struct __Reply__host_processor_info_t;
struct __Reply__mach_memory_object_memory_entry_t;
struct __Reply__host_page_size_t;
struct __Reply__host_kernel_version_t;
struct __Reply__host_info_t;
struct __Reply__kext_request_t;
struct __Reply__host_get_UNDServer_t;
struct __Reply__host_set_UNDServer_t;
struct __Reply__host_processor_set_priv_t;
struct __Reply__host_processor_sets_t;
struct __Reply__mach_vm_wire_external_t;
struct __Reply__host_swap_exception_ports_t;
struct __Reply__host_get_exception_ports_t;
struct __Reply__host_set_exception_ports_t;
struct __Reply__host_set_special_port_from_user_t;
struct __Reply__host_get_special_port_from_user_t;
struct __Reply__host_processors_t;
struct __Reply__vm_allocate_cpm_t;
struct __Reply__thread_wire_t;
struct __Reply__vm_wire_t;
struct __Reply__host_default_memory_manager_t;
struct __Reply__host_priv_statistics_t;
struct __Reply__host_reboot_t;
struct __Reply__host_get_boot_info_t;
struct __Reply__mach_eventlink_disassociate_t;
struct __Reply__mach_eventlink_associate_t;
struct __Reply__mach_eventlink_destroy_t;
struct __Reply__mach_eventlink_create_t;
struct __Reply__clock_alarm_t;
struct __Reply__clock_get_attributes_t;
struct __Reply__clock_get_time_t;
struct mach_port_info_ext;
struct ipc_info_tree_name;
struct mach_msg_mac_trailer32_t;
struct mach_msg_mac_trailer64_t;
struct __Reply__UNDNotificationCreated_rpc_t;
struct __Reply__UNDAlertCompletedWithResult_rpc_t;
struct OSDictionary_1;
struct _amfi;
struct IOMemoryMap_1;
struct IOVirtualRange_1;
struct kern_pbufpool_1;
struct cyc_list;
struct OSArray_1;

/* 1 */
typedef mach_header_64 kernel_mach_header_t;

/* 4 */
typedef unsigned int u_int32_t;

/* 3 */
typedef u_int32_t uint32_t;

/* 6 */
typedef int integer_t;

/* 5 */
typedef integer_t cpu_type_t;

/* 7 */
typedef integer_t cpu_subtype_t;

/* 2 */
struct mach_header_64
{
  uint32_t magic;
  cpu_type_t cputype;
  cpu_subtype_t cpusubtype;
  uint32_t filetype;
  uint32_t ncmds;
  uint32_t sizeofcmds;
  uint32_t flags;
  uint32_t reserved;
};

/* 10 */
typedef unsigned __int8 __uint8_t;

/* 11 */
typedef unsigned __int16 __uint16_t;

/* 12 */
typedef unsigned int __uint32_t;

/* 9 */
union in6_addr::$330434928707C706902F20BE7BA89EB4
{
  __uint8_t __u6_addr8[16];
  __uint16_t __u6_addr16[8];
  __uint32_t __u6_addr32[4];
};

/* 8 */
struct in6_addr
{
  in6_addr::$330434928707C706902F20BE7BA89EB4 __u6_addr;
};

/* 26 */
typedef void (__cdecl *mig_stub_routine_t)(mach_msg_header_t *, mach_msg_header_t *);

/* 25 */
typedef mig_stub_routine_t mig_routine_t;

/* 14 */
typedef mig_routine_t (__cdecl *mig_server_routine_t)(mach_msg_header_t *);

/* 24 */
typedef integer_t mach_msg_id_t;

/* 29 */
typedef unsigned __int64 uintptr_t;

/* 28 */
typedef uintptr_t vm_offset_t;

/* 27 */
typedef vm_offset_t vm_address_t;

/* 32 */
typedef int kern_return_t;

/* 31 */
typedef kern_return_t (*mig_impl_routine_t)(void);

/* 33 */
typedef mach_msg_type_descriptor_t *routine_arg_descriptor_t;

/* 30 */
struct routine_descriptor
{
  mig_impl_routine_t impl_routine;
  mig_stub_routine_t stub_routine;
  unsigned int argc;
  unsigned int descr_count;
  routine_arg_descriptor_t arg_descr;
  unsigned int max_reply_msg;
};

/* 13 */
struct catch_exc_subsystem
{
  mig_server_routine_t server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t reserved;
  routine_descriptor routine[3];
};

/* 16 */
typedef unsigned int mach_msg_bits_t;

/* 19 */
typedef unsigned int __darwin_natural_t;

/* 18 */
typedef __darwin_natural_t natural_t;

/* 17 */
typedef natural_t mach_msg_size_t;

/* 22 */
struct ipc_port;

/* 21 */
typedef struct ipc_port *ipc_port_t;

/* 20 */
typedef ipc_port_t mach_port_t;

/* 23 */
typedef natural_t mach_port_name_t;

/* 15 */
#pragma pack(push, 4)
struct mach_msg_header_t
{
  mach_msg_bits_t msgh_bits;
  mach_msg_size_t msgh_size;
  mach_port_t msgh_remote_port;
  mach_port_t msgh_local_port;
  mach_port_name_t msgh_voucher_port;
  mach_msg_id_t msgh_id;
};
#pragma pack(pop)

/* 34 */
#pragma pack(push, 4)
struct mach_msg_type_descriptor_t
{
  natural_t pad1;
  mach_msg_size_t pad2;
  unsigned __int32 pad3 : 24;
  unsigned __int32 type : 8;
};
#pragma pack(pop)

/* 35 */
struct catch_mach_exc_subsystem
{
  mig_server_routine_t server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t reserved;
  routine_descriptor routine[3];
};

/* 38 */
typedef unsigned __int64 __darwin_size_t;

/* 37 */
typedef __darwin_size_t size_t;

/* 39 */
typedef ccdigest_state *ccdigest_state_t;

/* 47 */
typedef ccdigest_ctx *ccdigest_ctx_t;

/* 36 */
struct ccdigest_info
{
  size_t output_size;
  size_t state_size;
  size_t block_size;
  size_t oid_size;
  const unsigned __int8 *oid;
  const void *initial_state;
  void (__cdecl *compress)(ccdigest_state_t, size_t, const void *);
  void (__cdecl *final)(const ccdigest_info *, ccdigest_ctx_t, unsigned __int8 *);
};

/* 43 */
typedef unsigned __int8 u_int8_t;

/* 42 */
typedef u_int8_t uint8_t;

/* 45 */
typedef unsigned __int64 u_int64_t;

/* 44 */
typedef u_int64_t uint64_t;

/* 46 */
typedef uint64_t cc_unit;

/* 41 */
union ccdigest_state::$67175509AEF0CB0D0935ED80FD36639C
{
  uint8_t u8;
  uint32_t u32;
  uint64_t u64;
  cc_unit ccn;
};

/* 40 */
struct __attribute__((aligned(8))) ccdigest_state
{
  ccdigest_state::$67175509AEF0CB0D0935ED80FD36639C state;
};

/* 49 */
union ccdigest_ctx::$67175509AEF0CB0D0935ED80FD36639C
{
  uint8_t u8;
  uint32_t u32;
  uint64_t u64;
  cc_unit ccn;
};

/* 48 */
struct __attribute__((aligned(8))) ccdigest_ctx
{
  ccdigest_ctx::$67175509AEF0CB0D0935ED80FD36639C state;
};

/* 50 */
struct sysctl_oid_list
{
  sysctl_oid *slh_first;
};

/* 52 */
struct sysctl_oid::$BF306FC4453E1DFFB4E5D662FA87221D
{
  sysctl_oid *sle_next;
};

/* 51 */
struct sysctl_oid
{
  sysctl_oid_list *oid_parent;
  sysctl_oid::$BF306FC4453E1DFFB4E5D662FA87221D oid_link;
  int oid_number;
  int oid_kind;
  void *oid_arg1;
  int oid_arg2;
  const char *oid_name;
  int (__cdecl *oid_handler)(sysctl_oid *, void *, int, sysctl_req *);
  const char *oid_fmt;
  const char *oid_descr;
  int oid_version;
  int oid_refcnt;
};

/* 54 */
struct proc;

/* 55 */
typedef u_int64_t user_addr_t;

/* 53 */
struct sysctl_req
{
  proc *p;
  int lock;
  user_addr_t oldptr;
  size_t oldlen;
  size_t oldidx;
  int (__cdecl *oldfunc)(sysctl_req *, const void *, size_t);
  user_addr_t newptr;
  size_t newlen;
  size_t newidx;
  int (__cdecl *newfunc)(sysctl_req *, void *, size_t);
};

/* 68 */
struct IORPC
{
  IORPCMessageMach *message;
  IORPCMessageMach *reply;
  uint32_t sendSize;
  uint32_t replySize;
};

/* 56 */
struct OSMetaClass_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSMetaClass)(OSMetaClass *__hidden this);
  void (__cdecl *~OSMetaClass_0)(OSMetaClass *__hidden this);
  void (__cdecl *release)(const OSMetaClass *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSMetaClass *__hidden this);
  void (__cdecl *retain)(const OSMetaClass *__hidden this);
  void (__cdecl *release_0)(const OSMetaClass *__hidden this);
  bool (__cdecl *serialize)(const OSMetaClass *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSMetaClass *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSMetaClass *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSMetaClass *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSMetaClass *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSMetaClassBase *__hidden this, const IORPC rpc);
  OSObject *(__cdecl *alloc)(const OSMetaClass *__hidden this);
  __int64 vcallOffset;
};

/* 58 */
struct __cppobj OSMetaClassBase
{
  OSMetaClassBase_vtbl *__vftable /*VFT*/;
};

/* 71 */
struct ExpansionData;

/* 57 */
struct __cppobj OSMetaClass : OSMetaClassBase
{
  ExpansionData *reserved;
  const OSMetaClass *superClassLink;
  const OSSymbol *className;
  unsigned int classSize;
  unsigned int instanceCount;
};

/* 61 */
struct __cppobj OSObject : OSMetaClassBase
{
  int retainCount;
};

/* 65 */
typedef void *OSSerialize::Editor;

/* 60 */
struct __cppobj OSSerialize : OSObject
{
  char *data;
  unsigned int length;
  unsigned int capacity;
  unsigned int capacityIncrement;
  OSArray *tags;
  bool binary;
  bool endCollection;
  OSSerialize::Editor editor;
  void *editRef;
  OSData *indexData;
};

/* 70 */
#pragma pack(push, 4)
struct mach_msg_body_t
{
  mach_msg_size_t msgh_descriptor_count;
};
#pragma pack(pop)

/* 69 */
struct IORPCMessageMach
{
  mach_msg_header_t msgh;
  mach_msg_body_t msgh_body;
};

/* 59 */
struct /*VFT*/ OSMetaClassBase_vtbl
{
  void (__cdecl *~OSMetaClassBase)(OSMetaClassBase *__hidden this);
  void (__cdecl *~OSMetaClassBase_0)(OSMetaClassBase *__hidden this);
  void (__cdecl *release)(const OSMetaClassBase *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSMetaClassBase *__hidden this);
  void (__cdecl *retain)(const OSMetaClassBase *__hidden this);
  void (__cdecl *release_0)(const OSMetaClassBase *__hidden this);
  bool (__cdecl *serialize)(const OSMetaClassBase *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSMetaClassBase *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSMetaClassBase *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSMetaClassBase *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSMetaClassBase *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSMetaClassBase *__hidden this, const IORPC rpc);
};

/* 73 */
struct __cppobj OSString : OSObject
{
  unsigned __int32 flags : 14;
  unsigned __int32 length : 18;
  char *string;
};

/* 72 */
struct __cppobj OSSymbol : OSString
{
};

/* 63 */
struct __cppobj OSCollection : OSObject
{
  unsigned int updateStamp;
  unsigned int fOptions;
};

/* 64 */
typedef const OSMetaClassBase *OSArray::ArrayPtrType;

/* 62 */
struct __cppobj OSArray : OSCollection
{
  unsigned int count;
  unsigned int capacity;
  unsigned int capacityIncrement;
  OSArray::ArrayPtrType *array;
};

/* 67 */
struct OSData::ExpansionData;

/* 66 */
struct __cppobj OSData : OSObject
{
  unsigned int length;
  unsigned int capacity;
  unsigned int capacityIncrement;
  void *data;
  OSData::ExpansionData *reserved;
};

/* 74 */
struct OSArray_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSArray)(OSArray *__hidden this);
  void (__cdecl *~OSArray_0)(OSArray *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSArray *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSArray *__hidden this);
  bool (__cdecl *isEqualTo)(const OSArray *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSCollection *__hidden this);
  void (__cdecl *free)(OSArray *__hidden this);
  unsigned int (__cdecl *iteratorSize)(const OSArray *__hidden this);
  bool (__cdecl *initIterator)(const OSArray *__hidden this, void *iterator);
  bool (__cdecl *getNextObjectForIterator)(const OSArray *__hidden this, void *iterator, OSObject **ret);
  unsigned int (__cdecl *getCount)(const OSArray *__hidden this);
  unsigned int (__cdecl *getCapacity)(const OSArray *__hidden this);
  unsigned int (__cdecl *getCapacityIncrement)(const OSArray *__hidden this);
  unsigned int (__cdecl *setCapacityIncrement)(OSArray *__hidden this, unsigned int increment);
  unsigned int (__cdecl *ensureCapacity)(OSArray *__hidden this, unsigned int newCapacity);
  void (__cdecl *flushCollection)(OSArray *__hidden this);
  unsigned int (__cdecl *setOptions)(OSArray *__hidden this, unsigned int options, unsigned int mask, void *context);
  OSCollection *(__cdecl *copyCollection)(OSArray *__hidden this, OSDictionary *cycleDict);
  bool (__cdecl *initWithCapacity)(OSArray *__hidden this, unsigned int capacity);
  bool (__cdecl *initWithObjects)(OSArray *__hidden this, const OSObject *objects[], unsigned int count, unsigned int capacity);
  bool (__cdecl *initWithArray)(OSArray *__hidden this, const OSArray *anArray, unsigned int capacity);
  bool (__cdecl *setObject)(OSArray *__hidden this, const OSMetaClassBase *anObject);
  bool (__cdecl *setObject_0)(OSArray *__hidden this, unsigned int index, const OSMetaClassBase *anObject);
  bool (__cdecl *merge)(OSArray *__hidden this, const OSArray *otherArray);
  void (__cdecl *replaceObject)(OSArray *__hidden this, unsigned int index, const OSMetaClassBase *anObject);
  void (__cdecl *removeObject)(OSArray *__hidden this, unsigned int index);
  bool (__cdecl *isEqualTo_0)(const OSArray *__hidden this, const OSArray *anArray);
  OSObject *(__cdecl *getObject)(const OSArray *__hidden this, unsigned int index);
  OSObject *(__cdecl *getLastObject)(const OSArray *__hidden this);
  unsigned int (__cdecl *getNextIndexOfObject)(const OSArray *__hidden this, const OSMetaClassBase *anObject, unsigned int index);
  __int64 vcallOffset;
};

/* 75 */
struct __cppobj OSDictionary : OSCollection
{
  unsigned int count;
  unsigned int capacity;
  unsigned int capacityIncrement;
  OSDictionary::dictEntry *dictionary;
};

/* 76 */
struct OSDictionary::dictEntry
{
  const OSSymbol *key;
  const OSMetaClassBase *value;
};

/* 77 */
struct OSBoolean_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSBoolean)(OSBoolean *__hidden this);
  void (__cdecl *~OSBoolean_0)(OSBoolean *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSBoolean *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSBoolean *__hidden this);
  bool (__cdecl *isEqualTo)(const OSBoolean *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSBoolean *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSBoolean *__hidden this, const void *tag, const int when);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSBoolean *__hidden this);
  bool (__cdecl *isTrue)(const OSBoolean *__hidden this);
  bool (__cdecl *isFalse)(const OSBoolean *__hidden this);
  bool (__cdecl *getValue)(const OSBoolean *__hidden this);
  bool (__cdecl *isEqualTo_0)(const OSBoolean *__hidden this, const OSBoolean *aBoolean);
  __int64 vcallOffset;
};

/* 78 */
struct __cppobj OSBoolean : OSObject
{
  bool value;
};

/* 79 */
struct OSCollectionIterator_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSCollectionIterator)(OSCollectionIterator *__hidden this);
  void (__cdecl *~OSCollectionIterator_0)(OSCollectionIterator *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSCollectionIterator *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSCollectionIterator *__hidden this);
  void (__cdecl *reset)(OSCollectionIterator *__hidden this);
  bool (__cdecl *isValid)(OSCollectionIterator *__hidden this);
  OSObject *(__cdecl *getNextObject)(OSCollectionIterator *__hidden this);
  bool (__cdecl *initWithCollection)(OSCollectionIterator *__hidden this, const OSCollection *inColl);
  __int64 vcallOffset;
};

/* 81 */
struct __cppobj OSIterator : OSObject
{
};

/* 80 */
struct __cppobj OSCollectionIterator : OSIterator
{
  const OSCollection *collection;
  void *collIterator;
  unsigned int initialUpdateStamp;
  bool valid;
};

/* 83 */
typedef void (__cdecl *OSData::DeallocFunction)(void *, unsigned int);

/* 82 */
struct OSData_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSData)(OSData *__hidden this);
  void (__cdecl *~OSData_0)(OSData *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSData *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSData *__hidden this);
  bool (__cdecl *isEqualTo)(const OSData *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSData *__hidden this);
  bool (__cdecl *initWithCapacity)(OSData *__hidden this, unsigned int capacity);
  bool (__cdecl *initWithBytes)(OSData *__hidden this, const void *bytes, unsigned int numBytes);
  bool (__cdecl *initWithBytesNoCopy)(OSData *__hidden this, void *bytes, unsigned int numBytes);
  bool (__cdecl *initWithData)(OSData *__hidden this, const OSData *inData);
  bool (__cdecl *initWithData_0)(OSData *__hidden this, const OSData *inData, unsigned int start, unsigned int numBytes);
  unsigned int (__cdecl *getLength)(const OSData *__hidden this);
  unsigned int (__cdecl *getCapacity)(const OSData *__hidden this);
  unsigned int (__cdecl *getCapacityIncrement)(const OSData *__hidden this);
  unsigned int (__cdecl *setCapacityIncrement)(OSData *__hidden this, unsigned int increment);
  unsigned int (__cdecl *ensureCapacity)(OSData *__hidden this, unsigned int newCapacity);
  bool (__cdecl *appendBytes)(OSData *__hidden this, const void *bytes, unsigned int numBytes);
  bool (__cdecl *appendBytes_0)(OSData *__hidden this, const OSData *aDataObj);
  const void *(__cdecl *getBytesNoCopy)(const OSData *__hidden this);
  const void *(__cdecl *getBytesNoCopy_0)(const OSData *__hidden this, unsigned int start, unsigned int numBytes);
  bool (__cdecl *isEqualTo_0)(const OSData *__hidden this, const OSData *aDataObj);
  bool (__cdecl *isEqualTo_1)(const OSData *__hidden this, const void *bytes, unsigned int numBytes);
  bool (__cdecl *isEqualTo_2)(const OSData *__hidden this, const OSString *aString);
  bool (__cdecl *appendByte)(OSData *__hidden this, unsigned __int8 byte, unsigned int numBytes);
  void (__cdecl *setDeallocFunction)(OSData *__hidden this, OSData::DeallocFunction func);
  __int64 vcallOffset;
};

/* 84 */
struct OSDictionary_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSDictionary)(OSDictionary *__hidden this);
  void (__cdecl *~OSDictionary_0)(OSDictionary *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSDictionary *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSDictionary *__hidden this);
  bool (__cdecl *isEqualTo)(const OSDictionary *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSCollection *__hidden this);
  void (__cdecl *free)(OSDictionary *__hidden this);
  unsigned int (__cdecl *iteratorSize)(const OSDictionary *__hidden this);
  bool (__cdecl *initIterator)(const OSDictionary *__hidden this, void *iterator);
  bool (__cdecl *getNextObjectForIterator)(const OSDictionary *__hidden this, void *iterator, OSObject **ret);
  unsigned int (__cdecl *getCount)(const OSDictionary *__hidden this);
  unsigned int (__cdecl *getCapacity)(const OSDictionary *__hidden this);
  unsigned int (__cdecl *getCapacityIncrement)(const OSDictionary *__hidden this);
  unsigned int (__cdecl *setCapacityIncrement)(OSDictionary *__hidden this, unsigned int increment);
  unsigned int (__cdecl *ensureCapacity)(OSDictionary *__hidden this, unsigned int newCapacity);
  void (__cdecl *flushCollection)(OSDictionary *__hidden this);
  unsigned int (__cdecl *setOptions)(OSDictionary *__hidden this, unsigned int options, unsigned int mask, void *context);
  OSCollection *(__cdecl *copyCollection)(OSDictionary *__hidden this, OSDictionary *cycleDict);
  bool (__cdecl *initWithCapacity)(OSDictionary *__hidden this, unsigned int capacity);
  bool (__cdecl *initWithObjects)(OSDictionary *__hidden this, const OSObject *objects[], const OSSymbol *keys[], unsigned int count, unsigned int capacity);
  bool (__cdecl *initWithObjects_0)(OSDictionary *__hidden this, const OSObject *objects[], const OSString *keys[], unsigned int count, unsigned int capacity);
  bool (__cdecl *initWithDictionary)(OSDictionary *__hidden this, const OSDictionary *dict, unsigned int capacity);
  bool (__cdecl *setObject)(OSDictionary *__hidden this, const OSSymbol *aKey, const OSMetaClassBase *anObject);
  bool (__cdecl *setObject_0)(OSDictionary *__hidden this, const OSString *aKey, const OSMetaClassBase *anObject);
  bool (__cdecl *setObject_1)(OSDictionary *__hidden this, const char *aKey, const OSMetaClassBase *anObject);
  void (__cdecl *removeObject)(OSDictionary *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeObject_0)(OSDictionary *__hidden this, const OSString *aKey);
  void (__cdecl *removeObject_1)(OSDictionary *__hidden this, const char *aKey);
  bool (__cdecl *merge)(OSDictionary *__hidden this, const OSDictionary *aDictionary);
  OSObject *(__cdecl *getObject)(const OSDictionary *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getObject_0)(const OSDictionary *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getObject_1)(const OSDictionary *__hidden this, const char *aKey);
  bool (__cdecl *isEqualTo_0)(const OSDictionary *__hidden this, const OSDictionary *aDictionary, const OSCollection *keys);
  bool (__cdecl *isEqualTo_1)(const OSDictionary *__hidden this, const OSDictionary *aDictionary);
  __int64 vcallOffset;
};

/* 101 */
enum kc_kind : __int32
{
  KCKindNone = 0xFFFFFFFF,
  KCKindUnknown = 0x0,
  KCKindPrimary = 0x1,
  KCKindPageable = 0x2,
  KCKindAuxiliary = 0x3,
  KCNumKinds = 0x4,
};

/* 100 */
typedef kc_kind kc_kind_t;

/* 107 */
typedef kern_return_t OSReturn;

/* 106 */
typedef uint8_t OSKextExcludeLevel;

/* 111 */
typedef int boolean_t;

/* 108 */
typedef segment_command_64 kernel_segment_command_t;

/* 112 */
typedef uint32_t OSKextLogSpec;

/* 88 */
typedef __int64 int64_t;

/* 87 */
typedef int64_t OSKextVersion;

/* 89 */
typedef uint32_t OSKextLoadTag;

/* 85 */
struct OSKext_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSKext)(OSKext *__hidden this);
  void (__cdecl *~OSKext_0)(OSKext *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSKext *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSKext *__hidden this);
  bool (__cdecl *initWithBooterData)(OSKext *__hidden this, OSString *deviceTreeName, OSData *booterData);
  bool (__cdecl *initWithPrelinkedInfoDict)(OSKext *__hidden this, OSDictionary *infoDict, bool doCoalesedSlides, kc_kind_t type);
  bool (__cdecl *initWithCodelessInfo)(OSKext *__hidden this, OSDictionary *infoDict);
  bool (__cdecl *setInfoDictionaryAndPath)(OSKext *__hidden this, OSDictionary *aDictionary, OSString *aPath);
  bool (__cdecl *setExecutable)(OSKext *__hidden this, OSData *anExecutable, OSData *externalData, bool externalDataIsMkext);
  bool (__cdecl *registerIdentifier)(OSKext *__hidden this);
  bool (__cdecl *isInExcludeList)(OSKext *__hidden this);
  bool (__cdecl *isLoadable)(OSKext *__hidden this);
  bool (__cdecl *resolveDependencies)(OSKext *__hidden this, OSArray *loopStack);
  bool (__cdecl *addBleedthroughDependencies)(OSKext *__hidden this, OSArray *anArray);
  bool (__cdecl *flushDependencies)(OSKext *__hidden this, bool forceFlag);
  uint32_t (__cdecl *getNumDependencies)(OSKext *__hidden this);
  OSArray *(__cdecl *getDependencies)(OSKext *__hidden this);
  OSReturn (__cdecl *load)(OSKext *__hidden this, OSKextExcludeLevel startOpt, OSKextExcludeLevel startMatchingOpt, OSArray *personalityNames);
  OSReturn (__cdecl *unload)(OSKext *__hidden this);
  OSReturn (__cdecl *queueKextNotification)(OSKext *__hidden this, const char *notificationName, OSString *kextIdentifier);
  OSReturn (__cdecl *slidePrelinkedExecutable)(OSKext *__hidden this, bool doCoalesedSlides);
  OSReturn (__cdecl *loadExecutable)(OSKext *__hidden this);
  void (__cdecl *jettisonLinkeditSegment)(OSKext *__hidden this);
  void (__cdecl *jettisonDATASegmentPadding)(OSKext *__hidden this);
  OSData *(__cdecl *getExecutable)(OSKext *__hidden this);
  void (__cdecl *setLinkedExecutable)(OSKext *__hidden this, OSData *anExecutable);
  OSReturn (__cdecl *start)(OSKext *__hidden this, bool startDependenciesFlag);
  OSReturn (__cdecl *stop)(OSKext *__hidden this);
  OSReturn (__cdecl *setVMAttributes)(OSKext *__hidden this, bool protect, bool wire);
  boolean_t (__cdecl *segmentShouldBeWired)(OSKext *__hidden this, kernel_segment_command_t *seg);
  OSReturn (__cdecl *validateKextMapping)(OSKext *__hidden this, bool startFlag);
  boolean_t (__cdecl *verifySegmentMapping)(OSKext *__hidden this, kernel_segment_command_t *seg);
  OSReturn (__cdecl *sendPersonalitiesToCatalog)(OSKext *__hidden this, bool startMatching, OSArray *personalityNames);
  OSDictionary *(__cdecl *copyInfo)(OSKext *__hidden this, OSArray *keys);
  OSReturn (__cdecl *addClass)(OSKext *__hidden this, OSMetaClass *aClass, uint32_t numClasses);
  OSReturn (__cdecl *removeClass)(OSKext *__hidden this, OSMetaClass *aClass);
  bool (__cdecl *hasOSMetaClassInstances)(OSKext *__hidden this);
  OSSet *(__cdecl *getMetaClasses)(OSKext *__hidden this);
  void (__cdecl *reportOSMetaClassInstances)(OSKext *__hidden this, OSKextLogSpec msgLogSpec);
  void (__cdecl *invokeOrCancelRequestCallbacks)(OSKext *__hidden this, OSReturn callbackResult, bool invokeFlag);
  uint32_t (__cdecl *countRequestCallbacks)(OSKext *__hidden this);
  void (__cdecl *setCPPInitialized)(OSKext *__hidden this, bool initialized);
  bool (__cdecl *setAutounloadEnabled)(OSKext *__hidden this, bool flag);
  const OSSymbol *(__cdecl *getIdentifier)(OSKext *__hidden this);
  const char *(__cdecl *getIdentifierCString)(OSKext *__hidden this);
  OSKextVersion (__cdecl *getVersion)(OSKext *__hidden this);
  OSKextVersion (__cdecl *getCompatibleVersion)(OSKext *__hidden this);
  bool (__cdecl *isLibrary)(OSKext *__hidden this);
  bool (__cdecl *isCompatibleWithVersion)(OSKext *__hidden this, OSKextVersion aVersion);
  OSObject *(__cdecl *getPropertyForHostArch)(OSKext *__hidden this, const char *key);
  OSKextLoadTag (__cdecl *getLoadTag)(OSKext *__hidden this);
  void (__cdecl *getSizeInfo)(OSKext *__hidden this, uint32_t *loadSize, uint32_t *wiredSize);
  OSData *(__cdecl *copyUUID)(OSKext *__hidden this);
  OSArray *(__cdecl *copyPersonalitiesArray)(OSKext *__hidden this);
  void (__cdecl *setDriverKitUUID)(OSKext *__hidden this, OSData *uuid);
  void (__cdecl *removePersonalitiesFromCatalog)(OSKext *__hidden this);
  bool (__cdecl *declaresExecutable)(OSKext *__hidden this);
  bool (__cdecl *isInterface)(OSKext *__hidden this);
  bool (__cdecl *isKernel)(OSKext *__hidden this);
  bool (__cdecl *isKernelComponent)(OSKext *__hidden this);
  bool (__cdecl *isExecutable)(OSKext *__hidden this);
  bool (__cdecl *isLoadableInSafeBoot)(OSKext *__hidden this);
  bool (__cdecl *isPrelinked)(OSKext *__hidden this);
  bool (__cdecl *isLoaded)(OSKext *__hidden this);
  bool (__cdecl *isStarted)(OSKext *__hidden this);
  bool (__cdecl *isCPPInitialized)(OSKext *__hidden this);
  __int64 vcallOffset;
};

/* 90 */
typedef kmod_info kmod_info_t;

/* 99 */
struct OSKext::$75D17BA4A8249E1B8D3A3A1E5F44B171
{
  unsigned __int32 loggingEnabled : 1;
  unsigned __int32 hasAllDependencies : 1;
  unsigned __int32 hasBleedthrough : 1;
  unsigned __int32 interface : 1;
  unsigned __int32 kernelComponent : 1;
  unsigned __int32 prelinked : 1;
  unsigned __int32 builtin : 1;
  unsigned __int32 loaded : 1;
  unsigned __int32 dtraceInitialized : 1;
  unsigned __int32 starting : 1;
  unsigned __int32 started : 1;
  unsigned __int32 stopping : 1;
  unsigned __int32 unloading : 1;
  unsigned __int32 resetSegmentsFromVnode : 1;
  unsigned __int32 requireExplicitLoad : 1;
  unsigned __int32 autounloadEnabled : 1;
  unsigned __int32 delayAutounload : 1;
  unsigned __int32 CPPInitialized : 1;
  unsigned __int32 jettisonLinkeditSeg : 1;
  unsigned __int32 resetSegmentsFromImmutableCopy : 1;
};

/* 102 */
struct list_head
{
  list_head *prev;
  list_head *next;
};

/* 104 */
typedef unsigned __int8 __darwin_uuid_t[16];

/* 103 */
typedef __darwin_uuid_t uuid_t;

/* 105 */
struct OSKextAccount;

/* 86 */
struct __cppobj OSKext : OSObject
{
  OSDictionary *infoDict;
  const OSSymbol *bundleID;
  OSString *path;
  OSString *executableRelPath;
  OSString *userExecutableRelPath;
  OSKextVersion version;
  OSKextVersion compatibleVersion;
  OSKextLoadTag loadTag;
  kmod_info_t *kmod_info;
  OSArray *dependencies;
  OSData *linkedExecutable;
  OSSet *metaClasses;
  OSData *interfaceUUID;
  OSData *driverKitUUID;
  OSKext::$75D17BA4A8249E1B8D3A3A1E5F44B171 flags;
  uint32_t matchingRefCount;
  kc_kind_t kc_type;
  list_head pendingPgoHead;
  uuid_t instance_uuid;
  OSKextAccount *account;
  uint32_t builtinKmodIdx;
  OSArray *savedMutableSegments;
};

/* 110 */
typedef int vm_prot_t;

/* 109 */
struct __attribute__((aligned(8))) segment_command_64
{
  uint32_t cmd;
  uint32_t cmdsize;
  char segname[16];
  uint64_t vmaddr;
  uint64_t vmsize;
  uint64_t fileoff;
  uint64_t filesize;
  vm_prot_t maxprot;
  vm_prot_t initprot;
  uint32_t nsects;
  uint32_t flags;
};

/* 98 */
struct __cppobj OSSet : OSCollection
{
  OSArray *members;
};

/* 92 */
typedef int int32_t;

/* 93 */
typedef kmod_reference kmod_reference_t;

/* 95 */
typedef uintptr_t vm_size_t;

/* 96 */
typedef kern_return_t __cdecl kmod_start_func_t(kmod_info *, void *);

/* 97 */
typedef kern_return_t __cdecl kmod_stop_func_t(kmod_info *, void *);

/* 91 */
#pragma pack(push, 4)
struct kmod_info
{
  kmod_info *next;
  int32_t info_version;
  uint32_t id;
  char name[64];
  char version[64];
  int32_t reference_count;
  kmod_reference_t *reference_list;
  vm_address_t address;
  vm_size_t size;
  vm_size_t hdr_size;
  kmod_start_func_t *start;
  kmod_stop_func_t *stop;
};
#pragma pack(pop)

/* 94 */
#pragma pack(push, 4)
struct kmod_reference
{
  kmod_reference *next;
  kmod_info *info;
};
#pragma pack(pop)

/* 113 */
struct OSNumber_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSNumber)(OSNumber *__hidden this);
  void (__cdecl *~OSNumber_0)(OSNumber *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSNumber *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSNumber *__hidden this);
  bool (__cdecl *isEqualTo)(const OSNumber *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSNumber *__hidden this);
  bool (__cdecl *init_0)(OSNumber *__hidden this, unsigned __int64 value, unsigned int numberOfBits);
  bool (__cdecl *init_1)(OSNumber *__hidden this, const char *valueString, unsigned int numberOfBits);
  unsigned int (__cdecl *numberOfBits)(const OSNumber *__hidden this);
  unsigned int (__cdecl *numberOfBytes)(const OSNumber *__hidden this);
  unsigned __int8 (__cdecl *unsigned8BitValue)(const OSNumber *__hidden this);
  unsigned __int16 (__cdecl *unsigned16BitValue)(const OSNumber *__hidden this);
  unsigned int (__cdecl *unsigned32BitValue)(const OSNumber *__hidden this);
  unsigned __int64 (__cdecl *unsigned64BitValue)(const OSNumber *__hidden this);
  void (__cdecl *addValue)(OSNumber *__hidden this, __int64 value);
  void (__cdecl *setValue)(OSNumber *__hidden this, unsigned __int64 value);
  bool (__cdecl *isEqualTo_0)(const OSNumber *__hidden this, const OSNumber *aNumber);
  __int64 vcallOffset;
};

/* 114 */
struct __cppobj OSNumber : OSObject
{
  unsigned int size;
  unsigned __int64 value;
};

/* 119 */
typedef int SInt32;

/* 118 */
typedef SInt32 (__cdecl *OSOrderedSet::OSOrderFunction)(const OSMetaClassBase *, const OSMetaClassBase *, void *);

/* 115 */
struct OSOrderedSet_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSOrderedSet)(OSOrderedSet *__hidden this);
  void (__cdecl *~OSOrderedSet_0)(OSOrderedSet *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSOrderedSet *__hidden this);
  bool (__cdecl *isEqualTo)(const OSOrderedSet *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSCollection *__hidden this);
  void (__cdecl *free)(OSOrderedSet *__hidden this);
  unsigned int (__cdecl *iteratorSize)(const OSOrderedSet *__hidden this);
  bool (__cdecl *initIterator)(const OSOrderedSet *__hidden this, void *iterator);
  bool (__cdecl *getNextObjectForIterator)(const OSOrderedSet *__hidden this, void *iterator, OSObject **ret);
  unsigned int (__cdecl *getCount)(const OSOrderedSet *__hidden this);
  unsigned int (__cdecl *getCapacity)(const OSOrderedSet *__hidden this);
  unsigned int (__cdecl *getCapacityIncrement)(const OSOrderedSet *__hidden this);
  unsigned int (__cdecl *setCapacityIncrement)(OSOrderedSet *__hidden this, unsigned int increment);
  unsigned int (__cdecl *ensureCapacity)(OSOrderedSet *__hidden this, unsigned int newCapacity);
  void (__cdecl *flushCollection)(OSOrderedSet *__hidden this);
  unsigned int (__cdecl *setOptions)(OSOrderedSet *__hidden this, unsigned int options, unsigned int mask, void *context);
  OSCollection *(__cdecl *copyCollection)(OSOrderedSet *__hidden this, OSDictionary *cycleDict);
  bool (__cdecl *initWithCapacity)(OSOrderedSet *__hidden this, unsigned int capacity, OSOrderedSet::OSOrderFunction orderFunc, void *orderingContext);
  bool (__cdecl *setObject)(OSOrderedSet *__hidden this, const OSMetaClassBase *anObject);
  bool (__cdecl *setFirstObject)(OSOrderedSet *__hidden this, const OSMetaClassBase *anObject);
  bool (__cdecl *setLastObject)(OSOrderedSet *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *removeObject)(OSOrderedSet *__hidden this, const OSMetaClassBase *anObject);
  bool (__cdecl *containsObject)(const OSOrderedSet *__hidden this, const OSMetaClassBase *anObject);
  bool (__cdecl *member)(const OSOrderedSet *__hidden this, const OSMetaClassBase *anObject);
  OSObject *(__cdecl *getFirstObject)(const OSOrderedSet *__hidden this);
  OSObject *(__cdecl *getLastObject)(const OSOrderedSet *__hidden this);
  SInt32 (__cdecl *orderObject)(OSOrderedSet *__hidden this, const OSMetaClassBase *anObject);
  bool (__cdecl *setObject_0)(OSOrderedSet *__hidden this, unsigned int index, const OSMetaClassBase *anObject);
  OSObject *(__cdecl *getObject)(const OSOrderedSet *__hidden this, unsigned int index);
  void *(__cdecl *getOrderingRef)(OSOrderedSet *__hidden this);
  bool (__cdecl *isEqualTo_0)(const OSOrderedSet *__hidden this, const OSOrderedSet *anOrderedSet);
  __int64 vcallOffset;
};

/* 117 */
struct _Element;

/* 116 */
struct __cppobj OSOrderedSet : OSCollection
{
  _Element *array;
  OSOrderedSet::OSOrderFunction ordering;
  void *orderingRef;
  unsigned int count;
  unsigned int capacity;
  unsigned int capacityIncrement;
  OSOrderedSet::ExpansionData *reserved;
};

/* 120 */
struct OSOrderedSet::ExpansionData
{
};

/* 121 */
struct OSSerialize_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSSerialize)(OSSerialize *__hidden this);
  void (__cdecl *~OSSerialize_0)(OSSerialize *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSSerialize *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSSerialize *__hidden this);
  char *(__cdecl *text)(const OSSerialize *__hidden this);
  void (__cdecl *clearText)(OSSerialize *__hidden this);
  bool (__cdecl *previouslySerialized)(OSSerialize *__hidden this, const OSMetaClassBase *object);
  bool (__cdecl *addXMLStartTag)(OSSerialize *__hidden this, const OSMetaClassBase *object, const char *tagString);
  bool (__cdecl *addXMLEndTag)(OSSerialize *__hidden this, const char *tagString);
  bool (__cdecl *addChar)(OSSerialize *__hidden this, const char aChar);
  bool (__cdecl *addString)(OSSerialize *__hidden this, const char *cString);
  bool (__cdecl *initWithCapacity)(OSSerialize *__hidden this, unsigned int inCapacity);
  unsigned int (__cdecl *getLength)(const OSSerialize *__hidden this);
  unsigned int (__cdecl *getCapacity)(const OSSerialize *__hidden this);
  unsigned int (__cdecl *getCapacityIncrement)(const OSSerialize *__hidden this);
  unsigned int (__cdecl *setCapacityIncrement)(OSSerialize *__hidden this, unsigned int increment);
  unsigned int (__cdecl *ensureCapacity)(OSSerialize *__hidden this, unsigned int newCapacity);
  __int64 vcallOffset;
};

/* 122 */
struct OSSerializer_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSSerializer)(OSSerializer *__hidden this);
  void (__cdecl *~OSSerializer_0)(OSSerializer *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSSerializer *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSSerializer *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSSerializer *__hidden this);
  __int64 vcallOffset;
};

/* 124 */
typedef bool (__cdecl *OSSerializerCallback)(void *, void *, OSSerialize *);

/* 123 */
struct __cppobj OSSerializer : OSObject
{
  void *target;
  void *ref;
  OSSerializerCallback callback;
};

/* 125 */
struct OSSet_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSSet)(OSSet *__hidden this);
  void (__cdecl *~OSSet_0)(OSSet *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSSet *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSSet *__hidden this);
  bool (__cdecl *isEqualTo)(const OSSet *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSCollection *__hidden this);
  void (__cdecl *free)(OSSet *__hidden this);
  unsigned int (__cdecl *iteratorSize)(const OSSet *__hidden this);
  bool (__cdecl *initIterator)(const OSSet *__hidden this, void *iterator);
  bool (__cdecl *getNextObjectForIterator)(const OSSet *__hidden this, void *iterator, OSObject **ret);
  unsigned int (__cdecl *getCount)(const OSSet *__hidden this);
  unsigned int (__cdecl *getCapacity)(const OSSet *__hidden this);
  unsigned int (__cdecl *getCapacityIncrement)(const OSSet *__hidden this);
  unsigned int (__cdecl *setCapacityIncrement)(OSSet *__hidden this, unsigned int increment);
  unsigned int (__cdecl *ensureCapacity)(OSSet *__hidden this, unsigned int newCapacity);
  void (__cdecl *flushCollection)(OSSet *__hidden this);
  unsigned int (__cdecl *setOptions)(OSSet *__hidden this, unsigned int options, unsigned int mask, void *context);
  OSCollection *(__cdecl *copyCollection)(OSSet *__hidden this, OSDictionary *cycleDict);
  bool (__cdecl *initWithCapacity)(OSSet *__hidden this, unsigned int capacity);
  bool (__cdecl *initWithObjects)(OSSet *__hidden this, const OSObject *objects[], unsigned int count, unsigned int capacity);
  bool (__cdecl *initWithArray)(OSSet *__hidden this, const OSArray *array, unsigned int capacity);
  bool (__cdecl *initWithSet)(OSSet *__hidden this, const OSSet *set, unsigned int capacity);
  bool (__cdecl *setObject)(OSSet *__hidden this, const OSMetaClassBase *anObject);
  bool (__cdecl *merge)(OSSet *__hidden this, const OSArray *array);
  bool (__cdecl *merge_0)(OSSet *__hidden this, const OSSet *set);
  void (__cdecl *removeObject)(OSSet *__hidden this, const OSMetaClassBase *anObject);
  bool (__cdecl *containsObject)(const OSSet *__hidden this, const OSMetaClassBase *anObject);
  bool (__cdecl *member)(const OSSet *__hidden this, const OSMetaClassBase *anObject);
  OSObject *(__cdecl *getAnyObject)(const OSSet *__hidden this);
  bool (__cdecl *isEqualTo_0)(const OSSet *__hidden this, const OSSet *aSet);
  __int64 vcallOffset;
};

/* 126 */
struct OSCollection_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSCollection)(OSCollection *__hidden this);
  void (__cdecl *~OSCollection_0)(OSCollection *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSCollection *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSCollection *__hidden this);
  void (__cdecl *free)(OSObject *__hidden this);
  unsigned int (__cdecl *iteratorSize)(const OSCollection *__hidden this);
  bool (__cdecl *initIterator)(const OSCollection *__hidden this, void *iterationContext);
  bool (__cdecl *getNextObjectForIterator)(const OSCollection *__hidden this, void *iterationContext, OSObject **nextObject);
  unsigned int (__cdecl *getCount)(const OSCollection *__hidden this);
  unsigned int (__cdecl *getCapacity)(const OSCollection *__hidden this);
  unsigned int (__cdecl *getCapacityIncrement)(const OSCollection *__hidden this);
  unsigned int (__cdecl *setCapacityIncrement)(OSCollection *__hidden this, unsigned int increment);
  unsigned int (__cdecl *ensureCapacity)(OSCollection *__hidden this, unsigned int newCapacity);
  void (__cdecl *flushCollection)(OSCollection *__hidden this);
  unsigned int (__cdecl *setOptions)(OSCollection *__hidden this, unsigned int options, unsigned int mask, void *context);
  OSCollection *(__cdecl *copyCollection)(OSCollection *__hidden this, OSDictionary *cycleDict);
  __int64 vcallOffset;
};

/* 127 */
struct OSSymbol_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSSymbol)(OSSymbol *__hidden this);
  void (__cdecl *~OSSymbol_0)(OSSymbol *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSString *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSSymbol *__hidden this);
  bool (__cdecl *isEqualTo)(const OSSymbol *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSSymbol *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSSymbol *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSSymbol *__hidden this);
  bool (__cdecl *initWithString)(OSSymbol *__hidden this, const OSString *aString);
  bool (__cdecl *initWithCString)(OSSymbol *__hidden this, const char *cString);
  bool (__cdecl *initWithCStringNoCopy)(OSSymbol *__hidden this, const char *cString);
  unsigned int (__cdecl *getLength)(const OSString *__hidden this);
  char (__cdecl *getChar)(const OSString *__hidden this, unsigned int index);
  bool (__cdecl *setChar)(OSString *__hidden this, char aChar, unsigned int index);
  const char *(__cdecl *getCStringNoCopy)(const OSString *__hidden this);
  bool (__cdecl *isEqualTo_0)(const OSString *__hidden this, const OSString *aString);
  bool (__cdecl *isEqualTo_1)(const OSSymbol *__hidden this, const char *cString);
  bool (__cdecl *isEqualTo_2)(const OSString *__hidden this, const OSData *aDataObject);
  bool (__cdecl *isEqualTo_3)(const OSSymbol *__hidden this, const OSSymbol *aSymbol);
  __int64 vcallOffset;
};

/* 128 */
struct OSString_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSString)(OSString *__hidden this);
  void (__cdecl *~OSString_0)(OSString *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSString *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSString *__hidden this);
  bool (__cdecl *isEqualTo)(const OSString *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSString *__hidden this);
  bool (__cdecl *initWithString)(OSString *__hidden this, const OSString *aString);
  bool (__cdecl *initWithCString)(OSString *__hidden this, const char *cString);
  bool (__cdecl *initWithCStringNoCopy)(OSString *__hidden this, const char *cString);
  unsigned int (__cdecl *getLength)(const OSString *__hidden this);
  char (__cdecl *getChar)(const OSString *__hidden this, unsigned int index);
  bool (__cdecl *setChar)(OSString *__hidden this, char aChar, unsigned int index);
  const char *(__cdecl *getCStringNoCopy)(const OSString *__hidden this);
  bool (__cdecl *isEqualTo_0)(const OSString *__hidden this, const OSString *aString);
  bool (__cdecl *isEqualTo_1)(const OSString *__hidden this, const char *cString);
  bool (__cdecl *isEqualTo_2)(const OSString *__hidden this, const OSData *aDataObject);
  __int64 vcallOffset;
};

/* 129 */
struct OSAction_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSAction)(OSAction *__hidden this);
  void (__cdecl *~OSAction_0)(OSAction *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSAction *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSAction *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSAction *__hidden this);
  __int64 vcallOffset;
};

/* 132 */
struct __cppobj OSInterface
{
};

/* 131 */
struct __cppobj OSActionInterface : OSInterface
{
};

/* 134 */
struct OSAction_IVars;

/* 135 */
struct OSAction_LocalIVars;

/* 133 */
union OSAction::$4F2A07BC51FE7116FB496449F4B49AD3
{
  OSAction_IVars *ivars;
  OSAction_LocalIVars *lvars;
};

/* 130 */
struct __cppobj OSAction : OSObject, OSActionInterface
{
  union
  {
    OSAction_IVars *ivars;
    OSAction_LocalIVars *lvars;
  };
};

/* 136 */
struct OSMetaClassBase_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSMetaClassBase)(OSMetaClassBase *__hidden this);
  void (__cdecl *~OSMetaClassBase_0)(OSMetaClassBase *__hidden this);
  void (__cdecl *release)(const OSMetaClassBase *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSMetaClassBase *__hidden this);
  void (__cdecl *retain)(const OSMetaClassBase *__hidden this);
  void (__cdecl *release_0)(const OSMetaClassBase *__hidden this);
  bool (__cdecl *serialize)(const OSMetaClassBase *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSMetaClassBase *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSMetaClassBase *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSMetaClassBase *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSMetaClassBase *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSMetaClassBase *__hidden this, const IORPC rpc);
  __int64 vcallOffset;
};

/* 137 */
struct IOConditionLock_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOConditionLock)(IOConditionLock *__hidden this);
  void (__cdecl *~IOConditionLock_0)(IOConditionLock *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOConditionLock *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOConditionLock *__hidden this);
  bool (__cdecl *initWithCondition)(IOConditionLock *__hidden this, int condition, bool inIntr);
  bool (__cdecl *tryLock)(IOConditionLock *__hidden this);
  int (__cdecl *lock)(IOConditionLock *__hidden this);
  void (__cdecl *unlock)(IOConditionLock *__hidden this);
  bool (__cdecl *getInterruptible)(const IOConditionLock *__hidden this);
  int (__cdecl *getCondition)(const IOConditionLock *__hidden this);
  int (__cdecl *setCondition)(IOConditionLock *__hidden this, int condition);
  int (__cdecl *lockWhen)(IOConditionLock *__hidden this, int condition);
  void (__cdecl *unlockWith)(IOConditionLock *__hidden this, int condition);
  __int64 vcallOffset;
};

/* 140 */
struct _IOLock;

/* 139 */
typedef struct _IOLock IOLock;

/* 138 */
struct __cppobj IOConditionLock : OSObject
{
  IOLock *cond_interlock;
  int condition;
  IOLock *sleep_interlock;
  unsigned __int8 interruptible;
  bool want_lock;
  bool waiting;
};

/* 146 */
struct IORegistryPlane;

/* 141 */
struct IORegistryIterator_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IORegistryIterator)(IORegistryIterator *__hidden this);
  void (__cdecl *~IORegistryIterator_0)(IORegistryIterator *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IORegistryIterator *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IORegistryIterator *__hidden this);
  void (__cdecl *reset)(IORegistryIterator *__hidden this);
  bool (__cdecl *isValid)(IORegistryIterator *__hidden this);
  IORegistryEntry *(__cdecl *getNextObject)(IORegistryIterator *__hidden this);
  IORegistryEntry *(__cdecl *getNextObjectFlat)(IORegistryIterator *__hidden this);
  IORegistryEntry *(__cdecl *getNextObjectRecursive)(IORegistryIterator *__hidden this);
  IORegistryEntry *(__cdecl *getCurrentEntry)(IORegistryIterator *__hidden this);
  void (__cdecl *enterEntry)(IORegistryIterator *__hidden this);
  void (__cdecl *enterEntry_0)(IORegistryIterator *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *exitEntry)(IORegistryIterator *__hidden this);
  OSOrderedSet *(__cdecl *iterateAll)(IORegistryIterator *__hidden this);
  __int64 vcallOffset;
};

/* 143 */
struct IORegistryIterator::IORegCursor
{
  IORegistryIterator::IORegCursor *next;
  IORegistryEntry *current;
  OSIterator *iter;
};

/* 148 */
typedef unsigned int UInt32;

/* 147 */
typedef UInt32 IOOptionBits;

/* 142 */
struct __cppobj IORegistryIterator : OSIterator
{
  IORegistryIterator::IORegCursor start;
  IORegistryIterator::IORegCursor *where;
  IORegistryEntry *root;
  OSOrderedSet *done;
  const IORegistryPlane *plane;
  IOOptionBits options;
};

/* 145 */
struct IORegistryEntry::ExpansionData;

/* 144 */
struct __cppobj IORegistryEntry : OSObject
{
  IORegistryEntry::ExpansionData *reserved;
  OSDictionary *fRegistryTable;
  OSDictionary *fPropertyTable;
};

/* 149 */
struct IONotifier_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IONotifier)(IONotifier *__hidden this);
  void (__cdecl *~IONotifier_0)(IONotifier *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IONotifier *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSObject *__hidden this);
  void (__cdecl *remove)(IONotifier *__hidden this);
  bool (__cdecl *disable)(IONotifier *__hidden this);
  void (__cdecl *enable)(IONotifier *__hidden this, bool was);
  __int64 vcallOffset;
};

/* 150 */
struct __cppobj IONotifier : OSObject
{
};

/* 151 */
struct OSIterator_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSIterator)(OSIterator *__hidden this);
  void (__cdecl *~OSIterator_0)(OSIterator *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSIterator *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSObject *__hidden this);
  void (__cdecl *reset)(OSIterator *__hidden this);
  bool (__cdecl *isValid)(OSIterator *__hidden this);
  OSObject *(__cdecl *getNextObject)(OSIterator *__hidden this);
  __int64 vcallOffset;
};

/* 152 */
struct IOCatalogue_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOCatalogue)(IOCatalogue *__hidden this);
  void (__cdecl *~IOCatalogue_0)(IOCatalogue *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const IOCatalogue *__hidden this, OSSerialize *s);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOCatalogue *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOCatalogue *__hidden this);
  __int64 vcallOffset;
};

/* 155 */
struct _IORWLock;

/* 154 */
typedef struct _IORWLock IORWLock;

/* 153 */
struct __cppobj IOCatalogue : OSObject
{
  IORWLock *lock;
  SInt32 generation;
  OSDictionary *personalities;
};

/* 173 */
typedef kern_return_t IOReturn;

/* 172 */
typedef IOReturn (__cdecl *IORegistryEntry::Action)(OSObject *, void *, void *, void *, void *);

/* 174 */
typedef void (__cdecl *IORegistryEntryApplierFunction)(IORegistryEntry *, void *);

/* 176 */
typedef unsigned __int64 UInt64;

/* 175 */
typedef UInt64 AbsoluteTime;

/* 178 */
typedef uint32_t IOReportConfigureAction;

/* 179 */
typedef uint32_t IOReportUpdateAction;

/* 192 */
typedef UInt32 IOItemCount;

/* 201 */
typedef void (__cdecl *IOInterruptAction)(OSObject *, void *, IOService *, int);

/* 202 */
typedef IOReturn (__cdecl *IOServiceInterestHandler)(void *, void *, UInt32, IOService *, void *, vm_size_t);

/* 203 */
typedef void (__cdecl *IOServiceApplierFunction)(IOService *, void *);

/* 204 */
typedef void (__cdecl *OSObjectApplierFunction)(OSObject *, void *);

/* 205 */
typedef void *IONotificationRef;

/* 207 */
struct task;

/* 206 */
typedef struct task *task_t;

/* 211 */
typedef unsigned __int64 IOPMPowerFlags;

/* 156 */
struct IOPMPowerSource_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOPMPowerSource)(IOPMPowerSource *__hidden this);
  void (__cdecl *~IOPMPowerSource_0)(IOPMPowerSource *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOPMPowerSource *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(IOPMPowerSource *__hidden this);
  void (__cdecl *free)(IOPMPowerSource *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOService *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  void (__cdecl *updateStatus)(IOPMPowerSource *__hidden this);
  __int64 vcallOffset;
};

/* 162 */
struct IOServicePM;

/* 158 */
struct __cppobj IOService : IORegistryEntry
{
  IOService::ExpansionData *reserved;
  IOService *__provider;
  SInt32 __providerGeneration;
  IOService *__owner;
  IOOptionBits __state[2];
  uint64_t __timeBusy;
  uint64_t __accumBusy;
  IOServicePM *pwrMgt;
  bool initialized;
  void *pm_vars;
  int _numInterruptSources;
  IOInterruptSource *_interruptSources;
};

/* 157 */
struct __cppobj IOPMPowerSource : IOService
{
  bool settingsChangedSinceUpdate;
  OSDictionary *properties;
  const OSSymbol *externalConnectedKey;
  const OSSymbol *externalChargeCapableKey;
  const OSSymbol *batteryInstalledKey;
  const OSSymbol *chargingKey;
  const OSSymbol *warnLevelKey;
  const OSSymbol *criticalLevelKey;
  const OSSymbol *currentCapacityKey;
  const OSSymbol *maxCapacityKey;
  const OSSymbol *timeRemainingKey;
  const OSSymbol *amperageKey;
  const OSSymbol *voltageKey;
  const OSSymbol *cycleCountKey;
  const OSSymbol *adapterInfoKey;
  const OSSymbol *locationKey;
  const OSSymbol *errorConditionKey;
  const OSSymbol *manufacturerKey;
  const OSSymbol *modelKey;
  const OSSymbol *serialKey;
  const OSSymbol *batteryInfoKey;
  IOPMPowerSource *nextInList;
};

/* 177 */
struct IOReportChannelList
{
  uint32_t nchannels;
};

/* 182 */
struct _IORecursiveLock;

/* 181 */
typedef struct _IORecursiveLock IORecursiveLock;

/* 170 */
struct _IOSimpleLock;

/* 169 */
typedef struct _IOSimpleLock IOSimpleLock;

/* 190 */
struct thread;

/* 189 */
typedef struct thread *thread_t;

/* 188 */
typedef thread_t IOThread;

/* 180 */
struct __cppobj IOWorkLoop : OSObject
{
  IORecursiveLock *gateLock;
  IOEventSource *eventChain;
  IOCommandGate *controlG;
  IOSimpleLock *workToDoLock;
  IOThread workThread;
  bool workToDo;
  bool loopRestart;
  IOWorkLoop::ExpansionData *reserved;
};

/* 195 */
struct IOMemoryDescriptorReserved;

/* 197 */
typedef unsigned __int16 u_int16_t;

/* 196 */
typedef u_int16_t uint16_t;

/* 199 */
typedef UInt64 IOByteCount64;

/* 198 */
typedef IOByteCount64 IOByteCount;

/* 194 */
struct __cppobj IOMemoryDescriptor : OSObject
{
  IOMemoryDescriptorReserved *reserved;
  OSSet *_mappings;
  IOOptionBits _flags;
  void *__iomd_reserved5;
  uint16_t __iomd_reserved1[4];
  uintptr_t __iomd_reserved2;
  uintptr_t __iomd_reserved3;
  uintptr_t __iomd_reserved4;
  IOByteCount _length;
  IOOptionBits _tag;
};

/* 193 */
struct __cppobj IODeviceMemory : IOMemoryDescriptor
{
};

/* 200 */
struct __cppobj IOMemoryMap : OSObject
{
};

/* 208 */
struct __cppobj IOUserClient : IOService
{
  IOUserClient::ExpansionData *reserved;
  void *__reserved[9];
};

/* 210 */
struct IOPMPowerState
{
  unsigned __int64 version;
  IOPMPowerFlags capabilityFlags;
  IOPMPowerFlags outputPowerCharacter;
  IOPMPowerFlags inputPowerRequirement;
  unsigned __int64 staticPower;
  unsigned __int64 stateOrder;
  unsigned __int64 powerToAttain;
  unsigned __int64 timeToAttain;
  unsigned __int64 settleUpTime;
  unsigned __int64 timeToLower;
  unsigned __int64 settleDownTime;
  unsigned __int64 powerDomainBudget;
};

/* 212 */
struct __cppobj IOPowerConnection : IOService
{
  bool stateKnown;
  IOPMPowerFlags currentPowerFlags;
  unsigned __int64 desiredDomainState;
  bool requestFlag;
  unsigned __int64 preventIdleSleepFlag;
  unsigned __int64 preventSystemSleepFlag;
  bool awaitingAck;
  bool readyFlag;
};

/* 160 */
struct IOInterruptAccountingReporter;

/* 161 */
struct OSObjectUserVars;

/* 159 */
struct IOService::ExpansionData
{
  uint64_t authorizationID;
  IOLock *interruptStatisticsLock;
  IOInterruptAccountingReporter *interruptStatisticsArray;
  int interruptStatisticsArrayCount;
  OSObjectUserVars *uvars;
};

/* 163 */
struct IOInterruptSource
{
  IOInterruptController *interruptController;
  OSData *vectorData;
};

/* 184 */
typedef void (*IOEventSource::Action)(OSObject *, ...);

/* 183 */
struct __cppobj IOEventSource : OSObject
{
  IOEventSource *eventChainNext;
  OSObject *owner;
  IOEventSource::Action action;
  bool enabled;
  IOWorkLoop *workLoop;
  void *refcon;
  IOEventSource::ExpansionData *reserved;
};

/* 186 */
struct __cppobj IOCommandGate : IOEventSource
{
  IOCommandGate::ExpansionData *reserved;
};

/* 191 */
struct IOWorkLoop::ExpansionData
{
  IOOptionBits options;
  IOEventSource *passiveEventChain;
  void *iokitstatsReserved;
  uint64_t lockInterval;
  uint64_t lockTime;
};

/* 209 */
struct IOUserClient::ExpansionData
{
  void *iokitstatsReserved;
  void *iokitFilterReserved;
};

/* 164 */
struct __cppobj IOInterruptController : IOService
{
  IOInterruptVector *vectors;
  IOSimpleLock *controllerLock;
  IOInterruptController::ExpansionData *ioic_reserved;
};

/* 185 */
struct IOEventSource::ExpansionData
{
  void *iokitstatsReserved;
};

/* 187 */
struct IOCommandGate::ExpansionData
{
};

/* 166 */
typedef void (__cdecl *IOInterruptHandler)(void *, void *, void *, int);

/* 165 */
struct IOInterruptVector
{
  char interruptActive;
  char interruptDisabledSoft;
  char interruptDisabledHard;
  char interruptRegistered;
  IOLock *interruptLock;
  IOService *nub;
  int source;
  void *target;
  IOInterruptHandler handler;
  void *refCon;
  IOSharedInterruptController *sharedController;
};

/* 171 */
struct IOInterruptController::ExpansionData
{
};

/* 167 */
struct __cppobj IOSharedInterruptController : IOInterruptController
{
  IOService *provider;
  int numVectors;
  int vectorsRegistered;
  int vectorsEnabled;
  int controllerDisabled;
  bool sourceIsLevel;
  IOSharedInterruptController::ExpansionData *iosic_reserved;
};

/* 168 */
struct IOSharedInterruptController::ExpansionData
{
};

/* 213 */
struct IOPMPowerSourceList_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOPMPowerSourceList)(IOPMPowerSourceList *__hidden this);
  void (__cdecl *~IOPMPowerSourceList_0)(IOPMPowerSourceList *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOPMPowerSourceList *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOPMPowerSourceList *__hidden this);
  __int64 vcallOffset;
};

/* 214 */
struct __cppobj IOPMPowerSourceList : OSObject
{
  IOPMPowerSource *firstItem;
  unsigned __int64 length;
};

/* 217 */
typedef ml_processor_info ml_processor_info_t;

/* 215 */
struct IOPMGR_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOPMGR)(IOPMGR *__hidden this);
  void (__cdecl *~IOPMGR_0)(IOPMGR *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOPMGR *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOService *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  void (__cdecl *enableCPUCore)(IOPMGR *__hidden this, unsigned int cpu_id);
  void (__cdecl *disableCPUCore)(IOPMGR *__hidden this, unsigned int cpu_id);
  void (__cdecl *enableCPUCluster)(IOPMGR *__hidden this, unsigned int cluster_id);
  void (__cdecl *disableCPUCluster)(IOPMGR *__hidden this, unsigned int cluster_id);
  void (__cdecl *initCPUIdle)(IOPMGR *__hidden this, ml_processor_info_t *info);
  void (__cdecl *enterCPUIdle)(IOPMGR *__hidden this, UInt64 *newIdleTimeoutTicks);
  void (__cdecl *exitCPUIdle)(IOPMGR *__hidden this, UInt64 *newIdleTimeoutTicks);
  void (__cdecl *updateCPUIdle)(IOPMGR *__hidden this, UInt64 *newIdleTimeoutTicks);
  __int64 vcallOffset;
};

/* 216 */
struct __cppobj IOPMGR : IOService
{
};

/* 219 */
typedef void *cpu_id_t;

/* 220 */
typedef void (__cdecl *time_base_enable_t)(cpu_id_t, boolean_t);

/* 221 */
typedef void (__cdecl *processor_idle_t)(cpu_id_t, boolean_t, uint64_t *);

/* 222 */
typedef void (*idle_tickle_t)(void);

/* 223 */
typedef void (__cdecl *idle_timer_t)(void *, uint64_t *);

/* 224 */
typedef void (__cdecl *platform_error_handler_t)(void *, vm_offset_t);

/* 225 */
enum cluster_type_t : unsigned __int32
{
};

/* 218 */
struct ml_processor_info
{
  cpu_id_t cpu_id;
  vm_offset_t start_paddr;
  boolean_t supports_nap;
  void *platform_cache_dispatch;
  time_base_enable_t time_base_enable;
  processor_idle_t processor_idle;
  idle_tickle_t *idle_tickle;
  idle_timer_t idle_timer;
  void *idle_timer_refcon;
  vm_offset_t powergate_stub_addr;
  uint32_t powergate_stub_length;
  uint32_t powergate_latency;
  platform_error_handler_t platform_error_handler;
  uint64_t regmap_paddr;
  uint32_t phys_id;
  uint32_t log_id;
  uint32_t l2_access_penalty;
  uint32_t cluster_id;
  cluster_type_t cluster_type;
  uint32_t l2_cache_id;
  uint32_t l2_cache_size;
  uint32_t l3_cache_id;
  uint32_t l3_cache_size;
};

/* 227 */
typedef IOReturn (__cdecl *IOWorkLoop::Action)(OSObject *, void *, void *, void *, void *);

/* 226 */
struct IOWorkLoop_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOWorkLoop)(IOWorkLoop *__hidden this);
  void (__cdecl *~IOWorkLoop_0)(IOWorkLoop *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOWorkLoop *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(IOWorkLoop *__hidden this);
  void (__cdecl *free)(IOWorkLoop *__hidden this);
  IOReturn (__cdecl *_maintRequest)(IOWorkLoop *__hidden this, void *command, void *data, void *, void *);
  void (__cdecl *threadMain)(IOWorkLoop *__hidden this);
  IOThread (__cdecl *getThread)(const IOWorkLoop *__hidden this);
  bool (__cdecl *onThread)(const IOWorkLoop *__hidden this);
  bool (__cdecl *inGate)(const IOWorkLoop *__hidden this);
  IOReturn (__cdecl *addEventSource)(IOWorkLoop *__hidden this, IOEventSource *newEvent);
  IOReturn (__cdecl *removeEventSource)(IOWorkLoop *__hidden this, IOEventSource *toRemove);
  void (__cdecl *enableAllEventSources)(const IOWorkLoop *__hidden this);
  void (__cdecl *disableAllEventSources)(const IOWorkLoop *__hidden this);
  void (__cdecl *enableAllInterrupts)(const IOWorkLoop *__hidden this);
  void (__cdecl *disableAllInterrupts)(const IOWorkLoop *__hidden this);
  void (__cdecl *signalWorkAvailable)(IOWorkLoop *__hidden this);
  void (__cdecl *openGate)(IOWorkLoop *__hidden this);
  void (__cdecl *closeGate)(IOWorkLoop *__hidden this);
  bool (__cdecl *tryCloseGate)(IOWorkLoop *__hidden this);
  int (__cdecl *sleepGate)(IOWorkLoop *__hidden this, void *event, UInt32 interuptibleType);
  void (__cdecl *wakeupGate)(IOWorkLoop *__hidden this, void *event, bool oneThread);
  IOReturn (__cdecl *runAction)(IOWorkLoop *__hidden this, IOWorkLoop::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *runEventSources)(IOWorkLoop *__hidden this);
  int (__cdecl *sleepGate_0)(IOWorkLoop *__hidden this, void *event, AbsoluteTime deadline, UInt32 interuptibleType);
  __int64 vcallOffset;
};

/* 229 */
typedef IOReturn (__cdecl *IOCommandGate::Action)(OSObject *, void *, void *, void *, void *);

/* 228 */
struct IOCommandGate_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOCommandGate)(IOCommandGate *__hidden this);
  void (__cdecl *~IOCommandGate_0)(IOCommandGate *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOCommandGate *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOCommandGate *__hidden this);
  bool (__cdecl *init_0)(IOEventSource *__hidden this, OSObject *owner, IOEventSource::Action action);
  bool (__cdecl *checkForWork)(IOEventSource *__hidden this);
  void (__cdecl *setWorkLoop)(IOCommandGate *__hidden this, IOWorkLoop *inWorkLoop);
  void (__cdecl *setNext)(IOEventSource *__hidden this, IOEventSource *next);
  IOEventSource *(__cdecl *getNext)(const IOEventSource *__hidden this);
  void (__cdecl *setAction)(IOEventSource *__hidden this, IOEventSource::Action action);
  IOEventSource::Action (__cdecl *getAction)(const IOEventSource *__hidden this);
  void (__cdecl *enable)(IOCommandGate *__hidden this);
  void (__cdecl *disable)(IOCommandGate *__hidden this);
  bool (__cdecl *isEnabled)(const IOEventSource *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOEventSource *__hidden this);
  bool (__cdecl *onThread)(const IOEventSource *__hidden this);
  bool (__cdecl *init_1)(IOCommandGate *__hidden this, OSObject *owner, IOCommandGate::Action action);
  IOReturn (__cdecl *runCommand)(IOCommandGate *__hidden this, void *arg0, void *arg1, void *arg2, void *arg3);
  IOReturn (__cdecl *runAction)(IOCommandGate *__hidden this, IOCommandGate::Action action, void *arg0, void *arg1, void *arg2, void *arg3);
  IOReturn (__cdecl *attemptCommand)(IOCommandGate *__hidden this, void *arg0, void *arg1, void *arg2, void *arg3);
  IOReturn (__cdecl *attemptAction)(IOCommandGate *__hidden this, IOCommandGate::Action action, void *arg0, void *arg1, void *arg2, void *arg3);
  IOReturn (__cdecl *commandSleep)(IOCommandGate *__hidden this, void *event, UInt32 interruptible);
  void (__cdecl *commandWakeup)(IOCommandGate *__hidden this, void *event, bool oneThread);
  IOReturn (__cdecl *commandSleep_0)(IOCommandGate *__hidden this, void *event, AbsoluteTime deadline, UInt32 interruptible);
  __int64 vcallOffset;
};

/* 230 */
struct IOCommandPool_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOCommandPool)(IOCommandPool *__hidden this);
  void (__cdecl *~IOCommandPool_0)(IOCommandPool *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOCommandPool *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOCommandPool *__hidden this);
  bool (__cdecl *initWithWorkLoop)(IOCommandPool *__hidden this, IOWorkLoop *workLoop);
  bool (__cdecl *init_0)(IOCommandPool *__hidden this, IOService *inOwner, IOWorkLoop *inWorkLoop, UInt32 inSize);
  IOCommand *(__cdecl *getCommand)(IOCommandPool *__hidden this, bool blockForCommand);
  void (__cdecl *returnCommand)(IOCommandPool *__hidden this, IOCommand *command);
  IOReturn (__cdecl *gatedGetCommand)(IOCommandPool *__hidden this, IOCommand **command, bool blockForCommand);
  IOReturn (__cdecl *gatedReturnCommand)(IOCommandPool *__hidden this, IOCommand *command);
  __int64 vcallOffset;
};

/* 233 */
struct queue_entry
{
  queue_entry *next;
  queue_entry *prev;
};

/* 232 */
typedef queue_entry queue_head_t;

/* 231 */
struct __cppobj IOCommandPool : OSObject
{
  queue_head_t fQueueHead;
  UInt32 fSleepers;
  IOCommandGate *fSerializer;
  IOCommandPool::ExpansionData *reserved;
};

/* 236 */
typedef queue_entry queue_chain_t;

/* 235 */
struct __cppobj IOCommand : OSObject
{
  queue_chain_t fCommandChain;
};

/* 234 */
struct IOCommandPool::ExpansionData
{
};

/* 246 */
typedef IOOptionBits IODirection;

/* 247 */
typedef unsigned __int8 UInt8;

/* 240 */
typedef void (__cdecl *IODMAEventSource::Action)(OSObject *, IODMAEventSource *, IODMACommand *, IOReturn, IOByteCount, AbsoluteTime);

/* 237 */
struct IODMAEventSource_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IODMAEventSource)(IODMAEventSource *__hidden this);
  void (__cdecl *~IODMAEventSource_0)(IODMAEventSource *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IODMAEventSource *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IODMAEventSource *__hidden this);
  bool (__cdecl *init_0)(IOEventSource *__hidden this, OSObject *owner, IOEventSource::Action action);
  bool (__cdecl *checkForWork)(IODMAEventSource *__hidden this);
  void (__cdecl *setWorkLoop)(IOEventSource *__hidden this, IOWorkLoop *workLoop);
  void (__cdecl *setNext)(IOEventSource *__hidden this, IOEventSource *next);
  IOEventSource *(__cdecl *getNext)(const IOEventSource *__hidden this);
  void (__cdecl *setAction)(IOEventSource *__hidden this, IOEventSource::Action action);
  IOEventSource::Action (__cdecl *getAction)(const IOEventSource *__hidden this);
  void (__cdecl *enable)(IOEventSource *__hidden this);
  void (__cdecl *disable)(IOEventSource *__hidden this);
  bool (__cdecl *isEnabled)(const IOEventSource *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOEventSource *__hidden this);
  bool (__cdecl *onThread)(const IOEventSource *__hidden this);
  void (__cdecl *completeDMACommand)(IODMAEventSource *__hidden this, IODMACommand *dmaCommand);
  void (__cdecl *notifyDMACommand)(IODMAEventSource *__hidden this, IODMACommand *dmaCommand, IOReturn status, IOByteCount actualByteCount, AbsoluteTime timeStamp);
  IOReturn (__cdecl *startDMACommand)(IODMAEventSource *__hidden this, IODMACommand *dmaCommand, IODirection direction, IOByteCount byteCount, IOByteCount byteOffset);
  IOReturn (__cdecl *stopDMACommand)(IODMAEventSource *__hidden this, bool flush, uint64_t timeout);
  IOReturn (__cdecl *queryDMACommand)(IODMAEventSource *__hidden this, IODMACommand **dmaCommand, IOByteCount *transferCount, bool waitForIdle);
  IOByteCount (__cdecl *getFIFODepth)(IODMAEventSource *__hidden this, IODirection direction);
  IOReturn (__cdecl *setFIFODepth)(IODMAEventSource *__hidden this, IOByteCount depth);
  IOByteCount (__cdecl *validFIFODepth)(IODMAEventSource *__hidden this, IOByteCount depth, IODirection direction);
  IOReturn (__cdecl *setFrameSize)(IODMAEventSource *__hidden this, UInt8 byteCount);
  IOReturn (__cdecl *setDMAConfig)(IODMAEventSource *__hidden this, UInt32 dmaIndex);
  bool (__cdecl *validDMAConfig)(IODMAEventSource *__hidden this, UInt32 dmaIndex);
  bool (__cdecl *init_1)(IODMAEventSource *__hidden this, OSObject *owner, IOService *provider, IODMAEventSource::Action completion, IODMAEventSource::Action notification, UInt32 dmaIndex);
  __int64 vcallOffset;
};

/* 238 */
struct __cppobj IODMAEventSource : IOEventSource
{
  IOService *dmaProvider;
  IODMAController *dmaController;
  UInt32 dmaIndex;
  queue_head_t dmaCommandsCompleted;
  IOSimpleLock *dmaCommandsCompletedLock;
  IODMAEventSource::Action dmaCompletionAction;
  IODMAEventSource::Action dmaNotificationAction;
  bool dmaSynchBusy;
};

/* 244 */
struct IODMACommand::Segment64
{
  UInt64 fIOVMAddr;
  UInt64 fLength;
};

/* 243 */
typedef bool (__cdecl *IODMACommand::SegmentFunction)(IODMACommand *, IODMACommand::Segment64, void *, UInt32);

/* 245 */
struct IODMACommandInternal;

/* 241 */
struct __cppobj IODMACommand : IOCommand
{
  void *fRefCon;
  UInt64 fMaxSegmentSize;
  UInt64 fMaxTransferSize;
  UInt32 fAlignMaskLength;
  UInt32 fAlignMaskInternalSegments;
  IOMapper *fMapper;
  IOMemoryDescriptor *fMemory;
  IODMACommand::SegmentFunction fOutSeg;
  UInt32 fAlignMask;
  UInt32 fNumAddressBits;
  UInt32 fNumSegments;
  uint32_t fMappingOptions;
  UInt32 fActive;
  IODMACommandInternal *reserved;
};

/* 239 */
struct __cppobj IODMAController : IOService
{
  IOService *_provider;
  const OSSymbol *_dmaControllerName;
};

/* 242 */
struct __cppobj IOMapper : IOService
{
  uint64_t __reserved[8];
  bool fIsSystem;
};

/* 255 */
typedef void (__cdecl *IOInterruptEventSource::Action)(OSObject *, IOInterruptEventSource *, int);

/* 253 */
typedef bool (__cdecl *IOFilterInterruptEventSource::Filter)(OSObject *, IOFilterInterruptEventSource *);

/* 248 */
struct IOFilterInterruptEventSource_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOFilterInterruptEventSource)(IOFilterInterruptEventSource *__hidden this);
  void (__cdecl *~IOFilterInterruptEventSource_0)(IOFilterInterruptEventSource *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOFilterInterruptEventSource *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOFilterInterruptEventSource *__hidden this);
  bool (__cdecl *init_0)(IOEventSource *__hidden this, OSObject *owner, IOEventSource::Action action);
  bool (__cdecl *checkForWork)(IOInterruptEventSource *__hidden this);
  void (__cdecl *setWorkLoop)(IOInterruptEventSource *__hidden this, IOWorkLoop *inWorkLoop);
  void (__cdecl *setNext)(IOEventSource *__hidden this, IOEventSource *next);
  IOEventSource *(__cdecl *getNext)(const IOEventSource *__hidden this);
  void (__cdecl *setAction)(IOEventSource *__hidden this, IOEventSource::Action action);
  IOEventSource::Action (__cdecl *getAction)(const IOEventSource *__hidden this);
  void (__cdecl *enable)(IOInterruptEventSource *__hidden this);
  void (__cdecl *disable)(IOInterruptEventSource *__hidden this);
  bool (__cdecl *isEnabled)(const IOEventSource *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOEventSource *__hidden this);
  bool (__cdecl *onThread)(const IOEventSource *__hidden this);
  bool (__cdecl *init_1)(IOFilterInterruptEventSource *__hidden this, OSObject *inOwner, IOInterruptEventSource::Action inAction, IOService *inProvider, int inIntIndex);
  const IOService *(__cdecl *getProvider)(const IOInterruptEventSource *__hidden this);
  int (__cdecl *getIntIndex)(const IOInterruptEventSource *__hidden this);
  bool (__cdecl *getAutoDisable)(const IOInterruptEventSource *__hidden this);
  void (__cdecl *interruptOccurred)(IOInterruptEventSource *__hidden this, void *, IOService *nub, int ind);
  void (__cdecl *normalInterruptOccurred)(IOFilterInterruptEventSource *__hidden this, void *self, IOService *prov, int ind);
  void (__cdecl *disableInterruptOccurred)(IOFilterInterruptEventSource *__hidden this, void *self, IOService *prov, int ind);
  bool (__cdecl *init_2)(IOFilterInterruptEventSource *__hidden this, OSObject *owner, IOInterruptEventSource::Action action, IOFilterInterruptEventSource::Filter filter, IOService *provider, int intIndex);
  void (__cdecl *signalInterrupt)(IOFilterInterruptEventSource *__hidden this);
  IOFilterInterruptEventSource::Filter (__cdecl *getFilterAction)(const IOFilterInterruptEventSource *__hidden this);
  __int64 vcallOffset;
};

/* 250 */
struct __cppobj IOInterruptEventSource : IOEventSource
{
  IOService *provider;
  int intIndex;
  unsigned int producerCount;
  unsigned int consumerCount;
  bool autoDisable;
  bool explicitDisable;
  IOInterruptEventSource::ExpansionData *reserved;
};

/* 249 */
struct __cppobj IOFilterInterruptEventSource : IOInterruptEventSource
{
  IOFilterInterruptEventSource::Filter filterAction;
  IOFilterInterruptEventSource::ExpansionData *reserved;
};

/* 252 */
struct IOInterruptAccountingData;

/* 251 */
struct IOInterruptEventSource::ExpansionData
{
  IOInterruptAccountingData *statistics;
};

/* 254 */
struct IOFilterInterruptEventSource::ExpansionData
{
};

/* 256 */
struct IOInterruptEventSource_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOInterruptEventSource)(IOInterruptEventSource *__hidden this);
  void (__cdecl *~IOInterruptEventSource_0)(IOInterruptEventSource *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOInterruptEventSource *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOInterruptEventSource *__hidden this);
  bool (__cdecl *init_0)(IOEventSource *__hidden this, OSObject *owner, IOEventSource::Action action);
  bool (__cdecl *checkForWork)(IOInterruptEventSource *__hidden this);
  void (__cdecl *setWorkLoop)(IOInterruptEventSource *__hidden this, IOWorkLoop *inWorkLoop);
  void (__cdecl *setNext)(IOEventSource *__hidden this, IOEventSource *next);
  IOEventSource *(__cdecl *getNext)(const IOEventSource *__hidden this);
  void (__cdecl *setAction)(IOEventSource *__hidden this, IOEventSource::Action action);
  IOEventSource::Action (__cdecl *getAction)(const IOEventSource *__hidden this);
  void (__cdecl *enable)(IOInterruptEventSource *__hidden this);
  void (__cdecl *disable)(IOInterruptEventSource *__hidden this);
  bool (__cdecl *isEnabled)(const IOEventSource *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOEventSource *__hidden this);
  bool (__cdecl *onThread)(const IOEventSource *__hidden this);
  bool (__cdecl *init_1)(IOInterruptEventSource *__hidden this, OSObject *owner, IOInterruptEventSource::Action action, IOService *provider, int intIndex);
  const IOService *(__cdecl *getProvider)(const IOInterruptEventSource *__hidden this);
  int (__cdecl *getIntIndex)(const IOInterruptEventSource *__hidden this);
  bool (__cdecl *getAutoDisable)(const IOInterruptEventSource *__hidden this);
  void (__cdecl *interruptOccurred)(IOInterruptEventSource *__hidden this, void *, IOService *nub, int ind);
  void (__cdecl *normalInterruptOccurred)(IOInterruptEventSource *__hidden this, void *, IOService *nub, int ind);
  void (__cdecl *disableInterruptOccurred)(IOInterruptEventSource *__hidden this, void *, IOService *nub, int ind);
  __int64 vcallOffset;
};

/* 260 */
typedef void (__cdecl *IOTimerEventSource::Action)(OSObject *, IOTimerEventSource *);

/* 257 */
struct IOTimerEventSource_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOTimerEventSource)(IOTimerEventSource *__hidden this);
  void (__cdecl *~IOTimerEventSource_0)(IOTimerEventSource *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOTimerEventSource *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOTimerEventSource *__hidden this);
  bool (__cdecl *init_0)(IOEventSource *__hidden this, OSObject *owner, IOEventSource::Action action);
  bool (__cdecl *checkForWork)(IOTimerEventSource *__hidden this);
  void (__cdecl *setWorkLoop)(IOTimerEventSource *__hidden this, IOWorkLoop *workLoop);
  void (__cdecl *setNext)(IOEventSource *__hidden this, IOEventSource *next);
  IOEventSource *(__cdecl *getNext)(const IOEventSource *__hidden this);
  void (__cdecl *setAction)(IOEventSource *__hidden this, IOEventSource::Action action);
  IOEventSource::Action (__cdecl *getAction)(const IOEventSource *__hidden this);
  void (__cdecl *enable)(IOTimerEventSource *__hidden this);
  void (__cdecl *disable)(IOTimerEventSource *__hidden this);
  bool (__cdecl *isEnabled)(const IOEventSource *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOEventSource *__hidden this);
  bool (__cdecl *onThread)(const IOEventSource *__hidden this);
  void (__cdecl *setTimeoutFunc)(IOTimerEventSource *__hidden this);
  bool (__cdecl *init_1)(IOTimerEventSource *__hidden this, OSObject *owner, IOTimerEventSource::Action action);
  IOReturn (__cdecl *setTimeoutTicks)(IOTimerEventSource *__hidden this, UInt32 ticks);
  IOReturn (__cdecl *setTimeoutMS)(IOTimerEventSource *__hidden this, UInt32 ms);
  IOReturn (__cdecl *setTimeoutUS)(IOTimerEventSource *__hidden this, UInt32 us);
  IOReturn (__cdecl *setTimeout)(IOTimerEventSource *__hidden this, UInt32 interval, UInt32 scale_factor);
  IOReturn (__cdecl *setTimeout_0)(IOTimerEventSource *__hidden this, AbsoluteTime interval);
  IOReturn (__cdecl *wakeAtTimeTicks)(IOTimerEventSource *__hidden this, UInt32 ticks);
  IOReturn (__cdecl *wakeAtTimeMS)(IOTimerEventSource *__hidden this, UInt32 ms);
  IOReturn (__cdecl *wakeAtTimeUS)(IOTimerEventSource *__hidden this, UInt32 us);
  IOReturn (__cdecl *wakeAtTime)(IOTimerEventSource *__hidden this, UInt32 abstime, UInt32 scale_factor);
  IOReturn (__cdecl *wakeAtTime_0)(IOTimerEventSource *__hidden this, AbsoluteTime abstime);
  void (__cdecl *cancelTimeout)(IOTimerEventSource *__hidden this);
  bool (__cdecl *init_2)(IOTimerEventSource *__hidden this, uint32_t options, OSObject *inOwner, IOTimerEventSource::Action inAction);
  IOReturn (__cdecl *setTimeout_1)(IOTimerEventSource *__hidden this, uint32_t options, AbsoluteTime interval, AbsoluteTime leeway);
  IOReturn (__cdecl *wakeAtTime_1)(IOTimerEventSource *__hidden this, uint32_t options, AbsoluteTime abstime, AbsoluteTime leeway);
  __int64 vcallOffset;
};

/* 258 */
struct __cppobj IOTimerEventSource : IOEventSource
{
  void *calloutEntry;
  AbsoluteTime abstime;
  IOTimerEventSource::ExpansionData *reserved;
};

/* 259 */
struct IOTimerEventSource::ExpansionData
{
  SInt32 calloutGeneration;
  SInt32 calloutGenerationSignaled;
  IOWorkLoop *workLoop;
};

/* 262 */
enum IODMACommand::MappingOptions : unsigned __int32
{
  kMapped = 0x0,
  kBypassed = 0x1,
  kNonCoherent = 0x2,
  kUnmapped = 0x3,
  kTypeMask = 0xF,
  kNoCacheStore = 0x10,
  kOnChip = 0x20,
  kIterateOnly = 0x40,
};

/* 261 */
struct IODMACommand_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IODMACommand)(IODMACommand *__hidden this);
  void (__cdecl *~IODMACommand_0)(IODMACommand *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IODMACommand *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IODMACommand *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(IOCommand *__hidden this);
  void (__cdecl *free)(IODMACommand *__hidden this);
  IODMACommand *(__cdecl *cloneCommand)(IODMACommand *__hidden this, void *refCon);
  bool (__cdecl *initWithSpecification)(IODMACommand *__hidden this, IODMACommand::SegmentFunction outSegFunc, UInt8 numAddressBits, UInt64 maxSegmentSize, IODMACommand::MappingOptions mappingOptions, UInt64 maxTransferSize, UInt32 alignment, IOMapper *mapper, void *refCon);
  IOReturn (__cdecl *setMemoryDescriptor)(IODMACommand *__hidden this, const IOMemoryDescriptor *mem, bool autoPrepare);
  IOReturn (__cdecl *clearMemoryDescriptor)(IODMACommand *__hidden this, bool autoComplete);
  const IOMemoryDescriptor *(__cdecl *getMemoryDescriptor)(const IODMACommand *__hidden this);
  IOReturn (__cdecl *prepare)(IODMACommand *__hidden this, UInt64 offset, UInt64 length, bool flushCache, bool synchronize);
  IOReturn (__cdecl *complete)(IODMACommand *__hidden this, bool invalidateCache, bool synchronize);
  IOReturn (__cdecl *synchronize)(IODMACommand *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *genIOVMSegments)(IODMACommand *__hidden this, UInt64 *offset, void *segments, UInt32 *numSegments);
  UInt64 (__cdecl *transfer)(IODMACommand *__hidden this, IOOptionBits transferOp, UInt64 offset, void *buffer, UInt64 length);
  IOReturn (__cdecl *prepareWithSpecification)(IODMACommand *__hidden this, IODMACommand::SegmentFunction outSegFunc, UInt8 numAddressBits, UInt64 maxSegmentSize, IODMACommand::MappingOptions mappingOptions, UInt64 maxTransferSize, UInt32 alignment, IOMapper *mapper, UInt64 offset, UInt64 length, bool flushCache, bool synchronize);
  IOReturn (__cdecl *getPreparedOffsetAndLength)(IODMACommand *__hidden this, UInt64 *offset, UInt64 *length);
  bool (__cdecl *initWithRefCon)(IODMACommand *__hidden this, void *refCon);
  bool (__cdecl *initWithSpecification_0)(IODMACommand *__hidden this, IODMACommand::SegmentFunction outSegFunc, const IODMACommand::SegmentOptions *segmentOptions, uint32_t mappingOptions, IOMapper *mapper, void *refCon);
  IOReturn (__cdecl *prepareWithSpecification_0)(IODMACommand *__hidden this, IODMACommand::SegmentFunction outSegFunc, const IODMACommand::SegmentOptions *segmentOptions, uint32_t mappingOptions, IOMapper *mapper, uint64_t offset, uint64_t length, bool flushCache, bool synchronize);
  IOBufferMemoryDescriptor *(__cdecl *createCopyBuffer)(IODMACommand *__hidden this, IODirection direction, UInt64 length);
  __int64 vcallOffset;
};

/* 263 */
struct IODMACommand::SegmentOptions
{
  uint8_t fStructSize;
  uint8_t fNumAddressBits;
  uint64_t fMaxSegmentSize;
  uint64_t fMaxTransferSize;
  uint32_t fAlignment;
  uint32_t fAlignmentLength;
  uint32_t fAlignmentInternalSegments;
};

/* 270 */
typedef IOVirtualRange IOAddressRange;

/* 266 */
union IOGeneralMemoryDescriptor::Ranges
{
  IOVirtualRange *v;
  IOAddressRange *v64;
  IOPhysicalRange *p;
  void *uio;
};

/* 269 */
typedef uint64_t mach_vm_address_t;

/* 268 */
typedef mach_vm_address_t IOVirtualAddress;

/* 267 */
struct IOVirtualRange
{
  IOVirtualAddress address;
  IOByteCount length;
};

/* 273 */
typedef UInt64 IOPhysicalAddress64;

/* 272 */
typedef IOPhysicalAddress64 IOPhysicalAddress;

/* 271 */
struct IOPhysicalRange
{
  IOPhysicalAddress address;
  IOByteCount length;
};

/* 274 */
union IOGeneralMemoryDescriptor::$ECA04EF03DB1B5A22FBE2CCFAFA5CDF1
{
  IOVirtualRange v;
  IOPhysicalRange p;
};

/* 275 */
typedef uint32_t ppnum_t;

/* 265 */
struct __cppobj IOGeneralMemoryDescriptor : IOMemoryDescriptor
{
  IOGeneralMemoryDescriptor::Ranges _ranges;
  unsigned int _rangesCount;
  task_t _task;
  IOGeneralMemoryDescriptor::$ECA04EF03DB1B5A22FBE2CCFAFA5CDF1 _singleRange;
  unsigned int _wireCount;
  bool _initialized;
  OSData *_memoryEntries;
  unsigned int _pages;
  ppnum_t _highestPage;
  uint32_t __iomd_reservedA;
  uint32_t __iomd_reservedB;
  IOLock *_prepareLock;
};

/* 264 */
struct __cppobj IOBufferMemoryDescriptor : IOGeneralMemoryDescriptor
{
  IOBufferMemoryDescriptor::ExpansionData *reserved;
  void *_buffer;
  vm_size_t _capacity;
  vm_offset_t _alignment;
  IOOptionBits _options;
  uintptr_t _internalReserved;
  unsigned int _internalFlags;
};

/* 276 */
struct IOBufferMemoryDescriptor::ExpansionData
{
  IOMemoryMap *map;
};

/* 277 */
struct IOCommand_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOCommand)(IOCommand *__hidden this);
  void (__cdecl *~IOCommand_0)(IOCommand *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOCommand *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(IOCommand *__hidden this);
  void (__cdecl *free)(OSObject *__hidden this);
  __int64 vcallOffset;
};

/* 280 */
typedef IOOptionBits IOMemoryDescriptor::DMACommandOps;

/* 281 */
typedef unsigned int UInt;

/* 282 */
typedef uint64_t addr64_t;

/* 283 */
typedef mach_port_t vm_map_t;

/* 278 */
struct IOInterleavedMemoryDescriptor_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOInterleavedMemoryDescriptor)(IOInterleavedMemoryDescriptor *__hidden this);
  void (__cdecl *~IOInterleavedMemoryDescriptor_0)(IOInterleavedMemoryDescriptor *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOInterleavedMemoryDescriptor *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOMemoryDescriptor *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOInterleavedMemoryDescriptor *__hidden this);
  bool (__cdecl *initWithOptions)(IOMemoryDescriptor *__hidden this, void *buffers, UInt32 count, UInt32 offset, task_t task, IOOptionBits options, IOMapper *mapper);
  IOReturn (__cdecl *setPurgeable)(IOMemoryDescriptor *__hidden this, IOOptionBits newState, IOOptionBits *oldState);
  IOReturn (__cdecl *performOperation)(IOMemoryDescriptor *__hidden this, IOOptionBits options, IOByteCount offset, IOByteCount length);
  IOReturn (__cdecl *dmaCommandOperation)(const IOMemoryDescriptor *__hidden this, IOMemoryDescriptor::DMACommandOps op, void *vData, UInt dataSize);
  addr64_t (__cdecl *getPhysicalSegment)(IOInterleavedMemoryDescriptor *__hidden this, IOByteCount offset, IOByteCount *length, IOOptionBits options);
  uint64_t (__cdecl *getPreparationID)(IOMemoryDescriptor *__hidden this);
  IODirection (__cdecl *getDirection)(const IOMemoryDescriptor *__hidden this);
  IOByteCount (__cdecl *getLength)(const IOMemoryDescriptor *__hidden this);
  void (__cdecl *setTag)(IOMemoryDescriptor *__hidden this, IOOptionBits tag);
  IOOptionBits (__cdecl *getTag)(IOMemoryDescriptor *__hidden this);
  IOByteCount (__cdecl *readBytes)(IOMemoryDescriptor *__hidden this, IOByteCount offset, void *bytes, IOByteCount withLength);
  IOByteCount (__cdecl *writeBytes)(IOMemoryDescriptor *__hidden this, IOByteCount offset, const void *bytes, IOByteCount withLength);
  IOReturn (__cdecl *prepare)(IOInterleavedMemoryDescriptor *__hidden this, IODirection forDirection);
  IOReturn (__cdecl *complete)(IOInterleavedMemoryDescriptor *__hidden this, IODirection forDirection);
  IOMemoryMap *(__cdecl *map)(IOMemoryDescriptor *__hidden this, IOOptionBits options);
  IOMemoryMap *(__cdecl *setMapping)(IOMemoryDescriptor *__hidden this, task_t task, IOVirtualAddress mapAddress, IOOptionBits options);
  IOReturn (__cdecl *redirect)(IOMemoryDescriptor *__hidden this, task_t safeTask, bool redirect);
  IOMemoryMap *(__cdecl *makeMapping)(IOMemoryDescriptor *__hidden this, IOMemoryDescriptor *owner, task_t intoTask, IOVirtualAddress atAddress, IOOptionBits options, IOByteCount offset, IOByteCount length);
  void (__cdecl *addMapping)(IOMemoryDescriptor *__hidden this, IOMemoryMap *mapping);
  void (__cdecl *removeMapping)(IOMemoryDescriptor *__hidden this, IOMemoryMap *mapping);
  IOReturn (__cdecl *doMap)(IOMemoryDescriptor *__hidden this, vm_map_t addressMap, IOVirtualAddress *atAddress, IOOptionBits options, IOByteCount sourceOffset, IOByteCount length);
  IOReturn (__cdecl *doUnmap)(IOMemoryDescriptor *__hidden this, vm_map_t addressMap, IOVirtualAddress logical, IOByteCount length);
  bool (__cdecl *initWithCapacity)(IOInterleavedMemoryDescriptor *__hidden this, IOByteCount capacity, IODirection direction);
  void (__cdecl *clearMemoryDescriptors)(IOInterleavedMemoryDescriptor *__hidden this, IODirection direction);
  bool (__cdecl *setMemoryDescriptor)(IOInterleavedMemoryDescriptor *__hidden this, IOMemoryDescriptor *descriptor, IOByteCount offset, IOByteCount length);
  __int64 vcallOffset;
};

/* 279 */
struct __cppobj IOInterleavedMemoryDescriptor : IOMemoryDescriptor
{
  IOByteCount _descriptorCapacity;
  UInt32 _descriptorCount;
  IOMemoryDescriptor **_descriptors;
  IOByteCount *_descriptorOffsets;
  IOByteCount *_descriptorLengths;
  bool _descriptorPrepared;
};

/* 284 */
struct IOMapper_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOMapper)(IOMapper *__hidden this);
  void (__cdecl *~IOMapper_0)(IOMapper *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOMapper *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOMapper *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOMapper *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  bool (__cdecl *initHardware)(IOMapper *__hidden this, IOService *provider);
  uint64_t (__cdecl *getPageSize)(const IOMapper *__hidden this);
  IOReturn (__cdecl *iovmMapMemory)(IOMapper *__hidden this, IOMemoryDescriptor *memory, uint64_t descriptorOffset, uint64_t length, uint32_t mapOptions, const IODMAMapSpecification *mapSpecification, IODMACommand *dmaCommand, const IODMAMapPageList *pageList, uint64_t *mapAddress, uint64_t *mapLength);
  IOReturn (__cdecl *iovmUnmapMemory)(IOMapper *__hidden this, IOMemoryDescriptor *memory, IODMACommand *dmaCommand, uint64_t mapAddress, uint64_t mapLength);
  IOReturn (__cdecl *iovmInsert)(IOMapper *__hidden this, uint32_t options, uint64_t mapAddress, uint64_t offset, uint64_t physicalAddress, uint64_t length);
  uint64_t (__cdecl *mapToPhysicalAddress)(IOMapper *__hidden this, uint64_t mappedAddress);
  __int64 vcallOffset;
};

/* 285 */
struct IODMAMapSpecification
{
  uint64_t alignment;
  IOService *device;
  uint32_t options;
  uint8_t numAddressBits;
  uint8_t resvA[3];
  uint32_t resvB[4];
};

/* 287 */
typedef upl_page_info upl_page_info_t;

/* 286 */
struct IODMAMapPageList
{
  uint32_t pageOffset;
  uint32_t pageListCount;
  const upl_page_info_t *pageList;
};

/* 288 */
struct upl_page_info
{
  unsigned int opaque[2];
};

/* 294 */
typedef UInt64 IOPhysicalLength64;

/* 293 */
typedef IOPhysicalLength64 IOPhysicalLength;

/* 292 */
struct IOMemoryCursor::PhysicalSegment
{
  IOPhysicalAddress location;
  IOPhysicalLength length;
};

/* 291 */
typedef void (__cdecl *IOMemoryCursor::SegmentFunction)(IOMemoryCursor::PhysicalSegment, void *, UInt32);

/* 289 */
struct IOMemoryCursor_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOMemoryCursor)(IOMemoryCursor *__hidden this);
  void (__cdecl *~IOMemoryCursor_0)(IOMemoryCursor *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOMemoryCursor *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSObject *__hidden this);
  bool (__cdecl *initWithSpecification)(IOMemoryCursor *__hidden this, IOMemoryCursor::SegmentFunction outSegFunc, IOPhysicalLength maxSegmentSize, IOPhysicalLength maxTransferSize, IOPhysicalLength alignment);
  UInt32 (__cdecl *genPhysicalSegments)(IOMemoryCursor *__hidden this, IOMemoryDescriptor *descriptor, IOByteCount fromPosition, void *segments, UInt32 maxSegments, UInt32 maxTransferSize, IOByteCount *transferSize);
  __int64 vcallOffset;
};

/* 290 */
struct __cppobj IOMemoryCursor : OSObject
{
  IOMemoryCursor::SegmentFunction outSeg;
  IOPhysicalLength maxSegmentSize;
  IOPhysicalLength maxTransferSize;
  IOPhysicalLength alignMask;
};

/* 295 */
struct IONaturalMemoryCursor_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IONaturalMemoryCursor)(IONaturalMemoryCursor *__hidden this);
  void (__cdecl *~IONaturalMemoryCursor_0)(IONaturalMemoryCursor *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IONaturalMemoryCursor *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSObject *__hidden this);
  bool (__cdecl *initWithSpecification)(IOMemoryCursor *__hidden this, IOMemoryCursor::SegmentFunction outSegFunc, IOPhysicalLength maxSegmentSize, IOPhysicalLength maxTransferSize, IOPhysicalLength alignment);
  UInt32 (__cdecl *genPhysicalSegments)(IOMemoryCursor *__hidden this, IOMemoryDescriptor *descriptor, IOByteCount fromPosition, void *segments, UInt32 maxSegments, UInt32 maxTransferSize, IOByteCount *transferSize);
  bool (__cdecl *initWithSpecification_0)(IONaturalMemoryCursor *__hidden this, IOPhysicalLength maxSegmentSize, IOPhysicalLength maxTransferSize, IOPhysicalLength alignment);
  UInt32 (__cdecl *getPhysicalSegments)(IONaturalMemoryCursor *__hidden this, IOMemoryDescriptor *descriptor, IOByteCount fromPosition, IOMemoryCursor::PhysicalSegment *segments, UInt32 maxSegments, UInt32 inMaxTransferSize, IOByteCount *transferSize);
  __int64 vcallOffset;
};

/* 296 */
struct __cppobj IONaturalMemoryCursor : IOMemoryCursor
{
};

/* 297 */
struct IOBigMemoryCursor_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOBigMemoryCursor)(IOBigMemoryCursor *__hidden this);
  void (__cdecl *~IOBigMemoryCursor_0)(IOBigMemoryCursor *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOBigMemoryCursor *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSObject *__hidden this);
  bool (__cdecl *initWithSpecification)(IOMemoryCursor *__hidden this, IOMemoryCursor::SegmentFunction outSegFunc, IOPhysicalLength maxSegmentSize, IOPhysicalLength maxTransferSize, IOPhysicalLength alignment);
  UInt32 (__cdecl *genPhysicalSegments)(IOMemoryCursor *__hidden this, IOMemoryDescriptor *descriptor, IOByteCount fromPosition, void *segments, UInt32 maxSegments, UInt32 maxTransferSize, IOByteCount *transferSize);
  bool (__cdecl *initWithSpecification_0)(IOBigMemoryCursor *__hidden this, IOPhysicalLength maxSegmentSize, IOPhysicalLength maxTransferSize, IOPhysicalLength alignment);
  UInt32 (__cdecl *getPhysicalSegments)(IOBigMemoryCursor *__hidden this, IOMemoryDescriptor *descriptor, IOByteCount fromPosition, IOMemoryCursor::PhysicalSegment *segments, UInt32 maxSegments, UInt32 inMaxTransferSize, IOByteCount *transferSize);
  __int64 vcallOffset;
};

/* 298 */
struct __cppobj IOBigMemoryCursor : IOMemoryCursor
{
};

/* 299 */
struct IOLittleMemoryCursor_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOLittleMemoryCursor)(IOLittleMemoryCursor *__hidden this);
  void (__cdecl *~IOLittleMemoryCursor_0)(IOLittleMemoryCursor *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOLittleMemoryCursor *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSObject *__hidden this);
  bool (__cdecl *initWithSpecification)(IOMemoryCursor *__hidden this, IOMemoryCursor::SegmentFunction outSegFunc, IOPhysicalLength maxSegmentSize, IOPhysicalLength maxTransferSize, IOPhysicalLength alignment);
  UInt32 (__cdecl *genPhysicalSegments)(IOMemoryCursor *__hidden this, IOMemoryDescriptor *descriptor, IOByteCount fromPosition, void *segments, UInt32 maxSegments, UInt32 maxTransferSize, IOByteCount *transferSize);
  bool (__cdecl *initWithSpecification_0)(IOLittleMemoryCursor *__hidden this, IOPhysicalLength maxSegmentSize, IOPhysicalLength maxTransferSize, IOPhysicalLength alignment);
  UInt32 (__cdecl *getPhysicalSegments)(IOLittleMemoryCursor *__hidden this, IOMemoryDescriptor *descriptor, IOByteCount fromPosition, IOMemoryCursor::PhysicalSegment *segments, UInt32 maxSegments, UInt32 inMaxTransferSize, IOByteCount *transferSize);
  __int64 vcallOffset;
};

/* 300 */
struct __cppobj IOLittleMemoryCursor : IOMemoryCursor
{
};

/* 302 */
typedef uint64_t mach_vm_size_t;

/* 301 */
struct IOMemoryMap_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOMemoryMap)(IOMemoryMap *__hidden this);
  void (__cdecl *~IOMemoryMap_0)(IOMemoryMap *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOMemoryMap *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const IOMemoryMap *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOMemoryMap *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOMemoryMap *__hidden this);
  IOVirtualAddress (__cdecl *getVirtualAddress)(IOMemoryMap *__hidden this);
  IOPhysicalAddress (__cdecl *getPhysicalSegment)(IOMemoryMap *__hidden this, IOByteCount offset, IOByteCount *length, IOOptionBits options);
  IOByteCount (__cdecl *getLength)(IOMemoryMap *__hidden this);
  task_t (__cdecl *getAddressTask)(IOMemoryMap *__hidden this);
  IOMemoryDescriptor *(__cdecl *getMemoryDescriptor)(IOMemoryMap *__hidden this);
  IOOptionBits (__cdecl *getMapOptions)(IOMemoryMap *__hidden this);
  IOReturn (__cdecl *unmap)(IOMemoryMap *__hidden this);
  void (__cdecl *taskDied)(IOMemoryMap *__hidden this);
  IOReturn (__cdecl *redirect)(IOMemoryMap *__hidden this, IOMemoryDescriptor *newBackingMemory, IOOptionBits options, mach_vm_size_t offset);
  __int64 vcallOffset;
};

/* 303 */
struct IOMultiMemoryDescriptor_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOMultiMemoryDescriptor)(IOMultiMemoryDescriptor *__hidden this);
  void (__cdecl *~IOMultiMemoryDescriptor_0)(IOMultiMemoryDescriptor *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOMultiMemoryDescriptor *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOMemoryDescriptor *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOMultiMemoryDescriptor *__hidden this);
  bool (__cdecl *initWithOptions)(IOMemoryDescriptor *__hidden this, void *buffers, UInt32 count, UInt32 offset, task_t task, IOOptionBits options, IOMapper *mapper);
  IOReturn (__cdecl *setPurgeable)(IOMultiMemoryDescriptor *__hidden this, IOOptionBits newState, IOOptionBits *oldState);
  IOReturn (__cdecl *performOperation)(IOMemoryDescriptor *__hidden this, IOOptionBits options, IOByteCount offset, IOByteCount length);
  IOReturn (__cdecl *dmaCommandOperation)(const IOMemoryDescriptor *__hidden this, IOMemoryDescriptor::DMACommandOps op, void *vData, UInt dataSize);
  addr64_t (__cdecl *getPhysicalSegment)(IOMultiMemoryDescriptor *__hidden this, IOByteCount offset, IOByteCount *length, IOOptionBits options);
  uint64_t (__cdecl *getPreparationID)(IOMultiMemoryDescriptor *__hidden this);
  IODirection (__cdecl *getDirection)(const IOMemoryDescriptor *__hidden this);
  IOByteCount (__cdecl *getLength)(const IOMemoryDescriptor *__hidden this);
  void (__cdecl *setTag)(IOMemoryDescriptor *__hidden this, IOOptionBits tag);
  IOOptionBits (__cdecl *getTag)(IOMemoryDescriptor *__hidden this);
  IOByteCount (__cdecl *readBytes)(IOMemoryDescriptor *__hidden this, IOByteCount offset, void *bytes, IOByteCount withLength);
  IOByteCount (__cdecl *writeBytes)(IOMemoryDescriptor *__hidden this, IOByteCount offset, const void *bytes, IOByteCount withLength);
  IOReturn (__cdecl *prepare)(IOMultiMemoryDescriptor *__hidden this, IODirection forDirection);
  IOReturn (__cdecl *complete)(IOMultiMemoryDescriptor *__hidden this, IODirection forDirection);
  IOMemoryMap *(__cdecl *map)(IOMemoryDescriptor *__hidden this, IOOptionBits options);
  IOMemoryMap *(__cdecl *setMapping)(IOMemoryDescriptor *__hidden this, task_t task, IOVirtualAddress mapAddress, IOOptionBits options);
  IOReturn (__cdecl *redirect)(IOMemoryDescriptor *__hidden this, task_t safeTask, bool redirect);
  IOMemoryMap *(__cdecl *makeMapping)(IOMemoryDescriptor *__hidden this, IOMemoryDescriptor *owner, task_t intoTask, IOVirtualAddress atAddress, IOOptionBits options, IOByteCount offset, IOByteCount length);
  void (__cdecl *addMapping)(IOMemoryDescriptor *__hidden this, IOMemoryMap *mapping);
  void (__cdecl *removeMapping)(IOMemoryDescriptor *__hidden this, IOMemoryMap *mapping);
  IOReturn (__cdecl *doMap)(IOMultiMemoryDescriptor *__hidden this, vm_map_t addressMap, IOVirtualAddress *atAddress, IOOptionBits options, IOByteCount sourceOffset, IOByteCount length);
  IOReturn (__cdecl *doUnmap)(IOMemoryDescriptor *__hidden this, vm_map_t addressMap, IOVirtualAddress logical, IOByteCount length);
  bool (__cdecl *initWithDescriptors)(IOMultiMemoryDescriptor *__hidden this, IOMemoryDescriptor **descriptors, UInt32 withCount, IODirection withDirection, bool asReference);
  __int64 vcallOffset;
};

/* 304 */
struct __cppobj IOMultiMemoryDescriptor : IOMemoryDescriptor
{
  IOMemoryDescriptor **_descriptors;
  UInt32 _descriptorsCount;
  bool _descriptorsIsAllocated;
};

/* 307 */
typedef IOByteCount IORangeScalar;

/* 305 */
struct IORangeAllocator_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IORangeAllocator)(IORangeAllocator *__hidden this);
  void (__cdecl *~IORangeAllocator_0)(IORangeAllocator *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const IORangeAllocator *__hidden this, OSSerialize *s);
  const OSMetaClass *(__cdecl *getMetaClass)(const IORangeAllocator *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IORangeAllocator *__hidden this);
  bool (__cdecl *allocElement)(IORangeAllocator *__hidden this, UInt32 index);
  void (__cdecl *deallocElement)(IORangeAllocator *__hidden this, UInt32 index);
  bool (__cdecl *init_0)(IORangeAllocator *__hidden this, IORangeScalar endOfRange, IORangeScalar defaultAlignment, UInt32 capacity, IOOptionBits options);
  UInt32 (__cdecl *getFragmentCount)(IORangeAllocator *__hidden this);
  UInt32 (__cdecl *getFragmentCapacity)(IORangeAllocator *__hidden this);
  void (__cdecl *setFragmentCapacityIncrement)(IORangeAllocator *__hidden this, UInt32 count);
  IORangeScalar (__cdecl *getFreeCount)(IORangeAllocator *__hidden this);
  bool (__cdecl *allocate)(IORangeAllocator *__hidden this, IORangeScalar size, IORangeScalar *result, IORangeScalar alignment);
  bool (__cdecl *allocateRange)(IORangeAllocator *__hidden this, IORangeScalar start, IORangeScalar size);
  void (__cdecl *deallocate)(IORangeAllocator *__hidden this, IORangeScalar start, IORangeScalar size);
  __int64 vcallOffset;
};

/* 308 */
struct IORangeAllocatorElement;

/* 306 */
struct __cppobj IORangeAllocator : OSObject
{
  UInt32 numElements;
  UInt32 capacity;
  UInt32 capacityIncrement;
  IORangeScalar defaultAlignmentMask;
  IOOptionBits options;
  IORangeAllocatorElement *elements;
};

/* 309 */
struct IOSubMemoryDescriptor_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOSubMemoryDescriptor)(IOSubMemoryDescriptor *__hidden this);
  void (__cdecl *~IOSubMemoryDescriptor_0)(IOSubMemoryDescriptor *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOSubMemoryDescriptor *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOMemoryDescriptor *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOSubMemoryDescriptor *__hidden this);
  bool (__cdecl *initWithOptions)(IOMemoryDescriptor *__hidden this, void *buffers, UInt32 count, UInt32 offset, task_t task, IOOptionBits options, IOMapper *mapper);
  IOReturn (__cdecl *setPurgeable)(IOSubMemoryDescriptor *__hidden this, IOOptionBits newState, IOOptionBits *oldState);
  IOReturn (__cdecl *performOperation)(IOMemoryDescriptor *__hidden this, IOOptionBits options, IOByteCount offset, IOByteCount length);
  IOReturn (__cdecl *dmaCommandOperation)(const IOMemoryDescriptor *__hidden this, IOMemoryDescriptor::DMACommandOps op, void *vData, UInt dataSize);
  addr64_t (__cdecl *getPhysicalSegment)(IOSubMemoryDescriptor *__hidden this, IOByteCount offset, IOByteCount *length, IOOptionBits options);
  uint64_t (__cdecl *getPreparationID)(IOSubMemoryDescriptor *__hidden this);
  IODirection (__cdecl *getDirection)(const IOMemoryDescriptor *__hidden this);
  IOByteCount (__cdecl *getLength)(const IOMemoryDescriptor *__hidden this);
  void (__cdecl *setTag)(IOMemoryDescriptor *__hidden this, IOOptionBits tag);
  IOOptionBits (__cdecl *getTag)(IOMemoryDescriptor *__hidden this);
  IOByteCount (__cdecl *readBytes)(IOMemoryDescriptor *__hidden this, IOByteCount offset, void *bytes, IOByteCount withLength);
  IOByteCount (__cdecl *writeBytes)(IOMemoryDescriptor *__hidden this, IOByteCount offset, const void *bytes, IOByteCount withLength);
  IOReturn (__cdecl *prepare)(IOSubMemoryDescriptor *__hidden this, IODirection forDirection);
  IOReturn (__cdecl *complete)(IOSubMemoryDescriptor *__hidden this, IODirection forDirection);
  IOMemoryMap *(__cdecl *map)(IOMemoryDescriptor *__hidden this, IOOptionBits options);
  IOMemoryMap *(__cdecl *setMapping)(IOMemoryDescriptor *__hidden this, task_t task, IOVirtualAddress mapAddress, IOOptionBits options);
  IOReturn (__cdecl *redirect)(IOSubMemoryDescriptor *__hidden this, task_t safeTask, bool redirect);
  IOMemoryMap *(__cdecl *makeMapping)(IOSubMemoryDescriptor *__hidden this, IOMemoryDescriptor *owner, task_t intoTask, IOVirtualAddress atAddress, IOOptionBits options, IOByteCount offset, IOByteCount length);
  void (__cdecl *addMapping)(IOMemoryDescriptor *__hidden this, IOMemoryMap *mapping);
  void (__cdecl *removeMapping)(IOMemoryDescriptor *__hidden this, IOMemoryMap *mapping);
  IOReturn (__cdecl *doMap)(IOMemoryDescriptor *__hidden this, vm_map_t addressMap, IOVirtualAddress *atAddress, IOOptionBits options, IOByteCount sourceOffset, IOByteCount length);
  IOReturn (__cdecl *doUnmap)(IOMemoryDescriptor *__hidden this, vm_map_t addressMap, IOVirtualAddress logical, IOByteCount length);
  bool (__cdecl *initSubRange)(IOSubMemoryDescriptor *__hidden this, IOMemoryDescriptor *parent, IOByteCount offset, IOByteCount length, IODirection withDirection);
  __int64 vcallOffset;
};

/* 310 */
struct __cppobj IOSubMemoryDescriptor : IOMemoryDescriptor
{
  IOMemoryDescriptor *_parent;
  IOByteCount _start;
};

/* 311 */
struct IOMemoryDescriptor_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOMemoryDescriptor)(IOMemoryDescriptor *__hidden this);
  void (__cdecl *~IOMemoryDescriptor_0)(IOMemoryDescriptor *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOMemoryDescriptor *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOMemoryDescriptor *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOMemoryDescriptor *__hidden this);
  bool (__cdecl *initWithOptions)(IOMemoryDescriptor *__hidden this, void *buffers, UInt32 count, UInt32 offset, task_t task, IOOptionBits options, IOMapper *mapper);
  IOReturn (__cdecl *setPurgeable)(IOMemoryDescriptor *__hidden this, IOOptionBits newState, IOOptionBits *oldState);
  IOReturn (__cdecl *performOperation)(IOMemoryDescriptor *__hidden this, IOOptionBits options, IOByteCount offset, IOByteCount length);
  IOReturn (__cdecl *dmaCommandOperation)(const IOMemoryDescriptor *__hidden this, IOMemoryDescriptor::DMACommandOps op, void *vData, UInt dataSize);
  addr64_t (__cdecl *getPhysicalSegment)(IOMemoryDescriptor *__hidden this, IOByteCount offset, IOByteCount *length, IOOptionBits options);
  uint64_t (__cdecl *getPreparationID)(IOMemoryDescriptor *__hidden this);
  IODirection (__cdecl *getDirection)(const IOMemoryDescriptor *__hidden this);
  IOByteCount (__cdecl *getLength)(const IOMemoryDescriptor *__hidden this);
  void (__cdecl *setTag)(IOMemoryDescriptor *__hidden this, IOOptionBits tag);
  IOOptionBits (__cdecl *getTag)(IOMemoryDescriptor *__hidden this);
  IOByteCount (__cdecl *readBytes)(IOMemoryDescriptor *__hidden this, IOByteCount offset, void *bytes, IOByteCount withLength);
  IOByteCount (__cdecl *writeBytes)(IOMemoryDescriptor *__hidden this, IOByteCount offset, const void *bytes, IOByteCount withLength);
  IOReturn (__cdecl *prepare)(IOMemoryDescriptor *__hidden this, IODirection forDirection);
  IOReturn (__cdecl *complete)(IOMemoryDescriptor *__hidden this, IODirection forDirection);
  IOMemoryMap *(__cdecl *map)(IOMemoryDescriptor *__hidden this, IOOptionBits options);
  IOMemoryMap *(__cdecl *setMapping)(IOMemoryDescriptor *__hidden this, task_t task, IOVirtualAddress mapAddress, IOOptionBits options);
  IOReturn (__cdecl *redirect)(IOMemoryDescriptor *__hidden this, task_t safeTask, bool redirect);
  IOMemoryMap *(__cdecl *makeMapping)(IOMemoryDescriptor *__hidden this, IOMemoryDescriptor *owner, task_t intoTask, IOVirtualAddress atAddress, IOOptionBits options, IOByteCount offset, IOByteCount length);
  void (__cdecl *addMapping)(IOMemoryDescriptor *__hidden this, IOMemoryMap *mapping);
  void (__cdecl *removeMapping)(IOMemoryDescriptor *__hidden this, IOMemoryMap *mapping);
  IOReturn (__cdecl *doMap)(IOMemoryDescriptor *__hidden this, vm_map_t addressMap, IOVirtualAddress *atAddress, IOOptionBits options, IOByteCount sourceOffset, IOByteCount length);
  IOReturn (__cdecl *doUnmap)(IOMemoryDescriptor *__hidden this, vm_map_t addressMap, IOVirtualAddress logical, IOByteCount length);
  __int64 vcallOffset;
};

/* 312 */
struct IOGeneralMemoryDescriptor_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOGeneralMemoryDescriptor)(IOGeneralMemoryDescriptor *__hidden this);
  void (__cdecl *~IOGeneralMemoryDescriptor_0)(IOGeneralMemoryDescriptor *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const IOGeneralMemoryDescriptor *__hidden this, OSSerialize *s);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOGeneralMemoryDescriptor *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOMemoryDescriptor *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOGeneralMemoryDescriptor *__hidden this);
  bool (__cdecl *initWithOptions)(IOGeneralMemoryDescriptor *__hidden this, void *buffers, UInt32 count, UInt32 offset, task_t task, IOOptionBits options, IOMapper *mapper);
  IOReturn (__cdecl *setPurgeable)(IOGeneralMemoryDescriptor *__hidden this, IOOptionBits newState, IOOptionBits *oldState);
  IOReturn (__cdecl *performOperation)(IOMemoryDescriptor *__hidden this, IOOptionBits options, IOByteCount offset, IOByteCount length);
  IOReturn (__cdecl *dmaCommandOperation)(const IOGeneralMemoryDescriptor *__hidden this, IOMemoryDescriptor::DMACommandOps op, void *vData, UInt dataSize);
  addr64_t (__cdecl *getPhysicalSegment)(IOGeneralMemoryDescriptor *__hidden this, IOByteCount offset, IOByteCount *length, IOOptionBits options);
  uint64_t (__cdecl *getPreparationID)(IOGeneralMemoryDescriptor *__hidden this);
  IODirection (__cdecl *getDirection)(const IOMemoryDescriptor *__hidden this);
  IOByteCount (__cdecl *getLength)(const IOMemoryDescriptor *__hidden this);
  void (__cdecl *setTag)(IOMemoryDescriptor *__hidden this, IOOptionBits tag);
  IOOptionBits (__cdecl *getTag)(IOMemoryDescriptor *__hidden this);
  IOByteCount (__cdecl *readBytes)(IOMemoryDescriptor *__hidden this, IOByteCount offset, void *bytes, IOByteCount withLength);
  IOByteCount (__cdecl *writeBytes)(IOMemoryDescriptor *__hidden this, IOByteCount offset, const void *bytes, IOByteCount withLength);
  IOReturn (__cdecl *prepare)(IOGeneralMemoryDescriptor *__hidden this, IODirection forDirection);
  IOReturn (__cdecl *complete)(IOGeneralMemoryDescriptor *__hidden this, IODirection forDirection);
  IOMemoryMap *(__cdecl *map)(IOMemoryDescriptor *__hidden this, IOOptionBits options);
  IOMemoryMap *(__cdecl *setMapping)(IOMemoryDescriptor *__hidden this, task_t task, IOVirtualAddress mapAddress, IOOptionBits options);
  IOReturn (__cdecl *redirect)(IOMemoryDescriptor *__hidden this, task_t safeTask, bool redirect);
  IOMemoryMap *(__cdecl *makeMapping)(IOMemoryDescriptor *__hidden this, IOMemoryDescriptor *owner, task_t intoTask, IOVirtualAddress atAddress, IOOptionBits options, IOByteCount offset, IOByteCount length);
  void (__cdecl *addMapping)(IOMemoryDescriptor *__hidden this, IOMemoryMap *mapping);
  void (__cdecl *removeMapping)(IOMemoryDescriptor *__hidden this, IOMemoryMap *mapping);
  IOReturn (__cdecl *doMap)(IOGeneralMemoryDescriptor *__hidden this, vm_map_t addressMap, IOVirtualAddress *atAddress, IOOptionBits options, IOByteCount sourceOffset, IOByteCount length);
  IOReturn (__cdecl *doUnmap)(IOGeneralMemoryDescriptor *__hidden this, vm_map_t addressMap, IOVirtualAddress logical, IOByteCount length);
  __int64 vcallOffset;
};

/* 319 */
typedef unsigned __int64 clock_sec_t;

/* 320 */
typedef unsigned int clock_nsec_t;

/* 313 */
struct IOPlatformExpert_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOPlatformExpert)(IOPlatformExpert *__hidden this);
  void (__cdecl *~IOPlatformExpert_0)(IOPlatformExpert *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOPlatformExpert *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOPlatformExpert *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOPlatformExpert *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOPlatformExpert *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  void (__cdecl *setBootROMType)(IOPlatformExpert *__hidden this, __int64 peBootROMType);
  void (__cdecl *setChipSetType)(IOPlatformExpert *__hidden this, __int64 peChipSetType);
  void (__cdecl *setMachineType)(IOPlatformExpert *__hidden this, __int64 peMachineType);
  bool (__cdecl *CheckSubTree)(IOPlatformExpert *__hidden this, OSArray *inSubTree, IOService *theNub, IOService *theDevice, OSDictionary *theParent);
  bool (__cdecl *RegisterServiceInTree)(IOPlatformExpert *__hidden this, IOService *theService, OSDictionary *theTreeNode, OSDictionary *theTreeParentNode, IOService *theProvider);
  void (__cdecl *PMInstantiatePowerDomains)(IOPlatformExpert *__hidden this);
  bool (__cdecl *configure)(IOPlatformExpert *__hidden this, IOService *provider);
  IOService *(__cdecl *createNub)(IOPlatformExpert *__hidden this, OSDictionary *from);
  bool (__cdecl *compareNubName)(const IOPlatformExpert *__hidden this, const IOService *nub, OSString *name, OSString **matched);
  IOReturn (__cdecl *getNubResources)(IOPlatformExpert *__hidden this, IOService *nub);
  __int64 (__cdecl *getBootROMType)(IOPlatformExpert *__hidden this);
  __int64 (__cdecl *getChipSetType)(IOPlatformExpert *__hidden this);
  __int64 (__cdecl *getMachineType)(IOPlatformExpert *__hidden this);
  bool (__cdecl *getModelName)(IOPlatformExpert *__hidden this, char *name, int maxLength);
  bool (__cdecl *getMachineName)(IOPlatformExpert *__hidden this, char *name, int maxLength);
  int (__cdecl *haltRestart)(IOPlatformExpert *__hidden this, unsigned int type);
  void (__cdecl *sleepKernel)(IOPlatformExpert *__hidden this);
  __int64 (__cdecl *getGMTTimeOfDay)(IOPlatformExpert *__hidden this);
  void (__cdecl *setGMTTimeOfDay)(IOPlatformExpert *__hidden this, __int64 secs);
  IOReturn (__cdecl *getConsoleInfo)(IOPlatformExpert *__hidden this, PE_Video *consoleInfo);
  IOReturn (__cdecl *setConsoleInfo)(IOPlatformExpert *__hidden this, PE_Video *consoleInfo, unsigned int op);
  void (__cdecl *registerNVRAMController)(IOPlatformExpert *__hidden this, IONVRAMController *nvram);
  IOReturn (__cdecl *registerInterruptController)(IOPlatformExpert *__hidden this, OSSymbol *name, IOInterruptController *interruptController);
  IOInterruptController *(__cdecl *lookUpInterruptController)(IOPlatformExpert *__hidden this, OSSymbol *name);
  void (__cdecl *setCPUInterruptProperties)(IOPlatformExpert *__hidden this, IOService *service);
  bool (__cdecl *atInterruptLevel)(IOPlatformExpert *__hidden this);
  IORangeAllocator *(__cdecl *getPhysicalRangeAllocator)(IOPlatformExpert *__hidden this);
  bool (__cdecl *platformAdjustService)(IOPlatformExpert *__hidden this, IOService *service);
  void (__cdecl *PMRegisterDevice)(IOPlatformExpert *__hidden this, IOService *theNub, IOService *theDevice);
  void (__cdecl *PMLog)(IOPlatformExpert *__hidden this, const char *, unsigned __int64, unsigned __int64, unsigned __int64);
  bool (__cdecl *hasPMFeature)(IOPlatformExpert *__hidden this, unsigned __int64 featureMask);
  bool (__cdecl *hasPrivPMFeature)(IOPlatformExpert *__hidden this, unsigned __int64 privFeatureMask);
  int (__cdecl *numBatteriesSupported)(IOPlatformExpert *__hidden this);
  IOByteCount (__cdecl *savePanicInfo)(IOPlatformExpert *__hidden this, UInt8 *buffer, IOByteCount length);
  OSString *(__cdecl *createSystemSerialNumberString)(IOPlatformExpert *__hidden this, OSData *myProperty);
  IOReturn (__cdecl *deregisterInterruptController)(IOPlatformExpert *__hidden this, OSSymbol *name);
  void (__cdecl *getUTCTimeOfDay)(IOPlatformExpert *__hidden this, clock_sec_t *secs, clock_nsec_t *nsecs);
  void (__cdecl *setUTCTimeOfDay)(IOPlatformExpert *__hidden this, clock_sec_t secs, clock_nsec_t nsecs);
  bool (__cdecl *getTargetName)(IOPlatformExpert *__hidden this, char *name, int maxLength);
  bool (__cdecl *getProductName)(IOPlatformExpert *__hidden this, char *name, int maxLength);
  __int64 vcallOffset;
};

/* 314 */
struct __cppobj IOPlatformExpert : IOService
{
  __int64 _peBootROMType;
  __int64 _peChipSetType;
  __int64 _peMachineType;
  IOPMrootDomain *root;
  int _pePMFeatures;
  int _pePrivPMFeatures;
  int _peNumBatteriesSupported;
  OSArray *thePowerTree;
  bool searchingForAdditionalParents;
  OSNumber *multipleParentKeyValue;
  int numInstancesRegistered;
  IOPlatformExpert::ExpansionData *iope_reserved;
};

/* 317 */
struct PE_Video
{
  unsigned __int64 v_baseAddr;
  unsigned __int64 v_rowBytes;
  unsigned __int64 v_width;
  unsigned __int64 v_height;
  unsigned __int64 v_depth;
  unsigned __int64 v_display;
  char v_pixelFormat[64];
  unsigned __int64 v_offset;
  unsigned __int64 v_length;
  unsigned __int8 v_rotate;
  unsigned __int8 v_scale;
  char reserved1[2];
  __int64 reserved2;
};

/* 318 */
struct __cppobj IONVRAMController : IOService
{
};

/* 315 */
struct __cppobj IOPMrootDomain : IOService
{
};

/* 316 */
struct IOPlatformExpert::ExpansionData
{
};

/* 321 */
struct IORegistryEntry_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IORegistryEntry)(IORegistryEntry *__hidden this);
  void (__cdecl *~IORegistryEntry_0)(IORegistryEntry *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IORegistryEntry *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IORegistryEntry *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IORegistryEntry *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IORegistryEntry *__hidden this, OSSerialize *serialize);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IORegistryEntry *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  __int64 vcallOffset;
};

/* 322 */
struct IODTPlatformExpert_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IODTPlatformExpert)(IODTPlatformExpert *__hidden this);
  void (__cdecl *~IODTPlatformExpert_0)(IODTPlatformExpert *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IODTPlatformExpert *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IODTPlatformExpert *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOPlatformExpert *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOPlatformExpert *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOPlatformExpert *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  void (__cdecl *setBootROMType)(IOPlatformExpert *__hidden this, __int64 peBootROMType);
  void (__cdecl *setChipSetType)(IOPlatformExpert *__hidden this, __int64 peChipSetType);
  void (__cdecl *setMachineType)(IOPlatformExpert *__hidden this, __int64 peMachineType);
  bool (__cdecl *CheckSubTree)(IOPlatformExpert *__hidden this, OSArray *inSubTree, IOService *theNub, IOService *theDevice, OSDictionary *theParent);
  bool (__cdecl *RegisterServiceInTree)(IOPlatformExpert *__hidden this, IOService *theService, OSDictionary *theTreeNode, OSDictionary *theTreeParentNode, IOService *theProvider);
  void (__cdecl *PMInstantiatePowerDomains)(IOPlatformExpert *__hidden this);
  bool (__cdecl *configure)(IODTPlatformExpert *__hidden this, IOService *provider);
  IOService *(__cdecl *createNub)(IOPlatformExpert *__hidden this, OSDictionary *from);
  bool (__cdecl *compareNubName)(const IODTPlatformExpert *__hidden this, const IOService *nub, OSString *name, OSString **matched);
  IOReturn (__cdecl *getNubResources)(IODTPlatformExpert *__hidden this, IOService *nub);
  __int64 (__cdecl *getBootROMType)(IOPlatformExpert *__hidden this);
  __int64 (__cdecl *getChipSetType)(IOPlatformExpert *__hidden this);
  __int64 (__cdecl *getMachineType)(IOPlatformExpert *__hidden this);
  bool (__cdecl *getModelName)(IODTPlatformExpert *__hidden this, char *name, int maxLength);
  bool (__cdecl *getMachineName)(IODTPlatformExpert *__hidden this, char *name, int maxLength);
  int (__cdecl *haltRestart)(IODTPlatformExpert *__hidden this, unsigned int type);
  void (__cdecl *sleepKernel)(IOPlatformExpert *__hidden this);
  __int64 (__cdecl *getGMTTimeOfDay)(IOPlatformExpert *__hidden this);
  void (__cdecl *setGMTTimeOfDay)(IOPlatformExpert *__hidden this, __int64 secs);
  IOReturn (__cdecl *getConsoleInfo)(IOPlatformExpert *__hidden this, PE_Video *consoleInfo);
  IOReturn (__cdecl *setConsoleInfo)(IOPlatformExpert *__hidden this, PE_Video *consoleInfo, unsigned int op);
  void (__cdecl *registerNVRAMController)(IODTPlatformExpert *__hidden this, IONVRAMController *nvram);
  IOReturn (__cdecl *registerInterruptController)(IOPlatformExpert *__hidden this, OSSymbol *name, IOInterruptController *interruptController);
  IOInterruptController *(__cdecl *lookUpInterruptController)(IOPlatformExpert *__hidden this, OSSymbol *name);
  void (__cdecl *setCPUInterruptProperties)(IOPlatformExpert *__hidden this, IOService *service);
  bool (__cdecl *atInterruptLevel)(IOPlatformExpert *__hidden this);
  IORangeAllocator *(__cdecl *getPhysicalRangeAllocator)(IOPlatformExpert *__hidden this);
  bool (__cdecl *platformAdjustService)(IOPlatformExpert *__hidden this, IOService *service);
  void (__cdecl *PMRegisterDevice)(IOPlatformExpert *__hidden this, IOService *theNub, IOService *theDevice);
  void (__cdecl *PMLog)(IOPlatformExpert *__hidden this, const char *, unsigned __int64, unsigned __int64, unsigned __int64);
  bool (__cdecl *hasPMFeature)(IOPlatformExpert *__hidden this, unsigned __int64 featureMask);
  bool (__cdecl *hasPrivPMFeature)(IOPlatformExpert *__hidden this, unsigned __int64 privFeatureMask);
  int (__cdecl *numBatteriesSupported)(IOPlatformExpert *__hidden this);
  IOByteCount (__cdecl *savePanicInfo)(IODTPlatformExpert *__hidden this, UInt8 *buffer, IOByteCount length);
  OSString *(__cdecl *createSystemSerialNumberString)(IODTPlatformExpert *__hidden this, OSData *myProperty);
  IOReturn (__cdecl *deregisterInterruptController)(IOPlatformExpert *__hidden this, OSSymbol *name);
  void (__cdecl *getUTCTimeOfDay)(IOPlatformExpert *__hidden this, clock_sec_t *secs, clock_nsec_t *nsecs);
  void (__cdecl *setUTCTimeOfDay)(IOPlatformExpert *__hidden this, clock_sec_t secs, clock_nsec_t nsecs);
  bool (__cdecl *getTargetName)(IODTPlatformExpert *__hidden this, char *name, int maxLength);
  bool (__cdecl *getProductName)(IODTPlatformExpert *__hidden this, char *name, int maxLength);
  void (__cdecl *processTopLevel)(IODTPlatformExpert *__hidden this, IORegistryEntry *root);
  const char *(__cdecl *deleteList)(IODTPlatformExpert *__hidden this);
  const char *(__cdecl *excludeList)(IODTPlatformExpert *__hidden this);
  IOService *(__cdecl *createNub_0)(IODTPlatformExpert *__hidden this, IORegistryEntry *from);
  bool (__cdecl *createNubs)(IODTPlatformExpert *__hidden this, IOService *parent, OSIterator *iter);
  IOReturn (__cdecl *readNVRAMProperty)(IODTPlatformExpert *__hidden this, IORegistryEntry *entry, const OSSymbol **name, OSData **value);
  IOReturn (__cdecl *writeNVRAMProperty)(IODTPlatformExpert *__hidden this, IORegistryEntry *entry, const OSSymbol *name, OSData *value);
  __int64 vcallOffset;
};

/* 323 */
struct __cppobj IODTPlatformExpert : IOPlatformExpert
{
  IODTNVRAM *dtNVRAM;
  IODTPlatformExpert::ExpansionData *iodtpe_reserved;
};

/* 325 */
struct IODTNVRAMVariables;

/* 324 */
struct __cppobj IODTNVRAM : IOService
{
  IONVRAMController *_nvramController;
  const OSSymbol *_registryPropertiesKey;
  UInt8 *_nvramImage;
  IOLock *_variableLock;
  IOLock *_controllerLock;
  UInt32 _commonPartitionOffset;
  UInt32 _commonPartitionSize;
  UInt8 *_commonImage;
  IODTNVRAMVariables *_commonService;
  OSDictionary *_commonDict;
  UInt32 _systemPartitionOffset;
  UInt32 _systemPartitionSize;
  UInt8 *_systemImage;
  IODTNVRAMVariables *_systemService;
  OSDictionary *_systemDict;
  OSDictionary *_nvramPartitionOffsets;
  OSDictionary *_nvramPartitionLengths;
  bool _systemPanicked;
  SInt32 _lastDeviceSync;
  bool _freshInterval;
  bool _isProxied;
  UInt32 _nvramSize;
};

/* 326 */
struct IODTPlatformExpert::ExpansionData
{
};

/* 327 */
struct IOPlatformExpertDevice_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOPlatformExpertDevice)(IOPlatformExpertDevice *__hidden this);
  void (__cdecl *~IOPlatformExpertDevice_0)(IOPlatformExpertDevice *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOPlatformExpertDevice *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOPlatformExpertDevice *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IOPlatformExpertDevice *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IOPlatformExpertDevice *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOService *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOPlatformExpertDevice *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOPlatformExpertDevice *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  bool (__cdecl *init_2)(IOPlatformExpertDevice *__hidden this, void *dtRoot);
  __int64 vcallOffset;
};

/* 328 */
struct __cppobj IOPlatformExpertDevice : IOService
{
  IOWorkLoop *workLoop;
  IOPlatformExpertDevice::ExpansionData *ioped_reserved;
};

/* 329 */
struct IOPlatformExpertDevice::ExpansionData
{
};

/* 330 */
struct IOPlatformDevice_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOPlatformDevice)(IOPlatformDevice *__hidden this);
  void (__cdecl *~IOPlatformDevice_0)(IOPlatformDevice *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOPlatformDevice *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IOPlatformDevice *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOService *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOPlatformDevice *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOPlatformDevice *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  __int64 vcallOffset;
};

/* 331 */
struct __cppobj IOPlatformDevice : IOService
{
  IOPlatformDevice::ExpansionData *iopd_reserved;
};

/* 332 */
struct IOPlatformDevice::ExpansionData
{
};

/* 333 */
struct IOPlatformIO_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOPlatformIO)(IOPlatformIO *__hidden this);
  void (__cdecl *~IOPlatformIO_0)(IOPlatformIO *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOPlatformIO *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOPlatformIO *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  bool (__cdecl *handlePlatformError)(IOPlatformIO *__hidden this, vm_offset_t far);
  __int64 vcallOffset;
};

/* 334 */
struct __cppobj IOPlatformIO : IOService
{
};

/* 336 */
typedef unsigned __int16 UInt16;

/* 335 */
struct IODTNVRAM_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IODTNVRAM)(IODTNVRAM *__hidden this);
  void (__cdecl *~IODTNVRAM_0)(IODTNVRAM *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IODTNVRAM *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IODTNVRAM *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IODTNVRAM *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IODTNVRAM *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IODTNVRAM *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IODTNVRAM *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IODTNVRAM *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IODTNVRAM *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IODTNVRAM *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IODTNVRAM *__hidden this, IORegistryEntry *old, const IORegistryPlane *plane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOService *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  UInt8 (__cdecl *calculatePartitionChecksum)(IODTNVRAM *__hidden this, UInt8 *partitionHeader);
  IOReturn (__cdecl *initVariables)(IODTNVRAM *__hidden this);
  UInt32 (__cdecl *getOFVariableType)(const IODTNVRAM *__hidden this, const char *propName);
  UInt32 (__cdecl *getOFVariableType_0)(const IODTNVRAM *__hidden this, const OSSymbol *propSymbol);
  UInt32 (__cdecl *getOFVariablePerm)(const IODTNVRAM *__hidden this, const char *propName);
  UInt32 (__cdecl *getOFVariablePerm_0)(const IODTNVRAM *__hidden this, const OSSymbol *propSymbol);
  bool (__cdecl *getOWVariableInfo)(IODTNVRAM *__hidden this, UInt32 variableNumber, const OSSymbol **propSymbol, UInt32 *propType, UInt32 *propOffset);
  bool (__cdecl *convertPropToObject)(IODTNVRAM *__hidden this, UInt8 *propName, UInt32 propNameLength, UInt8 *propData, UInt32 propDataLength, const OSSymbol **propSymbol, OSObject **propObject);
  bool (__cdecl *convertObjectToProp)(IODTNVRAM *__hidden this, UInt8 *buffer, UInt32 *length, const OSSymbol *propSymbol, OSObject *propObject);
  UInt16 (__cdecl *generateOWChecksum)(IODTNVRAM *__hidden this, UInt8 *buffer);
  bool (__cdecl *validateOWChecksum)(IODTNVRAM *__hidden this, UInt8 *buffer);
  void (__cdecl *updateOWBootArgs)(IODTNVRAM *__hidden this, const OSSymbol *key, OSObject *value);
  bool (__cdecl *searchNVRAMProperty)(IODTNVRAM *__hidden this, IONVRAMDescriptor *hdr, UInt32 *where);
  IOReturn (__cdecl *readNVRAMPropertyType0)(IODTNVRAM *__hidden this, IORegistryEntry *entry, const OSSymbol **name, OSData **value);
  IOReturn (__cdecl *writeNVRAMPropertyType0)(IODTNVRAM *__hidden this, IORegistryEntry *entry, const OSSymbol *name, OSData *value);
  OSData *(__cdecl *unescapeBytesToData)(IODTNVRAM *__hidden this, const UInt8 *bytes, UInt32 length);
  OSData *(__cdecl *escapeDataToData)(IODTNVRAM *__hidden this, OSData *value);
  IOReturn (__cdecl *readNVRAMPropertyType1)(IODTNVRAM *__hidden this, IORegistryEntry *entry, const OSSymbol **name, OSData **value);
  IOReturn (__cdecl *writeNVRAMPropertyType1)(IODTNVRAM *__hidden this, IORegistryEntry *entry, const OSSymbol *name, OSData *value);
  void (__cdecl *registerNVRAMController)(IODTNVRAM *__hidden this, IONVRAMController *nvram);
  void (__cdecl *sync)(IODTNVRAM *__hidden this);
  IOReturn (__cdecl *syncOFVariables)(IODTNVRAM *__hidden this);
  IOReturn (__cdecl *readXPRAM)(IODTNVRAM *__hidden this, IOByteCount offset, UInt8 *buffer, IOByteCount length);
  IOReturn (__cdecl *writeXPRAM)(IODTNVRAM *__hidden this, IOByteCount offset, UInt8 *buffer, IOByteCount length);
  IOReturn (__cdecl *readNVRAMProperty)(IODTNVRAM *__hidden this, IORegistryEntry *entry, const OSSymbol **name, OSData **value);
  IOReturn (__cdecl *writeNVRAMProperty)(IODTNVRAM *__hidden this, IORegistryEntry *entry, const OSSymbol *name, OSData *value);
  OSDictionary *(__cdecl *getNVRAMPartitions)(IODTNVRAM *__hidden this);
  IOReturn (__cdecl *readNVRAMPartition)(IODTNVRAM *__hidden this, const OSSymbol *partitionID, IOByteCount offset, UInt8 *buffer, IOByteCount length);
  IOReturn (__cdecl *writeNVRAMPartition)(IODTNVRAM *__hidden this, const OSSymbol *partitionID, IOByteCount offset, UInt8 *buffer, IOByteCount length);
  IOByteCount (__cdecl *savePanicInfo)(IODTNVRAM *__hidden this, UInt8 *buffer, IOByteCount length);
  bool (__cdecl *safeToSync)(IODTNVRAM *__hidden this);
  __int64 vcallOffset;
};

/* 337 */
struct __attribute__((packed)) __attribute__((aligned(2))) IONVRAMDescriptor
{
  unsigned __int32 format : 4;
  unsigned __int32 marker : 1;
  unsigned __int32 bridgeCount : 3;
  unsigned __int32 busNum : 2;
  unsigned __int32 bridgeDevices : 30;
  unsigned __int32 functionNum : 3;
  unsigned __int32 deviceNum : 5;
};

/* 338 */
struct IODMAController_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IODMAController)(IODMAController *__hidden this);
  void (__cdecl *~IODMAController_0)(IODMAController *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IODMAController *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IODMAController *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  void (__cdecl *registerDMAController)(IODMAController *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *initDMAChannel)(IODMAController *__hidden this, IOService *provider, IODMAEventSource *dmaES, UInt32 *dmaIndex, UInt32 reqIndex);
  IOReturn (__cdecl *startDMACommand)(IODMAController *__hidden this, UInt32 dmaIndex, IODMACommand *dmaCommand, IODirection direction, IOByteCount byteCount, IOByteCount byteOffset);
  IOReturn (__cdecl *stopDMACommand)(IODMAController *__hidden this, UInt32 dmaIndex, bool flush, uint64_t timeout);
  void (__cdecl *completeDMACommand)(IODMAController *__hidden this, IODMAEventSource *dmaES, IODMACommand *dmaCommand);
  void (__cdecl *notifyDMACommand)(IODMAController *__hidden this, IODMAEventSource *dmaES, IODMACommand *dmaCommand, IOReturn status, IOByteCount actualByteCount, AbsoluteTime timeStamp);
  IOReturn (__cdecl *queryDMACommand)(IODMAController *__hidden this, UInt32 dmaIndex, IODMACommand **dmaCommand, IOByteCount *transferCount, bool waitForIdle);
  IOByteCount (__cdecl *getFIFODepth)(IODMAController *__hidden this, UInt32 dmaIndex, IODirection direction);
  IOReturn (__cdecl *setFIFODepth)(IODMAController *__hidden this, UInt32 dmaIndex, IOByteCount depth);
  IOByteCount (__cdecl *validFIFODepth)(IODMAController *__hidden this, UInt32 dmaIndex, IOByteCount depth, IODirection direction);
  IOReturn (__cdecl *setFrameSize)(IODMAController *__hidden this, UInt32 dmaIndex, UInt8 byteCount);
  IOReturn (__cdecl *setDMAConfig)(IODMAController *__hidden this, UInt32 dmaIndex, IOService *provider, UInt32 reqIndex);
  bool (__cdecl *validDMAConfig)(IODMAController *__hidden this, UInt32 dmaIndex, IOService *provider, UInt32 reqIndex);
  __int64 vcallOffset;
};

/* 340 */
typedef int32_t IOInterruptVectorNumber;

/* 339 */
struct IOSharedInterruptController_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOSharedInterruptController)(IOSharedInterruptController *__hidden this);
  void (__cdecl *~IOSharedInterruptController_0)(IOSharedInterruptController *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOSharedInterruptController *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOService *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  IOReturn (__cdecl *registerInterrupt_0)(IOSharedInterruptController *__hidden this, IOService *nub, int source, void *target, IOInterruptHandler handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt_0)(IOSharedInterruptController *__hidden this, IOService *nub, int source);
  IOReturn (__cdecl *getInterruptType_0)(IOSharedInterruptController *__hidden this, IOService *nub, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt_0)(IOSharedInterruptController *__hidden this, IOService *nub, int source);
  IOReturn (__cdecl *disableInterrupt_0)(IOSharedInterruptController *__hidden this, IOService *nub, int source);
  IOReturn (__cdecl *causeInterrupt_0)(IOInterruptController *__hidden this, IOService *nub, int source);
  IOInterruptAction (__cdecl *getInterruptHandlerAddress)(IOSharedInterruptController *__hidden this);
  IOReturn (__cdecl *handleInterrupt)(IOSharedInterruptController *__hidden this, void *refCon, IOService *nub, int source);
  bool (__cdecl *vectorCanBeShared)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *initVector)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  int (__cdecl *getVectorType)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *disableVectorHard)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *enableVector)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *causeVector)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *setCPUInterruptProperties)(IOInterruptController *__hidden this, IOService *service);
  void (__cdecl *sendIPI)(IOInterruptController *__hidden this, unsigned int cpu_id, bool deferred);
  void (__cdecl *cancelDeferredIPI)(IOInterruptController *__hidden this, unsigned int cpu_id);
  IOReturn (__cdecl *initInterruptController)(IOSharedInterruptController *__hidden this, IOInterruptController *parentController, OSData *parentSource);
  __int64 vcallOffset;
};

/* 341 */
struct PassthruInterruptController_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~PassthruInterruptController)(PassthruInterruptController *__hidden this);
  void (__cdecl *~PassthruInterruptController_0)(PassthruInterruptController *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const PassthruInterruptController *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(PassthruInterruptController *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOService *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  IOReturn (__cdecl *registerInterrupt_0)(PassthruInterruptController *__hidden this, IOService *nub, int source, void *target, IOInterruptHandler handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt_0)(IOInterruptController *__hidden this, IOService *nub, int source);
  IOReturn (__cdecl *getInterruptType_0)(PassthruInterruptController *__hidden this, IOService *nub, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt_0)(PassthruInterruptController *__hidden this, IOService *nub, int source);
  IOReturn (__cdecl *disableInterrupt_0)(PassthruInterruptController *__hidden this, IOService *nub, int source);
  IOReturn (__cdecl *causeInterrupt_0)(PassthruInterruptController *__hidden this, IOService *nub, int source);
  IOInterruptAction (__cdecl *getInterruptHandlerAddress)(IOInterruptController *__hidden this);
  IOReturn (__cdecl *handleInterrupt)(PassthruInterruptController *__hidden this, void *refCon, IOService *nub, int source);
  bool (__cdecl *vectorCanBeShared)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *initVector)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  int (__cdecl *getVectorType)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *disableVectorHard)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *enableVector)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *causeVector)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *setCPUInterruptProperties)(PassthruInterruptController *__hidden this, IOService *service);
  void (__cdecl *sendIPI)(IOInterruptController *__hidden this, unsigned int cpu_id, bool deferred);
  void (__cdecl *cancelDeferredIPI)(IOInterruptController *__hidden this, unsigned int cpu_id);
  void *(__cdecl *waitForChildController)(PassthruInterruptController *__hidden this);
  void (__cdecl *externalInterrupt)(PassthruInterruptController *__hidden this);
  __int64 vcallOffset;
};

/* 344 */
struct semaphore;

/* 343 */
typedef struct semaphore *semaphore_t;

/* 342 */
struct __cppobj PassthruInterruptController : IOInterruptController
{
  IOInterruptHandler child_handler;
  void *child_target;
  void *child_refCon;
  IOService *child_nub;
  semaphore_t child_sentinel;
};

/* 345 */
struct IOInterruptController_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOInterruptController)(IOInterruptController *__hidden this);
  void (__cdecl *~IOInterruptController_0)(IOInterruptController *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOInterruptController *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOService *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  IOReturn (__cdecl *registerInterrupt_0)(IOInterruptController *__hidden this, IOService *nub, int source, void *target, IOInterruptHandler handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt_0)(IOInterruptController *__hidden this, IOService *nub, int source);
  IOReturn (__cdecl *getInterruptType_0)(IOInterruptController *__hidden this, IOService *nub, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt_0)(IOInterruptController *__hidden this, IOService *nub, int source);
  IOReturn (__cdecl *disableInterrupt_0)(IOInterruptController *__hidden this, IOService *nub, int source);
  IOReturn (__cdecl *causeInterrupt_0)(IOInterruptController *__hidden this, IOService *nub, int source);
  IOInterruptAction (__cdecl *getInterruptHandlerAddress)(IOInterruptController *__hidden this);
  IOReturn (__cdecl *handleInterrupt)(IOInterruptController *__hidden this, void *refCon, IOService *nub, int source);
  bool (__cdecl *vectorCanBeShared)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *initVector)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  int (__cdecl *getVectorType)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *disableVectorHard)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *enableVector)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *causeVector)(IOInterruptController *__hidden this, IOInterruptVectorNumber vectorNumber, IOInterruptVector *vector);
  void (__cdecl *setCPUInterruptProperties)(IOInterruptController *__hidden this, IOService *service);
  void (__cdecl *sendIPI)(IOInterruptController *__hidden this, unsigned int cpu_id, bool deferred);
  void (__cdecl *cancelDeferredIPI)(IOInterruptController *__hidden this, unsigned int cpu_id);
  __int64 vcallOffset;
};

/* 346 */
struct IOKitDiagnostics_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOKitDiagnostics)(IOKitDiagnostics *__hidden this);
  void (__cdecl *~IOKitDiagnostics_0)(IOKitDiagnostics *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const IOKitDiagnostics *__hidden this, OSSerialize *s);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOKitDiagnostics *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSObject *__hidden this);
  __int64 vcallOffset;
};

/* 347 */
struct __cppobj IOKitDiagnostics : OSObject
{
};

/* 351 */
typedef uint64_t io_user_reference_t;

/* 354 */
typedef OSObject *io_object_t;

/* 348 */
struct IOKitDiagnosticsClient_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOKitDiagnosticsClient)(IOKitDiagnosticsClient *__hidden this);
  void (__cdecl *~IOKitDiagnosticsClient_0)(IOKitDiagnosticsClient *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOKitDiagnosticsClient *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOUserClient *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(IOUserClient *__hidden this);
  void (__cdecl *free)(IOUserClient *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOUserClient *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IOKitDiagnosticsClient *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOService *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  IOReturn (__cdecl *externalMethod)(IOKitDiagnosticsClient *__hidden this, uint32_t selector, IOExternalMethodArguments *args, IOExternalMethodDispatch *dispatch, OSObject *target, void *reference);
  IOReturn (__cdecl *registerNotificationPort)(IOUserClient *__hidden this, mach_port_t port, UInt32 type, io_user_reference_t refCon);
  bool (__cdecl *initWithTask)(IOUserClient *__hidden this, task_t owningTask, void *securityToken, UInt32 type, OSDictionary *properties);
  bool (__cdecl *initWithTask_0)(IOUserClient *__hidden this, task_t owningTask, void *securityToken, UInt32 type);
  IOReturn (__cdecl *clientClose)(IOKitDiagnosticsClient *__hidden this);
  IOReturn (__cdecl *clientDied)(IOUserClient *__hidden this);
  IOService *(__cdecl *getService)(IOUserClient *__hidden this);
  IOReturn (__cdecl *registerNotificationPort_0)(IOUserClient *__hidden this, mach_port_t port, UInt32 type, UInt32 refCon);
  IOReturn (__cdecl *getNotificationSemaphore)(IOUserClient *__hidden this, UInt32 notification_type, semaphore_t *semaphore);
  IOReturn (__cdecl *connectClient)(IOUserClient *__hidden this, IOUserClient *client);
  IOReturn (__cdecl *clientMemoryForType)(IOUserClient *__hidden this, UInt32 type, IOOptionBits *options, IOMemoryDescriptor **memory);
  IOReturn (__cdecl *exportObjectToClient)(IOUserClient *__hidden this, task_t task, OSObject *obj, io_object_t *clientObj);
  IOExternalMethod *(__cdecl *getExternalMethodForIndex)(IOUserClient *__hidden this, UInt32 index);
  IOExternalAsyncMethod *(__cdecl *getExternalAsyncMethodForIndex)(IOUserClient *__hidden this, UInt32 index);
  IOExternalMethod *(__cdecl *getTargetAndMethodForIndex)(IOUserClient *__hidden this, IOService **targetP, UInt32 index);
  IOExternalAsyncMethod *(__cdecl *getAsyncTargetAndMethodForIndex)(IOUserClient *__hidden this, IOService **targetP, UInt32 index);
  IOExternalTrap *(__cdecl *getExternalTrapForIndex)(IOUserClient *__hidden this, UInt32 index);
  IOExternalTrap *(__cdecl *getTargetAndTrapForIndex)(IOUserClient *__hidden this, IOService **targetP, UInt32 index);
  __int64 vcallOffset;
};

/* 349 */
struct __cppobj IOKitDiagnosticsClient : IOUserClient
{
};

/* 350 */
struct IOExternalMethodArguments
{
  uint32_t version;
  uint32_t selector;
  mach_port_t asyncWakePort;
  io_user_reference_t *asyncReference;
  uint32_t asyncReferenceCount;
  const uint64_t *scalarInput;
  uint32_t scalarInputCount;
  const void *structureInput;
  uint32_t structureInputSize;
  IOMemoryDescriptor *structureInputDescriptor;
  uint64_t *scalarOutput;
  uint32_t scalarOutputCount;
  void *structureOutput;
  uint32_t structureOutputSize;
  IOMemoryDescriptor *structureOutputDescriptor;
  uint32_t structureOutputDescriptorSize;
  uint32_t __reservedA;
  OSObject **structureVariableOutputData;
  uint32_t __reserved[30];
};

/* 353 */
typedef IOReturn (__cdecl *IOExternalMethodAction)(OSObject *, void *, IOExternalMethodArguments *);

/* 352 */
struct IOExternalMethodDispatch
{
  IOExternalMethodAction function;
  uint32_t checkScalarInputCount;
  uint32_t checkStructureInputSize;
  uint32_t checkScalarOutputCount;
  uint32_t checkStructureOutputSize;
};

/* 357 */
struct $D22B7EC2FFE3E379BCF7926C521C3184
{
  IOReturn (__cdecl *ptr)(void *, void *, void *, void *, void *, void *);
  size_t adj;
};

/* 356 */
typedef $D22B7EC2FFE3E379BCF7926C521C3184 IOMethod;

/* 355 */
struct IOExternalMethod
{
  IOService *object;
  IOMethod func;
  IOOptionBits flags;
  IOByteCount count0;
  IOByteCount count1;
};

/* 361 */
typedef natural_t OSAsyncReference[8];

/* 360 */
struct $32A82CDB950F1A48B0FAEA7E2A340328
{
  IOReturn (__cdecl *ptr)(OSAsyncReference, void *, void *, void *, void *, void *, void *);
  size_t adj;
};

/* 359 */
typedef $32A82CDB950F1A48B0FAEA7E2A340328 IOAsyncMethod;

/* 358 */
struct IOExternalAsyncMethod
{
  IOService *object;
  IOAsyncMethod func;
  IOOptionBits flags;
  IOByteCount count0;
  IOByteCount count1;
};

/* 363 */
typedef $D22B7EC2FFE3E379BCF7926C521C3184 IOTrap;

/* 362 */
struct IOExternalTrap
{
  IOService *object;
  IOTrap func;
};

/* 372 */
typedef bool Boolean;

/* 369 */
typedef _IODataQueueEntry IODataQueueEntry;

/* 364 */
struct IOSharedDataQueue_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOSharedDataQueue)(IOSharedDataQueue *__hidden this);
  void (__cdecl *~IOSharedDataQueue_0)(IOSharedDataQueue *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOSharedDataQueue *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOSharedDataQueue *__hidden this);
  void (__cdecl *sendDataAvailableNotification)(IODataQueue *__hidden this);
  Boolean (__cdecl *initWithCapacity)(IOSharedDataQueue *__hidden this, UInt32 size);
  Boolean (__cdecl *initWithEntries)(IODataQueue *__hidden this, UInt32 numEntries, UInt32 entrySize);
  Boolean (__cdecl *enqueue)(IOSharedDataQueue *__hidden this, void *data, UInt32 dataSize);
  void (__cdecl *setNotificationPort)(IODataQueue *__hidden this, mach_port_t port);
  IOMemoryDescriptor *(__cdecl *getMemoryDescriptor)(IOSharedDataQueue *__hidden this);
  IODataQueueEntry *(__cdecl *peek)(IOSharedDataQueue *__hidden this);
  Boolean (__cdecl *dequeue)(IOSharedDataQueue *__hidden this, void *data, UInt32 *dataSize);
  __int64 vcallOffset;
};

/* 367 */
typedef _IODataQueueMemory IODataQueueMemory;

/* 366 */
struct __cppobj IODataQueue : OSObject
{
  IODataQueueMemory *dataQueue;
  void *notifyMsg;
};

/* 365 */
struct __cppobj IOSharedDataQueue : IODataQueue
{
  IOSharedDataQueue::ExpansionData *_reserved;
};

/* 370 */
struct _IODataQueueEntry
{
  UInt32 size;
  UInt8 data[4];
};

/* 368 */
struct _IODataQueueMemory
{
  UInt32 queueSize;
  UInt32 head;
  UInt32 tail;
  IODataQueueEntry queue[1];
};

/* 371 */
struct IOSharedDataQueue::ExpansionData
{
  UInt32 queueSize;
};

/* 373 */
struct IODataQueue_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IODataQueue)(IODataQueue *__hidden this);
  void (__cdecl *~IODataQueue_0)(IODataQueue *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IODataQueue *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IODataQueue *__hidden this);
  void (__cdecl *sendDataAvailableNotification)(IODataQueue *__hidden this);
  Boolean (__cdecl *initWithCapacity)(IODataQueue *__hidden this, UInt32 size);
  Boolean (__cdecl *initWithEntries)(IODataQueue *__hidden this, UInt32 numEntries, UInt32 entrySize);
  Boolean (__cdecl *enqueue)(IODataQueue *__hidden this, void *data, UInt32 dataSize);
  void (__cdecl *setNotificationPort)(IODataQueue *__hidden this, mach_port_t port);
  IOMemoryDescriptor *(__cdecl *getMemoryDescriptor)(IODataQueue *__hidden this);
  __int64 vcallOffset;
};

/* 374 */
struct IORTC_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IORTC)(IORTC *__hidden this);
  void (__cdecl *~IORTC_0)(IORTC *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IORTC *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOService *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  __int64 (__cdecl *getGMTTimeOfDay)(IORTC *__hidden this);
  void (__cdecl *setGMTTimeOfDay)(IORTC *__hidden this, __int64 secs);
  void (__cdecl *getUTCTimeOfDay)(IORTC *__hidden this, clock_sec_t *secs, clock_nsec_t *nsecs);
  void (__cdecl *setUTCTimeOfDay)(IORTC *__hidden this, clock_sec_t secs, clock_nsec_t nsecs);
  void (__cdecl *setAlarmEnable)(IORTC *__hidden this, IOOptionBits message);
  IOReturn (__cdecl *getMonotonicClockOffset)(IORTC *__hidden this, int64_t *usecs);
  IOReturn (__cdecl *setMonotonicClockOffset)(IORTC *__hidden this, int64_t usecs);
  IOReturn (__cdecl *getMonotonicClockAndTimestamp)(IORTC *__hidden this, uint64_t *usecs, uint64_t *mach_absolute_time);
  __int64 vcallOffset;
};

/* 375 */
struct __cppobj IORTC : IOService
{
  IORTC::ExpansionData *iortc_reserved;
};

/* 376 */
struct IORTC::ExpansionData
{
};

/* 377 */
struct IOUserClient_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOUserClient)(IOUserClient *__hidden this);
  void (__cdecl *~IOUserClient_0)(IOUserClient *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOUserClient *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOUserClient *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(IOUserClient *__hidden this);
  void (__cdecl *free)(IOUserClient *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOUserClient *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOService *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  IOReturn (__cdecl *externalMethod)(IOUserClient *__hidden this, uint32_t selector, IOExternalMethodArguments *arguments, IOExternalMethodDispatch *dispatch, OSObject *target, void *reference);
  IOReturn (__cdecl *registerNotificationPort)(IOUserClient *__hidden this, mach_port_t port, UInt32 type, io_user_reference_t refCon);
  bool (__cdecl *initWithTask)(IOUserClient *__hidden this, task_t owningTask, void *securityToken, UInt32 type, OSDictionary *properties);
  bool (__cdecl *initWithTask_0)(IOUserClient *__hidden this, task_t owningTask, void *securityToken, UInt32 type);
  IOReturn (__cdecl *clientClose)(IOUserClient *__hidden this);
  IOReturn (__cdecl *clientDied)(IOUserClient *__hidden this);
  IOService *(__cdecl *getService)(IOUserClient *__hidden this);
  IOReturn (__cdecl *registerNotificationPort_0)(IOUserClient *__hidden this, mach_port_t port, UInt32 type, UInt32 refCon);
  IOReturn (__cdecl *getNotificationSemaphore)(IOUserClient *__hidden this, UInt32 notification_type, semaphore_t *semaphore);
  IOReturn (__cdecl *connectClient)(IOUserClient *__hidden this, IOUserClient *client);
  IOReturn (__cdecl *clientMemoryForType)(IOUserClient *__hidden this, UInt32 type, IOOptionBits *options, IOMemoryDescriptor **memory);
  IOReturn (__cdecl *exportObjectToClient)(IOUserClient *__hidden this, task_t task, OSObject *obj, io_object_t *clientObj);
  IOExternalMethod *(__cdecl *getExternalMethodForIndex)(IOUserClient *__hidden this, UInt32 index);
  IOExternalAsyncMethod *(__cdecl *getExternalAsyncMethodForIndex)(IOUserClient *__hidden this, UInt32 index);
  IOExternalMethod *(__cdecl *getTargetAndMethodForIndex)(IOUserClient *__hidden this, IOService **targetP, UInt32 index);
  IOExternalAsyncMethod *(__cdecl *getAsyncTargetAndMethodForIndex)(IOUserClient *__hidden this, IOService **targetP, UInt32 index);
  IOExternalTrap *(__cdecl *getExternalTrapForIndex)(IOUserClient *__hidden this, UInt32 index);
  IOExternalTrap *(__cdecl *getTargetAndTrapForIndex)(IOUserClient *__hidden this, IOService **targetP, UInt32 index);
  __int64 vcallOffset;
};

/* 378 */
struct IOEventSource_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOEventSource)(IOEventSource *__hidden this);
  void (__cdecl *~IOEventSource_0)(IOEventSource *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOEventSource *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOEventSource *__hidden this);
  bool (__cdecl *init_0)(IOEventSource *__hidden this, OSObject *owner, IOEventSource::Action action);
  bool (__cdecl *checkForWork)(IOEventSource *__hidden this);
  void (__cdecl *setWorkLoop)(IOEventSource *__hidden this, IOWorkLoop *workLoop);
  void (__cdecl *setNext)(IOEventSource *__hidden this, IOEventSource *next);
  IOEventSource *(__cdecl *getNext)(const IOEventSource *__hidden this);
  void (__cdecl *setAction)(IOEventSource *__hidden this, IOEventSource::Action action);
  IOEventSource::Action (__cdecl *getAction)(const IOEventSource *__hidden this);
  void (__cdecl *enable)(IOEventSource *__hidden this);
  void (__cdecl *disable)(IOEventSource *__hidden this);
  bool (__cdecl *isEnabled)(const IOEventSource *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOEventSource *__hidden this);
  bool (__cdecl *onThread)(const IOEventSource *__hidden this);
  __int64 vcallOffset;
};

/* 379 */
struct IOPowerConnection_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOPowerConnection)(IOPowerConnection *__hidden this);
  void (__cdecl *~IOPowerConnection_0)(IOPowerConnection *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOPowerConnection *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOService *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  __int64 vcallOffset;
};

/* 380 */
struct IOWatchDogTimer_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOWatchDogTimer)(IOWatchDogTimer *__hidden this);
  void (__cdecl *~IOWatchDogTimer_0)(IOWatchDogTimer *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOWatchDogTimer *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IOWatchDogTimer *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOWatchDogTimer *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOWatchDogTimer *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  void (__cdecl *setWatchDogTimer)(IOWatchDogTimer *__hidden this, UInt32 timeOut);
  __int64 vcallOffset;
};

/* 381 */
struct __cppobj IOWatchDogTimer : IOService
{
  IONotifier *notifier;
  IOWatchDogTimer::ExpansionData *reserved;
};

/* 382 */
struct IOWatchDogTimer::ExpansionData
{
};

/* 383 */
struct IOBufferMemoryDescriptor_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOBufferMemoryDescriptor)(IOBufferMemoryDescriptor *__hidden this);
  void (__cdecl *~IOBufferMemoryDescriptor_0)(IOBufferMemoryDescriptor *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const IOGeneralMemoryDescriptor *__hidden this, OSSerialize *s);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOBufferMemoryDescriptor *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOBufferMemoryDescriptor *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOBufferMemoryDescriptor *__hidden this);
  bool (__cdecl *initWithOptions)(IOGeneralMemoryDescriptor *__hidden this, void *buffers, UInt32 count, UInt32 offset, task_t task, IOOptionBits options, IOMapper *mapper);
  IOReturn (__cdecl *setPurgeable)(IOGeneralMemoryDescriptor *__hidden this, IOOptionBits newState, IOOptionBits *oldState);
  IOReturn (__cdecl *performOperation)(IOMemoryDescriptor *__hidden this, IOOptionBits options, IOByteCount offset, IOByteCount length);
  IOReturn (__cdecl *dmaCommandOperation)(const IOGeneralMemoryDescriptor *__hidden this, IOMemoryDescriptor::DMACommandOps op, void *vData, UInt dataSize);
  addr64_t (__cdecl *getPhysicalSegment)(IOGeneralMemoryDescriptor *__hidden this, IOByteCount offset, IOByteCount *length, IOOptionBits options);
  uint64_t (__cdecl *getPreparationID)(IOGeneralMemoryDescriptor *__hidden this);
  IODirection (__cdecl *getDirection)(const IOMemoryDescriptor *__hidden this);
  IOByteCount (__cdecl *getLength)(const IOMemoryDescriptor *__hidden this);
  void (__cdecl *setTag)(IOMemoryDescriptor *__hidden this, IOOptionBits tag);
  IOOptionBits (__cdecl *getTag)(IOMemoryDescriptor *__hidden this);
  IOByteCount (__cdecl *readBytes)(IOMemoryDescriptor *__hidden this, IOByteCount offset, void *bytes, IOByteCount withLength);
  IOByteCount (__cdecl *writeBytes)(IOMemoryDescriptor *__hidden this, IOByteCount offset, const void *bytes, IOByteCount withLength);
  IOReturn (__cdecl *prepare)(IOGeneralMemoryDescriptor *__hidden this, IODirection forDirection);
  IOReturn (__cdecl *complete)(IOGeneralMemoryDescriptor *__hidden this, IODirection forDirection);
  IOMemoryMap *(__cdecl *map)(IOMemoryDescriptor *__hidden this, IOOptionBits options);
  IOMemoryMap *(__cdecl *setMapping)(IOMemoryDescriptor *__hidden this, task_t task, IOVirtualAddress mapAddress, IOOptionBits options);
  IOReturn (__cdecl *redirect)(IOMemoryDescriptor *__hidden this, task_t safeTask, bool redirect);
  IOMemoryMap *(__cdecl *makeMapping)(IOMemoryDescriptor *__hidden this, IOMemoryDescriptor *owner, task_t intoTask, IOVirtualAddress atAddress, IOOptionBits options, IOByteCount offset, IOByteCount length);
  void (__cdecl *addMapping)(IOMemoryDescriptor *__hidden this, IOMemoryMap *mapping);
  void (__cdecl *removeMapping)(IOMemoryDescriptor *__hidden this, IOMemoryMap *mapping);
  IOReturn (__cdecl *doMap)(IOGeneralMemoryDescriptor *__hidden this, vm_map_t addressMap, IOVirtualAddress *atAddress, IOOptionBits options, IOByteCount sourceOffset, IOByteCount length);
  IOReturn (__cdecl *doUnmap)(IOGeneralMemoryDescriptor *__hidden this, vm_map_t addressMap, IOVirtualAddress logical, IOByteCount length);
  bool (__cdecl *initWithPhysicalMask)(IOBufferMemoryDescriptor *__hidden this, task_t inTask, IOOptionBits options, mach_vm_size_t capacity, mach_vm_address_t alignment, mach_vm_address_t physicalMask);
  void (__cdecl *setLength)(IOBufferMemoryDescriptor *__hidden this, vm_size_t length);
  void (__cdecl *setDirection)(IOBufferMemoryDescriptor *__hidden this, IODirection direction);
  vm_size_t (__cdecl *getCapacity)(const IOBufferMemoryDescriptor *__hidden this);
  void *(__cdecl *getBytesNoCopy)(IOBufferMemoryDescriptor *__hidden this);
  void *(__cdecl *getBytesNoCopy_0)(IOBufferMemoryDescriptor *__hidden this, vm_size_t start, vm_size_t withLength);
  bool (__cdecl *appendBytes)(IOBufferMemoryDescriptor *__hidden this, const void *bytes, vm_size_t withLength);
  __int64 vcallOffset;
};

/* 384 */
struct IONVRAMController_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IONVRAMController)(IONVRAMController *__hidden this);
  void (__cdecl *~IONVRAMController_0)(IONVRAMController *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IONVRAMController *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IONVRAMController *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOService *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  void (__cdecl *sync)(IONVRAMController *__hidden this);
  IOReturn (__cdecl *read)(IONVRAMController *__hidden this, IOByteCount offset, UInt8 *buffer, IOByteCount length);
  IOReturn (__cdecl *write)(IONVRAMController *__hidden this, IOByteCount offset, UInt8 *buffer, IOByteCount length);
  __int64 vcallOffset;
};

/* 385 */
struct IOPMrootDomain_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOPMrootDomain)(IOPMrootDomain *__hidden this);
  void (__cdecl *~IOPMrootDomain_0)(IOPMrootDomain *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOPMrootDomain *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IOPMrootDomain *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOPMrootDomain *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IOPMrootDomain *__hidden this, OSObject *);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOPMrootDomain *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOPMrootDomain *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOPMrootDomain *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOPMrootDomain *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOPMrootDomain *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOPMrootDomain *__hidden this, IOPMPowerFlags, IOPowerConnection *, unsigned __int64);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOPMrootDomain *__hidden this, unsigned __int64, unsigned __int64);
  IOReturn (__cdecl *getAggressiveness)(IOPMrootDomain *__hidden this, unsigned __int64, unsigned __int64 *);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOPMrootDomain *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOPMrootDomain *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOPMrootDomain *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOPMrootDomain *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOPMrootDomain *__hidden this, unsigned __int64);
  IOReturn (__cdecl *sleepSystem)(IOPMrootDomain *__hidden this);
  IOReturn (__cdecl *receivePowerNotification)(IOPMrootDomain *__hidden this, UInt32 msg);
  void (__cdecl *setSleepSupported)(IOPMrootDomain *__hidden this, IOOptionBits flags);
  IOOptionBits (__cdecl *getSleepSupported)(IOPMrootDomain *__hidden this);
  IOReturn (__cdecl *changePowerStateTo)(IOPMrootDomain *__hidden this, unsigned __int64 ordinal);
  IOReturn (__cdecl *changePowerStateToPriv)(IOPMrootDomain *__hidden this, unsigned __int64 ordinal);
  __int64 vcallOffset;
};

/* 386 */
struct IOService_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~IOService)(IOService *__hidden this);
  void (__cdecl *~IOService_0)(IOService *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const IOService *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(IOService *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(IOService *__hidden this);
  OSObject *(__cdecl *copyProperty)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_1)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  IORegistryEntry *(__cdecl *copyParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *copyChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  IOReturn (__cdecl *runPropertyAction)(IORegistryEntry *__hidden this, IORegistryEntry::Action action, OSObject *target, void *arg0, void *arg1, void *arg2, void *arg3);
  bool (__cdecl *init_0)(IOService *__hidden this, OSDictionary *dictionary);
  void (__cdecl *setPropertyTable)(IORegistryEntry *__hidden this, OSDictionary *dict);
  bool (__cdecl *setProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_1)(IORegistryEntry *__hidden this, const char *aKey, OSObject *anObject);
  bool (__cdecl *setProperty_2)(IORegistryEntry *__hidden this, const char *aKey, const char *aString);
  bool (__cdecl *setProperty_3)(IORegistryEntry *__hidden this, const char *aKey, bool aBoolean);
  bool (__cdecl *setProperty_4)(IORegistryEntry *__hidden this, const char *aKey, unsigned __int64 aValue, unsigned int aNumberOfBits);
  bool (__cdecl *setProperty_5)(IORegistryEntry *__hidden this, const char *aKey, void *bytes, unsigned int length);
  void (__cdecl *removeProperty)(IORegistryEntry *__hidden this, const OSSymbol *aKey);
  void (__cdecl *removeProperty_0)(IORegistryEntry *__hidden this, const OSString *aKey);
  void (__cdecl *removeProperty_1)(IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *getProperty_0)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *getProperty_1)(const IORegistryEntry *__hidden this, const char *aKey);
  OSObject *(__cdecl *getProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *getProperty_4)(const IORegistryEntry *__hidden this, const char *aKey, const IORegistryPlane *plane, IOOptionBits options);
  OSObject *(__cdecl *copyProperty_2)(const IORegistryEntry *__hidden this, const OSSymbol *aKey);
  OSObject *(__cdecl *copyProperty_3)(const IORegistryEntry *__hidden this, const OSString *aKey);
  OSObject *(__cdecl *copyProperty_4)(const IORegistryEntry *__hidden this, const char *aKey);
  OSDictionary *(__cdecl *dictionaryWithProperties)(const IORegistryEntry *__hidden this);
  bool (__cdecl *serializeProperties)(const IOService *__hidden this, OSSerialize *s);
  IOReturn (__cdecl *setProperties)(IORegistryEntry *__hidden this, OSObject *properties);
  OSIterator *(__cdecl *getParentIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToParents)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getParentEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  OSIterator *(__cdecl *getChildIterator)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *applyToChildren)(const IORegistryEntry *__hidden this, IORegistryEntryApplierFunction applier, void *context, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *getChildEntry)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *isChild)(const IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane, bool onlyChild);
  bool (__cdecl *isParent)(const IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane, bool onlyParent);
  bool (__cdecl *inPlane)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  unsigned int (__cdecl *getDepth)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *attachToParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  void (__cdecl *detachFromParent)(IORegistryEntry *__hidden this, IORegistryEntry *parent, const IORegistryPlane *plane);
  bool (__cdecl *attachToChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachFromChild)(IORegistryEntry *__hidden this, IORegistryEntry *child, const IORegistryPlane *plane);
  void (__cdecl *detachAbove)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *detachAll)(IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const char *(__cdecl *getName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyName)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  bool (__cdecl *compareNames)(const IORegistryEntry *__hidden this, OSObject *name, OSString **matched);
  bool (__cdecl *compareName)(const IORegistryEntry *__hidden this, OSString *name, OSString **matched);
  void (__cdecl *setName)(IORegistryEntry *__hidden this, const OSSymbol *name, const IORegistryPlane *plane);
  void (__cdecl *setName_0)(IORegistryEntry *__hidden this, const char *name, const IORegistryPlane *plane);
  const char *(__cdecl *getLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  const OSSymbol *(__cdecl *copyLocation)(const IORegistryEntry *__hidden this, const IORegistryPlane *plane);
  void (__cdecl *setLocation)(IORegistryEntry *__hidden this, const OSSymbol *location, const IORegistryPlane *plane);
  void (__cdecl *setLocation_0)(IORegistryEntry *__hidden this, const char *location, const IORegistryPlane *plane);
  bool (__cdecl *getPath)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  bool (__cdecl *getPathComponent)(const IORegistryEntry *__hidden this, char *path, int *length, const IORegistryPlane *plane);
  IORegistryEntry *(__cdecl *childFromPath)(IORegistryEntry *__hidden this, const char *path, const IORegistryPlane *plane, char *residualPath, int *residualLength);
  bool (__cdecl *init_1)(IOService *__hidden this, IORegistryEntry *from, const IORegistryPlane *inPlane);
  bool (__cdecl *requestTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *willTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options);
  bool (__cdecl *didTerminate)(IOService *__hidden this, IOService *provider, IOOptionBits options, bool *defer);
  SInt32 (__cdecl *nextIdleTimeout)(IOService *__hidden this, AbsoluteTime currentTime, AbsoluteTime lastActivity, unsigned int powerState);
  void (__cdecl *systemWillShutdown)(IOService *__hidden this, IOOptionBits specifier);
  IOService *(__cdecl *copyClientWithCategory)(IOService *__hidden this, const OSSymbol *category);
  IOReturn (__cdecl *configureReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportConfigureAction action, void *result, void *destination);
  IOReturn (__cdecl *updateReport)(IOService *__hidden this, IOReportChannelList *channels, IOReportUpdateAction action, void *result, void *destination);
  IOOptionBits (__cdecl *getState)(const IOService *__hidden this);
  void (__cdecl *registerService)(IOService *__hidden this, IOOptionBits options);
  IOService *(__cdecl *probe)(IOService *__hidden this, IOService *provider, SInt32 *score);
  bool (__cdecl *start)(IOService *__hidden this, IOService *provider);
  void (__cdecl *stop)(IOService *__hidden this, IOService *provider);
  bool (__cdecl *open)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *close)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *isOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *handleOpen)(IOService *__hidden this, IOService *forClient, IOOptionBits options, void *arg);
  void (__cdecl *handleClose)(IOService *__hidden this, IOService *forClient, IOOptionBits options);
  bool (__cdecl *handleIsOpen)(const IOService *__hidden this, const IOService *forClient);
  bool (__cdecl *terminate)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *finalize)(IOService *__hidden this, IOOptionBits options);
  bool (__cdecl *lockForArbitration)(IOService *__hidden this, bool isSuccessRequired);
  void (__cdecl *unlockForArbitration)(IOService *__hidden this);
  bool (__cdecl *terminateClient)(IOService *__hidden this, IOService *client, IOOptionBits options);
  UInt32 (__cdecl *getBusyState)(IOService *__hidden this);
  void (__cdecl *adjustBusy)(IOService *__hidden this, SInt32 delta);
  bool (__cdecl *matchPropertyTable)(IOService *__hidden this, OSDictionary *table, SInt32 *score);
  bool (__cdecl *matchPropertyTable_0)(IOService *__hidden this, OSDictionary *table);
  IOService *(__cdecl *matchLocation)(IOService *__hidden this, IOService *client);
  bool (__cdecl *addNeededResource)(IOService *__hidden this, const char *key);
  bool (__cdecl *compareProperty)(IOService *__hidden this, OSDictionary *matching, const char *key);
  bool (__cdecl *compareProperty_0)(IOService *__hidden this, OSDictionary *matching, const OSString *key);
  bool (__cdecl *compareProperties)(IOService *__hidden this, OSDictionary *matching, OSCollection *keys);
  bool (__cdecl *attach)(IOService *__hidden this, IOService *provider);
  void (__cdecl *detach)(IOService *__hidden this, IOService *provider);
  IOService *(__cdecl *getProvider)(const IOService *__hidden this);
  IOWorkLoop *(__cdecl *getWorkLoop)(const IOService *__hidden this);
  OSIterator *(__cdecl *getProviderIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenProviderIterator)(const IOService *__hidden this);
  IOService *(__cdecl *getClient)(const IOService *__hidden this);
  OSIterator *(__cdecl *getClientIterator)(const IOService *__hidden this);
  OSIterator *(__cdecl *getOpenClientIterator)(const IOService *__hidden this);
  IOReturn (__cdecl *callPlatformFunction)(IOService *__hidden this, const OSSymbol *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *callPlatformFunction_0)(IOService *__hidden this, const char *functionName, bool waitForFunction, void *param1, void *param2, void *param3, void *param4);
  IOReturn (__cdecl *getResources)(IOService *__hidden this);
  IOItemCount (__cdecl *getDeviceMemoryCount)(IOService *__hidden this);
  IODeviceMemory *(__cdecl *getDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index);
  IOMemoryMap *(__cdecl *mapDeviceMemoryWithIndex)(IOService *__hidden this, unsigned int index, IOOptionBits options);
  OSArray *(__cdecl *getDeviceMemory)(IOService *__hidden this);
  void (__cdecl *setDeviceMemory)(IOService *__hidden this, OSArray *array);
  IOReturn (__cdecl *registerInterrupt)(IOService *__hidden this, int source, OSObject *target, IOInterruptAction handler, void *refCon);
  IOReturn (__cdecl *unregisterInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *getInterruptType)(IOService *__hidden this, int source, int *interruptType);
  IOReturn (__cdecl *enableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *disableInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *causeInterrupt)(IOService *__hidden this, int source);
  IOReturn (__cdecl *requestProbe)(IOService *__hidden this, IOOptionBits options);
  IOReturn (__cdecl *message)(IOService *__hidden this, UInt32 type, IOService *provider, void *argument);
  IOReturn (__cdecl *messageClient)(IOService *__hidden this, UInt32 messageType, OSObject *client, void *messageArgument, vm_size_t argSize);
  IOReturn (__cdecl *messageClients)(IOService *__hidden this, UInt32 type, void *argument, vm_size_t argSize);
  IONotifier *(__cdecl *registerInterest)(IOService *__hidden this, const OSSymbol *typeOfInterest, IOServiceInterestHandler handler, void *target, void *ref);
  void (__cdecl *applyToProviders)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToClients)(IOService *__hidden this, IOServiceApplierFunction applier, void *context);
  void (__cdecl *applyToInterested)(IOService *__hidden this, const OSSymbol *typeOfInterest, OSObjectApplierFunction applier, void *context);
  IOReturn (__cdecl *acknowledgeNotification)(IOService *__hidden this, IONotificationRef notification, IOOptionBits response);
  IOReturn (__cdecl *newUserClient)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, OSDictionary *properties, IOUserClient **handler);
  IOReturn (__cdecl *newUserClient_0)(IOService *__hidden this, task_t owningTask, void *securityID, UInt32 type, IOUserClient **handler);
  const char *(__cdecl *stringFromReturn)(IOService *__hidden this, IOReturn rtn);
  int (__cdecl *errnoFromReturn)(IOService *__hidden this, IOReturn rtn);
  void (__cdecl *PMinit)(IOService *__hidden this);
  void (__cdecl *PMstop)(IOService *__hidden this);
  void (__cdecl *joinPMtree)(IOService *__hidden this, IOService *driver);
  IOReturn (__cdecl *registerPowerDriver)(IOService *__hidden this, IOService *controllingDriver, IOPMPowerState *powerStates, unsigned __int64 numberOfStates);
  IOReturn (__cdecl *requestPowerDomainState)(IOService *__hidden this, IOPMPowerFlags desiredState, IOPowerConnection *whichChild, unsigned __int64 specificationFlags);
  bool (__cdecl *activityTickle)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 stateNumber);
  IOReturn (__cdecl *setAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 newLevel);
  IOReturn (__cdecl *getAggressiveness)(IOService *__hidden this, unsigned __int64 type, unsigned __int64 *currentLevel);
  IOReturn (__cdecl *addPowerChild)(IOService *__hidden this, IOService *theChild);
  IOReturn (__cdecl *removePowerChild)(IOService *__hidden this, IOPowerConnection *theChild);
  IOReturn (__cdecl *setIdleTimerPeriod)(IOService *__hidden this, unsigned __int64 period);
  IOReturn (__cdecl *setPowerState)(IOService *__hidden this, unsigned __int64 powerStateOrdinal, IOService *whatDevice);
  unsigned __int64 (__cdecl *maxCapabilityForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *initialPowerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  unsigned __int64 (__cdecl *powerStateForDomainState)(IOService *__hidden this, IOPMPowerFlags domainState);
  IOReturn (__cdecl *powerStateWillChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  IOReturn (__cdecl *powerStateDidChangeTo)(IOService *__hidden this, IOPMPowerFlags capabilities, unsigned __int64 stateNumber, IOService *whatDevice);
  bool (__cdecl *askChangeDown)(IOService *__hidden this, unsigned __int64);
  bool (__cdecl *tellChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellNoChangeDown)(IOService *__hidden this, unsigned __int64);
  void (__cdecl *tellChangeUp)(IOService *__hidden this, unsigned __int64);
  IOReturn (__cdecl *allowPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  IOReturn (__cdecl *cancelPowerChange)(IOService *__hidden this, unsigned __int64 refcon);
  void (__cdecl *powerChangeDone)(IOService *__hidden this, unsigned __int64 stateNumber);
  __int64 vcallOffset;
};

/* 387 */
struct OSObject_vtbl_layout
{
  __int64 thisOffset;
  void *rtti;
  void (__cdecl *~OSObject)(OSObject *__hidden this);
  void (__cdecl *~OSObject_0)(OSObject *__hidden this);
  void (__cdecl *release)(const OSObject *__hidden this, int freeWhen);
  int (__cdecl *getRetainCount)(const OSObject *__hidden this);
  void (__cdecl *retain)(const OSObject *__hidden this);
  void (__cdecl *release_0)(const OSObject *__hidden this);
  bool (__cdecl *serialize)(const OSObject *__hidden this, OSSerialize *serializer);
  const OSMetaClass *(__cdecl *getMetaClass)(const OSObject *__hidden this);
  bool (__cdecl *isEqualTo)(const OSMetaClassBase *__hidden this, const OSMetaClassBase *anObject);
  void (__cdecl *taggedRetain)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease)(const OSObject *__hidden this, const void *tag);
  void (__cdecl *taggedRelease_0)(const OSObject *__hidden this, const void *tag, const int freeWhen);
  kern_return_t (__cdecl *Dispatch)(OSObject *__hidden this, const IORPC rpc);
  bool (__cdecl *init)(OSObject *__hidden this);
  void (__cdecl *free)(OSObject *__hidden this);
  __int64 vcallOffset;
};

/* 388 */
typedef PE_state PE_state_t;

/* 389 */
struct PE_state
{
  boolean_t initialized;
  PE_Video video;
  void *deviceTreeHead;
  void *bootArgs;
  vm_size_t deviceTreeSize;
};

/* 390 */
struct NDR_record_t
{
  unsigned __int8 mig_vers;
  unsigned __int8 if_vers;
  unsigned __int8 reserved1;
  unsigned __int8 mig_encoding;
  unsigned __int8 int_rep;
  unsigned __int8 char_rep;
  unsigned __int8 float_rep;
  unsigned __int8 reserved2;
};

/* 391 */
#pragma pack(push, 8)
struct lowglo
{
  unsigned __int8 lgVerCode[8];
  uint64_t lgZero;
  uint64_t lgStext;
  uint64_t lgVersion;
  uint64_t lgOSVersion;
  uint64_t lgKmodptr;
  uint64_t lgTransOff;
  uint64_t lgRebootFlag;
  uint64_t lgManualPktAddr;
  uint64_t lgAltDebugger;
  uint64_t lgPmapMemQ;
  uint64_t lgPmapMemPageOffset;
  uint64_t lgPmapMemChainOffset;
  uint64_t lgStaticAddr;
  uint64_t lgStaticSize;
  uint64_t lgLayoutMajorVersion;
  uint64_t lgLayoutMagic;
  uint64_t lgPmapMemStartAddr;
  uint64_t lgPmapMemEndAddr;
  uint64_t lgPmapMemPagesize;
  uint64_t lgPmapMemFromArrayMask;
  uint64_t lgPmapMemFirstppnum;
  uint64_t lgPmapMemPackedShift;
  uint64_t lgPmapMemPackedBaseAddr;
  uint64_t lgLayoutMinorVersion;
  uint64_t lgPageShift;
  uint64_t lgVmFirstPhys;
  uint64_t lgVmLastPhys;
  uint64_t lgPhysMapBase;
  uint64_t lgPhysMapEnd;
  uint64_t lgPmapIoRangePtr;
  uint64_t lgNumPmapIoRanges;
};
#pragma pack(pop)

/* 392 */
enum vtype : unsigned __int32
{
  VNON = 0x0,
  VREG = 0x1,
  VDIR = 0x2,
  VBLK = 0x3,
  VCHR = 0x4,
  VLNK = 0x5,
  VSOCK = 0x6,
  VFIFO = 0x7,
  VBAD = 0x8,
  VSTR = 0x9,
  VCPLX = 0xA,
};

/* 393 */
struct msginfo
{
  int msgmax;
  int msgmni;
  int msgmnb;
  int msgtql;
  int msgssz;
  int msgseg;
};

/* 394 */
union guid_t
{
  unsigned __int8 g_guid[16];
  unsigned int g_guid_asint[4];
};

/* 395 */
struct clock_frequency_info_t
{
  unsigned __int64 bus_clock_rate_hz;
  unsigned __int64 cpu_clock_rate_hz;
  unsigned __int64 dec_clock_rate_hz;
  unsigned __int64 bus_clock_rate_num;
  unsigned __int64 bus_clock_rate_den;
  unsigned __int64 bus_to_cpu_rate_num;
  unsigned __int64 bus_to_cpu_rate_den;
  unsigned __int64 bus_to_dec_rate_num;
  unsigned __int64 bus_to_dec_rate_den;
  unsigned __int64 timebase_frequency_hz;
  unsigned __int64 timebase_frequency_num;
  unsigned __int64 timebase_frequency_den;
  unsigned __int64 bus_frequency_hz;
  unsigned __int64 bus_frequency_min_hz;
  unsigned __int64 bus_frequency_max_hz;
  unsigned __int64 cpu_frequency_hz;
  unsigned __int64 cpu_frequency_min_hz;
  unsigned __int64 cpu_frequency_max_hz;
  unsigned __int64 prf_frequency_hz;
  unsigned __int64 prf_frequency_min_hz;
  unsigned __int64 prf_frequency_max_hz;
  unsigned __int64 mem_frequency_hz;
  unsigned __int64 mem_frequency_min_hz;
  unsigned __int64 mem_frequency_max_hz;
  unsigned __int64 fix_frequency_hz;
};

/* 396 */
struct __attribute__((aligned(8))) section_64
{
  char sectname[16];
  char segname[16];
  uint64_t addr;
  uint64_t size;
  uint32_t offset;
  uint32_t align;
  uint32_t reloff;
  uint32_t nreloc;
  uint32_t flags;
  uint32_t reserved1;
  uint32_t reserved2;
  uint32_t reserved3;
};

/* 397 */
struct linkedit_data_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint32_t dataoff;
  uint32_t datasize;
};

/* 398 */
struct symtab_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint32_t symoff;
  uint32_t nsyms;
  uint32_t stroff;
  uint32_t strsize;
};

/* 399 */
struct dysymtab_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint32_t ilocalsym;
  uint32_t nlocalsym;
  uint32_t iextdefsym;
  uint32_t nextdefsym;
  uint32_t iundefsym;
  uint32_t nundefsym;
  uint32_t tocoff;
  uint32_t ntoc;
  uint32_t modtaboff;
  uint32_t nmodtab;
  uint32_t extrefsymoff;
  uint32_t nextrefsyms;
  uint32_t indirectsymoff;
  uint32_t nindirectsyms;
  uint32_t extreloff;
  uint32_t nextrel;
  uint32_t locreloff;
  uint32_t nlocrel;
};

/* 400 */
struct uuid_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint8_t uuid[16];
};

/* 401 */
struct build_version_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint32_t platform;
  uint32_t minos;
  uint32_t sdk;
  uint32_t ntools;
};

/* 402 */
struct source_version_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint64_t version;
};

/* 403 */
union __attribute__((aligned(8))) __n64
{
  unsigned __int64 n64_u64[1];
  unsigned __int32 n64_u32[2];
  unsigned __int16 n64_u16[4];
  unsigned __int8 n64_u8[8];
  __int64 n64_i64[1];
  __int32 n64_i32[2];
  __int16 n64_i16[4];
  __int8 n64_i8[8];
  float n64_f32[2];
  double n64_f64[1];
};

/* 404 */
union __attribute__((aligned(8))) __n128
{
  unsigned __int64 n128_u64[2];
  unsigned __int32 n128_u32[4];
  unsigned __int16 n128_u16[8];
  unsigned __int8 n128_u8[16];
  __int64 n128_i64[2];
  __int32 n128_i32[4];
  __int16 n128_i16[8];
  __int8 n128_i8[16];
  float n128_f32[4];
  double n128_f64[2];
};

/* 405 */
typedef int16x4_t int16x2_t;

/* 410 */
union __attribute__((aligned(8))) int16x4_t
{
  __int8 i8[8];
  __int16 i16[4];
  __int32 i32[2];
  unsigned __int8 u8[8];
  unsigned __int16 u16[4];
  unsigned __int32 u32[2];
};

/* 406 */
typedef uint16x4_t uint16x2_t;

/* 412 */
union __attribute__((aligned(8))) uint16x4_t
{
  __int8 i8[8];
  __int16 i16[4];
  __int32 i32[2];
  unsigned __int8 u8[8];
  unsigned __int16 u16[4];
  unsigned __int32 u32[2];
};

/* 407 */
typedef float16x4_t float16x2_t;

/* 426 */
union __attribute__((aligned(8))) float16x4_t
{
  __int8 i8[8];
  __int16 i16[4];
  __int32 i32[2];
  unsigned __int8 u8[8];
  unsigned __int16 u16[4];
  unsigned __int32 u32[2];
};

/* 408 */
union __attribute__((aligned(8))) int8x8_t
{
  __int8 i8[8];
  __int16 i16[4];
  __int32 i32[2];
  unsigned __int8 u8[8];
  unsigned __int16 u16[4];
  unsigned __int32 u32[2];
};

/* 409 */
union __attribute__((aligned(8))) uint8x8_t
{
  __int8 i8[8];
  __int16 i16[4];
  __int32 i32[2];
  unsigned __int8 u8[8];
  unsigned __int16 u16[4];
  unsigned __int32 u32[2];
};

/* 411 */
union __attribute__((aligned(8))) int32x2_t
{
  __int8 i8[8];
  __int16 i16[4];
  __int32 i32[2];
  unsigned __int8 u8[8];
  unsigned __int16 u16[4];
  unsigned __int32 u32[2];
};

/* 413 */
union __attribute__((aligned(8))) uint32x2_t
{
  __int8 i8[8];
  __int16 i16[4];
  __int32 i32[2];
  unsigned __int8 u8[8];
  unsigned __int16 u16[4];
  unsigned __int32 u32[2];
};

/* 414 */
union __attribute__((aligned(16))) int8x16_t
{
  __int8 i8[16];
  __int16 i16[8];
  __int32 i32[4];
  __int64 i64[2];
  unsigned __int8 u8[16];
  unsigned __int16 u16[8];
  unsigned __int32 u32[4];
  unsigned __int64 u64[2];
};

/* 415 */
union __attribute__((aligned(16))) int16x8_t
{
  __int8 i8[16];
  __int16 i16[8];
  __int32 i32[4];
  __int64 i64[2];
  unsigned __int8 u8[16];
  unsigned __int16 u16[8];
  unsigned __int32 u32[4];
  unsigned __int64 u64[2];
};

/* 416 */
union __attribute__((aligned(16))) int32x4_t
{
  __int8 i8[16];
  __int16 i16[8];
  __int32 i32[4];
  __int64 i64[2];
  unsigned __int8 u8[16];
  unsigned __int16 u16[8];
  unsigned __int32 u32[4];
  unsigned __int64 u64[2];
};

/* 417 */
union __attribute__((aligned(16))) int64x2_t
{
  __int8 i8[16];
  __int16 i16[8];
  __int32 i32[4];
  __int64 i64[2];
  unsigned __int8 u8[16];
  unsigned __int16 u16[8];
  unsigned __int32 u32[4];
  unsigned __int64 u64[2];
};

/* 418 */
union __attribute__((aligned(16))) uint8x16_t
{
  __int8 i8[16];
  __int16 i16[8];
  __int32 i32[4];
  __int64 i64[2];
  unsigned __int8 u8[16];
  unsigned __int16 u16[8];
  unsigned __int32 u32[4];
  unsigned __int64 u64[2];
};

/* 419 */
union __attribute__((aligned(16))) uint16x8_t
{
  __int8 i8[16];
  __int16 i16[8];
  __int32 i32[4];
  __int64 i64[2];
  unsigned __int8 u8[16];
  unsigned __int16 u16[8];
  unsigned __int32 u32[4];
  unsigned __int64 u64[2];
};

/* 420 */
union __attribute__((aligned(16))) uint32x4_t
{
  __int8 i8[16];
  __int16 i16[8];
  __int32 i32[4];
  __int64 i64[2];
  unsigned __int8 u8[16];
  unsigned __int16 u16[8];
  unsigned __int32 u32[4];
  unsigned __int64 u64[2];
};

/* 421 */
union __attribute__((aligned(16))) uint64x2_t
{
  __int8 i8[16];
  __int16 i16[8];
  __int32 i32[4];
  __int64 i64[2];
  unsigned __int8 u8[16];
  unsigned __int16 u16[8];
  unsigned __int32 u32[4];
  unsigned __int64 u64[2];
};

/* 422 */
union __attribute__((aligned(8))) poly8x8_t
{
  __int8 i8[8];
  __int16 i16[4];
  __int32 i32[2];
  unsigned __int8 u8[8];
  unsigned __int16 u16[4];
  unsigned __int32 u32[2];
};

/* 423 */
union __attribute__((aligned(8))) poly16x4_t
{
  __int8 i8[8];
  __int16 i16[4];
  __int32 i32[2];
  unsigned __int8 u8[8];
  unsigned __int16 u16[4];
  unsigned __int32 u32[2];
};

/* 424 */
union __attribute__((aligned(16))) poly16x8_t
{
  __int8 i8[16];
  __int16 i16[8];
  __int32 i32[4];
  __int64 i64[2];
  unsigned __int8 u8[16];
  unsigned __int16 u16[8];
  unsigned __int32 u32[4];
  unsigned __int64 u64[2];
};

/* 425 */
union __attribute__((aligned(16))) poly8x16_t
{
  __int8 i8[16];
  __int16 i16[8];
  __int32 i32[4];
  __int64 i64[2];
  unsigned __int8 u8[16];
  unsigned __int16 u16[8];
  unsigned __int32 u32[4];
  unsigned __int64 u64[2];
};

/* 428 */
typedef float float32_t;

/* 427 */
union __attribute__((aligned(8))) float32x2_t
{
  float32_t f32[2];
  __int8 i8[8];
  __int16 i16[4];
  __int32 i32[2];
  unsigned __int8 u8[8];
  unsigned __int16 u16[4];
  unsigned __int32 u32[2];
};

/* 429 */
union __attribute__((aligned(16))) float16x8_t
{
  __int8 i8[16];
  __int16 i16[8];
  __int32 i32[4];
  __int64 i64[2];
  unsigned __int8 u8[16];
  unsigned __int16 u16[8];
  unsigned __int32 u32[4];
  unsigned __int64 u64[2];
};

/* 430 */
union __attribute__((aligned(16))) float32x4_t
{
  float32_t f32[4];
  __int8 i8[16];
  __int16 i16[8];
  __int32 i32[4];
  __int64 i64[2];
  unsigned __int8 u8[16];
  unsigned __int16 u16[8];
  unsigned __int32 u32[4];
  unsigned __int64 u64[2];
};

/* 432 */
typedef double float64_t;

/* 431 */
union __attribute__((aligned(16))) float64x2_t
{
  float64_t f64[2];
};

/* 434 */
typedef unsigned __int128 __uint128_t;

/* 433 */
typedef __uint128_t poly128_t;

/* 435 */
typedef dispatch_gate_s *dispatch_gate_t;

/* 450 */
typedef uint32_t dispatch_lock;

/* 451 */
struct dispatch_gate_s
{
  dispatch_lock dgl_lock;
};

/* 436 */
typedef firehose_push_reply_s firehose_push_reply_t;

/* 7241 */
struct firehose_push_reply_s
{
  uint64_t fpr_mem_flushed_pos;
  uint64_t fpr_io_flushed_pos;
};

/* 437 */
typedef __int64 long;

/* 438 */
typedef firehose_chunk_s *firehose_chunk_t;

/* 445 */
union firehose_chunk_pos_u
{
  volatile uint64_t fcp_atomic_pos;
  uint64_t fcp_pos;
  struct __attribute__((aligned(2)))
  {
    uint16_t fcp_next_entry_offs;
    uint16_t fcp_private_offs;
    uint8_t fcp_refcnt;
    uint8_t fcp_qos;
    uint8_t fcp_stream;
  };
};

/* 446 */
struct firehose_chunk_s
{
  union
  {
    uint8_t fc_start[4096];
    struct
    {
      firehose_chunk_pos_u fc_pos;
      uint64_t fc_timestamp;
      uint8_t fc_data[4080];
    };
  };
};

/* 439 */
struct __attribute__((aligned(4))) firehose_tracepoint_query_s
{
  uint64_t stamp;
  uint16_t pubsize;
  uint16_t privsize;
  _BYTE gapC;
  bool is_bank_ok;
};

/* 440 */
typedef firehose_tracepoint_query_s *firehose_tracepoint_query_t;

/* 441 */
typedef uint8_t firehose_tracepoint_type_t;

/* 444 */
typedef uint64_t firehose_tracepoint_id_t;

/* 442 */
union firehose_tracepoint_id_u
{
  struct
  {
    _BYTE gap0;
    firehose_tracepoint_type_t _type;
    uint32_t _code;
  } ftid;
  firehose_tracepoint_id_t ftid_value;
  volatile firehose_tracepoint_id_t ftid_atomic_value;
};

/* 443 */
struct firehose_tracepoint_s
{
  firehose_tracepoint_id_u ft_id;
  uint64_t ft_thread;
  union
  {
    struct
    {
      _BYTE gap0[8];
    };
    uint64_t ft_stamp_and_length;
    volatile uint64_t ft_atomic_stamp_and_length;
  };
  uint8_t ft_data[];
};

/* 447 */
typedef struct ipc_port *ipc_port_t_0;

/* 448 */
typedef int __int32_t;

/* 449 */
typedef __int32_t __darwin_pid_t;

/* 454 */
typedef uint8_t firehose_chunk_ref_t;

/* 452 */
union firehose_stream_state_u
{
  uint64_t fss_atomic_state;
  dispatch_gate_s fss_gate;
  struct
  {
    uint32_t fss_allocator;
    firehose_chunk_ref_t fss_current;
    uint16_t fss_generation;
  };
};

/* 453 */
struct __attribute__((aligned(128))) firehose_buffer_stream_s
{
  firehose_stream_state_u fbs_state;
  uint64_t fbs_loss_start;
};

/* 455 */
union firehose_bank_state_u
{
  uint64_t fbs_atomic_state;
  struct
  {
    union
    {
      struct
      {
        uint16_t fbs_mem_bank;
        uint16_t fbs_io_bank;
      };
      uint16_t fbs_banks[2];
    };
    firehose_chunk_ref_t fbs_max_ref;
    uint8_t fbs_unused1;
    uint16_t fbs_unused2;
  };
};

/* 456 */
union firehose_ring_tail_u
{
  uint64_t frp_atomic_tail;
  struct
  {
    uint16_t frp_mem_tail;
    uint16_t frp_mem_flushed;
    uint16_t frp_io_tail;
    uint16_t frp_io_flushed;
  };
};

/* 457 */
typedef ipc_port_t_0 mach_port_t_0;

/* 458 */
typedef __darwin_pid_t pid_t;

/* 459 */
struct __attribute__((aligned(64))) firehose_buffer_bank_s
{
  volatile firehose_bank_state_u fbb_state;
  volatile uint64_t fbb_metadata_bitmap;
  volatile uint64_t fbb_mem_flushed;
  volatile uint64_t fbb_mem_notifs;
  volatile uint64_t fbb_mem_sync_pushes;
  volatile uint64_t fbb_io_flushed;
  volatile uint64_t fbb_io_notifs;
  volatile uint64_t fbb_io_sync_pushes;
  volatile unsigned __int64 fbb_flags;
  uint64_t fbb_bitmap;
  firehose_bank_state_u fbb_limits;
  uint32_t _fbb_unused;
};

/* 460 */
struct __attribute__((aligned(4096))) firehose_buffer_header_s
{
  volatile uint16_t fbh_mem_ring[64];
  volatile uint16_t fbh_io_ring[64];
  volatile firehose_ring_tail_u fbh_ring_tail;
  uint32_t fbh_spi_version;
  __attribute__((aligned(64))) volatile uint16_t fbh_ring_mem_head;
  __attribute__((aligned(64))) volatile uint16_t fbh_ring_io_head;
  firehose_buffer_bank_s fbh_bank;
  firehose_buffer_stream_s fbh_stream[7];
  uint64_t fbh_uniquepid;
  pid_t fbh_pid;
  mach_port_t_0 fbh_logd_port;
  volatile mach_port_t_0 fbh_sendp[2];
  mach_port_t_0 fbh_recvp;
};

/* 461 */
union firehose_buffer_u
{
  firehose_buffer_header_s fb_header;
  firehose_chunk_s fb_chunks[64];
};

/* 462 */
typedef ccchacha20poly1305_ctx chacha20poly1305_ctx;

/* 9184 */
struct ccchacha20_ctx_0
{
  uint32_t state[16];
  uint8_t buffer[64];
  size_t leftover;
};

/* 9183 */
struct ccpoly1305_ctx_0
{
  uint32_t r0;
  uint32_t r1;
  uint32_t r2;
  uint32_t r3;
  uint32_t r4;
  uint32_t s1;
  uint32_t s2;
  uint32_t s3;
  uint32_t s4;
  uint32_t h0;
  uint32_t h1;
  uint32_t h2;
  uint32_t h3;
  uint32_t h4;
  uint8_t buf[16];
  size_t buf_used;
  uint8_t key[16];
};

/* 465 */
struct __attribute__((aligned(8))) ccchacha20poly1305_ctx
{
  ccchacha20_ctx_0 chacha20_ctx;
  ccpoly1305_ctx_0 poly1305_ctx;
  uint64_t aad_nbytes;
  uint64_t text_nbytes;
  uint8_t state;
};

/* 463 */
struct ccpoly1305_ctx
{
  uint32_t r0;
  uint32_t r1;
  uint32_t r2;
  uint32_t r3;
  uint32_t r4;
  uint32_t s1;
  uint32_t s2;
  uint32_t s3;
  uint32_t s4;
  uint32_t h0;
  uint32_t h1;
  uint32_t h2;
  uint32_t h3;
  uint32_t h4;
  uint8_t buf[16];
  size_t buf_used;
  uint8_t key[16];
};

/* 464 */
struct ccchacha20_ctx
{
  uint32_t state[16];
  uint8_t buffer[64];
  size_t leftover;
};

/* 466 */
struct ccchacha20poly1305_info
{
};

/* 467 */
struct ccchacha20poly1305_fns
{
  const ccchacha20poly1305_info *(*info)(void);
  int (*init)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, const uint8_t *);
  int (*reset)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *);
  int (*setnonce)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, const uint8_t *);
  int (*incnonce)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, uint8_t *);
  int (*aad)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, size_t, const void *);
  int (*encrypt)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, size_t, const void *, void *);
  int (*finalize)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, uint8_t *);
  int (*decrypt)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, size_t, const void *, void *);
  int (*verify)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, const uint8_t *);
};

/* 468 */
struct au_mask
{
  unsigned int am_success;
  unsigned int am_failure;
};

/* 469 */
typedef au_tid_addr au_tid_addr_t;

/* 5621 */
typedef __int32_t __darwin_dev_t;

/* 2349 */
typedef __darwin_dev_t dev_t;

/* 4177 */
struct au_tid_addr
{
  dev_t at_port;
  u_int32_t at_type;
  u_int32_t at_addr[4];
};

/* 470 */
typedef au_mask au_mask_t;

/* 471 */
typedef auditinfo_addr auditinfo_addr_t;

/* 5622 */
typedef __uint32_t __darwin_uid_t;

/* 2354 */
typedef __darwin_uid_t uid_t;

/* 2352 */
typedef uid_t au_id_t;

/* 2351 */
typedef pid_t au_asid_t;

/* 2350 */
typedef u_int64_t au_asflgs_t;

/* 4165 */
struct auditinfo_addr
{
  au_id_t ai_auid;
  au_mask_t ai_mask;
  au_tid_addr_t ai_termid;
  au_asid_t ai_asid;
  au_asflgs_t ai_flags;
};

/* 472 */
struct au_session
{
  auditinfo_addr_t *as_aia_p;
  au_mask_t as_mask;
};

/* 2355 */
typedef unsigned __int16 u_short;

/* 7756 */
typedef __uint32_t __darwin_gid_t;

/* 2353 */
typedef __darwin_gid_t gid_t;

/* 473 */
struct posix_cred
{
  uid_t cr_uid;
  uid_t cr_ruid;
  uid_t cr_svuid;
  u_short cr_ngroups;
  u_short __cr_padding;
  gid_t cr_groups[16];
  gid_t cr_rgid;
  gid_t cr_svgid;
  uid_t cr_gmuid;
  int cr_flags;
};

/* 2357 */
typedef unsigned __int64 u_long;

/* 474 */
struct ucred
{
  ucred_rw *cr_rw;
  void *cr_unused;
  u_long cr_ref;
  posix_cred cr_posix;
  __attribute__((aligned(16))) au_session cr_audit;
};

/* 11823 */
struct ucred_rw::$437D89FB471DF8CBAD6BCEC2C74858C8
{
  ucred_rw *le_next;
  ucred_rw **le_prev;
};

/* 7668 */
typedef uint32_t os_ref_count_t;

/* 2580 */
typedef os_ref_count_t os_ref_atomic_t;

/* 3026 */
struct os_refcnt
{
  os_ref_atomic_t ref_count;
};

/* 489 */
typedef os_refcnt os_refcnt_t;

/* 1132 */
struct __attribute__((aligned(8))) ucred_rw
{
  struct ucred_rw::$437D89FB471DF8CBAD6BCEC2C74858C8 crw_link;
  ucred *crw_cred;
  os_refcnt_t crw_weak_ref;
};

/* 475 */
typedef ucred *kauth_cred_t;

/* 476 */
struct ccgcm_ctx
{
  uint8_t b[16];
};

/* 477 */
struct ccmode_gcm
{
  size_t size;
  int encdec;
  size_t block_size;
  _BYTE gap18[48];
  const void *custom;
};

/* 481 */
struct cccbc_ctx
{
  uint8_t b[16];
};

/* 478 */
struct aes_decrypt_ctx
{
  cccbc_ctx ctx[18];
};

/* 479 */
struct cccbc_iv
{
  uint8_t b[16];
};

/* 480 */
struct ccmode_cbc
{
  size_t size;
  size_t block_size;
  _BYTE gap10[16];
  const void *custom;
};

/* 482 */
struct aes_encrypt_ctx
{
  cccbc_ctx ctx[18];
};

/* 7243 */
typedef char *__builtin_va_list;

/* 483 */
typedef __builtin_va_list va_list;

/* 484 */
struct ppl_iommu_seg_iter
{
  size_t seg_index;
  size_t seg_offset;
  uintptr_t refcon;
};

/* 1198 */
typedef uint64_t pmap_paddr_t;

/* 485 */
struct ppl_iommu_seg
{
  vm_address_t iova;
  pmap_paddr_t paddr;
  size_t nbytes;
  vm_prot_t prot;
  uintptr_t refcon;
};

/* 486 */
struct ppl_iommu_state
{
  const ppl_iommu_desc *desc;
  const char *name;
  uintptr_t secure_id;
};

/* 5530 */
typedef vm_offset_t vm_address_t_0;

/* 487 */
struct ppl_iommu_desc
{
  const char *name;
  const uintptr_t magic;
  bool dynamic_state;
  kern_return_t (*init)(const ppl_iommu_desc *, const char *, const void *, size_t, ppl_iommu_state **, uint32_t *);
  kern_return_t (*iovmalloc)(ppl_iommu_state *, vm_address_t_0, size_t, uintptr_t, uintptr_t *, uint32_t *);
  kern_return_t (*map)(ppl_iommu_state *, const ppl_iommu_seg_0 *, size_t, uintptr_t, ppl_iommu_seg_iter *, uintptr_t *, uint32_t *);
  kern_return_t (*unmap)(ppl_iommu_state *, const ppl_iommu_seg *, size_t, uintptr_t, ppl_iommu_seg_iter *, uintptr_t *);
  void (*iovmfree)(ppl_iommu_state *, vm_address_t_0, size_t, uintptr_t, uintptr_t *);
  kern_return_t (*ioctl)(ppl_iommu_state *, uintptr_t, const void *, size_t, void *, size_t);
};

/* 9149 */
struct ppl_iommu_seg_0
{
  vm_address_t_0 iova;
  pmap_paddr_t paddr;
  size_t nbytes;
  vm_prot_t prot;
  uintptr_t refcon;
};

/* 7010 */
typedef int64_t ledger_amount_t;

/* 488 */
struct ledger_entry_small
{
  volatile uint32_t les_flags;
  volatile ledger_amount_t les_credit;
};

/* 490 */
struct ledger
{
  uint64_t l_id;
  os_refcnt_t l_refs;
  int32_t l_size;
  ledger_template *l_template;
  ledger_entry_small l_entries[];
};

/* 8201 */
union lck_mtx_state
{
  struct
  {
    _BYTE gap0[4];
    uint16_t ilk_tail;
    uint16_t as_tail;
  };
  uint32_t data;
  uint64_t val;
};

/* 5670 */
typedef lck_mtx_state lck_mtx_state_t;

/* 6743 */
struct _lck_mtx_
{
  _BYTE gap0[3];
  uint8_t lck_mtx_type;
  uint32_t lck_mtx_grp;
  lck_mtx_state_t lck_mtx;
};

/* 8202 */
typedef _lck_mtx_ lck_mtx_t_0;

/* 2282 */
typedef zone *zone_t;

/* 6761 */
struct ledger_template
{
  const char *lt_name;
  int lt_refs;
  volatile uint32_t lt_inuse;
  lck_mtx_t_0 lt_lock;
  zone_t lt_zone;
  bool lt_initialized;
  uint16_t lt_next_offset;
  uint16_t lt_cnt;
  uint16_t lt_table_size;
  entry_template *lt_entries;
  uint16_t *lt_entries_lut;
};

/* 2280 */
typedef zone_stats *zone_stats_t;

/* 6525 */
typedef zone_magazine *zone_magazine_t;

/* 5834 */
struct zone_depot
{
  uint32_t zd_full;
  uint32_t zd_empty;
  zone_magazine_t zd_head;
  zone_magazine_t *zd_tail;
};

/* 11824 */
struct hw_lck_ticket_t::$::$28F7DFA11181930270CE585751F7D878::$35A5A89059E359E36A582F531262779D
{
  uint8_t cticket;
  uint8_t nticket;
};

/* 11825 */
union hw_lck_ticket_t::$053955A6F0316B7A8F7C3BF2A32F4CA5::$28F7DFA11181930270CE585751F7D878
{
  struct
  {
    uint8_t cticket;
    uint8_t nticket;
  };
  uint16_t tcurnext;
};

/* 11826 */
struct hw_lck_ticket_t::$053955A6F0316B7A8F7C3BF2A32F4CA5
{
  uint8_t lck_type;
  union
  {
    struct
    {
      uint8_t cticket;
      uint8_t nticket;
    };
    uint16_t tcurnext;
  };
};

/* 5689 */
union hw_lck_ticket_t
{
  struct
  {
    uint8_t lck_type;
    union
    {
      struct
      {
        uint8_t cticket;
        uint8_t nticket;
      };
      uint16_t tcurnext;
    };
  };
  uint32_t lck_value;
};

/* 8246 */
struct zone_packed_virtual_address
{
  uint32_t packed_address;
};

/* 5833 */
typedef zone_packed_virtual_address zone_pva_t;

/* 2281 */
struct zone
{
  zone *z_self;
  zone_stats_t z_stats;
  const char *z_name;
  zone_view *z_views;
  zone_expand *z_expander;
  uint64_t z_quo_magic;
  uint32_t z_align_magic;
  uint16_t z_elem_size;
  uint16_t z_elem_offs;
  uint16_t z_chunk_pages;
  uint16_t z_chunk_elems;
  zone_cache *z_pcpu_cache;
  zone_depot z_recirc;
  hw_lck_ticket_t z_recirc_lock;
  uint32_t z_recirc_full_min;
  uint32_t z_recirc_full_wma;
  union
  {
    uint32_t z_recirc_empty_min;
    uint32_t z_elems_free_min;
  };
  union
  {
    uint32_t z_recirc_empty_wma;
    uint32_t z_elems_free_wma;
  };
  uint32_t z_recirc_cont_cur;
  uint32_t z_recirc_cont_wma;
  uint16_t z_depot_size;
  uint16_t z_depot_limit;
  hw_lck_ticket_t z_lock;
  uint32_t z_wired_max;
  uint32_t z_wired_hwm;
  uint32_t z_wired_cur;
  uint32_t z_wired_empty;
  uint32_t z_va_cur;
  zone_pva_t z_pageq_empty;
  zone_pva_t z_pageq_partial;
  zone_pva_t z_pageq_full;
  zone_pva_t z_pageq_va;
  uint32_t z_elems_free;
  uint32_t z_elems_avail;
  uint32_t z_elems_rsv;
  uint32_t z_array_size_class;
  zone *z_kt_next;
  uint8_t z_cacheline3[];
};

/* 6760 */
struct entry_template
{
  char et_key[32];
  char et_group[32];
  char et_units[32];
  uint32_t et_flags;
  uint16_t et_size;
  uint16_t et_offset;
  ledger_callback *et_callback;
};

/* 2279 */
struct __attribute__((aligned(8))) zone_stats
{
  uint64_t zs_mem_allocated;
  uint64_t zs_mem_freed;
  uint64_t zs_alloc_fail;
  uint32_t zs_alloc_rr;
};

/* 970 */
typedef zone_view *zone_view_t;

/* 971 */
struct zone_view
{
  zone_t zv_zone;
  zone_stats_t zv_stats;
  const char *zv_name;
  zone_view_t zv_next;
};

/* 2581 */
typedef struct thread *thread_t_0;

/* 5832 */
struct __attribute__((aligned(8))) zone_expand
{
  zone_expand *ze_next;
  thread_t_0 ze_thread;
  bool ze_pg_wait;
  bool ze_vm_priv;
  bool ze_clear_priv;
};

/* 2230 */
typedef smr *smr_t;

/* 6526 */
struct __attribute__((aligned(16))) zone_cache
{
  hw_lck_ticket_t zc_depot_lock;
  uint16_t zc_alloc_cur;
  uint16_t zc_free_cur;
  vm_offset_t *zc_alloc_elems;
  vm_offset_t *zc_free_elems;
  zone_depot zc_depot;
  smr_t zc_smr;
};

/* 5378 */
typedef unsigned __int64 smr_seq_t;

/* 6524 */
struct zone_magazine
{
  zone_magazine_t zm_next;
  smr_seq_t zm_seq;
  vm_offset_t zm_elems[];
};

/* 6758 */
typedef void (*ledger_callback_t)(int, const void *, const void *);

/* 6759 */
struct ledger_callback
{
  ledger_callback_t lc_func;
  const void *lc_param0;
  const void *lc_param1;
};

/* 2235 */
struct smr_clock_t
{
  smr_seq_t s_rd_seq;
  smr_seq_t s_wr_seq;
};

/* 3915 */
struct smr
{
  smr_clock_t smr_clock;
  smr_pcpu *smr_pcpu;
  unsigned __int64 smr_flags;
  unsigned __int64 smr_early;
};

/* 2234 */
struct smr_pcpu
{
  smr_seq_t c_rd_seq;
};

/* 491 */
typedef ledger *ledger_t;

/* 492 */
typedef kern_return_t kmod_stop_func_t_0(kmod_info_0 *, void *);

/* 494 */
typedef kmod_reference_0 kmod_reference_t_0;

/* 5593 */
typedef uintptr_t vm_size_t_0;

/* 493 */
typedef kern_return_t kmod_start_func_t_0(kmod_info_0 *, void *);

/* 5467 */
struct __attribute__((packed)) __attribute__((aligned(4))) kmod_info_0
{
  kmod_info_0 *next;
  int32_t info_version;
  uint32_t id;
  char name[64];
  char version[64];
  int32_t reference_count;
  kmod_reference_t_0 *reference_list;
  vm_address_t address;
  vm_size_t_0 size;
  vm_size_t_0 hdr_size;
  kmod_start_func_t_0 *start;
  kmod_stop_func_t_0 *stop;
};

/* 7244 */
struct kmod_reference_0
{
  kmod_reference_0 *next;
  kmod_info_0 *info;
};

/* 495 */
typedef kmod_info_1 kmod_info_t_0;

/* 9150 */
struct __attribute__((packed)) __attribute__((aligned(4))) kmod_info_1
{
  kmod_info_0 *next;
  int32_t info_version;
  uint32_t id;
  char name[64];
  char version[64];
  int32_t reference_count;
  kmod_reference_t_0 *reference_list;
  vm_address_t_0 address;
  vm_size_t_0 size;
  vm_size_t_0 hdr_size;
  kmod_start_func_t_0 *start;
  kmod_stop_func_t_0 *stop;
};

/* 496 */
typedef kmod_info_t_0 *kmod_info_array_t;

/* 497 */
struct timer
{
  uint64_t tstamp;
  uint64_t all_bits;
};

/* 498 */
typedef timer *timer_t;

/* 499 */
struct __block_descriptor
{
  unsigned __int64 reserved;
  unsigned __int64 Size;
};

/* 500 */
struct __block_literal_1
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
};

/* 1035 */
typedef OSObject_0 *io_object_t_0;

/* 501 */
typedef int mpo_iokit_check_get_property_t(kauth_cred_t, io_object_t_0, const char *);

/* 2619 */
struct __cppobj OSMetaClassBase_0
{
  int (**_vptr$OSMetaClassBase)(void);
};

/* 1034 */
struct __cppobj __attribute__((aligned(8))) OSObject_0 : OSMetaClassBase_0
{
  int retainCount;
};

/* 502 */
typedef int mpo_iokit_check_filter_properties_t(kauth_cred_t, io_object_t_0);

/* 503 */
typedef void mpo_vnode_notify_link_t(kauth_cred_t, vnode *, label *, vnode *, label *, componentname *);

/* 896 */
struct lck_mtx_t
{
  uintptr_t opaque[2];
};

/* 872 */
typedef vnode *vnode_t;

/* 927 */
struct buflists
{
  buf *lh_first;
};

/* 842 */
struct klist
{
  knote *slh_first;
};

/* 2366 */
typedef int kauth_action_t;

/* 926 */
typedef vnode_resolve *vnode_resolve_t;

/* 925 */
struct fl_head
{
  file_lease *lh_first;
};

/* 852 */
struct vnode
{
  lck_mtx_t v_lock;
  struct
  {
    vnode *tqe_next;
    vnode **tqe_prev;
  } v_freelist;
  struct
  {
    vnode *tqe_next;
    vnode **tqe_prev;
  } v_mntvnodes;
  struct
  {
    namecache *tqh_first;
    namecache **tqh_last;
  } v_ncchildren;
  struct
  {
    namecache *lh_first;
  } v_nclinks;
  vnode_t v_defer_reclaimlist;
  uint32_t v_listflag;
  uint32_t v_flag;
  uint16_t v_lflag;
  uint8_t v_iterblkflags;
  uint8_t v_references;
  int32_t v_kusecount;
  int32_t v_usecount;
  int32_t v_iocount;
  _BYTE gap68[8];
  uint16_t v_type;
  uint16_t v_tag;
  uint32_t v_id;
  _BYTE gap78[8];
  buflists v_cleanblkhd;
  buflists v_dirtyblkhd;
  klist v_knotes;
  _BYTE gap98[8];
  kauth_action_t v_authorized_actions;
  int v_cred_timestamp;
  int v_nc_generation;
  int32_t v_numoutput;
  int32_t v_writecount;
  uint32_t v_holdcount;
  const char *v_name;
  _BYTE gapC0[8];
  lockf *v_lockf;
  int (**v_op)(void *);
  _BYTE gapD8[8];
  void *v_data;
  label *v_label;
  vnode_resolve_t v_resolve;
  vnode_t v_fmlink;
  fl_head v_leases;
};

/* 903 */
struct label
{
  label **l_owner;
  void *l_perpolicy[7];
};

/* 749 */
typedef vfs_context *vfs_context_t;

/* 750 */
struct __attribute__((aligned(8))) componentname
{
  uint32_t cn_nameiop;
  uint32_t cn_flags;
  vfs_context_t cn_context;
  nameidata *cn_ndp;
  char *cn_pnbuf;
  int cn_pnlen;
  char *cn_nameptr;
  int cn_namelen;
  uint32_t cn_hash;
  uint32_t cn_consume;
};

/* 924 */
struct namecache
{
  struct
  {
    namecache *tqe_next;
    namecache **tqe_prev;
  } nc_entry;
  struct
  {
    namecache *tqe_next;
    namecache **tqe_prev;
  } nc_child;
  union
  {
    struct
    {
      namecache *le_next;
      namecache **le_prev;
    } nc_link;
    struct
    {
      namecache *tqe_next;
      namecache **tqe_prev;
    } nc_negentry;
  } nc_un;
  smrq_link nc_hash;
  uint32_t nc_vid;
  uint32_t nc_counter;
  vnode_t nc_dvp;
  vnode_t nc_vp;
  unsigned int nc_hashval;
  const char *nc_name;
};

/* 5608 */
typedef long __darwin_time_t;

/* 2347 */
typedef __int32_t __darwin_suseconds_t;

/* 834 */
struct __attribute__((aligned(8))) timeval
{
  __darwin_time_t tv_sec;
  __darwin_suseconds_t tv_usec;
};

/* 7856 */
typedef int64_t daddr64_t;

/* 3301 */
typedef buf *buf_t;

/* 809 */
typedef struct proc *proc_t;

/* 3302 */
struct bufattr
{
  cpx *ba_cpx;
  uint64_t ba_cp_file_off;
  uint64_t ba_flags;
  void *ba_verify_ctx;
};

/* 1069 */
struct buf
{
  struct
  {
    buf *le_next;
    buf **le_prev;
  } b_hash;
  struct
  {
    buf *le_next;
    buf **le_prev;
  } b_vnbufs;
  struct
  {
    buf *tqe_next;
    buf **tqe_prev;
  } b_freelist;
  int b_timestamp;
  timeval b_timestamp_tv;
  int b_whichq;
  volatile uint32_t b_flags;
  volatile uint32_t b_lflags;
  int b_error;
  int b_bufsize;
  int b_bcount;
  int b_resid;
  dev_t b_dev;
  uintptr_t b_datap;
  daddr64_t b_lblkno;
  daddr64_t b_blkno;
  void (*b_iodone)(buf_t, void *);
  vnode_t b_vp;
  kauth_cred_t b_rcred;
  kauth_cred_t b_wcred;
  void *b_upl;
  buf_t b_real_bp;
  struct
  {
    buf *tqe_next;
    buf **tqe_prev;
  } b_act;
  void *b_drvdata;
  void *b_fsprivate;
  void *b_transaction;
  int b_dirtyoff;
  int b_dirtyend;
  int b_validoff;
  int b_validend;
  uint32_t b_redundancy_flags;
  proc_t b_proc;
  bufattr b_attr;
  uint32_t b_lblksize;
  vnode_t b_vnop_vp;
};

/* 5614 */
typedef char int8_t;

/* 861 */
struct kevent_internal_s
{
  uint64_t kei_ident;
  int8_t kei_filter;
  uint8_t kei_filtid;
  uint16_t kei_flags;
  int32_t kei_qos;
  uint64_t kei_udata;
  uint32_t kei_fflags;
  uint32_t kei_sfflags;
  int64_t kei_sdata;
  uint64_t kei_ext[4];
};

/* 862 */
struct knote
{
  struct
  {
    knote *tqe_next;
    knote **tqe_prev;
  } kn_tqe;
  struct
  {
    knote *sle_next;
  } kn_link;
  struct
  {
    knote *sle_next;
  } kn_selnext;
  _BYTE gap20[8];
  union
  {
    void *kn_hook;
    uint32_t kn_hook32;
  };
  union
  {
    fileproc *kn_fp;
    proc *kn_proc;
    ipc_object *kn_ipc_obj;
    thread_call *kn_thcall;
    thread *kn_thread;
  };
  kevent_internal_s kn_kevent;
};

/* 653 */
typedef __int16 short;

/* 2345 */
typedef __int64 __int64_t;

/* 2346 */
typedef __int64_t __darwin_off_t;

/* 2361 */
typedef __darwin_off_t off_t;

/* 5615 */
typedef char *caddr_t;

/* 1068 */
struct lockf
{
  short lf_flags;
  short lf_type;
  int lf_boosted;
  off_t lf_start;
  off_t lf_end;
  caddr_t lf_id;
  lockf **lf_head;
  vnode *lf_vnode;
  lockf *lf_next;
  locklist lf_blkhd;
  struct
  {
    lockf *tqe_next;
    lockf **tqe_prev;
  } lf_block;
  proc *lf_owner;
};

/* 7248 */
typedef uint64_t resolver_result_t;

/* 2337 */
enum path_operation : __int32
{
  path_operation::OP_LOOKUP = 0x0,
  path_operation::OP_MOUNT = 0x1,
  path_operation::OP_UNMOUNT = 0x2,
  path_operation::OP_STATFS = 0x3,
  path_operation::OP_OPEN = 0x4,
  path_operation::OP_LINK = 0x5,
  path_operation::OP_UNLINK = 0x6,
  path_operation::OP_RENAME = 0x7,
  path_operation::OP_CHDIR = 0x8,
  path_operation::OP_CHROOT = 0x9,
  path_operation::OP_MKNOD = 0xA,
  path_operation::OP_MKFIFO = 0xB,
  path_operation::OP_SYMLINK = 0xC,
  path_operation::OP_ACCESS = 0xD,
  path_operation::OP_PATHCONF = 0xE,
  path_operation::OP_READLINK = 0xF,
  path_operation::OP_GETATTR = 0x10,
  path_operation::OP_SETATTR = 0x11,
  path_operation::OP_TRUNCATE = 0x12,
  path_operation::OP_COPYFILE = 0x13,
  path_operation::OP_MKDIR = 0x14,
  path_operation::OP_RMDIR = 0x15,
  path_operation::OP_REVOKE = 0x16,
  path_operation::OP_EXCHANGEDATA = 0x17,
  path_operation::OP_SEARCHFS = 0x18,
  path_operation::OP_FSCTL = 0x19,
  path_operation::OP_GETXATTR = 0x1A,
  path_operation::OP_SETXATTR = 0x1B,
  path_operation::OP_REMOVEXATTR = 0x1C,
  path_operation::OP_LISTXATTR = 0x1D,
  path_operation::OP_MAXOP = 0x1E,
};

/* 915 */
typedef resolver_result_t (*trigger_vnode_resolve_callback_t)(vnode_t, const componentname *, path_operation, int, void *, vfs_context_t);

/* 914 */
typedef resolver_result_t (*trigger_vnode_unresolve_callback_t)(vnode_t, int, void *, vfs_context_t);

/* 913 */
typedef resolver_result_t (*trigger_vnode_rearm_callback_t)(vnode_t, int, void *, vfs_context_t);

/* 912 */
typedef void (*trigger_vnode_reclaim_callback_t)(vnode_t, void *);

/* 916 */
struct vnode_resolve
{
  lck_mtx_t vr_lock;
  trigger_vnode_resolve_callback_t vr_resolve_func;
  trigger_vnode_unresolve_callback_t vr_unresolve_func;
  trigger_vnode_rearm_callback_t vr_rearm_func;
  trigger_vnode_reclaim_callback_t vr_reclaim_func;
  void *vr_data;
  uint32_t vr_flags;
  uint32_t vr_lastseq;
};

/* 910 */
struct file_lease
{
  struct
  {
    file_lease *le_next;
    file_lease **le_prev;
  } fl_link;
  fileglob *fl_fg;
  pid_t fl_pid;
  int fl_type;
  uint32_t fl_flags;
  uint64_t fl_release_start;
  uint64_t fl_downgrade_start;
};

/* 748 */
struct vfs_context
{
  thread_t_0 vc_thread;
  kauth_cred_t vc_ucred;
};

/* 5618 */
typedef u_int64_t user_addr_t_0;

/* 5617 */
enum uio_seg : __int32
{
  UIO_USERSPACE = 0x0,
  UIO_SYSSPACE = 0x2,
  UIO_USERSPACE32 = 0x5,
  UIO_USERSPACE64 = 0x8,
  UIO_SYSSPACE32 = 0xB,
};

/* 2362 */
typedef unsigned int u_int;

/* 911 */
struct nameidata
{
  user_addr_t_0 ni_dirp;
  uio_seg ni_segflg;
  path_operation ni_op;
  vnode *ni_startdir;
  vnode *ni_rootdir;
  vnode *ni_usedvp;
  vnode *ni_vp;
  vnode *ni_dvp;
  u_int ni_pathlen;
  char *ni_next;
  char ni_pathbuf[256];
  u_long ni_loopcnt;
  componentname ni_cnd;
  int32_t ni_flag;
  int ni_ncgeneration;
};

/* 922 */
struct __smrq_link_t
{
  smrq_link *volatile __smr_ptr;
};

/* 923 */
struct smrq_link
{
  __smrq_link_t next;
  __smrq_link_t *prev;
};

/* 5196 */
typedef uint32_t cpx_flags_t;

/* 5197 */
struct cpx
{
  aes_encrypt_ctx *cpx_iv_aes_ctx_ptr;
  cpx_flags_t cpx_flags;
  uint16_t cpx_max_key_len;
  uint16_t cpx_key_len;
  uint8_t cpx_cached_key[];
};

/* 1129 */
enum fileproc_vflags_t : __int32
{
  FPV_NONE = 0x0,
  FPV_DRAIN = 0x1,
};

/* 921 */
struct fileproc
{
  os_refcnt_t fp_iocount;
  fileproc_vflags_t fp_vflags;
  _BYTE gap8[2];
  uint16_t fp_guard_attrs;
  _BYTE gapC[12];
  union
  {
    select_set *fp_wset;
    fileproc_guard *fp_guard;
  };
};

/* 7112 */
typedef natural_t ipc_object_bits_t;

/* 7111 */
typedef natural_t ipc_object_refs_t;

/* 1127 */
struct ipc_object
{
  ipc_object_bits_t io_bits;
  ipc_object_refs_t io_references;
};

/* 2219 */
struct priority_queue_entry_deadline
{
  priority_queue_entry_deadline *next;
  priority_queue_entry_deadline *prev;
  _BYTE gap10[8];
  uint64_t deadline;
};

/* 2464 */
typedef queue_entry_0 queue_head_t_0;

/* 5896 */
struct queue_entry_0
{
  queue_entry_0 *next;
  queue_entry_0 *prev;
};

/* 3297 */
typedef queue_entry_0 queue_chain_t_0;

/* 5203 */
typedef void *thread_call_param_t;

/* 7110 */
typedef void (*thread_call_func_t)(thread_call_param_t, thread_call_param_t);

/* 1126 */
struct thread_call
{
  uint64_t tc_soft_deadline;
  priority_queue_entry_deadline tc_pqlink;
  queue_head_t_0 *tc_queue;
  queue_chain_t_0 tc_qlink;
  _BYTE gap40[4];
  int32_t tc_refs;
  uint64_t tc_ttd;
  uint64_t tc_pending_timestamp;
  thread_call_func_t tc_func;
  thread_call_param_t tc_param0;
  thread_call_param_t tc_param1;
  uint64_t tc_submit_count;
  uint64_t tc_finish_count;
};

/* 3938 */
struct locklist
{
  lockf *tqh_first;
  lockf **tqh_last;
};

/* 11822 */
struct fileglob::$6A14DBE904EC481F4A4A747F4FCE03B3
{
  fileglob *le_next;
  fileglob **le_prev;
};

/* 920 */
struct fileglob
{
  struct fileglob::$6A14DBE904EC481F4A4A747F4FCE03B3 f_msglist;
  uint32_t fg_flag;
  os_ref_atomic_t fg_count;
  uint32_t fg_msgcount;
  int32_t fg_lflags;
  _BYTE gap20[16];
  off_t fg_offset;
  uintptr_t fg_data;
  _BYTE gap40[8];
  lck_mtx_t fg_lock;
};

/* 11827 */
struct select_set::$825ABE9E22C26F960E5B824A0F99C4FD
{
  _BYTE gap0[4];
};

/* 5686 */
typedef queue_entry_0 *queue_entry_t;

/* 5897 */
struct circle_queue_head
{
  queue_entry_t head;
};

/* 5687 */
typedef circle_queue_head circle_queue_head_t;

/* 853 */
struct priority_queue_sched_max
{
  priority_queue_entry_sched *pq_root;
};

/* 11828 */
union select_set::$A32129BA27CD8E1C92884EA057485E9E
{
  circle_queue_head_t selset_queue;
  priority_queue_sched_max selset_prio_queue;
  turnstile *selset_ts;
};

/* 8203 */
struct waitq_link_list_entry
{
  waitq_link_list_entry *next;
};

/* 5681 */
typedef waitq_link_list_entry waitq_link_list_t;

/* 854 */
struct mpsc_queue_chain
{
  mpsc_queue_chain *mpqc_next;
};

/* 11829 */
union select_set::$E77BF5311F3FAE1723A446294344FB72
{
  circle_queue_head_t selset_links;
  waitq_link_list_t selset_sellinks;
  void *selset_inheritor;
  mpsc_queue_chain selset_defer;
};

/* 5598 */
struct select_set
{
  struct
  {
    _BYTE gap0[4];
  };
  hw_lck_ticket_t selset_interlock;
  union
  {
    circle_queue_head_t selset_queue;
    priority_queue_sched_max selset_prio_queue;
    turnstile *selset_ts;
  };
  union
  {
    circle_queue_head_t selset_links;
    waitq_link_list_t selset_sellinks;
    void *selset_inheritor;
    mpsc_queue_chain selset_defer;
  };
  uint64_t selset_id;
};

/* 5612 */
typedef unsigned __int64 __uint64_t;

/* 1125 */
typedef __uint64_t guardid_t;

/* 917 */
struct fileproc_guard
{
  select_set *fpg_wset;
  guardid_t fpg_guard;
};

/* 858 */
struct __attribute__((aligned(8))) priority_queue_entry_sched
{
  priority_queue_entry_sched *next;
  priority_queue_entry_sched *prev;
  _BYTE gap10[8];
};

/* 856 */
struct waitq
{
  char opaque[40];
};

/* 11831 */
union turnstile::$5A6636AE3B7D72C8FACC1CFFC9AD52B6
{
  waitq ts_waitq;
};

/* 855 */
struct turnstile_list
{
  turnstile *slh_first;
};

/* 11830 */
struct turnstile::$2565DEBDD157181B79D55BE94F79F351::$D30FCDA6619EA728495E4AAB8484BCCE
{
  turnstile *sle_next;
};

/* 11832 */
union turnstile::$2565DEBDD157181B79D55BE94F79F351
{
  turnstile_list ts_free_turnstiles;
  struct turnstile::$2565DEBDD157181B79D55BE94F79F351::$D30FCDA6619EA728495E4AAB8484BCCE ts_free_elm;
  mpsc_queue_chain ts_deallocate_link;
};

/* 11833 */
struct turnstile::$D30FCDA6619EA728495E4AAB8484BCCE
{
  turnstile *sle_next;
};

/* 5610 */
enum turnstile_update_flags : __int8
{
  turnstile_update_flags::TURNSTILE_UPDATE_FLAGS_NONE = 0x0,
  turnstile_update_flags::TURNSTILE_IMMEDIATE_UPDATE = 0x1,
  turnstile_update_flags::TURNSTILE_DELAYED_UPDATE = 0x2,
  turnstile_update_flags::TURNSTILE_INHERITOR_THREAD = 0x4,
  turnstile_update_flags::TURNSTILE_INHERITOR_TURNSTILE = 0x8,
  turnstile_update_flags::TURNSTILE_INHERITOR_NEEDS_PRI_UPDATE = 0x10,
  turnstile_update_flags::TURNSTILE_NEEDS_PRI_UPDATE = 0x20,
  turnstile_update_flags::TURNSTILE_INHERITOR_WORKQ = 0x40,
  turnstile_update_flags::TURNSTILE_UPDATE_BOOST = 0x80,
};

/* 5611 */
typedef turnstile_update_flags turnstile_update_flags_t;

/* 857 */
struct __attribute__((aligned(4))) turnstile
{
  union
  {
    waitq ts_waitq;
  };
  union
  {
    turnstile_list ts_free_turnstiles;
    struct turnstile::$2565DEBDD157181B79D55BE94F79F351::$D30FCDA6619EA728495E4AAB8484BCCE ts_free_elm;
    mpsc_queue_chain ts_deallocate_link;
  };
  priority_queue_sched_max ts_inheritor_queue;
  priority_queue_entry_sched ts_inheritor_links;
  struct turnstile::$D30FCDA6619EA728495E4AAB8484BCCE ts_htable_link;
  uintptr_t ts_proprietor;
  os_ref_atomic_t ts_refcount;
  uint32_t ts_type_gencount;
  uint32_t ts_prim_count;
  turnstile_update_flags_t ts_inheritor_flags;
  uint8_t ts_priority;
};

/* 504 */
typedef int mpo_proc_check_proc_info_t(kauth_cred_t, struct proc *, int, int);

/* 505 */
typedef int mpo_kext_check_unload_t(kauth_cred_t, const char *);

/* 506 */
typedef int mpo_kext_check_load_t(kauth_cred_t, const char *);

/* 507 */
typedef int mpo_vnode_find_sigs_t(struct proc *, vnode *, off_t, label *);

/* 508 */
typedef void mpo_pty_notify_close_t(proc_t, tty *, dev_t, label *);

/* 2360 */
typedef unsigned __int8 u_char;

/* 828 */
struct clist
{
  int c_cc;
  int c_cn;
  u_char *c_cf;
  u_char *c_cl;
  u_char *c_cs;
  u_char *c_ce;
  u_char *c_cq;
};

/* 827 */
struct __attribute__((aligned(8))) selinfo
{
  waitq si_waitq;
  klist si_note;
  u_int si_flags;
};

/* 1062 */
typedef unsigned __int64 tcflag_t;

/* 1060 */
typedef unsigned __int8 cc_t;

/* 1061 */
typedef unsigned __int64 speed_t;

/* 826 */
struct termios
{
  tcflag_t c_iflag;
  tcflag_t c_oflag;
  tcflag_t c_cflag;
  tcflag_t c_lflag;
  cc_t c_cc[20];
  speed_t c_ispeed;
  speed_t c_ospeed;
};

/* 825 */
struct winsize
{
  unsigned __int16 ws_row;
  unsigned __int16 ws_col;
  unsigned __int16 ws_xpixel;
  unsigned __int16 ws_ypixel;
};

/* 829 */
struct __attribute__((aligned(8))) tty
{
  lck_mtx_t t_lock;
  clist t_rawq;
  long t_rawcc;
  clist t_canq;
  long t_cancc;
  clist t_outq;
  long t_outcc;
  int t_line;
  dev_t t_dev;
  int t_state;
  int t_flags;
  int t_timeout;
  pgrp *t_pgrp;
  session *t_session;
  selinfo t_rsel;
  selinfo t_wsel;
  termios t_termios;
  winsize t_winsize;
  void (*t_oproc)(tty *);
  void (*t_stop)(tty *, int);
  int (*t_param)(tty *, termios *);
  void *t_sc;
  int t_column;
  int t_rocount;
  int t_rocol;
  int t_hiwat;
  int t_lowat;
  int t_gen;
  void *t_iokit;
  os_ref_atomic_t t_refcnt;
};

/* 844 */
struct __smrq_slink_t
{
  smrq_slink *volatile __smr_ptr;
};

/* 900 */
struct smrq_slink
{
  __smrq_slink_t next;
};

/* 831 */
struct pgrp
{
  lck_mtx_t pg_mlock;
  smrq_slink pg_hash;
  struct
  {
    proc *lh_first;
  } pg_members;
  session *pg_session;
  pid_t pg_id;
  int pg_jobc;
  os_ref_atomic_t pg_refcount;
  os_ref_atomic_t pg_hashref;
};

/* 830 */
struct __attribute__((aligned(8))) session
{
  lck_mtx_t s_mlock;
  struct
  {
    session *le_next;
    session **le_prev;
  } s_hash;
  proc *s_leader;
  vnode *s_ttyvp;
  tty *s_ttyp;
  uint32_t s_ttyvid;
  pid_t s_ttypgrpid;
  dev_t s_ttydev;
  pid_t s_sid;
  os_ref_atomic_t s_refcount;
  char s_login[255];
};

/* 509 */
typedef void mpo_pty_notify_grant_t(proc_t, tty *, dev_t, label *);

/* 510 */
typedef int mpo_system_check_info_t(kauth_cred_t, const char *);

/* 511 */
typedef void mpo_vnode_notify_open_t(kauth_cred_t, vnode *, label *, int);

/* 512 */
typedef int mpo_vnode_check_lookup_preflight_t(kauth_cred_t, vnode *, label *, const char *, size_t);

/* 513 */
typedef int mpo_system_check_kas_info_t(kauth_cred_t, int);

/* 514 */
typedef void mpo_vnode_notify_deleteextattr_t(kauth_cred_t, vnode *, label *, const char *);

/* 515 */
typedef int mpo_vnode_check_setacl_t(kauth_cred_t, vnode *, label *, kauth_acl *);

/* 764 */
union guid_t_0
{
  unsigned __int8 g_guid[16];
  unsigned int g_guid_asint[4];
};

/* 1041 */
typedef u_int32_t kauth_ace_rights_t;

/* 765 */
struct kauth_ace
{
  guid_t_0 ace_applicable;
  u_int32_t ace_flags;
  kauth_ace_rights_t ace_rights;
};

/* 766 */
struct kauth_acl
{
  u_int32_t acl_entrycount;
  u_int32_t acl_flags;
  kauth_ace acl_ace[1];
};

/* 516 */
typedef void mpo_vnode_notify_rename_t(kauth_cred_t, vnode *, label *, vnode *, label *, componentname *);

/* 517 */
typedef int mpo_proc_check_ledger_t(kauth_cred_t, struct proc *, int);

/* 518 */
typedef int mpo_iokit_check_open_t(kauth_cred_t, io_object_t_0, unsigned int);

/* 519 */
typedef int mpo_vnode_check_fsgetpath_t(kauth_cred_t, vnode *, label *);

/* 1373 */
typedef u_int64_t user_size_t;

/* 520 */
typedef int mpo_proc_check_map_anon_t(struct proc *, kauth_cred_t, user_addr_t_0, user_size_t, int, int, int *);

/* 521 */
typedef int mpo_priv_grant_t(kauth_cred_t, int);

/* 522 */
typedef int mpo_priv_check_t(kauth_cred_t, int);

/* 523 */
typedef int mpo_vnode_check_searchfs_t(kauth_cred_t, vnode *, label *, attrlist *, attrlist *);

/* 1082 */
typedef u_int32_t attrgroup_t;

/* 909 */
struct attrlist
{
  u_short bitmapcount;
  u_int16_t reserved;
  attrgroup_t commonattr;
  attrgroup_t volattr;
  attrgroup_t dirattr;
  attrgroup_t fileattr;
  attrgroup_t forkattr;
};

/* 524 */
typedef int mpo_vnode_check_supplemental_signature_t(vnode *, label *, cs_blob *, vnode *, cs_blob *, unsigned int *);

/* 5623 */
typedef integer_t cpu_subtype_t_0;

/* 3285 */
struct cs_cpu_info
{
  cpu_type_t csb_cpu_type;
  cpu_subtype_t_0 csb_cpu_subtype;
};

/* 3284 */
struct cs_signer_info
{
  unsigned int csb_flags;
  unsigned int csb_signer_type;
};

/* 5620 */
typedef uintptr_t vm_offset_t_0;

/* 3282 */
typedef __CodeDirectory CS_CodeDirectory;

/* 2009 */
typedef __SC_GenericBlob CS_GenericBlob;

/* 3283 */
struct cs_blob_platform_flags
{
  _BYTE gap0[4];
};

/* 928 */
struct cs_blob
{
  cs_blob *csb_next;
  vnode_t csb_vnode;
  void *csb_ro_addr;
  union
  {
    struct
    {
      cpu_type_t csb_cpu_type;
      cpu_subtype_t_0 csb_cpu_subtype;
    };
    cs_cpu_info csb_cpu_info;
  };
  union
  {
    struct
    {
      unsigned int csb_flags;
      unsigned int csb_signer_type;
    };
    cs_signer_info csb_signer_info;
  };
  off_t csb_base_offset;
  off_t csb_start_offset;
  off_t csb_end_offset;
  vm_size_t_0 csb_mem_size;
  vm_offset_t_0 csb_mem_offset;
  void *csb_mem_kaddr;
  unsigned __int8 csb_cdhash[20];
  const cs_hash *csb_hashtype;
  unsigned __int8 csb_linkage[20];
  const cs_hash *csb_linkage_hashtype;
  int csb_hash_pageshift;
  int csb_hash_firstlevel_pageshift;
  const CS_CodeDirectory *csb_cd;
  const char *csb_teamid;
  char *csb_supplement_teamid;
  const CS_GenericBlob *csb_entitlements_blob;
  const CS_GenericBlob *csb_der_entitlements_blob;
  __attribute__((aligned(16))) unsigned int csb_reconstituted;
  union
  {
    struct
    {
      _BYTE gap0[4];
    };
    cs_blob_platform_flags csb_platform_flags;
  };
  unsigned int csb_validation_category;
};

/* 3662 */
typedef void (*cs_md_init)(void *);

/* 3661 */
typedef void (*cs_md_update)(void *, const void *, size_t);

/* 3660 */
typedef void (*cs_md_final)(void *, void *);

/* 3663 */
struct cs_hash
{
  uint8_t cs_type;
  size_t cs_size;
  size_t cs_digest_size;
  cs_md_init cs_init;
  cs_md_update cs_update;
  cs_md_final cs_final;
};

/* 7855 */
struct __attribute__((aligned(8))) __CodeDirectory
{
  uint32_t magic;
  uint32_t length;
  uint32_t version;
  uint32_t flags;
  uint32_t hashOffset;
  uint32_t identOffset;
  uint32_t nSpecialSlots;
  uint32_t nCodeSlots;
  uint32_t codeLimit;
  uint8_t hashSize;
  uint8_t hashType;
  uint8_t platform;
  uint8_t pageSize;
  uint32_t spare2;
  uint32_t scatterOffset;
  uint32_t teamOffset;
  uint32_t spare3;
  uint64_t codeLimit64;
  uint64_t execSegBase;
  uint64_t execSegLimit;
  uint64_t execSegFlags;
  uint32_t runtime;
  uint32_t preEncryptOffset;
  uint8_t linkageHashType;
  uint8_t linkageApplicationType;
  uint16_t linkageApplicationSubType;
  uint32_t linkageOffset;
  uint32_t linkageSize;
};

/* 7653 */
struct __SC_GenericBlob
{
  uint32_t magic;
  uint32_t length;
  char data[];
};

/* 525 */
typedef int mpo_iokit_check_set_properties_t(kauth_cred_t, io_object_t_0, io_object_t_0);

/* 526 */
typedef int mpo_proc_check_suspend_resume_t(kauth_cred_t, struct proc *, int);

/* 527 */
typedef int mpo_proc_check_run_cs_invalid_t(struct proc *);

/* 3459 */
typedef socket *socket_t_0;

/* 528 */
typedef int mpo_vnode_check_uipc_connect_t(kauth_cred_t, vnode *, label *, socket_t_0);

/* 652 */
struct sockbuf
{
  u_int32_t sb_cc;
  u_int32_t sb_hiwat;
  u_int32_t sb_mbcnt;
  u_int32_t sb_mbmax;
  u_int32_t sb_ctl;
  u_int32_t sb_lowat;
  mbuf *sb_mb;
  mbuf *sb_mbtail;
  mbuf *sb_lastrecord;
  socket *sb_so;
  selinfo sb_sel;
  timeval sb_timeo;
  u_int32_t sb_flags;
  u_int32_t sb_idealsize;
  void (*sb_upcall)(socket *, void *, int);
  void *sb_upcallarg;
  u_int32_t sb_wantlock;
  u_int32_t sb_waiters;
  thread_t_0 sb_cfil_thread;
  u_int32_t sb_cfil_refs;
  u_int32_t sb_preconn_hiwat;
};

/* 7819 */
typedef u_int64_t u_quad_t;

/* 1077 */
typedef u_quad_t so_gen_t;

/* 651 */
struct data_stats
{
  u_int64_t rxpackets;
  u_int64_t rxbytes;
  u_int64_t txpackets;
  u_int64_t txbytes;
};

/* 7082 */
typedef unsigned __int8 __darwin_uuid_t_0[16];

/* 5609 */
typedef __darwin_uuid_t_0 uuid_t_0;

/* 654 */
struct __attribute__((aligned(8))) socket
{
  int so_zone;
  short so_type;
  u_short so_error;
  u_int32_t so_options;
  short so_linger;
  short so_state;
  void *so_pcb;
  protosw *so_proto;
  socket *so_head;
  struct
  {
    socket *tqh_first;
    socket **tqh_last;
  } so_incomp;
  struct
  {
    socket *tqh_first;
    socket **tqh_last;
  } so_comp;
  struct
  {
    socket *tqe_next;
    socket **tqe_prev;
  } so_list;
  short so_qlen;
  short so_incqlen;
  short so_qlimit;
  short so_timeo;
  pid_t so_pgid;
  u_int32_t so_oobmark;
  sockbuf so_rcv;
  sockbuf so_snd;
  caddr_t so_tpcb;
  void (*so_event)(socket *, void *, uint32_t);
  void *so_eventarg;
  kauth_cred_t so_cred;
  so_gen_t so_gencnt;
  struct
  {
    socket *stqe_next;
  } so_cache_ent;
  caddr_t so_saved_pcb;
  u_int64_t cache_timestamp;
  uint32_t so_eventmask;
  pid_t last_pid;
  u_int64_t last_upid;
  socket_filter_entry *so_filt;
  u_int32_t so_flags;
  u_int32_t so_flags1;
  uint32_t so_upcallusecount;
  int so_usecount;
  int so_retaincnt;
  uint16_t so_traffic_class;
  int8_t so_netsvctype;
  uint8_t so_restrictions;
  thread_t_0 so_send_filt_thread;
  void *lock_lr[4];
  void *unlock_lr[4];
  u_int8_t next_lock_lr;
  u_int8_t next_unlock_lr;
  u_int16_t so_pktheadroom;
  u_int32_t so_ifdenied_notifies;
  thread_t_0 so_background_thread;
  data_stats so_tc_stats[4];
  klist so_klist;
  flow_divert_pcb *so_fd_pcb;
  soflow_db *so_flow_db;
  cfil_info *so_cfil;
  u_int32_t so_state_change_cnt;
  pid_t e_pid;
  u_int64_t e_upid;
  pid_t so_rpid;
  uuid_t_0 last_uuid;
  uuid_t_0 e_uuid;
  uuid_t_0 so_vuuid;
  uuid_t_0 so_ruuid;
  int32_t so_policy_gencnt;
  u_int64_t so_extended_bk_start;
  u_int8_t so_fallback_mode;
  u_int8_t so_log_seqn;
  uint8_t so_mpkl_send_proto;
  uuid_t_0 so_mpkl_send_uuid;
};

/* 943 */
struct protosw
{
  struct
  {
    protosw *tqe_next;
    protosw **tqe_prev;
  } pr_entry;
  domain *pr_domain;
  protosw *pr_protosw;
  u_int16_t pr_type;
  u_int16_t pr_protocol;
  u_int32_t pr_flags;
  void (*pr_input)(mbuf *, int);
  int (*pr_output)(mbuf *, socket *);
  void (*pr_ctlinput)(int, sockaddr *, void *, ifnet *);
  int (*pr_ctloutput)(socket *, sockopt *);
  pr_usrreqs *pr_usrreqs;
  void (*pr_init)(protosw *, domain *);
  void (*pr_drain)(void);
  int (*pr_sysctl)(int *, u_int, void *, size_t *, void *, size_t);
  int (*pr_lock)(socket *, int, void *);
  int (*pr_unlock)(socket *, int, void *);
  lck_mtx_t *(*pr_getlock)(socket *, int);
  struct
  {
    socket_filter *tqh_first;
    socket_filter **tqh_last;
  } pr_filter_head;
  protosw_old *pr_old;
  void (*pr_update_last_owner)(socket *, proc *, proc *);
  void (*pr_copy_last_owner)(socket *, socket *);
};

/* 2846 */
struct m_hdr
{
  mbuf *mh_next;
  mbuf *mh_nextpkt;
  caddr_t mh_data;
  int32_t mh_len;
  u_int16_t mh_type;
  u_int16_t mh_flags;
};

/* 2843 */
struct packet_tags
{
  m_tag *slh_first;
};

/* 2745 */
struct tcp_pktinfo
{
  union
  {
    struct
    {
      uint32_t segsz;
      uint32_t start_seq;
      pid_t pid;
      pid_t e_pid;
    } __tx;
    struct
    {
      uint8_t seg_cnt;
    } __rx;
  } __offload;
};

/* 2744 */
struct mptcp_pktinfo
{
  uint64_t mtpi_dsn;
  uint32_t mtpi_rel_seq;
  uint16_t mtpi_length;
  uint16_t mtpi_csum;
};

/* 2748 */
struct tcp_mtag
{
  union
  {
    tcp_pktinfo tm_tcp;
    mptcp_pktinfo tm_mptcp;
  };
};

/* 2747 */
struct udp_mtag
{
  pid_t _pid;
  pid_t _e_pid;
};

/* 2746 */
struct rawip_mtag
{
  pid_t _pid;
  pid_t _e_pid;
};

/* 2752 */
struct proto_mtag_
{
  union
  {
    tcp_mtag tcp;
    udp_mtag udp;
    rawip_mtag rawip;
  } __pr_u;
};

/* 2751 */
struct pf_mtag
{
  u_int16_t pftag_flags;
  u_int16_t pftag_rtableid;
  u_int16_t pftag_tag;
  u_int16_t pftag_routed;
};

/* 2750 */
struct necp_mtag_
{
  u_int32_t necp_policy_id;
  u_int32_t necp_skip_policy_id;
  u_int32_t necp_route_rule_id;
  u_int16_t necp_last_interface_index;
  u_int16_t necp_app_id;
};

/* 2749 */
struct __attribute__((aligned(4))) driver_mtag_
{
  uintptr_t _drv_tx_compl_arg;
  uintptr_t _drv_tx_compl_data;
  kern_return_t _drv_tx_status;
  uint16_t _drv_flowid;
};

/* 2842 */
union builtin_mtag
{
  struct
  {
    proto_mtag_ _proto_mtag;
    pf_mtag _pf_mtag;
    necp_mtag_ _necp_mtag;
  } _net_mtag;
  driver_mtag_ _drv_mtag;
};

/* 2845 */
struct pkthdr
{
  ifnet *rcvif;
  void *pkt_hdr;
  int32_t len;
  u_int32_t csum_flags;
  union
  {
    struct
    {
      u_int16_t val;
      u_int16_t start;
    } _csum_rx;
    struct
    {
      u_int16_t start;
      u_int16_t stuff;
    } _csum_tx;
    u_int32_t csum_data;
  };
  u_int16_t vlan_tag;
  u_int8_t pkt_proto;
  u_int8_t pkt_flowsrc;
  u_int32_t pkt_flowid;
  u_int32_t pkt_flags;
  u_int32_t pkt_svc;
  u_int32_t pkt_compl_context;
  union
  {
    struct
    {
      u_int16_t src;
      u_int16_t src_flags;
      u_int16_t dst;
      u_int16_t dst_flags;
    } _pkt_iaif;
    u_int64_t pkt_ifainfo;
    struct
    {
      u_int32_t if_data;
      u_int32_t sndbuf_data;
    } _pkt_bsr;
  };
  u_int64_t pkt_timestamp;
  packet_tags tags;
  builtin_mtag builtin_mtag;
  uint32_t comp_gencnt;
  uint16_t pkt_ext_flags;
  uint16_t pkt_crumbs;
  struct
  {
    union
    {
      u_int8_t __mpriv8[16];
      u_int16_t __mpriv16[8];
      struct {union {u_int8_t __val8[4];u_int16_t __val16[2];u_int32_t __val32;} __mpriv32_u;}; __mpriv32[4];
      u_int64_t __mpriv64[2];
    } __mpriv_u;
  } pkt_mpriv;
  u_int32_t redzone;
  u_int32_t pkt_compl_callbacks;
};

/* 5146 */
typedef void (*m_ext_free_func_t)(caddr_t, u_int, caddr_t);

/* 2844 */
struct m_ext
{
  caddr_t ext_buf;
  m_ext_free_func_t ext_free;
  u_int ext_size;
  caddr_t ext_arg;
  ext_ref *ext_refflags;
};

/* 941 */
struct mbuf
{
  m_hdr m_hdr;
  union
  {
    struct
    {
      pkthdr MH_pkthdr;
      union
      {
        m_ext MH_ext;
        char MH_databuf[80];
      } MH_dat;
    } MH;
    char M_databuf[224];
  } M_dat;
};

/* 1076 */
struct socket_filter_entry
{
  socket_filter_entry *sfe_next_onsocket;
  socket_filter_entry *sfe_next_onfilter;
  socket_filter_entry *sfe_next_oncleanup;
  socket_filter *sfe_filter;
  socket *sfe_socket;
  void *sfe_cookie;
  uint32_t sfe_flags;
  int32_t sfe_refcount;
};

/* 2798 */
typedef mbuf *mbuf_t;

/* 1104 */
typedef __uint8_t sa_family_t;

/* 695 */
struct sockaddr
{
  __uint8_t sa_len;
  sa_family_t sa_family;
  char sa_data[14];
};

/* 2916 */
struct __sockaddr_header
{
  __uint8_t sa_len;
  sa_family_t sa_family;
};

/* 7814 */
typedef __uint16_t in_port_t;

/* 7675 */
typedef __uint32_t in_addr_t;

/* 2204 */
struct in_addr
{
  in_addr_t s_addr;
};

/* 2915 */
struct sockaddr_in
{
  __uint8_t sin_len;
  sa_family_t sin_family;
  in_port_t sin_port;
  in_addr sin_addr;
  char sin_zero[8];
};

/* 2777 */
struct in6_addr_0
{
  union
  {
    __uint8_t __u6_addr8[16];
    __uint16_t __u6_addr16[8];
    __uint32_t __u6_addr32[4];
  } __u6_addr;
};

/* 2761 */
struct sockaddr_in6
{
  __uint8_t sin6_len;
  sa_family_t sin6_family;
  in_port_t sin6_port;
  __uint32_t sin6_flowinfo;
  in6_addr_0 sin6_addr;
  __uint32_t sin6_scope_id;
};

/* 3007 */
union sockaddr_in_4_6
{
  sockaddr sa;
  __sockaddr_header sah;
  sockaddr_in sin;
  sockaddr_in6 sin6;
};

/* 1075 */
struct __attribute__((aligned(8))) flow_divert_pcb
{
  lck_mtx_t mtx;
  socket_t_0 so;
  struct
  {
    flow_divert_pcb *rbe_left;
    flow_divert_pcb *rbe_right;
    flow_divert_pcb *rbe_parent;
  } rb_link;
  uint32_t hash;
  mbuf_t connect_token;
  uint32_t flags;
  uint32_t send_window;
  flow_divert_group *group;
  uint32_t control_group_unit;
  uint32_t aggregate_unit;
  uint32_t policy_control_unit;
  int32_t ref_count;
  uint32_t bytes_written_by_app;
  uint32_t bytes_read_by_app;
  uint32_t bytes_sent;
  uint32_t bytes_received;
  uint8_t log_level;
  struct
  {
    flow_divert_pcb *sle_next;
  } tmp_list_entry;
  mbuf_t connect_packet;
  uint8_t *app_data;
  size_t app_data_length;
  sockaddr_in_4_6 local_endpoint;
  sockaddr *original_remote_endpoint;
  ifnet *original_last_outifp6;
  ifnet *original_last_outifp;
  uint8_t original_vflag;
};

/* 1074 */
struct __attribute__((aligned(8))) soflow_db
{
  os_refcnt_t soflow_db_ref_count;
  socket *soflow_db_so;
  uint32_t soflow_db_count;
  soflow_hash_head *soflow_db_hashbase;
  u_long soflow_db_hashmask;
  soflow_hash_entry *soflow_db_only_entry;
  _BYTE gap30[8];
};

/* 3785 */
struct timeval64
{
  __int64_t tv_sec;
  __int64_t tv_usec;
};

/* 4571 */
struct cfil_mqhead
{
  mbuf *mq_first;
  mbuf **mq_last;
};

/* 4572 */
struct cfil_queue
{
  uint64_t q_start;
  uint64_t q_end;
  cfil_mqhead q_mq;
};

/* 4573 */
struct cfi_buf
{
  uint64_t cfi_pending_first;
  uint64_t cfi_pending_last;
  uint32_t cfi_pending_mbcnt;
  uint32_t cfi_pending_mbnum;
  uint32_t cfi_tail_drop_cnt;
  uint64_t cfi_pass_offset;
  cfil_queue cfi_inject_q;
};

/* 4574 */
struct cfe_buf
{
  cfil_queue cfe_pending_q;
  cfil_queue cfe_ctl_q;
  uint64_t cfe_pass_offset;
  uint64_t cfe_peek_offset;
  uint64_t cfe_peeked;
};

/* 4575 */
struct cfil_entry
{
  struct
  {
    cfil_entry *tqe_next;
    cfil_entry **tqe_prev;
  } cfe_link;
  struct
  {
    cfil_entry *sle_next;
  } cfe_order_link;
  content_filter *cfe_filter;
  cfil_info *cfe_cfil_info;
  uint32_t cfe_flags;
  uint32_t cfe_necp_control_unit;
  timeval cfe_last_event;
  timeval cfe_last_action;
  uint64_t cfe_byte_inbound_count_reported;
  uint64_t cfe_byte_outbound_count_reported;
  timeval cfe_stats_report_ts;
  uint32_t cfe_stats_report_frequency;
  boolean_t cfe_laddr_sent;
  cfe_buf cfe_snd;
  cfe_buf cfe_rcv;
};

/* 1073 */
struct __attribute__((aligned(8))) cfil_info
{
  struct
  {
    cfil_info *tqe_next;
    cfil_info **tqe_prev;
  } cfi_link;
  struct
  {
    cfil_info *tqe_next;
    cfil_info **tqe_prev;
  } cfi_link_stats;
  socket *cfi_so;
  uint64_t cfi_flags;
  uint64_t cfi_sock_id;
  timeval64 cfi_first_event;
  uint32_t cfi_op_list_ctr;
  uint32_t cfi_op_time[6];
  unsigned __int8 cfi_op_list[6];
  sockaddr_in_4_6 cfi_so_attach_faddr;
  sockaddr_in_4_6 cfi_so_attach_laddr;
  int cfi_dir;
  uint64_t cfi_byte_inbound_count;
  uint64_t cfi_byte_outbound_count;
  boolean_t cfi_isSignatureLatest;
  u_int32_t cfi_filter_control_unit;
  u_int32_t cfi_debug;
  cfi_buf cfi_snd;
  cfi_buf cfi_rcv;
  cfil_entry cfi_entries[8];
  soflow_hash_entry *cfi_hash_entry;
  struct
  {
    cfil_entry *slh_first;
  } cfi_ordered_entries;
  os_refcnt_t cfi_ref_count;
};

/* 942 */
struct domain
{
  int dom_family;
  uint32_t dom_flags;
  uint32_t dom_refs;
  lck_mtx_t *dom_mtx;
  lck_mtx_t dom_mtx_s;
  struct
  {
    domain *tqe_next;
    domain **tqe_prev;
  } dom_entry;
  struct
  {
    protosw *tqh_first;
    protosw **tqh_last;
  } dom_protosw;
  void (*dom_init)(domain *);
  int (*dom_externalize)(mbuf *);
  void (*dom_dispose)(mbuf *);
  int (*dom_rtattach)(void **, int);
  int dom_rtoffset;
  int dom_maxrtkey;
  int dom_protohdrlen;
  const char *dom_name;
  domain_old *dom_old;
};

/* 843 */
struct lck_rw_t
{
  uintptr_t opaque[2];
};

/* 2841 */
struct if_description
{
  u_int32_t ifd_maxlen;
  u_int32_t ifd_len;
  u_int8_t *ifd_desc;
};

/* 2840 */
struct ifaddrhead
{
  ifaddr *tqh_first;
  ifaddr **tqh_last;
};

/* 2839 */
struct __attribute__((aligned(8))) if_data_internal
{
  u_char ifi_type;
  u_char ifi_typelen;
  u_char ifi_physical;
  u_char ifi_addrlen;
  u_char ifi_hdrlen;
  u_char ifi_recvquota;
  u_char ifi_xmitquota;
  u_char ifi_unused1;
  u_int32_t ifi_mtu;
  u_int32_t ifi_metric;
  u_int32_t ifi_baudrate;
  u_int64_t ifi_ipackets;
  u_int64_t ifi_ierrors;
  u_int64_t ifi_opackets;
  u_int64_t ifi_oerrors;
  u_int64_t ifi_collisions;
  u_int64_t ifi_ibytes;
  u_int64_t ifi_obytes;
  u_int64_t ifi_imcasts;
  u_int64_t ifi_omcasts;
  u_int64_t ifi_iqdrops;
  u_int64_t ifi_noproto;
  u_int32_t ifi_recvtiming;
  u_int32_t ifi_xmittiming;
  u_int64_t ifi_alignerrs;
  u_int64_t ifi_dt_bytes;
  u_int64_t ifi_fpackets;
  u_int64_t ifi_fbytes;
  timeval ifi_lastchange;
  timeval ifi_lastupdown;
  u_int32_t ifi_hwassist;
  u_int32_t ifi_tso_v4_mtu;
  u_int32_t ifi_tso_v6_mtu;
};

/* 5149 */
typedef u_int32_t ifnet_family_t;

/* 5148 */
typedef u_int32_t ifnet_subfamily_t;

/* 5353 */
typedef int errno_t;

/* 2799 */
typedef ifnet *ifnet_t;

/* 2800 */
typedef errno_t (*dlil_input_func)(ifnet_t, mbuf_t, mbuf_t, const ifnet_stat_increment_param *, boolean_t, struct thread *);

/* 2796 */
typedef errno_t (*dlil_output_func)(ifnet_t, mbuf_t);

/* 2795 */
typedef void (*ifnet_start_func)(ifnet_t);

/* 2818 */
typedef errno_t (*ifnet_output_func)(ifnet_t, mbuf_t);

/* 2838 */
typedef errno_t (*ifnet_pre_enqueue_func)(ifnet_t, mbuf_t);

/* 5145 */
typedef u_int32_t ifnet_ctl_cmd_t;

/* 2836 */
typedef errno_t (*ifnet_ctl_func)(ifnet_t, ifnet_ctl_cmd_t, u_int32_t, void *);

/* 2837 */
typedef void (*ifnet_input_poll_func)(ifnet_t, u_int32_t, u_int32_t, mbuf_t *, mbuf_t *, u_int32_t *, u_int32_t *);

/* 2835 */
typedef errno_t (*ifnet_ioctl_func)(ifnet_t, unsigned __int64, void *);

/* 5144 */
typedef u_int32_t bpf_tap_mode;

/* 2794 */
typedef errno_t (*bpf_packet_func)(ifnet_t, mbuf_t);

/* 2834 */
typedef errno_t (*ifnet_set_bpf_tap)(ifnet_t, bpf_tap_mode, bpf_packet_func);

/* 2826 */
typedef void (*ifnet_detached_func)(ifnet_t);

/* 5143 */
typedef u_int32_t protocol_family_t;

/* 2833 */
typedef errno_t (*ifnet_demux_func)(ifnet_t, mbuf_t, char *, protocol_family_t *);

/* 2832 */
typedef void (*ifnet_event_func)(ifnet_t, const kev_msg *);

/* 9219 */
typedef errno_t (*ifnet_framer_func_0)(ifnet_t, mbuf_t *, const sockaddr *, const char *, const char *);

/* 2830 */
typedef errno_t (*ifnet_framer_extended_func)(ifnet_t, mbuf_t *, const sockaddr *, const char *, const char *, u_int32_t *, u_int32_t *);

/* 2829 */
typedef errno_t (*ifnet_add_proto_func)(ifnet_t, protocol_family_t, const ifnet_demux_desc *, u_int32_t);

/* 2828 */
typedef errno_t (*ifnet_del_proto_func)(ifnet_t, protocol_family_t);

/* 2827 */
typedef errno_t (*ifnet_check_multi)(ifnet_t, const sockaddr *);

/* 757 */
struct timespec
{
  __darwin_time_t tv_sec;
  long tv_nsec;
};

/* 2825 */
struct if_bandwidths
{
  uint64_t eff_bw;
  uint64_t max_bw;
};

/* 2824 */
struct if_latencies
{
  u_int64_t eff_lt;
  u_int64_t max_lt;
};

/* 2823 */
struct ifnet_filter_head
{
  ifnet_filter *tqh_first;
  ifnet_filter **tqh_last;
};

/* 2822 */
struct ifmultihead
{
  ifmultiaddr *lh_first;
};

/* 5142 */
typedef u_int32_t ifnet_model_t;

/* 2789 */
struct pktcntr
{
  u_int64_t packets;
  u_int64_t bytes;
};

/* 2785 */
struct if_rxpoll_stats
{
  u_int32_t ifi_poll_off_req;
  u_int32_t ifi_poll_off_err;
  u_int32_t ifi_poll_on_req;
  u_int32_t ifi_poll_on_err;
  u_int32_t ifi_poll_wakeups_avg;
  u_int32_t ifi_poll_wakeups_lowat;
  u_int32_t ifi_poll_wakeups_hiwat;
  u_int64_t ifi_poll_packets;
  u_int32_t ifi_poll_packets_avg;
  u_int32_t ifi_poll_packets_min;
  u_int32_t ifi_poll_packets_max;
  u_int32_t ifi_poll_packets_lowat;
  u_int32_t ifi_poll_packets_hiwat;
  u_int64_t ifi_poll_bytes;
  u_int32_t ifi_poll_bytes_avg;
  u_int32_t ifi_poll_bytes_min;
  u_int32_t ifi_poll_bytes_max;
  u_int32_t ifi_poll_bytes_lowat;
  u_int32_t ifi_poll_bytes_hiwat;
  u_int32_t ifi_poll_packets_limit;
  u_int64_t ifi_poll_interval_time;
};

/* 2821 */
struct if_poll_params
{
  u_int16_t poll_req;
  u_int16_t poll_update;
  u_int32_t poll_flags;
  timespec poll_cycle;
  thread *poll_thread;
  ifnet_model_t poll_mode;
  pktcntr poll_tstats;
  if_rxpoll_stats poll_pstats;
  pktcntr poll_sstats;
  timespec poll_mode_holdtime;
  timespec poll_mode_lasttime;
  timespec poll_sample_holdtime;
  timespec poll_sample_lasttime;
  timespec poll_dbg_lasttime;
};

/* 1055 */
typedef thread_call *thread_call_t;

/* 8189 */
typedef __darwin_uuid_t_0 uuid_t_1;

/* 2820 */
struct if_nexus_netif
{
  uuid_t_1 if_nif_provider;
  uuid_t_1 if_nif_instance;
  uuid_t_1 if_nif_attach;
};

/* 2819 */
struct if_nexus_flowswitch
{
  uuid_t_1 if_fsw_provider;
  uuid_t_1 if_fsw_instance;
  uuid_t_1 if_fsw_device;
  uint32_t if_fsw_ipaddr_gencnt;
};

/* 9473 */
struct __attribute__((aligned(8))) route_0
{
  rtentry *ro_rt;
  llentry *ro_lle;
  ifaddr *ro_srcia;
  uint32_t ro_flags;
  sockaddr ro_dst;
};

/* 2816 */
struct route_in6
{
  rtentry *ro_rt;
  llentry *ro_lle;
  ifaddr *ro_srcia;
  uint32_t ro_flags;
  sockaddr_in6 ro_dst;
};

/* 2815 */
struct ll_reach_tree
{
  if_llreach *rbh_root;
};

/* 2814 */
struct if_traffic_class
{
  u_int64_t ifi_ibepackets;
  u_int64_t ifi_ibebytes;
  u_int64_t ifi_obepackets;
  u_int64_t ifi_obebytes;
  u_int64_t ifi_ibkpackets;
  u_int64_t ifi_ibkbytes;
  u_int64_t ifi_obkpackets;
  u_int64_t ifi_obkbytes;
  u_int64_t ifi_ivipackets;
  u_int64_t ifi_ivibytes;
  u_int64_t ifi_ovipackets;
  u_int64_t ifi_ovibytes;
  u_int64_t ifi_ivopackets;
  u_int64_t ifi_ivobytes;
  u_int64_t ifi_ovopackets;
  u_int64_t ifi_ovobytes;
  u_int64_t ifi_ipvpackets;
  u_int64_t ifi_ipvbytes;
  u_int64_t ifi_opvpackets;
  u_int64_t ifi_opvbytes;
};

/* 2813 */
struct if_interface_state
{
  u_int8_t valid_bitmask;
  u_int8_t rrc_state;
  int8_t lqm_state;
  u_int8_t interface_availability;
};

/* 2812 */
struct __attribute__((aligned(16))) if_lim_perf_stat
{
  u_int64_t lim_dl_max_bandwidth;
  u_int64_t lim_ul_max_bandwidth;
  u_int64_t lim_total_txpkts;
  u_int64_t lim_total_rxpkts;
  u_int64_t lim_total_retxpkts;
  u_int64_t lim_packet_loss_percent;
  u_int64_t lim_total_oopkts;
  u_int64_t lim_packet_ooo_percent;
  u_int64_t lim_rtt_variance;
  u_int64_t lim_rtt_average;
  u_int64_t lim_rtt_min;
  u_int64_t lim_conn_timeouts;
  u_int64_t lim_conn_attempts;
  u_int64_t lim_conn_timeout_percent;
  u_int64_t lim_bk_txpkts;
};

/* 5147 */
typedef u_int8_t ipv6_router_mode_t;

/* 940 */
struct ifnet
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func if_output_dlil;
  volatile ifnet_start_func if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func if_input_ctl;
  ifnet_ioctl_func if_ioctl;
  ifnet_set_bpf_tap if_set_bpf_tap;
  ifnet_detached_func if_free;
  ifnet_demux_func if_demux;
  ifnet_event_func if_event;
  ifnet_framer_func_0 if_framer_legacy;
  ifnet_framer_extended_func if_framer;
  ifnet_add_proto_func if_add_proto;
  ifnet_del_proto_func if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route_0 if_fwd_route;
  route_0 if_src_route;
  route_in6 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 7247 */
enum sopt_dir : __int32
{
  sopt_dir::SOPT_GET = 0x0,
  sopt_dir::SOPT_SET = 0x1,
};

/* 647 */
struct sockopt
{
  sopt_dir sopt_dir;
  int sopt_level;
  int sopt_name;
  user_addr_t_0 sopt_val;
  size_t sopt_valsize;
  proc *sopt_p;
};

/* 938 */
typedef __uint32_t sae_associd_t;

/* 937 */
typedef __uint32_t sae_connid_t;

/* 936 */
typedef int64_t user_ssize_t;

/* 939 */
struct pr_usrreqs
{
  uint32_t pru_flags;
  int (*pru_abort)(socket *);
  int (*pru_accept)(socket *, sockaddr **);
  int (*pru_attach)(socket *, int, proc *);
  int (*pru_bind)(socket *, sockaddr *, proc *);
  int (*pru_connect)(socket *, sockaddr *, proc *);
  int (*pru_connect2)(socket *, socket *);
  int (*pru_connectx)(socket *, sockaddr *, sockaddr *, proc *, uint32_t, sae_associd_t, sae_connid_t *, uint32_t, void *, uint32_t, uio *, user_ssize_t *);
  int (*pru_control)(socket *, u_long, caddr_t, ifnet *, proc *);
  int (*pru_detach)(socket *);
  int (*pru_disconnect)(socket *);
  int (*pru_disconnectx)(socket *, sae_associd_t, sae_connid_t);
  int (*pru_listen)(socket *, proc *);
  int (*pru_peeraddr)(socket *, sockaddr **);
  int (*pru_rcvd)(socket *, int);
  int (*pru_rcvoob)(socket *, mbuf *, int);
  int (*pru_send)(socket *, int, mbuf *, sockaddr *, mbuf *, proc *);
  int (*pru_send_list)(socket *, int, mbuf *, sockaddr *, mbuf *, proc *);
  int (*pru_sense)(socket *, void *, int);
  int (*pru_shutdown)(socket *);
  int (*pru_sockaddr)(socket *, sockaddr **);
  int (*pru_sopoll)(socket *, int, ucred *, void *);
  int (*pru_soreceive)(socket *, sockaddr **, uio *, mbuf **, mbuf **, int *);
  int (*pru_soreceive_list)(socket *, recv_msg_elem *, u_int, int *);
  int (*pru_sosend)(socket *, sockaddr *, uio *, mbuf *, mbuf *, int);
  int (*pru_sosend_list)(socket *, uio **, u_int, int);
  int (*pru_socheckopt)(socket *, sockopt *);
  int (*pru_preconnect)(socket *);
  int (*pru_defunct)(socket *);
};

/* 3454 */
typedef u_int32_t sflt_handle;

/* 3453 */
typedef void (*sf_unregistered_func)(sflt_handle);

/* 3452 */
typedef errno_t (*sf_attach_func)(void **, socket_t_0);

/* 1037 */
struct __socket;

/* 1038 */
typedef struct __socket *socket_t;

/* 3451 */
typedef void (*sf_detach_func)(void *, socket_t);

/* 3437 */
typedef u_int32_t sflt_event_t;

/* 3450 */
typedef void (*sf_notify_func)(void *, socket_t, sflt_event_t, void *);

/* 3449 */
typedef int (*sf_getpeername_func)(void *, socket_t_0, sockaddr **);

/* 3448 */
typedef int (*sf_getsockname_func)(void *, socket_t_0, sockaddr **);

/* 3436 */
typedef u_int32_t sflt_data_flag_t;

/* 3447 */
typedef errno_t (*sf_data_in_func)(void *, socket_t_0, const sockaddr *, mbuf_t *, mbuf_t *, sflt_data_flag_t);

/* 3446 */
typedef errno_t (*sf_data_out_func)(void *, socket_t_0, const sockaddr *, mbuf_t *, mbuf_t *, sflt_data_flag_t);

/* 3445 */
typedef errno_t (*sf_connect_in_func)(void *, socket_t_0, const sockaddr *);

/* 3444 */
typedef errno_t (*sf_connect_out_func)(void *, socket_t_0, const sockaddr *);

/* 3443 */
typedef errno_t (*sf_bind_func)(void *, socket_t_0, const sockaddr *);

/* 3435 */
typedef sockopt *sockopt_t;

/* 3442 */
typedef errno_t (*sf_setoption_func)(void *, socket_t, sockopt_t);

/* 3441 */
typedef errno_t (*sf_getoption_func)(void *, socket_t, sockopt_t);

/* 3440 */
typedef errno_t (*sf_listen_func)(void *, socket_t);

/* 3439 */
typedef errno_t (*sf_ioctl_func)(void *, socket_t, unsigned __int64, const char *);

/* 3434 */
typedef errno_t (*sf_accept_func)(void *, socket_t_0, socket_t_0, const sockaddr *, const sockaddr *);

/* 3438 */
struct sflt_filter_ext
{
  unsigned int sf_ext_len;
  sf_accept_func sf_ext_accept;
  void *sf_ext_rsvd[5];
};

/* 3455 */
struct sflt_filter
{
  sflt_handle sf_handle;
  int sf_flags;
  char *sf_name;
  sf_unregistered_func sf_unregistered;
  sf_attach_func sf_attach;
  sf_detach_func sf_detach;
  sf_notify_func sf_notify;
  sf_getpeername_func sf_getpeername;
  sf_getsockname_func sf_getsockname;
  sf_data_in_func sf_data_in;
  sf_data_out_func sf_data_out;
  sf_connect_in_func sf_connect_in;
  sf_connect_out_func sf_connect_out;
  sf_bind_func sf_bind;
  sf_setoption_func sf_setoption;
  sf_getoption_func sf_getoption;
  sf_listen_func sf_listen;
  sf_ioctl_func sf_ioctl;
  sflt_filter_ext sf_ext;
};

/* 934 */
struct socket_filter
{
  struct
  {
    socket_filter *tqe_next;
    socket_filter **tqe_prev;
  } sf_protosw_next;
  struct
  {
    socket_filter *tqe_next;
    socket_filter **tqe_prev;
  } sf_global_next;
  socket_filter_entry *sf_entry_head;
  protosw *sf_proto;
  sflt_filter sf_filter;
  os_refcnt sf_refcount;
  uint32_t sf_flags;
};

/* 933 */
struct protosw_old
{
  short pr_type;
  __attribute__((packed)) __attribute__((aligned(4))) domain *pr_domain;
  short pr_protocol;
  unsigned int pr_flags;
  __attribute__((packed)) void (*pr_input)(mbuf *, int) __attribute__((aligned(1)));
  __attribute__((packed)) int (*pr_output)(mbuf *, socket *) __attribute__((aligned(1)));
  __attribute__((packed)) void (*pr_ctlinput)(int, sockaddr *, void *, ifnet *) __attribute__((aligned(1)));
  __attribute__((packed)) int (*pr_ctloutput)(socket *, sockopt *) __attribute__((aligned(1)));
  __attribute__((packed)) __attribute__((aligned(1))) void *pr_ousrreq;
  __attribute__((packed)) void (*pr_init)(void) __attribute__((aligned(1)));
  __attribute__((packed)) void (*pr_unused)(void) __attribute__((aligned(1)));
  __attribute__((packed)) void (*pr_unused2)(void) __attribute__((aligned(1)));
  __attribute__((packed)) void (*pr_drain)(void) __attribute__((aligned(1)));
  __attribute__((packed)) int (*pr_sysctl)(int *, u_int, void *, size_t *, void *, size_t) __attribute__((aligned(1)));
  __attribute__((packed)) __attribute__((aligned(1))) pr_usrreqs_old *pr_usrreqs;
  __attribute__((packed)) int (*pr_lock)(socket *, int, void *) __attribute__((aligned(1)));
  __attribute__((packed)) int (*pr_unlock)(socket *, int, void *) __attribute__((aligned(1)));
  __attribute__((packed)) lck_mtx_t *(*pr_getlock)(socket *, int) __attribute__((aligned(1)));
  struct
  {
    socket_filter *tqh_first;
    __attribute__((packed)) __attribute__((aligned(1))) socket_filter **tqh_last;
  } pr_filter_head;
  __attribute__((packed)) __attribute__((aligned(1))) protosw_old *pr_next;
  u_int32_t reserved[1];
};

/* 2753 */
struct m_tag
{
  uint64_t m_tag_cookie;
  struct
  {
    m_tag *sle_next;
  } m_tag_link;
  uint16_t m_tag_type;
  uint16_t m_tag_len;
  uint32_t m_tag_id;
};

/* 2743 */
struct ext_ref
{
  mbuf *paired;
  u_int16_t minref;
  u_int16_t refcnt;
  u_int16_t prefcnt;
  u_int16_t flags;
  u_int32_t priv;
  uintptr_t ext_token;
};

/* 3606 */
struct fd_pcb_tree
{
  flow_divert_pcb *rbh_root;
};

/* 3605 */
struct send_queue_head
{
  mbuf *mq_first;
  mbuf **mq_last;
};

/* 3604 */
struct __attribute__((aligned(4))) flow_divert_trie
{
  flow_divert_trie_node *nodes;
  uint16_t *child_maps;
  uint8_t *bytes;
  void *memory;
  uint16_t nodes_count;
  uint16_t child_maps_count;
  uint16_t bytes_count;
  uint16_t nodes_free_next;
  uint16_t child_maps_free_next;
  uint16_t bytes_free_next;
  uint16_t root;
};

/* 3607 */
struct __attribute__((aligned(8))) flow_divert_group
{
  lck_rw_t lck;
  fd_pcb_tree pcb_tree;
  uint32_t ctl_unit;
  uint8_t atomic_bits;
  send_queue_head send_queue;
  uint8_t *token_key;
  size_t token_key_size;
  uint32_t flags;
  flow_divert_trie signing_id_trie;
  int32_t ref_count;
};

/* 3362 */
struct soflow_hash_head
{
  soflow_hash_entry *lh_first;
};

/* 3364 */
struct in_addr_4in6
{
  u_int32_t ia46_pad32[3];
  in_addr ia46_addr4;
};

/* 7863 */
typedef void *nstat_context;

/* 3365 */
struct soflow_hash_entry
{
  struct
  {
    soflow_hash_entry *le_next;
    soflow_hash_entry **le_prev;
  } soflow_entry_link;
  struct
  {
    soflow_hash_entry *tqe_next;
    soflow_hash_entry **tqe_prev;
  } soflow_entry_list_link;
  os_refcnt_t soflow_ref_count;
  soflow_db *soflow_db;
  uint16_t soflow_outifindex;
  in_port_t soflow_fport;
  in_port_t soflow_lport;
  sa_family_t soflow_family;
  uint32_t soflow_flowhash;
  uint64_t soflow_lastused;
  uint32_t soflow_faddr6_ifscope;
  uint32_t soflow_laddr6_ifscope;
  union
  {
    in_addr_4in6 addr46;
    in6_addr_0 addr6;
  } soflow_faddr;
  union
  {
    in_addr_4in6 addr46;
    in6_addr_0 addr6;
  } soflow_laddr;
  _BYTE gap70[8];
  uint64_t soflow_rxpackets;
  uint64_t soflow_rxbytes;
  uint64_t soflow_txpackets;
  uint64_t soflow_txbytes;
  uint64_t soflow_feat_ctxt_id;
  void *soflow_feat_ctxt;
  uuid_t_1 soflow_uuid;
  nstat_context soflow_nstat_context;
};

/* 7950 */
typedef void *kern_ctl_ref;

/* 4576 */
typedef cfil_crypto_state *cfil_crypto_state_t;

/* 4577 */
struct content_filter
{
  kern_ctl_ref cf_kcref;
  u_int32_t cf_kcunit;
  u_int32_t cf_flags;
  uint32_t cf_necp_control_unit;
  uint32_t cf_sock_count;
  struct
  {
    cfil_entry *tqh_first;
    cfil_entry **tqh_last;
  } cf_sock_entries;
  cfil_crypto_state_t cf_crypto_state;
};

/* 3245 */
struct domain_old
{
  int dom_family;
  __attribute__((packed)) __attribute__((aligned(1))) const char *dom_name;
  __attribute__((packed)) void (*dom_init)(void) __attribute__((aligned(1)));
  __attribute__((packed)) int (*dom_externalize)(mbuf *) __attribute__((aligned(1)));
  __attribute__((packed)) void (*dom_dispose)(mbuf *) __attribute__((aligned(1)));
  __attribute__((packed)) __attribute__((aligned(1))) protosw_old *dom_protosw;
  __attribute__((packed)) __attribute__((aligned(1))) domain_old *dom_next;
  __attribute__((packed)) int (*dom_rtattach)(void **, int) __attribute__((aligned(1)));
  int dom_rtoffset;
  int dom_maxrtkey;
  int dom_protohdrlen;
  int dom_refs;
  __attribute__((packed)) __attribute__((aligned(1))) lck_mtx_t *dom_mtx;
  uint32_t dom_flags;
  uint32_t reserved[2];
};

/* 2811 */
struct __attribute__((aligned(8))) ifaddr
{
  lck_mtx_t ifa_lock;
  uint32_t ifa_refcnt;
  uint32_t ifa_debug;
  sockaddr *ifa_addr;
  sockaddr *ifa_dstaddr;
  sockaddr *ifa_netmask;
  ifnet *ifa_ifp;
  struct
  {
    ifaddr *tqe_next;
    ifaddr **tqe_prev;
  } ifa_link;
  void (*ifa_rtrequest)(int, rtentry *, sockaddr *);
  uint32_t ifa_flags;
  int32_t ifa_metric;
  void (*ifa_free)(ifaddr *);
  void (*ifa_trace)(ifaddr *, int);
  void (*ifa_attached)(ifaddr *);
  void (*ifa_detached)(ifaddr *);
  void *ifa_del_wc;
  int ifa_del_waiters;
};

/* 5154 */
typedef errno_t (*bpf_send_func)(ifnet_t, u_int32_t, mbuf_t);

/* 5153 */
typedef errno_t (*bpf_tap_func)(ifnet_t, u_int32_t, bpf_tap_mode);

/* 5113 */
struct bpf_if
{
  bpf_if *bif_next;
  bpf_d *bif_dlist;
  uint32_t bif_dlt;
  uint32_t bif_hdrlen;
  uint32_t bif_exthdrlen;
  uint32_t bif_comphdrlen;
  ifnet *bif_ifp;
  bpf_send_func bif_send;
  bpf_tap_func bif_tap;
};

/* 2797 */
struct ifnet_stat_increment_param
{
  u_int32_t packets_in;
  u_int32_t bytes_in;
  u_int32_t errors_in;
  u_int32_t packets_out;
  u_int32_t bytes_out;
  u_int32_t errors_out;
  u_int32_t collisions;
  u_int32_t dropped;
};

/* 2792 */
struct kev_d_vectors
{
  u_int32_t data_length;
  void *data_ptr;
};

/* 2793 */
struct kev_msg
{
  u_int32_t vendor_code;
  u_int32_t kev_class;
  u_int32_t kev_subclass;
  u_int32_t event_code;
  kev_d_vectors dv[5];
};

/* 2791 */
struct __attribute__((aligned(8))) ifnet_demux_desc
{
  u_int32_t type;
  void *data;
  u_int32_t datalen;
};

/* 5010 */
struct proto_hash_entry
{
  if_proto *slh_first;
};

/* 2787 */
struct ifclassq_disc_slot
{
  u_int32_t qid;
  void *cl;
};

/* 2788 */
struct tb_regulator
{
  u_int64_t tbr_rate_raw;
  u_int32_t tbr_percent;
  int64_t tbr_rate;
  int64_t tbr_depth;
  int64_t tbr_token;
  int64_t tbr_filluptime;
  u_int64_t tbr_last;
};

/* 2790 */
struct ifclassq
{
  lck_mtx_t ifcq_lock;
  os_refcnt_t ifcq_refcnt;
  ifnet *ifcq_ifp;
  u_int32_t ifcq_len;
  u_int32_t ifcq_maxlen;
  pktcntr ifcq_xmitcnt;
  pktcntr ifcq_dropcnt;
  u_int32_t ifcq_type;
  u_int32_t ifcq_flags;
  u_int32_t ifcq_sflags;
  u_int32_t ifcq_target_qdelay;
  u_int32_t ifcq_bytes;
  u_int32_t ifcq_pkt_drop_limit;
  void *ifcq_disc;
  ifclassq_disc_slot ifcq_disc_slots[10];
  tb_regulator ifcq_tbr;
};

/* 9296 */
typedef errno_t (*iff_input_func_0)(void *, ifnet_t, protocol_family_t, mbuf_t *, char **);

/* 9295 */
typedef errno_t (*iff_output_func_0)(void *, ifnet_t, protocol_family_t, mbuf_t *);

/* 8067 */
typedef void (*iff_event_func_0)(void *, ifnet_t, protocol_family_t, const kev_msg *);

/* 8066 */
typedef errno_t (*iff_ioctl_func_0)(void *, ifnet_t, protocol_family_t, unsigned __int64, void *);

/* 8065 */
typedef void (*iff_detached_func_0)(void *, ifnet_t);

/* 5008 */
struct ifnet_filter
{
  struct
  {
    ifnet_filter *tqe_next;
    ifnet_filter **tqe_prev;
  } filt_next;
  u_int32_t filt_skip;
  u_int32_t filt_flags;
  ifnet_t filt_ifp;
  const char *filt_name;
  void *filt_cookie;
  protocol_family_t filt_protocol;
  iff_input_func_0 filt_input;
  iff_output_func_0 filt_output;
  iff_event_func_0 filt_event;
  iff_ioctl_func_0 filt_ioctl;
  iff_detached_func_0 filt_detached;
};

/* 2786 */
struct ifmultiaddr
{
  lck_mtx_t ifma_lock;
  u_int32_t ifma_refcount;
  u_int32_t ifma_anoncnt;
  u_int32_t ifma_reqcnt;
  u_int32_t ifma_debug;
  u_int32_t ifma_flags;
  struct
  {
    ifmultiaddr *le_next;
    ifmultiaddr **le_prev;
  } ifma_link;
  sockaddr *ifma_addr;
  ifmultiaddr *ifma_ll;
  ifnet *ifma_ifp;
  void *ifma_protospec;
  void (*ifma_trace)(ifmultiaddr *, int);
};

/* 2909 */
struct ip_msource_tree
{
  ip_msource *rbh_root;
};

/* 2908 */
struct __attribute__((aligned(8))) ifqueue
{
  void *ifq_head;
  void *ifq_tail;
  int ifq_len;
  int ifq_maxlen;
  int ifq_drops;
};

/* 2905 */
struct inm_st
{
  uint16_t iss_fmode;
  uint16_t iss_asm;
  uint16_t iss_ex;
  uint16_t iss_in;
  uint16_t iss_rec;
};

/* 2910 */
struct in_multi
{
  lck_mtx_t inm_lock;
  u_int32_t inm_refcount;
  u_int32_t inm_reqcnt;
  u_int32_t inm_debug;
  struct
  {
    in_multi *le_next;
    in_multi **le_prev;
  } inm_link;
  in_addr inm_addr;
  ifnet *inm_ifp;
  ifmultiaddr *inm_ifma;
  u_int inm_timer;
  u_int inm_state;
  void *inm_rti;
  igmp_ifinfo *inm_igi;
  struct
  {
    in_multi *sle_next;
  } inm_dtle;
  struct
  {
    in_multi *sle_next;
  } inm_nrele;
  u_int32_t inm_nrelecnt;
  ip_msource_tree inm_srcs;
  u_long inm_nsrc;
  ifqueue inm_scq;
  timeval inm_lastgsrtv;
  uint16_t inm_sctimer;
  uint16_t inm_scrv;
  inm_st inm_st[2];
  void (*inm_trace)(in_multi *, int);
};

/* 2782 */
struct mq_head
{
  mbuf *mq_first;
  mbuf **mq_last;
};

/* 2781 */
struct __attribute__((aligned(8))) kq_head
{
  __kern_packet *kq_first;
  __kern_packet **kq_last;
  uint32_t kq_len;
};

/* 5120 */
enum classq_type : __int32
{
  classq_type::Q_DROPHEAD = 0x0,
  classq_type::Q_DROPTAIL = 0x1,
  classq_type::Q_SFB = 0x2,
};

/* 5141 */
typedef classq_type classq_type_t;

/* 5119 */
enum classq_state : __int32
{
  classq_state::QS_RUNNING = 0x0,
  classq_state::QS_SUSPENDED = 0x1,
};

/* 5140 */
typedef classq_state classq_state_t;

/* 8092 */
enum classq_pkt_type : __int32
{
  classq_pkt_type::QP_INVALID = 0x0,
  classq_pkt_type::QP_MBUF = 0x1,
  classq_pkt_type::QP_PACKET = 0x2,
};

/* 5139 */
typedef classq_pkt_type classq_pkt_type_t;

/* 8093 */
struct __attribute__((aligned(8))) _class_queue_
{
  union
  {
    mq_head __mbufq;
    kq_head __kpktq;
  } __pktq_u;
  u_int32_t qlen;
  u_int32_t qlim;
  u_int64_t qsize;
  classq_type_t qtype;
  classq_state_t qstate;
  classq_pkt_type_t qptype;
};

/* 2783 */
typedef _class_queue_ class_queue_t;

/* 1053 */
typedef _lck_grp_ lck_grp_t;

/* 2784 */
struct dlil_threading_info
{
  lck_mtx_t dlth_lock;
  class_queue_t dlth_pkts;
  ifnet *dlth_ifp;
  ifnet_stat_increment_param dlth_stats;
  uint32_t dlth_flags;
  uint32_t dlth_wtot;
  errno_t (*dlth_strategy)(dlil_threading_info *, ifnet *, mbuf *, mbuf *, const ifnet_stat_increment_param *, boolean_t, thread *);
  boolean_t dlth_affinity;
  uint32_t dlth_affinity_tag;
  thread *dlth_thread;
  thread *dlth_driver_thread;
  thread *dlth_poller_thread;
  lck_grp_t *dlth_lock_grp;
  char dlth_name[32];
  uint64_t dlth_pkts_cnt;
};

/* 4318 */
struct pfi_kif
{
  char pfik_name[16];
  struct
  {
    pfi_kif *rbe_left;
    pfi_kif *rbe_right;
    pfi_kif *rbe_parent;
  } pfik_tree;
  u_int64_t pfik_packets[2][2][2];
  u_int64_t pfik_bytes[2][2][2];
  u_int64_t pfik_tzero;
  int pfik_flags;
  void *pfik_ah_cookie;
  ifnet *pfik_ifp;
  int pfik_states;
  int pfik_rules;
  struct
  {
    pfi_dynaddr *tqh_first;
    pfi_dynaddr **tqh_last;
  } pfik_dynaddrs;
};

/* 2779 */
typedef classq_pkt classq_pkt_t;

/* 2780 */
struct nexus_ifnet_ops
{
  void (*ni_finalize)(nexus_netif_adapter *, ifnet *);
  void (*ni_reap)(nexus_netif_adapter *, ifnet *, uint32_t, boolean_t);
  errno_t (*ni_dequeue)(nexus_netif_adapter *, uint32_t, uint32_t, uint32_t, classq_pkt_t *, classq_pkt_t *, uint32_t *, uint32_t *, boolean_t, errno_t);
  errno_t (*ni_get_len)(nexus_netif_adapter *, uint32_t, uint32_t *, uint32_t *, errno_t);
  void (*ni_detach_notify)(nexus_netif_adapter *);
};

/* 5107 */
enum nexus_adapter_type_t : __int32
{
  NA_INVALID = 0x0,
  NA_PSEUDO = 0x1,
  NA_USER_PIPE = 0x2,
  NA_KERNEL_PIPE = 0x3,
  NA_MONITOR = 0x4,
  NA_NETIF_DEV = 0x5,
  NA_NETIF_HOST = 0x6,
  NA_NETIF_COMPAT_DEV = 0x7,
  NA_NETIF_COMPAT_HOST = 0x8,
  NA_NETIF_FILTER = 0x9,
  NA_NETIF_VP = 0xA,
  NA_FLOWSWITCH_VP = 0xB,
};

/* 5127 */
enum nexus_meta_type_t : __int32
{
  NEXUS_META_TYPE_INVALID = 0x0,
  NEXUS_META_TYPE_QUANTUM = 0x1,
  NEXUS_META_TYPE_PACKET = 0x2,
  NEXUS_META_TYPE_RESERVED = 0x3,
  NEXUS_META_TYPE_MAX = 0x3,
};

/* 5126 */
enum nexus_meta_subtype_t : __int32
{
  NEXUS_META_SUBTYPE_INVALID = 0x0,
  NEXUS_META_SUBTYPE_PAYLOAD = 0x1,
  NEXUS_META_SUBTYPE_RAW = 0x2,
  NEXUS_META_SUBTYPE_RESERVED = 0x3,
  NEXUS_META_SUBTYPE_MAX = 0x3,
};

/* 5138 */
typedef uint16_t nexus_port_t;

/* 2955 */
struct ch_selinfo
{
  lck_mtx_t csi_lock;
  selinfo csi_si;
  uint32_t csi_flags;
  uint32_t csi_pending;
  uint64_t csi_eff_interval;
  uint64_t csi_interval;
  thread_call_t csi_tcall;
};

/* 5086 */
enum nexus_stats_type_t : __int32
{
  NEXUS_STATS_TYPE_INVALID = 0x0,
  NEXUS_STATS_TYPE_FSW = 0x1,
  NEXUS_STATS_TYPE_CHAN_ERRORS = 0x2,
};

/* 5114 */
typedef uint64_t kern_packet_t;

/* 5082 */
enum na_activate_mode_t : __int32
{
  NA_ACTIVATE_MODE_ON = 0x0,
  NA_ACTIVATE_MODE_DEFUNCT = 0x1,
  NA_ACTIVATE_MODE_OFF = 0x2,
};

/* 5081 */
enum nxspec_cmd_t : __int32
{
  NXSPEC_CMD_CONNECT = 0x0,
  NXSPEC_CMD_DISCONNECT = 0x1,
  NXSPEC_CMD_START = 0x2,
  NXSPEC_CMD_STOP = 0x3,
};

/* 9477 */
struct nexus_adapter_0
{
  volatile uint32_t na_flags;
  nexus_adapter_type_t na_type;
  const nexus_meta_type_t na_md_type;
  const nexus_meta_subtype_t na_md_subtype;
  nexus_port_t na_nx_port;
  uint32_t na_channels;
  uint32_t na_num_rx_rings;
  uint32_t na_num_tx_rings;
  uint32_t na_num_allocator_ring_pairs;
  uint32_t na_num_event_rings;
  uint64_t na_work_ts;
  __kern_channel_ring *na_tx_rings;
  __kern_channel_ring *na_rx_rings;
  kern_nexus *na_nx;
  volatile uint32_t na_refcount;
  int na_si_users[5];
  ch_selinfo na_si[5];
  skmem_arena *na_arena;
  uint32_t na_num_tx_slots;
  uint32_t na_num_rx_slots;
  uint32_t na_num_allocator_slots;
  uint32_t na_num_event_slots;
  uint32_t na_total_slots;
  const uint32_t na_flowadv_max;
  const nexus_stats_type_t na_stats_type;
  __kern_channel_ring *na_alloc_rings;
  __kern_channel_ring *na_free_rings;
  __kern_channel_ring *na_event_rings;
  uint64_t na_ch_mit_ival;
  kern_nexus_domain_provider *na_nxdom_prov;
  slot_ctx *na_slot_ctxs;
  kern_packet_t *na_scratch;
  __kern_channel_ring *na_tail;
  void *na_private;
  ifnet *na_ifp;
  uint8_t na_kring_svc_lut[10];
  uint32_t na_next_pipe;
  uint32_t na_max_pipes;
  nexus_upipe_adapter **na_pipes;
  char na_name[64];
  uuid_t_1 na_uuid;
  int (*na_activate)(nexus_adapter *, na_activate_mode_t);
  int (*na_special)(nexus_adapter *, kern_channel *, chreq *, nxspec_cmd_t);
  int (*na_txsync)(__kern_channel_ring *, proc *, uint32_t);
  int (*na_rxsync)(__kern_channel_ring *, proc *, uint32_t);
  int (*na_notify)(__kern_channel_ring *, proc *, uint32_t);
  int (*na_channel_event_notify)(nexus_adapter *, __kern_channel_event *, uint16_t);
  int (*na_config)(nexus_adapter *, uint32_t *, uint32_t *, uint32_t *, uint32_t *);
  int (*na_krings_create)(nexus_adapter *, kern_channel *);
  void (*na_krings_delete)(nexus_adapter *, kern_channel *, boolean_t);
  void (*na_dtor)(nexus_adapter *);
  void (*na_free)(nexus_adapter *);
  void (*na_rx)(nexus_adapter *, __kern_packet *, nexus_pkt_stats *);
};

/* 3020 */
struct __attribute__((aligned(8))) nexus_netif_adapter
{
  nexus_adapter_0 nifna_up;
  nx_netif *nifna_netif;
  nx_netif_mit *nifna_tx_mit;
  nx_netif_mit *nifna_rx_mit;
  union
  {
    netif_filter *nifna_filter;
    netif_flow *nifna_flow;
  };
  uint16_t nifna_gencnt;
};

/* 2807 */
struct radix_node
{
  radix_mask *rn_mklist;
  radix_node *rn_parent;
  short rn_bit;
  char rn_bmask;
  u_char rn_flags;
  union
  {
    struct
    {
      caddr_t rn_Key;
      caddr_t rn_Mask;
      radix_node *rn_Dupedkey;
    } rn_leaf;
    struct
    {
      int rn_Off;
      radix_node *rn_L;
      radix_node *rn_R;
    } rn_node;
  } rn_u;
};

/* 2808 */
struct eventhandler_lists_ctxt
{
  struct
  {
    eventhandler_list *tqh_first;
    eventhandler_list **tqh_last;
  } eventhandler_lists;
  int eventhandler_lists_initted;
  lck_mtx_t eventhandler_mutex;
};

/* 2810 */
struct rtentry
{
  radix_node rt_nodes[2];
  lck_mtx_t rt_lock;
  uint32_t rt_refcnt;
  uint32_t rt_flags;
  uint32_t rt_genid;
  sockaddr *rt_gateway;
  ifnet *rt_ifp;
  ifaddr *rt_ifa;
  sockaddr *rt_genmask;
  void *rt_llinfo;
  void (*rt_llinfo_get_ri)(rtentry *, rt_reach_info *);
  void (*rt_llinfo_get_iflri)(rtentry *, ifnet_llreach_info *);
  void (*rt_llinfo_purge)(rtentry *);
  void (*rt_llinfo_free)(void *);
  void (*rt_llinfo_refresh)(rtentry *);
  rt_metrics rt_rmx;
  rtentry *rt_gwroute;
  rtentry *rt_parent;
  nstat_counts *rt_stats;
  void (*rt_if_ref_fn)(ifnet *, int);
  uint32_t *rt_tree_genid;
  uint64_t rt_expire;
  uint64_t base_calendartime;
  uint64_t base_uptime;
  u_int32_t rtt_hist[10];
  u_int32_t rtt_min;
  u_int32_t rtt_expire_ts;
  u_int8_t rtt_index;
  eventhandler_lists_ctxt rt_evhdlr_ctxt;
};

/* 5613 */
typedef short int16_t;

/* 6827 */
typedef __darwin_time_t time_t;

/* 2778 */
struct llentry
{
  struct
  {
    llentry *le_next;
    llentry **le_prev;
  } lle_next;
  union
  {
    in_addr addr4;
    in6_addr_0 addr6;
  } r_l3addr;
  uint16_t r_flags;
  uint16_t r_skip_req;
  lltable *lle_tbl;
  llentries *lle_head;
  void (*lle_free)(llentry *);
  mbuf *la_hold;
  int la_numheld;
  u_int64_t la_expire;
  uint16_t la_flags;
  uint16_t la_asked;
  uint16_t la_preempt;
  int16_t ln_state;
  uint16_t ln_router;
  time_t ln_ntick;
  time_t lle_remtime;
  time_t lle_hittime;
  int lle_refcnt;
  union
  {
    uint64_t mac_aligned;
    uint16_t mac16[3];
  } ll_addr;
  struct
  {
    llentry *le_next;
    llentry **le_prev;
  } lle_chain;
  thread_call_t lle_timer;
  u_int64_t ln_lastused;
  if_llreach *ln_llreach;
  lck_rw_t lle_lock;
  lck_mtx_t req_mtx;
};

/* 4249 */
struct lr_key_s
{
  u_int16_t proto;
  u_int8_t addr[6];
};

/* 4250 */
struct __attribute__((aligned(8))) if_llreach
{
  lck_mtx_t lr_lock;
  struct
  {
    if_llreach *rbe_left;
    if_llreach *rbe_right;
    if_llreach *rbe_parent;
  } lr_link;
  ifnet *lr_ifp;
  u_int32_t lr_refcnt;
  u_int32_t lr_reqcnt;
  u_int32_t lr_debug;
  u_int32_t lr_probes;
  u_int64_t lr_basecal;
  u_int64_t lr_baseup;
  u_int64_t lr_lastrcvd;
  u_int32_t lr_basereachable;
  u_int32_t lr_reachable;
  lr_key_s lr_key;
  int32_t lr_rssi;
  int32_t lr_lqm;
  int32_t lr_npm;
};

/* 4477 */
struct igmp_ifinfo
{
  lck_mtx_t igi_lock;
  uint32_t igi_refcnt;
  uint32_t igi_debug;
  struct
  {
    igmp_ifinfo *le_next;
    igmp_ifinfo **le_prev;
  } igi_link;
  ifnet *igi_ifp;
  uint32_t igi_version;
  uint32_t igi_v1_timer;
  uint32_t igi_v2_timer;
  uint32_t igi_v3_timer;
  uint32_t igi_flags;
  uint32_t igi_rv;
  uint32_t igi_qi;
  uint32_t igi_qri;
  uint32_t igi_uri;
  struct
  {
    in_multi *slh_first;
  } igi_relinmhead;
  ifqueue igi_gq;
  ifqueue igi_v2q;
};

/* 4277 */
struct mld_ifinfo
{
  lck_mtx_t mli_lock;
  uint32_t mli_refcnt;
  uint32_t mli_debug;
  struct
  {
    mld_ifinfo *le_next;
    mld_ifinfo **le_prev;
  } mli_link;
  ifnet *mli_ifp;
  uint32_t mli_version;
  uint32_t mli_v1_timer;
  uint32_t mli_v2_timer;
  uint32_t mli_flags;
  uint32_t mli_rv;
  uint32_t mli_qi;
  uint32_t mli_qri;
  uint32_t mli_uri;
  struct
  {
    in6_multi *slh_first;
  } mli_relinmhead;
  ifqueue mli_gq;
  ifqueue mli_v1q;
};

/* 2904 */
struct tcpstat_local
{
  u_int64_t badformat;
  u_int64_t unspecv6;
  u_int64_t synfin;
  u_int64_t badformatipsec;
  u_int64_t noconnnolist;
  u_int64_t noconnlist;
  u_int64_t listbadsyn;
  u_int64_t icmp6unreach;
  u_int64_t deprecate6;
  u_int64_t ooopacket;
  u_int64_t rstinsynrcv;
  u_int64_t dospacket;
  u_int64_t cleanup;
  u_int64_t synwindow;
};

/* 3363 */
struct udpstat_local
{
  u_int64_t port_unreach;
  u_int64_t faithprefix;
  u_int64_t port0;
  u_int64_t badlength;
  u_int64_t badchksum;
  u_int64_t badmcast;
  u_int64_t cleanup;
  u_int64_t badipsec;
};

/* 2903 */
struct in_ifextra
{
  uint32_t netsig_len;
  u_int8_t netsig[20];
  lltable *ii_llt;
};

/* 2901 */
struct scope6_id
{
  u_int32_t s6id_list[16];
};

/* 2900 */
struct in6_ifstat
{
  u_quad_t ifs6_in_receive;
  u_quad_t ifs6_in_hdrerr;
  u_quad_t ifs6_in_toobig;
  u_quad_t ifs6_in_noroute;
  u_quad_t ifs6_in_addrerr;
  u_quad_t ifs6_in_protounknown;
  u_quad_t ifs6_in_truncated;
  u_quad_t ifs6_in_discard;
  u_quad_t ifs6_in_deliver;
  u_quad_t ifs6_out_forward;
  u_quad_t ifs6_out_request;
  u_quad_t ifs6_out_discard;
  u_quad_t ifs6_out_fragok;
  u_quad_t ifs6_out_fragfail;
  u_quad_t ifs6_out_fragcreat;
  u_quad_t ifs6_reass_reqd;
  u_quad_t ifs6_reass_ok;
  u_quad_t ifs6_atmfrag_rcvd;
  u_quad_t ifs6_reass_fail;
  u_quad_t ifs6_in_mcast;
  u_quad_t ifs6_out_mcast;
  u_quad_t ifs6_cantfoward_icmp6;
  u_quad_t ifs6_addr_expiry_cnt;
  u_quad_t ifs6_pfx_expiry_cnt;
  u_quad_t ifs6_defrtr_expiry_cnt;
};

/* 2899 */
struct icmp6_ifstat
{
  u_quad_t ifs6_in_msg;
  u_quad_t ifs6_in_error;
  u_quad_t ifs6_in_dstunreach;
  u_quad_t ifs6_in_adminprohib;
  u_quad_t ifs6_in_timeexceed;
  u_quad_t ifs6_in_paramprob;
  u_quad_t ifs6_in_pkttoobig;
  u_quad_t ifs6_in_echo;
  u_quad_t ifs6_in_echoreply;
  u_quad_t ifs6_in_routersolicit;
  u_quad_t ifs6_in_routeradvert;
  u_quad_t ifs6_in_neighborsolicit;
  u_quad_t ifs6_in_neighboradvert;
  u_quad_t ifs6_in_redirect;
  u_quad_t ifs6_in_mldquery;
  u_quad_t ifs6_in_mldreport;
  u_quad_t ifs6_in_mlddone;
  u_quad_t ifs6_out_msg;
  u_quad_t ifs6_out_error;
  u_quad_t ifs6_out_dstunreach;
  u_quad_t ifs6_out_adminprohib;
  u_quad_t ifs6_out_timeexceed;
  u_quad_t ifs6_out_paramprob;
  u_quad_t ifs6_out_pkttoobig;
  u_quad_t ifs6_out_echo;
  u_quad_t ifs6_out_echoreply;
  u_quad_t ifs6_out_routersolicit;
  u_quad_t ifs6_out_routeradvert;
  u_quad_t ifs6_out_neighborsolicit;
  u_quad_t ifs6_out_neighboradvert;
  u_quad_t ifs6_out_redirect;
  u_quad_t ifs6_out_mldquery;
  u_quad_t ifs6_out_mldreport;
  u_quad_t ifs6_out_mlddone;
};

/* 2897 */
struct in6_cga_modifier
{
  u_int8_t octets[16];
};

/* 2898 */
struct __attribute__((aligned(8))) nd_ifinfo
{
  lck_mtx_t lock;
  boolean_t initialized;
  u_int32_t linkmtu;
  u_int32_t maxmtu;
  u_int32_t basereachable;
  u_int32_t reachable;
  u_int32_t retrans;
  u_int32_t flags;
  int recalctm;
  u_int8_t chlim;
  u_int8_t _pad[3];
  u_int8_t randomseed0[8];
  u_int8_t randomseed1[8];
  u_int8_t randomid[8];
  int32_t nprefixes;
  int32_t ndefrouters;
  boolean_t cga_initialized;
  in6_cga_modifier local_cga_modifier;
  uint8_t cga_collision_count;
};

/* 2896 */
struct ipv6_prefix
{
  in6_addr_0 ipv6_prefix;
  uint32_t prefix_len;
};

/* 2902 */
struct in6_ifextra
{
  scope6_id scope6_id;
  in6_ifstat in6_ifstat;
  icmp6_ifstat icmp6_ifstat;
  nd_ifinfo nd_ifinfo;
  uint32_t netsig_len;
  u_int8_t netsig[20];
  ipv6_prefix nat64_prefixes[4];
  lltable *ii_llt;
};

/* 2757 */
struct if_cellular_status_v1
{
  u_int32_t valid_bitmask;
  u_int32_t link_quality_metric;
  u_int32_t ul_effective_bandwidth;
  u_int32_t ul_max_bandwidth;
  u_int32_t ul_min_latency;
  u_int32_t ul_effective_latency;
  u_int32_t ul_max_latency;
  u_int32_t ul_retxt_level;
  u_int32_t ul_bytes_lost;
  u_int32_t ul_min_queue_size;
  u_int32_t ul_avg_queue_size;
  u_int32_t ul_max_queue_size;
  u_int32_t dl_effective_bandwidth;
  u_int32_t dl_max_bandwidth;
  u_int32_t config_inactivity_time;
  u_int32_t config_backoff_time;
  u_int16_t mss_recommended;
  u_int16_t reserved_1;
  u_int32_t reserved_2;
  u_int64_t reserved_3;
  u_int64_t reserved_4;
  u_int64_t reserved_5;
  u_int64_t reserved_6;
};

/* 2759 */
struct if_cellular_status
{
  union
  {
    if_cellular_status_v1 if_status_v1;
  } if_cell_u;
};

/* 2756 */
struct if_wifi_status_v1
{
  u_int32_t valid_bitmask;
  u_int32_t link_quality_metric;
  u_int32_t ul_effective_bandwidth;
  u_int32_t ul_max_bandwidth;
  u_int32_t ul_min_latency;
  u_int32_t ul_effective_latency;
  u_int32_t ul_max_latency;
  u_int32_t ul_retxt_level;
  u_int32_t ul_bytes_lost;
  u_int32_t ul_error_rate;
  u_int32_t dl_effective_bandwidth;
  u_int32_t dl_max_bandwidth;
  u_int32_t dl_min_latency;
  u_int32_t dl_effective_latency;
  u_int32_t dl_max_latency;
  u_int32_t dl_error_rate;
  u_int32_t config_frequency;
  u_int32_t config_multicast_rate;
  u_int32_t scan_count;
  u_int32_t scan_duration;
  u_int64_t reserved_1;
  u_int64_t reserved_2;
  u_int64_t reserved_3;
  u_int64_t reserved_4;
};

/* 2758 */
struct if_wifi_status
{
  union
  {
    if_wifi_status_v1 if_status_v1;
  } if_wifi_u;
};

/* 2760 */
struct if_link_status
{
  u_int32_t ifsr_version;
  u_int32_t ifsr_len;
  union
  {
    if_cellular_status ifsr_cell;
    if_wifi_status ifsr_wifi;
  } ifsr_u;
};

/* 2754 */
struct if_tcp_ecn_perf_stat
{
  u_int64_t total_txpkts;
  u_int64_t total_rxmitpkts;
  u_int64_t total_rxpkts;
  u_int64_t total_oopkts;
  u_int64_t total_reorderpkts;
  u_int64_t rtt_avg;
  u_int64_t rtt_var;
  u_int64_t sack_episodes;
  u_int64_t rxmit_drop;
  u_int64_t rst_drop;
  u_int64_t oo_percent;
  u_int64_t reorder_percent;
  u_int64_t rxmit_percent;
};

/* 2755 */
struct if_tcp_ecn_stat
{
  u_int64_t timestamp;
  u_int64_t ecn_client_setup;
  u_int64_t ecn_server_setup;
  u_int64_t ecn_client_success;
  u_int64_t ecn_server_success;
  u_int64_t ecn_peer_nosupport;
  u_int64_t ecn_syn_lost;
  u_int64_t ecn_synack_lost;
  u_int64_t ecn_recv_ce;
  u_int64_t ecn_recv_ece;
  u_int64_t ecn_conn_recv_ce;
  u_int64_t ecn_conn_recv_ece;
  u_int64_t ecn_conn_plnoce;
  u_int64_t ecn_conn_plce;
  u_int64_t ecn_conn_noplce;
  u_int64_t ecn_fallback_synloss;
  u_int64_t ecn_fallback_reorder;
  u_int64_t ecn_fallback_ce;
  u_int64_t ecn_off_conn;
  u_int64_t ecn_total_conn;
  u_int64_t ecn_fallback_droprst;
  u_int64_t ecn_fallback_droprxmt;
  u_int64_t ecn_fallback_synrst;
  if_tcp_ecn_perf_stat ecn_on;
  if_tcp_ecn_perf_stat ecn_off;
};

/* 3248 */
struct ns_token
{
  ifnet_t nt_ifp;
  struct
  {
    ns_token *sle_next;
  } nt_ifp_link;
  struct
  {
    ns_token *sle_next;
  } nt_all_link;
  uint32_t nt_state;
  union
  {
    uint32_t nt_addr[4];
    in_addr nt_inaddr;
    in6_addr_0 nt_in6addr;
  };
  uint8_t nt_addr_len;
  uint8_t nt_proto;
  in_port_t nt_port;
  uint32_t nt_flags;
  ns_flow_info *nt_flow_info;
};

/* 3142 */
typedef _pktsched_pkt_ pktsched_pkt_t;

/* 4513 */
enum netem_model_t : __int32
{
  NETEM_MODEL_NULL = 0x0,
  NETEM_MODEL_NLC = 0x1,
  NETEM_MODEL_IOD = 0x2,
  NETEM_MODEL_FPD = 0x3,
};

/* 4512 */
typedef int (*netem_enqueue_fn_t)(netem *, classq_pkt_t *, bool *);

/* 4511 */
struct bandwidth
{
  uint64_t rate;
  uint64_t prev_time_to_send;
};

/* 4510 */
struct corruption
{
  uint32_t corruption_p;
};

/* 4509 */
struct duplication
{
  uint32_t duplication_p;
};

/* 4508 */
struct latency
{
  uint32_t latency_ms;
  uint32_t jitter_ms;
  uint64_t prev_time_to_send;
};

/* 8017 */
enum _4state_markov_packet_loss_state : __int32
{
  _4state_markov_packet_loss_state::__NO_LOSS = 0x0,
  _4state_markov_packet_loss_state::GAP_RX = 0x1,
  _4state_markov_packet_loss_state::GAP_LOSS = 0x2,
  _4state_markov_packet_loss_state::BURST_RX = 0x3,
  _4state_markov_packet_loss_state::BURST_LOSS = 0x4,
};

/* 4507 */
struct loss
{
  _4state_markov_packet_loss_state state;
  uint32_t p_gr_gl;
  uint32_t p_gr_bl;
  uint32_t p_bl_br;
  uint32_t p_bl_gr;
  uint32_t p_br_bl;
  uint32_t recovery_ms;
  uint64_t recovery_window;
};

/* 4506 */
struct reordering
{
  uint32_t reordering_p;
  uint32_t reordering_ms;
};

/* 4514 */
struct netem
{
  lck_mtx_t netem_lock;
  char netem_name[64];
  uint32_t netem_flags;
  ifnet *netem_ifp;
  thread *netem_output_thread;
  void *netem_output_handle;
  int (*netem_output)(void *, pktsched_pkt_t *, uint32_t);
  uint32_t netem_output_max_batch_size;
  uint32_t netem_output_ival_ms;
  heap *netem_heap;
  netem_model_t netem_model;
  netem_enqueue_fn_t netem_enqueue;
  bandwidth netem_bandwidth_model;
  corruption netem_corruption_model;
  duplication netem_duplication_model;
  latency netem_latency_model;
  loss netem_loss_model;
  reordering netem_reordering_model;
};

/* 5616 */
enum uio_rw : __int32
{
  uio_rw::UIO_READ = 0x0,
  uio_rw::UIO_WRITE = 0x1,
};

/* 957 */
struct __attribute__((aligned(8))) uio
{
  _BYTE gap0[16];
  int uio_max_iovs;
  int uio_iovcnt;
  off_t uio_offset;
  uio_seg uio_segflg;
  uio_rw uio_rw;
  user_size_t uio_resid_64;
  u_int32_t uio_flags;
};

/* 935 */
struct recv_msg_elem
{
  uio *uio;
  sockaddr *psa;
  mbuf *controlp;
  int which;
  int flags;
};

/* 932 */
struct pr_usrreqs_old
{
  int (*pru_abort)(socket *);
  int (*pru_accept)(socket *, sockaddr **);
  int (*pru_attach)(socket *, int, proc *);
  int (*pru_bind)(socket *, sockaddr *, proc *);
  int (*pru_connect)(socket *, sockaddr *, proc *);
  int (*pru_connect2)(socket *, socket *);
  int (*pru_control)(socket *, u_long, caddr_t, ifnet *, proc *);
  int (*pru_detach)(socket *);
  int (*pru_disconnect)(socket *);
  int (*pru_listen)(socket *, proc *);
  int (*pru_peeraddr)(socket *, sockaddr **);
  int (*pru_rcvd)(socket *, int);
  int (*pru_rcvoob)(socket *, mbuf *, int);
  int (*pru_send)(socket *, int, mbuf *, sockaddr *, mbuf *, proc *);
  int (*pru_sense)(socket *, void *, int);
  int (*pru_shutdown)(socket *);
  int (*pru_sockaddr)(socket *, sockaddr **);
  int (*pru_sosend)(socket *, sockaddr *, uio *, mbuf *, mbuf *, int);
  int (*pru_soreceive)(socket *, sockaddr **, uio *, mbuf **, mbuf **, int *);
  int (*pru_sopoll)(socket *, int, ucred *, void *);
};

/* 4391 */
struct flow_divert_trie_node
{
  uint16_t start;
  uint16_t length;
  uint16_t child_map;
};

/* 4570 */
typedef uint8_t cfil_crypto_key[32];

/* 4549 */
struct cfil_crypto_state
{
  const ccdigest_info_0 *digest_info;
  cfil_crypto_key key;
};

/* 5151 */
struct bpf_comp_stats
{
  uint64_t bcs_total_read;
  uint64_t bcs_total_size;
  uint64_t bcs_total_hdr_size;
  uint64_t bcs_count_no_common_prefix;
  uint64_t bcs_count_compressed_prefix;
  uint64_t bcs_total_compressed_prefix_size;
  uint64_t bcs_max_compressed_prefix_size;
};

/* 5152 */
struct bpf_d
{
  bpf_d *bd_next;
  caddr_t bd_sbuf;
  caddr_t bd_hbuf;
  caddr_t bd_fbuf;
  uint32_t bd_slen;
  uint32_t bd_hlen;
  uint32_t bd_scnt;
  uint32_t bd_hcnt;
  uint32_t bd_bufsize;
  int bd_hbuf_read;
  int bd_headdrop;
  uint32_t bd_rtout;
  bpf_if *bd_bif;
  bpf_insn *bd_filter;
  uint64_t bd_rcount;
  uint64_t bd_dcount;
  uint64_t bd_fcount;
  uint64_t bd_wcount;
  uint64_t bd_wdcount;
  uint8_t bd_promisc;
  uint8_t bd_state;
  uint8_t bd_immediate;
  uint32_t bd_dev_minor;
  int bd_async;
  int bd_sig;
  pid_t bd_sigio;
  selinfo bd_sel;
  int bd_hdrcmplt;
  int bd_seesent;
  int bd_oflags;
  thread_call_t bd_thread_call;
  int bd_traffic_class;
  int bd_flags;
  int bd_refcnt;
  void *bd_ref_lr[4];
  void *bd_unref_lr[4];
  int bd_next_ref_lr;
  int bd_next_unref_lr;
  proc *bd_opened_by;
  uuid_t_1 bd_uuid;
  pid_t bd_pid;
  uint8_t bd_prev_slen;
  caddr_t bd_prev_sbuf;
  caddr_t bd_prev_fbuf;
  bpf_comp_stats bd_bcs;
};

/* 8059 */
typedef errno_t (*proto_media_input_0)(ifnet_t, protocol_family_t, mbuf_t, char *);

/* 9290 */
typedef errno_t (*proto_media_preout_0)(ifnet_t, protocol_family_t, mbuf_t *, const sockaddr *, void *, char *, char *);

/* 8058 */
typedef void (*proto_media_event_0)(ifnet_t, protocol_family_t, const kev_msg *);

/* 8057 */
typedef errno_t (*proto_media_ioctl_0)(ifnet_t, protocol_family_t, unsigned __int64, void *);

/* 9289 */
typedef errno_t (*proto_media_detached_0)(ifnet_t, protocol_family_t);

/* 9297 */
typedef errno_t (*proto_media_resolve_multi_1)(ifnet_t, const sockaddr *, sockaddr_dl *, size_t);

/* 4796 */
typedef errno_t (*proto_media_send_arp)(ifnet_t, u_short, const sockaddr_dl *, const sockaddr *, const sockaddr_dl *, const sockaddr *);

/* 8088 */
typedef errno_t (*proto_media_input_v2_0)(ifnet_t, protocol_family_t, mbuf_t);

/* 5009 */
struct if_proto
{
  struct
  {
    if_proto *sle_next;
  } next_hash;
  u_int32_t refcount;
  u_int32_t detached;
  ifnet *ifp;
  protocol_family_t protocol_family;
  int proto_kpi;
  union
  {
    struct
    {
      proto_media_input_0 input;
      proto_media_preout_0 pre_output;
      proto_media_event_0 event;
      proto_media_ioctl_0 ioctl;
      proto_media_detached_0 detached;
      proto_media_resolve_multi_1 resolve_multi;
      proto_media_send_arp send_arp;
    } v1;
    struct
    {
      proto_media_input_v2_0 input;
      proto_media_preout_0 pre_output;
      proto_media_event_0 event;
      proto_media_ioctl_0 ioctl;
      proto_media_detached_0 detached;
      proto_media_resolve_multi_1 resolve_multi;
      proto_media_send_arp send_arp;
    } v2;
  } kpi;
};

/* 2906 */
struct ims_st
{
  uint16_t ex;
  uint16_t in;
};

/* 2907 */
struct __attribute__((aligned(4))) ip_msource
{
  struct
  {
    ip_msource *rbe_left;
    ip_msource *rbe_right;
    ip_msource *rbe_parent;
  } ims_link;
  in_addr_t ims_haddr;
  ims_st ims_st[2];
  uint8_t ims_stp;
};

/* 2883 */
struct __quantum
{
  union
  {
    uuid_t_1 __uuid;
    uint8_t __val8[16];
    uint16_t __val16[8];
    uint32_t __val32[4];
    uint64_t __val64[2];
  } __flow_id_u;
  uint32_t __q_len;
  uint32_t __q_svc_class;
  volatile uint16_t __q_flags;
  uint16_t __q_pad[3];
};

/* 5607 */
typedef uint64_t mach_vm_address_t_0;

/* 5131 */
typedef uint32_t obj_idx_t;

/* 2855 */
struct __buflet
{
  union
  {
    uint64_t __buflet_next;
    const mach_vm_address_t_0 __nbft_addr;
  };
  const mach_vm_address_t_0 __baddr;
  const obj_idx_t __bft_idx;
  const obj_idx_t __bidx;
  const obj_idx_t __nbft_idx;
  const uint16_t __dlim;
  uint16_t __dlen;
  uint16_t __doff;
  const uint16_t __flag;
  const uint16_t __gro_len;
  const uint16_t __buf_off;
};

/* 9471 */
struct __kern_buflet_0
{
  __buflet buf_com;
  const skmem_bufctl *buf_ctl;
};

/* 9880 */
struct __attribute__((aligned(8))) __kern_quantum_0
{
  __quantum qum_com;
  struct
  {
    __kern_quantum *sle_next;
  } qum_upp_link;
  const kern_pbufpool_0 *qum_pp;
  const __user_quantum *qum_user;
  const __kern_slot_desc *qum_ksd;
  __kern_buflet_0 qum_buf[1];
  pid_t qum_pid;
};

/* 5122 */
typedef uint32_t packet_trace_id_t;

/* 2849 */
struct __packet_com
{
  uint16_t __link_flags;
  uint8_t __headroom;
  uint8_t __l2_len;
  uint32_t __csum_flags;
  union
  {
    struct
    {
      uint16_t __csum_start_off;
      uint16_t __csum_value;
    } __csum_rx;
    struct
    {
      uint16_t __csum_start_off;
      uint16_t __csum_stuff_off;
    } __csum_tx;
    uint32_t __csum_data;
  };
  uint32_t __comp_gencnt;
  packet_trace_id_t __trace_id;
  uint8_t __aggr_type;
  uint8_t __seg_cnt;
  uint16_t __proto_seg_sz;
  union
  {
    volatile uint32_t __flags32[2];
    volatile uint64_t __flags;
  };
};

/* 2884 */
struct __packet
{
  union
  {
    uint64_t __pkt_data[4];
    __packet_com __pkt_com;
  };
};

/* 5137 */
typedef uint16_t packet_trace_tag_t;

/* 2886 */
struct __attribute__((aligned(8))) __kern_packet
{
  __kern_quantum_0 pkt_qum;
  __packet pkt_com;
  __packet_opt *pkt_com_opt;
  uint64_t pkt_timestamp;
  __kern_packet *pkt_nextpkt;
  union
  {
    mbuf *pkt_mbuf;
    __kern_packet *pkt_pkt;
  };
  __flow *pkt_flow;
  __packet_compl *pkt_tx_compl;
  void *pkt_priv;
  uint32_t pkt_fpd_seqnum;
  uint16_t pkt_fpd_metadata;
  const uint16_t pkt_bufs_max;
  const uint16_t pkt_bufs_cnt;
  uint32_t pkt_chain_count;
  uint32_t pkt_chain_bytes;
  nexus_port_t pkt_nx_port;
  uint16_t pkt_vpna_gencnt;
  packet_trace_tag_t pkt_trace_tag;
  uint8_t pkt_qset_idx;
  uint8_t _pad[1];
};

/* 7259 */
struct _lck_grp_stat_
{
  uint64_t lgs_count;
  uint32_t lgs_enablings;
  uint32_t lgs_probeid;
  uint64_t lgs_limit;
};

/* 1051 */
typedef _lck_grp_stat_ lck_grp_stat_t;

/* 7260 */
struct _lck_grp_stats_
{
  lck_grp_stat_t lgss_spin_held;
  lck_grp_stat_t lgss_spin_miss;
  lck_grp_stat_t lgss_spin_spin;
  lck_grp_stat_t lgss_ticket_held;
  lck_grp_stat_t lgss_ticket_miss;
  lck_grp_stat_t lgss_ticket_spin;
  lck_grp_stat_t lgss_mtx_held;
  lck_grp_stat_t lgss_mtx_direct_wait;
  lck_grp_stat_t lgss_mtx_miss;
  lck_grp_stat_t lgss_mtx_wait;
};

/* 1052 */
typedef _lck_grp_stats_ lck_grp_stats_t;

/* 7776 */
struct _lck_grp_
{
  os_ref_atomic_t lck_grp_refcnt;
  uint32_t lck_grp_attr_id;
  uint32_t lck_grp_spincnt;
  uint32_t lck_grp_ticketcnt;
  uint32_t lck_grp_mtxcnt;
  uint32_t lck_grp_rwcnt;
  char lck_grp_name[64];
  lck_grp_stats_t lck_grp_stats;
};

/* 4316 */
struct pf_addr
{
  union
  {
    in_addr _v4addr;
    in6_addr_0 _v6addr;
    u_int8_t _addr8[16];
    u_int16_t _addr16[8];
    u_int32_t _addr32[4];
  } pfa;
};

/* 4317 */
struct __attribute__((aligned(4))) pfi_dynaddr
{
  struct
  {
    pfi_dynaddr *tqe_next;
    pfi_dynaddr **tqe_prev;
  } entry;
  pf_addr pfid_addr4;
  pf_addr pfid_mask4;
  pf_addr pfid_addr6;
  pf_addr pfid_mask6;
  pfr_ktable *pfid_kt;
  pfi_kif *pfid_kif;
  void *pfid_hook_cookie;
  uint8_t pfid_net;
  int pfid_acnt4;
  int pfid_acnt6;
  sa_family_t pfid_af;
  u_int8_t pfid_iflags;
};

/* 8170 */
struct __attribute__((aligned(8))) classq_pkt
{
  union
  {
    mbuf *cp_mbuf;
    __kern_packet *cp_kpkt;
  };
  classq_pkt_type_t cp_ptype;
};

/* 5105 */
typedef uint32_t slot_idx_t;

/* 5106 */
enum txrx : __int32
{
  txrx::NR_RX = 0x0,
  txrx::NR_TX = 0x1,
  txrx::NR_TXRX = 0x2,
  txrx::NR_A = 0x2,
  txrx::NR_F = 0x3,
  txrx::NR_TXRXAF = 0x4,
  txrx::NR_EV = 0x4,
  txrx::NR_ALL = 0x5,
};

/* 865 */
struct lck_spin_t
{
  uintptr_t opaque[2];
};

/* 5088 */
enum kern_packet_svc_class_t : __int32
{
  KPKT_SC_UNSPEC = 0xFFFFFFFF,
  KPKT_SC_BK_SYS = 0x80090,
  KPKT_SC_BK = 0x100080,
  KPKT_SC_BE = 0x0,
  KPKT_SC_RD = 0x180010,
  KPKT_SC_OAM = 0x200020,
  KPKT_SC_AV = 0x280120,
  KPKT_SC_RV = 0x300110,
  KPKT_SC_VI = 0x380100,
  KPKT_SC_SIG = 0x380130,
  KPKT_SC_VO = 0x400180,
  KPKT_SC_CTL = 0x480190,
};

/* 2954 */
struct nx_mbq
{
  lck_mtx_t nx_mbq_lock;
  class_queue_t nx_mbq_q;
  lck_grp_t *nx_mbq_grp;
  __kern_channel_ring *nx_mbq_kring;
};

/* 2953 */
struct channel_ring_error_stats
{
  uint32_t cres_pkt_alloc_failures;
  uint32_t __cres_reserved[1];
};

/* 2952 */
struct channel_ring_stats
{
  uint64_t crs_total_slots_transferred;
  uint64_t crs_total_bytes_transferred;
  uint64_t crs_number_of_transfers;
  uint32_t crs_min_slots_transferred;
  uint32_t crs_max_slots_transferred;
  uint32_t crs_slots_per_second;
  uint32_t crs_slots_per_second_ma;
  uint64_t crs_bytes_per_second;
  uint64_t crs_bytes_per_second_ma;
  uint32_t __crs_reserved[2];
};

/* 2951 */
struct channel_ring_user_stats
{
  uint64_t crsu_total_slots_transferred;
  uint64_t crsu_total_bytes_transferred;
  uint64_t crsu_number_of_syncs;
  uint32_t crsu_min_slots_transferred;
  uint32_t crsu_max_slots_transferred;
  uint32_t crsu_slots_per_sync;
  uint32_t crsu_slots_per_sync_ma;
  uint64_t crsu_bytes_per_sync;
  uint64_t crsu_bytes_per_sync_ma;
  uint32_t __crsu_reserved[2];
};

/* 2956 */
struct __attribute__((aligned(32))) __kern_channel_ring
{
  __user_channel_ring *ckr_ring;
  uint32_t ckr_flags;
  slot_idx_t ckr_num_slots;
  uint32_t ckr_max_pkt_len;
  uint32_t ckr_largest;
  const slot_idx_t ckr_lim;
  txrx ckr_tx;
  volatile slot_idx_t ckr_khead;
  volatile slot_idx_t ckr_ktail;
  volatile slot_idx_t ckr_khead_pre;
  volatile slot_idx_t ckr_rhead;
  volatile slot_idx_t ckr_rtail;
  uint32_t ckr_transfer_decay;
  uint64_t ckr_ready_bytes;
  uint64_t ckr_ready_slots;
  lck_spin_t ckr_slock;
  thread *ckr_owner;
  uint32_t ckr_busy;
  uint32_t ckr_want;
  uint32_t ckr_state;
  volatile uint32_t ckr_alloc_ws;
  nexus_adapter *ckr_na;
  kern_pbufpool *ckr_pp;
  __slot_desc *ckr_usds;
  __slot_desc *ckr_ksds;
  __slot_desc *ckr_ksds_last;
  skmem_cache *ckr_ksds_cache;
  uint32_t ckr_ring_id;
  boolean_t ckr_rate_limited;
  uint64_t *ckr_scratch;
  int (*ckr_na_sync)(__kern_channel_ring *, proc *, uint32_t);
  int (*volatile ckr_na_notify)(__kern_channel_ring *, proc *, uint32_t);
  int (*ckr_prologue)(kern_channel *, __kern_channel_ring *, const slot_idx_t, uint32_t *, uint64_t *, proc *);
  void (*ckr_finalize)(kern_channel *, __kern_channel_ring *, const slot_idx_t, proc *);
  uint64_t ckr_sync_time;
  int (*ckr_save_notify)(__kern_channel_ring *, proc *, uint32_t);
  uint32_t *ckr_leases;
  slot_idx_t ckr_klease;
  slot_idx_t ckr_lease_idx;
  kern_packet_svc_class_t ckr_svc;
  uint32_t ckr_slot_ctxs_set;
  slot_ctx *ckr_slot_ctxs;
  void *ckr_ctx;
  ch_selinfo ckr_si;
  int (*ckr_netif_notify)(__kern_channel_ring *, proc *, uint32_t);
  void (*ckr_netif_mit_stats)(__kern_channel_ring *, uint64_t, uint64_t);
  nx_netif_mit *ckr_mit;
  volatile uint32_t ckr_pending_intr;
  volatile uint32_t ckr_pending_doorbell;
  mbuf **ckr_tx_pool;
  nx_mbq ckr_rx_queue;
  __kern_channel_ring *ckr_pipe;
  __user_channel_ring *ckr_save_ring;
  lck_mtx_t ckr_qlock;
  __kern_channel_ring **ckr_monitors;
  uint32_t ckr_max_monitors;
  uint32_t ckr_n_monitors;
  int (*ckr_mon_sync)(__kern_channel_ring *, proc *, uint32_t);
  int (*ckr_mon_notify)(__kern_channel_ring *, proc *, uint32_t);
  uint32_t ckr_mon_tail;
  uint32_t ckr_mon_pos;
  uint32_t ckr_users;
  int64_t ckr_tbr_token;
  int64_t ckr_tbr_depth;
  uint64_t ckr_tbr_last;
  channel_ring_error_stats ckr_err_stats;
  channel_ring_stats ckr_stats;
  uint64_t ckr_accumulated_bytes;
  uint64_t ckr_accumulated_slots;
  uint64_t ckr_accumulate_start;
  channel_ring_user_stats ckr_usr_stats;
  uint64_t ckr_user_accumulated_bytes;
  uint64_t ckr_user_accumulated_slots;
  uint64_t ckr_user_accumulated_syncs;
  uint64_t ckr_user_accumulate_start;
  lck_grp_t *ckr_qlock_group;
  lck_grp_t *ckr_slock_group;
  char ckr_name[64];
};

/* 5104 */
typedef void (*nexus_ctx_release_fn_t)(void *const);

/* 5087 */
enum nexus_advisory_type_t : __int32
{
  NEXUS_ADVISORY_TYPE_INVALID = 0x0,
  NEXUS_ADVISORY_TYPE_FLOWSWITCH = 0x1,
  NEXUS_ADVISORY_TYPE_NETIF = 0x2,
};

/* 2979 */
struct kern_nexus_advisory
{
  skmem_region *nxv_reg;
  void *nxv_adv;
  nexus_advisory_type_t nxv_adv_type;
  union
  {
    sk_nexusadv *flowswitch_nxv_adv;
    netif_nexus_advisory *netif_nxv_adv;
  };
};

/* 5124 */
typedef uint64_t bitmap_t;

/* 5103 */
typedef nexus_port_t nexus_port_size_t;

/* 2980 */
struct __attribute__((aligned(8))) kern_nexus
{
  uint32_t nx_refcnt;
  volatile uint32_t nx_flags;
  void *nx_ctx;
  nexus_ctx_release_fn_t nx_ctx_release;
  kern_nexus_provider *nx_prov;
  uint64_t nx_id;
  uuid_t_1 nx_uuid;
  struct
  {
    kern_nexus *stqe_next;
  } nx_prov_link;
  struct
  {
    kern_nexus *rbe_left;
    kern_nexus *rbe_right;
    kern_nexus *rbe_parent;
  } nx_link;
  struct
  {
    kern_channel *stqh_first;
    kern_channel **stqh_last;
  } nx_ch_head;
  uint32_t nx_ch_count;
  struct
  {
    kern_channel *stqh_first;
    kern_channel **stqh_last;
  } nx_ch_nonxref_head;
  lck_rw_t nx_ch_if_adv_lock;
  struct
  {
    kern_channel *stqh_first;
    kern_channel **stqh_last;
  } nx_ch_if_adv_head;
  void *nx_arg;
  kern_pbufpool *nx_rx_pp;
  kern_pbufpool *nx_tx_pp;
  kern_nexus_advisory nx_adv;
  nx_port_info *nx_ports;
  bitmap_t *nx_ports_bmap;
  nexus_port_size_t nx_active_ports;
  nexus_port_size_t nx_num_ports;
};

/* 5084 */
enum skmem_arena_type_t : __int32
{
  SKMEM_ARENA_TYPE_NEXUS = 0x0,
  SKMEM_ARENA_TYPE_NECP = 0x1,
  SKMEM_ARENA_TYPE_SYSTEM = 0x2,
};

/* 1201 */
typedef IOSKArena *IOSKArenaRef;

/* 7087 */
typedef uint64_t mach_vm_size_t_0;

/* 2946 */
struct skmem_arena
{
  lck_mtx_t ar_lock;
  uint32_t ar_refcnt;
  struct
  {
    skmem_arena *tqe_next;
    skmem_arena **tqe_prev;
  } ar_link;
  char ar_name[64];
  skmem_arena_type_t ar_type;
  uint32_t ar_flags;
  size_t ar_zsize;
  IOSKArenaRef ar_ar;
  skmem_region *ar_regions[28];
  mach_vm_size_t_0 ar_mapsize;
  uint32_t ar_mapcnt;
  uint32_t ar_maprdrcnt;
  struct
  {
    skmem_arena_mmap_info *slh_first;
  } ar_map_head;
};

/* 2982 */
typedef kern_nexus_domain_provider *kern_nexus_domain_provider_t;

/* 2984 */
typedef errno_t (*nxdom_prov_init_fn_t)(kern_nexus_domain_provider_t);

/* 2983 */
typedef void (*nxdom_prov_fini_fn_t)(kern_nexus_domain_provider_t);

/* 2986 */
struct kern_nexus_domain_provider_init
{
  uint32_t nxdpi_version;
  uint32_t nxdpi_flags;
  nxdom_prov_init_fn_t nxdpi_init;
  nxdom_prov_fini_fn_t nxdpi_fini;
};

/* 2985 */
struct nxdom_prov_cb
{
  int (*dp_cb_init)(kern_nexus_domain_provider *);
  void (*dp_cb_fini)(kern_nexus_domain_provider *);
  int (*dp_cb_params)(kern_nexus_domain_provider *, const uint32_t, const nxprov_params *, nxprov_params *, skmem_region_params *, uint32_t);
  int (*dp_cb_mem_new)(kern_nexus_domain_provider *, kern_nexus *, nexus_adapter *);
  int (*dp_cb_config)(kern_nexus_domain_provider *, kern_nexus *, nx_cfg_req *, int, proc *, kauth_cred_t);
  int (*dp_cb_nx_ctor)(kern_nexus *);
  void (*dp_cb_nx_dtor)(kern_nexus *);
  int (*dp_cb_nx_mem_info)(kern_nexus *, kern_pbufpool **, kern_pbufpool **);
  size_t (*dp_cb_nx_mib_get)(kern_nexus *, nexus_mib_filter *, void *, size_t, proc *);
  int (*dp_cb_nx_stop)(kern_nexus *);
};

/* 2987 */
struct kern_nexus_domain_provider
{
  struct
  {
    kern_nexus_domain_provider *stqe_next;
  } nxdom_prov_link;
  struct
  {
    kern_nexus_domain_provider *stqe_next;
  } nxdom_prov_detaching_link;
  char nxdom_prov_name[64];
  uuid_t_1 nxdom_prov_uuid;
  uint64_t nxdom_prov_gencnt;
  uint32_t nxdom_prov_refcnt;
  uint32_t nxdom_prov_flags;
  nxdom *nxdom_prov_dom;
  kern_nexus_domain_provider_init nxdom_prov_ext;
  nxdom_prov_cb nxdom_prov_cb;
};

/* 2947 */
struct slot_ctx
{
  mach_vm_address_t_0 slot_ctx_arg;
};

/* 5099 */
enum ch_endpoint_t : __int32
{
  CH_ENDPOINT_NULL = 0x0,
  CH_ENDPOINT_USER_PIPE_MASTER = 0x1,
  CH_ENDPOINT_USER_PIPE_SLAVE = 0x2,
  CH_ENDPOINT_KERNEL_PIPE = 0x3,
  CH_ENDPOINT_NET_IF = 0x4,
  CH_ENDPOINT_FLOW_SWITCH = 0x5,
};

/* 2944 */
struct nexus_upipe_adapter
{
  nexus_adapter_0 pna_up;
  uint32_t pna_id;
  ch_endpoint_t pna_role;
  nexus_adapter *pna_parent;
  nexus_upipe_adapter *pna_peer;
  boolean_t pna_peer_ref;
  uint32_t pna_parent_slot;
};

/* 2957 */
struct nexus_adapter
{
  volatile uint32_t na_flags;
  nexus_adapter_type_t na_type;
  const nexus_meta_type_t na_md_type;
  const nexus_meta_subtype_t na_md_subtype;
  nexus_port_t na_nx_port;
  uint32_t na_channels;
  uint32_t na_num_rx_rings;
  uint32_t na_num_tx_rings;
  uint32_t na_num_allocator_ring_pairs;
  uint32_t na_num_event_rings;
  uint64_t na_work_ts;
  __kern_channel_ring *na_tx_rings;
  __kern_channel_ring *na_rx_rings;
  kern_nexus *na_nx;
  volatile uint32_t na_refcount;
  int na_si_users[5];
  ch_selinfo na_si[5];
  skmem_arena *na_arena;
  uint32_t na_num_tx_slots;
  uint32_t na_num_rx_slots;
  uint32_t na_num_allocator_slots;
  uint32_t na_num_event_slots;
  uint32_t na_total_slots;
  const uint32_t na_flowadv_max;
  const nexus_stats_type_t na_stats_type;
  __kern_channel_ring *na_alloc_rings;
  __kern_channel_ring *na_free_rings;
  __kern_channel_ring *na_event_rings;
  uint64_t na_ch_mit_ival;
  kern_nexus_domain_provider *na_nxdom_prov;
  slot_ctx *na_slot_ctxs;
  kern_packet_t *na_scratch;
  __kern_channel_ring *na_tail;
  void *na_private;
  ifnet *na_ifp;
  uint8_t na_kring_svc_lut[10];
  uint32_t na_next_pipe;
  uint32_t na_max_pipes;
  nexus_upipe_adapter **na_pipes;
  char na_name[64];
  uuid_t_1 na_uuid;
  int (*na_activate)(nexus_adapter *, na_activate_mode_t);
  int (*na_special)(nexus_adapter *, kern_channel *, chreq *, nxspec_cmd_t);
  int (*na_txsync)(__kern_channel_ring *, proc *, uint32_t);
  int (*na_rxsync)(__kern_channel_ring *, proc *, uint32_t);
  int (*na_notify)(__kern_channel_ring *, proc *, uint32_t);
  int (*na_channel_event_notify)(nexus_adapter *, __kern_channel_event *, uint16_t);
  int (*na_config)(nexus_adapter *, uint32_t *, uint32_t *, uint32_t *, uint32_t *);
  int (*na_krings_create)(nexus_adapter *, kern_channel *);
  void (*na_krings_delete)(nexus_adapter *, kern_channel *, boolean_t);
  void (*na_dtor)(nexus_adapter *);
  void (*na_free)(nexus_adapter *);
  void (*na_rx)(nexus_adapter *, __kern_packet *, nexus_pkt_stats *);
};

/* 5101 */
typedef uint32_t ring_id_t;

/* 1470 */
typedef uint64_t mach_vm_offset_t;

/* 5085 */
typedef IOSKMapper *IOSKMapperRef;

/* 8091 */
typedef struct task *task_t_1;

/* 2945 */
struct __attribute__((aligned(8))) skmem_arena_mmap_info
{
  struct
  {
    skmem_arena_mmap_info *sle_next;
  } ami_link;
  skmem_arena *ami_arena;
  IOSKMapperRef ami_mapref;
  task_t_1 ami_maptask;
  mach_vm_address_t_0 ami_mapaddr;
  mach_vm_size_t_0 ami_mapsize;
  boolean_t ami_redirect;
};

/* 2958 */
struct kern_channel
{
  lck_mtx_t ch_lock;
  nexus_adapter *ch_na;
  kern_nexus *ch_nexus;
  ch_info *ch_info;
  kern_pbufpool *ch_pp;
  uint32_t ch_refcnt;
  volatile uint32_t ch_flags;
  ring_id_t ch_first[5];
  ring_id_t ch_last[5];
  __user_channel_schema *ch_schema;
  ch_selinfo *ch_si[5];
  struct
  {
    kern_channel *stqe_next;
  } ch_link;
  struct
  {
    kern_channel *stqe_next;
  } ch_link_if_adv;
  void *ch_ctx;
  mach_vm_offset_t ch_schema_offset;
  skmem_arena_mmap_info ch_mmap;
  int ch_fd;
  pid_t ch_pid;
  char ch_name[32];
};

/* 5098 */
enum channel_threshold_unit_t : __int32
{
  CHANNEL_THRESHOLD_UNIT_SLOTS = 0x0,
  CHANNEL_THRESHOLD_UNIT_BYTES = 0x1,
};

/* 2942 */
struct ch_ev_thresh
{
  channel_threshold_unit_t cet_unit;
  uint32_t cet_value;
};

/* 5100 */
enum ring_set_t : __int32
{
  RING_SET_ALL = 0x0,
  RING_SET_DEFAULT = 0x0,
};

/* 2943 */
struct chreq
{
  char cr_name[64];
  uuid_t_1 cr_spec_uuid;
  ch_ev_thresh cr_tx_lowat;
  ch_ev_thresh cr_rx_lowat;
  nexus_port_t cr_port;
  uint32_t cr_mode;
  uint32_t cr_pipe_id;
  ring_id_t cr_ring_id;
  ring_set_t cr_ring_set;
  ch_endpoint_t cr_real_endpoint;
  ch_endpoint_t cr_endpoint;
  mach_vm_size_t_0 cr_memsize;
  mach_vm_offset_t cr_memoffset;
};

/* 5080 */
enum os_channel_event_type_t : __int32
{
  CHANNEL_EVENT_PACKET_TRANSMIT_STATUS = 0x1,
  CHANNEL_EVENT_MIN = 0x1,
  CHANNEL_EVENT_MAX = 0x1,
};

/* 2941 */
struct __kern_channel_event
{
  os_channel_event_type_t ev_type;
  uint32_t ev_flags;
  uint16_t _reserved;
  uint16_t ev_dlen;
  uint8_t ev_data[];
};

/* 2940 */
struct nexus_pkt_stats
{
  uint64_t nps_pkts;
  uint64_t nps_bytes;
};

/* 3027 */
struct __attribute__((aligned(16))) netif_stats
{
  uint64_t _arr[131];
};

/* 3025 */
struct netif_agent_flow_head
{
  netif_agent_flow *slh_first;
};

/* 5092 */
typedef void *netagent_session_t;

/* 3006 */
typedef void pkt_copy_from_mbuf_t(const txrx, kern_packet_t, const uint16_t, mbuf *, const uint16_t, const uint32_t, const boolean_t, const uint16_t);

/* 3005 */
typedef void pkt_copy_to_mbuf_t(const txrx, kern_packet_t, const uint16_t, mbuf *, const uint16_t, const uint32_t, const boolean_t, const uint16_t);

/* 5090 */
typedef void pkt_copy_from_pkt_t(const txrx, kern_packet_t, const uint16_t, kern_packet_t, const uint16_t, const uint32_t, const boolean_t, const uint16_t, const uint16_t, const boolean_t);

/* 3024 */
struct netif_filter_head
{
  netif_filter *stqh_first;
  netif_filter **stqh_last;
};

/* 3004 */
struct nx_pktq
{
  lck_mtx_t nx_pktq_lock;
  class_queue_t nx_pktq_q;
  lck_grp_t *nx_pktq_grp;
  __kern_channel_ring *nx_pktq_kring;
};

/* 3023 */
struct netif_flow_head
{
  netif_flow *slh_first;
};

/* 5091 */
typedef errno_t (*kern_nexus_capab_interface_advisory_config_fn_t)(void *, bool);

/* 2994 */
typedef errno_t (*kern_nexus_capab_qsext_notify_steering_info_fn_t)(void *, void *, ifnet_traffic_descriptor_common *, bool);

/* 3022 */
struct netif_qset_extensions
{
  kern_nexus_capab_qsext_notify_steering_info_fn_t qe_notify_steering_info;
  void *qe_prov_ctx;
};

/* 3028 */
struct nx_netif
{
  lck_rw_t nif_lock;
  kern_nexus *nif_nx;
  nxbind *nif_dev_nxb;
  nxbind *nif_host_nxb;
  uuid_t_1 nif_uuid;
  netif_stats nif_stats;
  uint32_t nif_flags;
  os_refcnt nif_refcnt;
  lck_mtx_t nif_agent_lock;
  netif_agent_flow_head nif_agent_flow_list;
  uint32_t nif_agent_flow_cnt;
  uint32_t nif_agent_flags;
  netagent_session_t nif_agent_session;
  uuid_t_1 nif_agent_uuid;
  uint32_t nif_hwassist;
  uint32_t nif_capabilities;
  uint32_t nif_capenable;
  uint64_t nif_input_rate;
  ifnet *nif_ifp;
  nx_flowswitch *nif_fsw;
  sk_nexusadv *nif_fsw_nxadv;
  netif_nexus_advisory *nif_netif_nxadv;
  pkt_copy_from_mbuf_t *nif_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *nif_pkt_copy_to_mbuf;
  pkt_copy_from_pkt_t *nif_pkt_copy_from_pkt;
  lck_mtx_t nif_filter_lock;
  uint32_t nif_filter_flags;
  uint32_t nif_filter_vp_cnt;
  uint32_t nif_filter_cnt;
  kern_pbufpool_1 *nif_filter_pp;
  netif_filter_head nif_filter_list;
  union
  {
    nx_mbq nif_tx_processed_mbq[4];
    nx_pktq nif_tx_processed_pktq[4];
  };
  lck_mtx_t nif_flow_lock;
  uint32_t nif_vp_cnt;
  uint32_t nif_flow_flags;
  uint32_t nif_flow_cnt;
  netif_flow_head nif_flow_list;
  netif_flowtable *nif_flow_table;
  kern_channel *nif_hw_ch;
  uint32_t nif_hw_ch_refcnt;
  lck_rw_t nif_llink_lock;
  kern_nexus_netif_llink_init *nif_default_llink_params;
  netif_llink *nif_default_llink;
  struct
  {
    netif_llink *stqh_first;
    netif_llink **stqh_last;
  } nif_llink_list;
  uint16_t nif_llink_cnt;
  uint32_t nif_extended_capabilities;
  kern_nexus_capab_interface_advisory_config_fn_t nif_intf_adv_config;
  void *nif_intf_adv_prov_ctx;
  netif_qset_extensions nif_qset_extensions;
};

/* 5083 */
enum mit_mode_t : __int32
{
  MIT_MODE_SIMPLE = 0x0,
  MIT_MODE_ADVANCED_STATIC = 0x1,
  MIT_MODE_ADVANCED_DYNAMIC = 0x2,
};

/* 3018 */
struct mit_cfg_tbl
{
  uint32_t cfg_plowat;
  uint32_t cfg_phiwat;
  uint32_t cfg_blowat;
  uint32_t cfg_bhiwat;
  uint32_t cfg_ival;
};

/* 3019 */
struct __attribute__((aligned(8))) nx_netif_mit
{
  lck_spin_t mit_lock;
  volatile __kern_channel_ring *mit_ckr;
  uint32_t mit_flags;
  uint32_t mit_requests;
  uint32_t mit_interval;
  uint32_t mit_cfg_idx_max;
  uint32_t mit_cfg_idx;
  const mit_cfg_tbl *mit_cfg;
  mit_mode_t mit_mode;
  uint32_t mit_packets_avg;
  uint32_t mit_packets_min;
  uint32_t mit_packets_max;
  uint32_t mit_bytes_avg;
  uint32_t mit_bytes_min;
  uint32_t mit_bytes_max;
  pktcntr mit_sstats;
  timespec mit_mode_holdtime;
  timespec mit_mode_lasttime;
  timespec mit_sample_time;
  timespec mit_sample_lasttime;
  timespec mit_start_time;
  thread *mit_thread;
  char mit_name[64];
  const ifnet *mit_netif_ifp;
  mit_cfg_tbl mit_tbl[5];
};

/* 3017 */
struct netif_filter
{
  struct
  {
    netif_filter *stqe_next;
  } nf_link;
  nexus_port_t nf_port;
  uint32_t nf_refcnt;
  void *nf_cb_arg;
  errno_t (*nf_cb_func)(void *, __kern_packet *, uint32_t);
};

/* 3015 */
struct netif_flow_desc
{
  uint16_t fd_ethertype;
  in6_addr_0 fd_laddr;
  in6_addr_0 fd_raddr;
};

/* 3016 */
struct netif_flow
{
  struct
  {
    netif_flow *sle_next;
  } nf_link;
  struct
  {
    netif_flow *sle_next;
  } nf_table_link;
  nexus_port_t nf_port;
  uint32_t nf_refcnt;
  netif_flow_desc nf_desc;
  void *nf_cb_arg;
  errno_t (*nf_cb_func)(void *, void *, uint32_t);
};

/* 2806 */
struct __attribute__((aligned(8))) radix_mask
{
  short rm_bit;
  char rm_unused;
  u_char rm_flags;
  radix_mask *rm_mklist;
  union
  {
    caddr_t rm_mask;
    radix_node *rm_leaf;
  };
  int rm_refs;
};

/* 2805 */
struct __attribute__((aligned(8))) rt_reach_info
{
  u_int32_t ri_refcnt;
  u_int32_t ri_probes;
  u_int64_t ri_snd_expire;
  u_int64_t ri_rcv_expire;
  int32_t ri_rssi;
  int32_t ri_lqm;
  int32_t ri_npm;
};

/* 2804 */
struct ifnet_llreach_info
{
  u_int32_t iflri_refcnt;
  u_int32_t iflri_probes;
  u_int64_t iflri_snd_expire;
  u_int64_t iflri_rcv_expire;
  u_int64_t iflri_curtime;
  u_int32_t iflri_netproto;
  u_int8_t iflri_addr[64];
  int32_t iflri_rssi;
  int32_t iflri_lqm;
  int32_t iflri_npm;
};

/* 2809 */
struct rt_metrics
{
  u_int32_t rmx_locks;
  u_int32_t rmx_mtu;
  u_int32_t rmx_hopcount;
  int32_t rmx_expire;
  u_int32_t rmx_recvpipe;
  u_int32_t rmx_sendpipe;
  u_int32_t rmx_ssthresh;
  u_int32_t rmx_rtt;
  u_int32_t rmx_rttvar;
  u_int32_t rmx_pksent;
  u_int32_t rmx_state;
  u_int32_t rmx_filler[3];
};

/* 3233 */
struct nstat_counts
{
  u_int64_t nstat_rxpackets;
  u_int64_t nstat_rxbytes;
  u_int64_t nstat_txpackets;
  u_int64_t nstat_txbytes;
  u_int64_t nstat_cell_rxbytes;
  u_int64_t nstat_cell_txbytes;
  u_int64_t nstat_wifi_rxbytes;
  u_int64_t nstat_wifi_txbytes;
  u_int64_t nstat_wired_rxbytes;
  u_int64_t nstat_wired_txbytes;
  u_int32_t nstat_rxduplicatebytes;
  u_int32_t nstat_rxoutoforderbytes;
  u_int32_t nstat_txretransmit;
  u_int32_t nstat_connectattempts;
  u_int32_t nstat_connectsuccesses;
  u_int32_t nstat_min_rtt;
  u_int32_t nstat_avg_rtt;
  u_int32_t nstat_var_rtt;
};

/* 2803 */
struct eventhandler_list
{
  char el_name[32];
  int el_flags;
  u_int el_runcount;
  lck_mtx_t el_lock;
  struct
  {
    eventhandler_list *tqe_next;
    eventhandler_list **tqe_prev;
  } el_link;
  struct
  {
    eventhandler_entry *tqh_first;
    eventhandler_entry **tqh_last;
  } el_entries;
};

/* 2774 */
typedef llentry *llt_lookup_t(lltable *, uint16_t, const sockaddr *);

/* 2773 */
typedef llentry *llt_alloc_t(lltable *, uint16_t, const sockaddr *);

/* 2772 */
typedef void llt_delete_t(lltable *, llentry *);

/* 2771 */
typedef void llt_prefix_free_t(lltable *, const sockaddr *, const sockaddr *, uint16_t);

/* 2770 */
typedef int llt_dump_entry_t(lltable *, llentry *, sysctl_req_0 *);

/* 2769 */
typedef uint32_t llt_hash_t(const llentry *, uint32_t);

/* 2768 */
typedef int llt_match_prefix_t(const sockaddr *, const sockaddr *, uint16_t, llentry *);

/* 2767 */
typedef void llt_free_entry_t(lltable *, llentry *);

/* 2765 */
typedef int llt_foreach_cb_t(lltable *, llentry *, void *);

/* 2766 */
typedef int llt_foreach_entry_t(lltable *, llt_foreach_cb_t *, void *);

/* 2764 */
typedef void llt_link_entry_t(lltable *, llentry *);

/* 2763 */
typedef void llt_unlink_entry_t(llentry *);

/* 2762 */
typedef void llt_fill_sa_entry_t(const llentry *, sockaddr *);

/* 2776 */
struct lltable
{
  struct
  {
    lltable *sle_next;
  } llt_link;
  int llt_af;
  int llt_hsize;
  llentries *lle_head;
  ifnet *llt_ifp;
  llt_lookup_t *llt_lookup;
  llt_alloc_t *llt_alloc_entry;
  llt_delete_t *llt_delete_entry;
  llt_prefix_free_t *llt_prefix_free;
  llt_dump_entry_t *llt_dump_entry;
  llt_hash_t *llt_hash;
  llt_match_prefix_t *llt_match_prefix;
  llt_free_entry_t *llt_free_entry;
  llt_foreach_entry_t *llt_foreach_entry;
  llt_link_entry_t *llt_link_entry;
  llt_unlink_entry_t *llt_unlink_entry;
  llt_fill_sa_entry_t *llt_fill_sa_entry;
};

/* 2775 */
struct llentries
{
  llentry *lh_first;
};

/* 3113 */
struct ip6_msource_tree
{
  ip6_msource *rbh_root;
};

/* 3110 */
struct in6m_st
{
  uint16_t iss_fmode;
  uint16_t iss_asm;
  uint16_t iss_ex;
  uint16_t iss_in;
  uint16_t iss_rec;
};

/* 3114 */
struct in6_multi
{
  lck_mtx_t in6m_lock;
  u_int32_t in6m_refcount;
  u_int32_t in6m_reqcnt;
  u_int32_t in6m_debug;
  struct
  {
    in6_multi *le_next;
    in6_multi **le_prev;
  } in6m_entry;
  in6_addr_0 in6m_addr;
  uint32_t ifscope;
  ifnet *in6m_ifp;
  ifmultiaddr *in6m_ifma;
  u_int in6m_state;
  u_int in6m_timer;
  mld_ifinfo *in6m_mli;
  struct
  {
    in6_multi *sle_next;
  } in6m_dtle;
  struct
  {
    in6_multi *sle_next;
  } in6m_nrele;
  u_int32_t in6m_nrelecnt;
  ip6_msource_tree in6m_srcs;
  u_long in6m_nsrc;
  ifqueue in6m_scq;
  timeval in6m_lastgsrtv;
  uint16_t in6m_sctimer;
  uint16_t in6m_scrv;
  in6m_st in6m_st[2];
  void (*in6m_trace)(in6_multi *, int);
};

/* 3128 */
struct __attribute__((aligned(4))) ns_flow_info
{
  uuid_t_1 nfi_flow_uuid;
  ifnet *nfi_ifp;
  sockaddr_in_4_6 nfi_laddr;
  sockaddr_in_4_6 nfi_faddr;
  uint8_t nfi_protocol;
  uint8_t nfi_pad[3];
  pid_t nfi_owner_pid;
  pid_t nfi_effective_pid;
  char nfi_owner_name[17];
  char nfi_effective_name[17];
};

/* 9476 */
struct _pktsched_pkt_
{
  classq_pkt_t __pkt;
  classq_pkt_t __tail;
  uint32_t __plen;
  uint32_t __pcnt;
};

/* 4504 */
struct heap_elem
{
  uint64_t key;
  pktsched_pkt_t pkt;
};

/* 4505 */
struct heap
{
  size_t limit;
  size_t size;
  heap_elem p[];
};

/* 8257 */
enum cc_impl : __int32
{
  cc_impl::CC_IMPL_UNKNOWN = 0x0,
  cc_impl::CC_IMPL_SHA256_LTC = 0x1,
  cc_impl::CC_IMPL_SHA256_VNG_ARM = 0x2,
  cc_impl::CC_IMPL_SHA256_VNG_ARM64_NEON = 0x3,
  cc_impl::CC_IMPL_SHA256_VNG_INTEL_SUPPLEMENTAL_SSE3 = 0x4,
  cc_impl::CC_IMPL_SHA256_VNG_INTEL_AVX1 = 0x5,
  cc_impl::CC_IMPL_SHA256_VNG_INTEL_AVX2 = 0x6,
  cc_impl::CC_IMPL_AES_ECB_LTC = 0xB,
  cc_impl::CC_IMPL_AES_ECB_ARM = 0xC,
  cc_impl::CC_IMPL_AES_ECB_INTEL_OPT = 0xD,
  cc_impl::CC_IMPL_AES_ECB_INTEL_AESNI = 0xE,
  cc_impl::CC_IMPL_AES_ECB_SKG = 0xF,
  cc_impl::CC_IMPL_AES_ECB_TRNG = 0x10,
  cc_impl::CC_IMPL_AES_XTS_GENERIC = 0x15,
  cc_impl::CC_IMPL_AES_XTS_ARM = 0x16,
  cc_impl::CC_IMPL_AES_XTS_INTEL_OPT = 0x17,
  cc_impl::CC_IMPL_AES_XTS_INTEL_AESNI = 0x18,
  cc_impl::CC_IMPL_SHA1_LTC = 0x1F,
  cc_impl::CC_IMPL_SHA1_VNG_ARM = 0x20,
  cc_impl::CC_IMPL_SHA1_VNG_INTEL_SUPPLEMENTAL_SSE3 = 0x21,
  cc_impl::CC_IMPL_SHA1_VNG_INTEL_AVX1 = 0x22,
  cc_impl::CC_IMPL_SHA1_VNG_INTEL_AVX2 = 0x23,
  cc_impl::CC_IMPL_SHA384_LTC = 0x29,
  cc_impl::CC_IMPL_SHA384_VNG_ARM = 0x2A,
  cc_impl::CC_IMPL_SHA384_VNG_INTEL_SUPPLEMENTAL_SSE3 = 0x2B,
  cc_impl::CC_IMPL_SHA384_VNG_INTEL_AVX1 = 0x2C,
  cc_impl::CC_IMPL_SHA384_VNG_INTEL_AVX2 = 0x2D,
  cc_impl::CC_IMPL_SHA512_LTC = 0x33,
  cc_impl::CC_IMPL_SHA512_VNG_ARM = 0x34,
  cc_impl::CC_IMPL_SHA512_VNG_INTEL_SUPPLEMENTAL_SSE3 = 0x35,
  cc_impl::CC_IMPL_SHA512_VNG_INTEL_AVX1 = 0x36,
  cc_impl::CC_IMPL_SHA512_VNG_INTEL_AVX2 = 0x37,
};

/* 5872 */
typedef cc_impl cc_impl_t;

/* 2094 */
struct __attribute__((aligned(8))) ccdigest_info_0
{
  size_t output_size;
  size_t state_size;
  size_t block_size;
  size_t oid_size;
  const unsigned __int8 *oid;
  const void *initial_state;
  _BYTE gap30[16];
  cc_impl_t impl;
};

/* 5150 */
typedef u_int32_t bpf_u_int32;

/* 5112 */
struct bpf_insn
{
  u_short code;
  u_char jt;
  u_char jf;
  bpf_u_int32 k;
};

/* 3186 */
struct sockaddr_dl
{
  u_char sdl_len;
  u_char sdl_family;
  u_short sdl_index;
  u_char sdl_type;
  u_char sdl_nlen;
  u_char sdl_alen;
  u_char sdl_slen;
  char sdl_data[12];
};

/* 2856 */
struct __kern_buflet
{
  __buflet buf_com;
  const skmem_bufctl *buf_ctl;
};

/* 2885 */
struct __attribute__((aligned(8))) __kern_quantum
{
  __quantum qum_com;
  struct
  {
    __kern_quantum *sle_next;
  } qum_upp_link;
  const kern_pbufpool *qum_pp;
  const __user_quantum *qum_user;
  const __kern_slot_desc *qum_ksd;
  __kern_buflet qum_buf[1];
  pid_t qum_pid;
};

/* 5136 */
typedef void (*pbuf_ctx_retain_fn_t)(void *const);

/* 5135 */
typedef void (*pbuf_ctx_release_fn_t)(void *const);

/* 5134 */
typedef uint8_t pbufpool_name_t[64];

/* 2853 */
typedef kern_pbufpool *kern_pbufpool_t;

/* 2852 */
typedef sksegment *kern_segment_t;

/* 5125 */
typedef IOMemoryDescriptor_0 *IOSKMemoryRef;

/* 5123 */
typedef IOSKMemoryRef IOSKMemoryDescriptor;

/* 7815 */
typedef void (*pbuf_seg_ctor_fn_t_0)(const kern_pbufpool_t, const kern_segment_t, const IOSKMemoryDescriptor);

/* 9220 */
typedef void (*pbuf_seg_dtor_fn_t_0)(const kern_pbufpool_t, const kern_segment_t, const IOSKMemoryDescriptor);

/* 9472 */
struct kern_pbufpool_0
{
  lck_mtx_t pp_lock;
  uint32_t pp_refcnt;
  uint32_t pp_flags;
  uint32_t pp_buf_obj_size[2];
  uint16_t pp_buf_size[2];
  uint16_t pp_max_frags;
  skmem_cache *pp_buf_cache[2];
  skmem_cache *pp_kmd_cache;
  skmem_cache *pp_kbft_cache[2];
  skmem_cache *pp_raw_kbft_cache;
  skmem_region *pp_buf_region[2];
  skmem_region *pp_kmd_region;
  skmem_region *pp_umd_region;
  skmem_region *pp_ubft_region;
  skmem_region *pp_kbft_region;
  kern_pbufpool_u_bkt *pp_u_hash_table;
  uint64_t pp_u_bufinuse;
  kern_pbufpool_u_bft_bkt *pp_u_bft_hash_table;
  uint64_t pp_u_bftinuse;
  void *pp_ctx;
  pbuf_ctx_retain_fn_t pp_ctx_retain;
  pbuf_ctx_release_fn_t pp_ctx_release;
  nexus_meta_type_t pp_md_type;
  nexus_meta_subtype_t pp_md_subtype;
  uint32_t pp_midx_start;
  uint32_t pp_bidx_start;
  pbufpool_name_t pp_name;
  pbuf_seg_ctor_fn_t_0 pp_pbuf_seg_ctor;
  pbuf_seg_dtor_fn_t_0 pp_pbuf_seg_dtor;
};

/* 2854 */
struct __user_buflet
{
  __buflet buf_com;
};

/* 2851 */
struct __attribute__((aligned(8))) __user_quantum
{
  __quantum qum_com;
  __user_buflet qum_buf[1];
  uint16_t qum_usecnt;
};

/* 2850 */
struct __kern_slot_desc
{
  union
  {
    __kern_quantum *sd_qum;
    __kern_packet *sd_pkt;
    __kern_buflet *sd_buf;
    void *sd_md;
  };
};

/* 2873 */
struct skmem_bufctl
{
  struct
  {
    skmem_bufctl *sle_next;
  } bc_link;
  void *bc_addr;
  void *bc_addrm;
  skmem_slab *bc_slab;
  uint32_t bc_lim;
  uint32_t bc_flags;
  uint32_t bc_idx;
  volatile uint32_t bc_usecnt;
};

/* 2847 */
struct __packet_opt_com
{
  union
  {
    uint64_t __token_data[2];
    uint8_t __token[16];
  };
  uint64_t __expire_ts;
  uint16_t __vlan_tag;
  uint16_t __token_len;
  uint8_t __token_type;
  uint8_t __expiry_action;
  uint8_t __app_type;
  uint8_t __app_metadata;
};

/* 2848 */
struct __packet_opt
{
  union
  {
    uint64_t __pkt_opt_data[4];
    __packet_opt_com __pkt_opt_com;
  };
};

/* 2735 */
struct __flow_l3_ipv4_addrs
{
  in_addr _src;
  in_addr _dst;
};

/* 2734 */
struct __flow_l3_ipv6_addrs
{
  in6_addr_0 _src;
  in6_addr_0 _dst;
};

/* 2739 */
struct __flow_l3
{
  union
  {
    __flow_l3_ipv4_addrs _l3_ipv4;
    __flow_l3_ipv6_addrs _l3_ipv6;
  };
  uint8_t _l3_ip_ver;
  uint8_t _l3_proto;
  uint8_t _l3_hlen;
  uint32_t _l3_frag_id;
  mach_vm_address_t_0 _l3_ptr;
};

/* 2738 */
struct __flow_classq
{
  uint32_t _fcq_hash;
  uint32_t _fcq_flags;
};

/* 5121 */
typedef uint32_t flowadv_idx_t;

/* 2737 */
struct __flow_source
{
  union
  {
    uint64_t _fsrc_id_64[2];
    uint32_t _fsrc_id_32[4];
    uuid_t_1 _fsrc_id;
  };
  flowadv_idx_t _fsrc_fidx;
  uint8_t _fsrc_type;
  uint8_t _fsrc_pad[3];
};

/* 2736 */
struct __flow_policy
{
  uint32_t _fpc_id;
  uint32_t _fpc_pad;
  union
  {
    uint64_t _fpc_euuid_64[2];
    uint32_t _fpc_euuid_32[4];
    uuid_t_1 _fpc_euuid;
  };
};

/* 2741 */
struct __flow_init
{
  __flow_l3 __l3;
  __flow_classq __classq;
  uint32_t __ulen;
  uint8_t __ulp_encap;
  uint8_t __pad[3];
  uint64_t __pad64[2];
  __flow_source __source;
  __flow_policy __policy;
};

/* 2733 */
struct __flow_l4_tcp
{
  in_port_t _src;
  in_port_t _dst;
  uint32_t _seq;
  uint32_t _ack;
  union
  {
    struct
    {
      _BYTE gap0;
      uint8_t _flags;
      uint16_t _win;
    };
    uint32_t _ofw;
  };
};

/* 2732 */
struct __flow_l4_udp
{
  in_port_t _src;
  in_port_t _dst;
  uint32_t _ls;
};

/* 2731 */
struct __flow_l4_esp
{
  uint32_t _spi;
};

/* 2740 */
struct __flow_l4
{
  union
  {
    __flow_l4_tcp _l4_tcp;
    __flow_l4_udp _l4_udp;
    __flow_l4_esp _l4_esp;
  };
  uint8_t _l4_hlen;
  uint8_t _l4_agg_fast;
  uint8_t _l4_pad[6];
  mach_vm_address_t_0 _l4_ptr;
};

/* 2742 */
struct __flow
{
  union
  {
    __flow_init flow_init;
    uint64_t flow_init_data[16];
  };
  union
  {
    __flow_l4 flow_l4;
    uint64_t flow_l4_data[4];
  };
};

/* 2730 */
struct __packet_compl
{
  union
  {
    uint64_t compl_data64[3];
    struct
    {
      uintptr_t _cb_arg;
      uintptr_t _cb_data;
      uint32_t _tx_status;
      uint32_t _pad;
    } compl_data;
  };
  uint32_t compl_callbacks;
  uint32_t compl_context;
};

/* 4313 */
struct __attribute__((aligned(4))) pfr_table
{
  char pfrt_anchor[1024];
  char pfrt_name[32];
  uint32_t pfrt_flags;
  uint8_t pfrt_fback;
};

/* 4314 */
struct __attribute__((aligned(8))) pfr_tstats
{
  pfr_table pfrts_t;
  u_int64_t pfrts_packets[2][3];
  u_int64_t pfrts_bytes[2][3];
  u_int64_t pfrts_match;
  u_int64_t pfrts_nomatch;
  u_int64_t pfrts_tzero;
  int pfrts_cnt;
  int pfrts_refcnt[2];
};

/* 4315 */
struct __attribute__((aligned(8))) pfr_ktable
{
  pfr_tstats pfrkt_ts;
  struct
  {
    pfr_ktable *rbe_left;
    pfr_ktable *rbe_right;
    pfr_ktable *rbe_parent;
  } pfrkt_tree;
  struct
  {
    pfr_ktable *sle_next;
  } pfrkt_workq;
  radix_node_head *pfrkt_ip4;
  radix_node_head *pfrkt_ip6;
  pfr_ktable *pfrkt_shadow;
  pfr_ktable *pfrkt_root;
  pf_ruleset *pfrkt_rs;
  u_int64_t pfrkt_larg;
  u_int32_t pfrkt_nflags;
};

/* 2950 */
struct __user_channel_ring
{
  volatile slot_idx_t ring_head;
  const volatile slot_idx_t ring_tail;
  const volatile slot_idx_t ring_khead;
  const uint32_t ring_num_slots;
  const uint32_t ring_def_buf_size;
  const uint32_t ring_large_buf_size;
  const uint16_t ring_md_size;
  const uint16_t ring_bft_size;
  const uint16_t ring_id;
  const uint16_t ring_kind;
  const mach_vm_offset_t ring_def_buf_base;
  const mach_vm_offset_t ring_large_buf_base;
  const mach_vm_offset_t ring_md_base;
  const mach_vm_offset_t ring_sd_base;
  const mach_vm_offset_t ring_bft_base;
  const volatile uint64_t ring_sync_time;
  const volatile uint64_t ring_notify_time;
  const volatile uint32_t ring_alloc_ws;
  const volatile uint32_t ring_alloc_buf_ws;
};

/* 2881 */
typedef void (*pbuf_seg_ctor_fn_t)(const kern_pbufpool_t, const kern_segment_t, const IOSKMemoryDescriptor);

/* 2880 */
typedef void (*pbuf_seg_dtor_fn_t)(const kern_pbufpool_t, const kern_segment_t, const IOSKMemoryDescriptor);

/* 2882 */
struct kern_pbufpool
{
  lck_mtx_t pp_lock;
  uint32_t pp_refcnt;
  uint32_t pp_flags;
  uint32_t pp_buf_obj_size[2];
  uint16_t pp_buf_size[2];
  uint16_t pp_max_frags;
  skmem_cache *pp_buf_cache[2];
  skmem_cache *pp_kmd_cache;
  skmem_cache *pp_kbft_cache[2];
  skmem_cache *pp_raw_kbft_cache;
  skmem_region *pp_buf_region[2];
  skmem_region *pp_kmd_region;
  skmem_region *pp_umd_region;
  skmem_region *pp_ubft_region;
  skmem_region *pp_kbft_region;
  kern_pbufpool_u_bkt *pp_u_hash_table;
  uint64_t pp_u_bufinuse;
  kern_pbufpool_u_bft_bkt *pp_u_bft_hash_table;
  uint64_t pp_u_bftinuse;
  void *pp_ctx;
  pbuf_ctx_retain_fn_t pp_ctx_retain;
  pbuf_ctx_release_fn_t pp_ctx_release;
  nexus_meta_type_t pp_md_type;
  nexus_meta_subtype_t pp_md_subtype;
  uint32_t pp_midx_start;
  uint32_t pp_bidx_start;
  pbufpool_name_t pp_name;
  pbuf_seg_ctor_fn_t pp_pbuf_seg_ctor;
  pbuf_seg_dtor_fn_t pp_pbuf_seg_dtor;
};

/* 2948 */
struct __user_slot_desc
{
  obj_idx_t sd_md_idx;
  uint16_t sd_flags;
  uint16_t sd_len;
};

/* 2949 */
struct __slot_desc
{
  union
  {
    __user_slot_desc _sd_user;
    uint64_t _sd_private[1];
  };
};

/* 2878 */
typedef int (*skmem_ctor_fn_t)(skmem_obj_info *, skmem_obj_info *, void *, uint32_t);

/* 5133 */
typedef void (*skmem_dtor_fn_t)(void *, void *);

/* 5132 */
typedef void (*skmem_reclaim_fn_t)(void *);

/* 2877 */
struct skmem_maglist
{
  struct
  {
    skmem_mag *slh_first;
  } ml_list;
  uint32_t ml_total;
  uint32_t ml_min;
  uint32_t ml_reaplimit;
  uint64_t ml_alloc;
};

/* 2876 */
typedef int (*skmem_slab_alloc_fn_t)(skmem_cache *, skmem_obj_info *, skmem_obj_info *, uint32_t);

/* 2875 */
typedef void (*skmem_slab_free_fn_t)(skmem_cache *, void *);

/* 2860 */
struct __attribute__((aligned(128))) skmem_cpu_cache
{
  lck_mtx_t cp_lock;
  skmem_mag *cp_loaded;
  skmem_mag *cp_ploaded;
  uint64_t cp_alloc;
  uint64_t cp_free;
  int cp_rounds;
  int cp_prounds;
  int cp_magsize;
};

/* 2879 */
struct skmem_cache
{
  uint32_t skm_mode;
  skmem_ctor_fn_t skm_ctor;
  skmem_dtor_fn_t skm_dtor;
  skmem_reclaim_fn_t skm_reclaim;
  void *skm_private;
  lck_mtx_t skm_dp_lock;
  skmem_magtype *skm_magtype;
  skmem_maglist skm_full;
  skmem_maglist skm_empty;
  lck_mtx_t skm_sl_lock;
  skmem_slab_alloc_fn_t skm_slab_alloc;
  skmem_slab_free_fn_t skm_slab_free;
  size_t skm_chunksize;
  size_t skm_objsize;
  size_t skm_slabsize;
  size_t skm_hash_initial;
  size_t skm_hash_limit;
  size_t skm_hash_shift;
  size_t skm_hash_mask;
  skmem_bufctl_bkt *skm_hash_table;
  struct
  {
    skmem_slab *tqh_first;
    skmem_slab **tqh_last;
  } skm_sl_partial_list;
  struct
  {
    skmem_slab *tqh_first;
    skmem_slab **tqh_last;
  } skm_sl_empty_list;
  skmem_region *skm_region;
  uint32_t skm_cpu_mag_size;
  uint32_t skm_cpu_mag_resize;
  uint32_t skm_cpu_mag_purge;
  uint32_t skm_cpu_mag_reap;
  uint64_t skm_depot_contention;
  uint64_t skm_depot_contention_prev;
  uint32_t skm_depot_full;
  uint32_t skm_depot_empty;
  uint32_t skm_depot_ws_zero;
  uint32_t skm_sl_rescale;
  uint32_t skm_sl_create;
  uint32_t skm_sl_destroy;
  uint32_t skm_sl_alloc;
  uint32_t skm_sl_free;
  uint32_t skm_sl_partial;
  uint32_t skm_sl_empty;
  uint64_t skm_sl_alloc_fail;
  uint64_t skm_sl_bufinuse;
  uint64_t skm_sl_bufmax;
  struct
  {
    skmem_cache *tqe_next;
    skmem_cache **tqe_prev;
  } skm_link;
  char skm_name[64];
  uuid_t_1 skm_uuid;
  size_t skm_bufsize;
  size_t skm_bufalign;
  size_t skm_objalign;
  lck_mtx_t skm_rs_lock;
  thread *skm_rs_owner;
  uint32_t skm_rs_busy;
  uint32_t skm_rs_want;
  skmem_cpu_cache skm_cpu_cache[1];
};

/* 2961 */
typedef kern_nexus_provider *kern_nexus_provider_t;

/* 2960 */
typedef kern_nexus *kern_nexus_t;

/* 2959 */
typedef kern_channel *kern_channel_t;

/* 2974 */
typedef errno_t (*nxprov_pre_connect_fn_t)(kern_nexus_provider_t, proc_t, kern_nexus_t, nexus_port_t, kern_channel_t, void **);

/* 2973 */
typedef errno_t (*nxprov_connected_fn_t)(kern_nexus_provider_t, kern_nexus_t, kern_channel_t);

/* 2972 */
typedef void (*nxprov_pre_disconnect_fn_t)(kern_nexus_provider_t, kern_nexus_t, kern_channel_t);

/* 2971 */
typedef void (*nxprov_disconnected_fn_t)(kern_nexus_provider_t, kern_nexus_t, kern_channel_t);

/* 2937 */
typedef __kern_channel_ring *kern_channel_ring_t;

/* 2970 */
typedef errno_t (*nxprov_ring_init_fn_t)(kern_nexus_provider_t, kern_nexus_t, kern_channel_t, kern_channel_ring_t, boolean_t, void **);

/* 2969 */
typedef void (*nxprov_ring_fini_fn_t)(kern_nexus_provider_t, kern_nexus_t, kern_channel_ring_t);

/* 2936 */
typedef __slot_desc *kern_channel_slot_t;

/* 2968 */
typedef errno_t (*nxprov_slot_init_fn_t)(kern_nexus_provider_t, kern_nexus_t, kern_channel_ring_t, kern_channel_slot_t, uint32_t, kern_slot_prop **, void **);

/* 2967 */
typedef void (*nxprov_slot_fini_fn_t)(kern_nexus_provider_t, kern_nexus_t, kern_channel_ring_t, kern_channel_slot_t, uint32_t);

/* 2966 */
typedef errno_t (*nxprov_sync_tx_fn_t)(kern_nexus_provider_t, kern_nexus_t, kern_channel_ring_t, uint32_t);

/* 2965 */
typedef errno_t (*nxprov_sync_rx_fn_t)(kern_nexus_provider_t, kern_nexus_t, kern_channel_ring_t, uint32_t);

/* 2964 */
typedef errno_t (*nxprov_tx_doorbell_fn_t)(kern_nexus_provider_t, kern_nexus_t, kern_channel_ring_t, uint32_t);

/* 2963 */
typedef errno_t (*nxprov_sync_packets_fn_t)(kern_nexus_provider_t, kern_nexus_t, kern_channel_ring_t, uint64_t *, uint32_t *, uint32_t);

/* 5093 */
enum kern_nexus_capab_t : __int32
{
  KERN_NEXUS_CAPAB_INTERFACE_ADVISORY = 0x1,
  KERN_NEXUS_CAPAB_QSET_EXTENSIONS = 0x2,
};

/* 2962 */
typedef errno_t (*nxprov_capab_config_fn_t)(kern_nexus_provider_t, kern_nexus_t, kern_nexus_capab_t, void *, uint32_t *);

/* 2977 */
struct kern_nexus_provider_init
{
  uint32_t nxpi_version;
  uint32_t nxpi_flags;
  nxprov_pre_connect_fn_t nxpi_pre_connect;
  nxprov_connected_fn_t nxpi_connected;
  nxprov_pre_disconnect_fn_t nxpi_pre_disconnect;
  nxprov_disconnected_fn_t nxpi_disconnected;
  nxprov_ring_init_fn_t nxpi_ring_init;
  nxprov_ring_fini_fn_t nxpi_ring_fini;
  nxprov_slot_init_fn_t nxpi_slot_init;
  nxprov_slot_fini_fn_t nxpi_slot_fini;
  nxprov_sync_tx_fn_t nxpi_sync_tx;
  nxprov_sync_rx_fn_t nxpi_sync_rx;
  nxprov_tx_doorbell_fn_t nxpi_tx_doorbell;
  nxprov_sync_packets_fn_t nxpi_rx_sync_packets;
  nxprov_sync_packets_fn_t nxpi_tx_sync_packets;
  nxprov_capab_config_fn_t nxpi_config_capab;
};

/* 3014 */
typedef netif_qset *kern_netif_qset_t;

/* 2934 */
typedef errno_t (*nxprov_qset_init_fn_t)(kern_nexus_provider_t, kern_nexus_t, void *, uint8_t, uint64_t, kern_netif_qset_t, void **);

/* 2933 */
typedef void (*nxprov_qset_fini_fn_t)(kern_nexus_provider_t, kern_nexus_t, void *);

/* 3009 */
typedef netif_queue *kern_netif_queue_t;

/* 2932 */
typedef errno_t (*nxprov_queue_init_fn_t)(kern_nexus_provider_t, kern_nexus_t, void *, uint8_t, bool, kern_netif_queue_t, void **);

/* 2931 */
typedef void (*nxprov_queue_fini_fn_t)(kern_nexus_provider_t, kern_nexus_t, void *);

/* 2930 */
typedef errno_t (*nxprov_tx_qset_notify_fn_t)(kern_nexus_provider_t, kern_nexus_t, void *, uint32_t);

/* 2976 */
struct kern_nexus_netif_provider_init
{
  uint32_t nxnpi_version;
  uint32_t nxnpi_flags;
  nxprov_pre_connect_fn_t nxnpi_pre_connect;
  nxprov_connected_fn_t nxnpi_connected;
  nxprov_pre_disconnect_fn_t nxnpi_pre_disconnect;
  nxprov_disconnected_fn_t nxnpi_disconnected;
  nxprov_qset_init_fn_t nxnpi_qset_init;
  nxprov_qset_fini_fn_t nxnpi_qset_fini;
  nxprov_queue_init_fn_t nxnpi_queue_init;
  nxprov_queue_fini_fn_t nxnpi_queue_fini;
  nxprov_tx_qset_notify_fn_t nxnpi_tx_qset_notify;
  nxprov_capab_config_fn_t nxnpi_config_capab;
};

/* 5128 */
enum skmem_region_id_t : __int32
{
  SKMEM_REGION_GUARD_HEAD = 0x0,
  SKMEM_REGION_SCHEMA = 0x1,
  SKMEM_REGION_RING = 0x2,
  SKMEM_REGION_BUF_DEF = 0x3,
  SKMEM_REGION_BUF_LARGE = 0x4,
  SKMEM_REGION_RXBUF_DEF = 0x5,
  SKMEM_REGION_RXBUF_LARGE = 0x6,
  SKMEM_REGION_TXBUF_DEF = 0x7,
  SKMEM_REGION_TXBUF_LARGE = 0x8,
  SKMEM_REGION_UMD = 0x9,
  SKMEM_REGION_TXAUSD = 0xA,
  SKMEM_REGION_RXFUSD = 0xB,
  SKMEM_REGION_UBFT = 0xC,
  SKMEM_REGION_USTATS = 0xD,
  SKMEM_REGION_FLOWADV = 0xE,
  SKMEM_REGION_NEXUSADV = 0xF,
  SKMEM_REGION_SYSCTLS = 0x10,
  SKMEM_REGION_GUARD_TAIL = 0x11,
  SKMEM_REGION_KMD = 0x12,
  SKMEM_REGION_RXKMD = 0x13,
  SKMEM_REGION_TXKMD = 0x14,
  SKMEM_REGION_KBFT = 0x15,
  SKMEM_REGION_RXKBFT = 0x16,
  SKMEM_REGION_TXKBFT = 0x17,
  SKMEM_REGION_TXAKSD = 0x18,
  SKMEM_REGION_RXFKSD = 0x19,
  SKMEM_REGION_KSTATS = 0x1A,
  SKMEM_REGION_INTRINSIC = 0x1B,
  SKMEM_REGIONS = 0x1C,
};

/* 2869 */
struct __attribute__((aligned(8))) skmem_region_params
{
  const char *srp_name;
  skmem_region_id_t srp_id;
  uint32_t srp_cflags;
  uint32_t srp_r_seg_size;
  uint32_t srp_c_seg_size;
  uint32_t srp_seg_cnt;
  uint32_t srp_r_obj_size;
  uint32_t srp_r_obj_cnt;
  uint32_t srp_c_obj_size;
  uint32_t srp_c_obj_cnt;
  size_t srp_align;
  nexus_meta_type_t srp_md_type;
  nexus_meta_subtype_t srp_md_subtype;
  uint16_t srp_max_frags;
};

/* 2978 */
struct kern_nexus_provider
{
  uint32_t nxprov_refcnt;
  uint32_t nxprov_flags;
  struct
  {
    kern_nexus_provider *stqe_next;
  } nxprov_link;
  struct
  {
    kern_nexus *stqh_first;
    kern_nexus **stqh_last;
  } nxprov_nx_head;
  uint32_t nxprov_nx_count;
  nxctl *nxprov_ctl;
  uuid_t_1 nxprov_uuid;
  kern_nexus_domain_provider *nxprov_dom_prov;
  union
  {
    kern_nexus_provider_init nxprov_ext;
    kern_nexus_netif_provider_init nxprov_netif_ext;
  };
  nxprov_params *nxprov_params;
  skmem_region_params nxprov_region_params[28];
};

/* 1203 */
struct IOSKMemoryBufferSpec
{
  boolean_t user_writable;
  boolean_t kernel_writable;
  boolean_t iodir_in;
  boolean_t iodir_out;
  boolean_t purgeable;
  boolean_t inhibitCache;
  boolean_t physcontig;
  boolean_t puredata;
  boolean_t threadSafe;
};

/* 1209 */
struct IOSKRegionSpec
{
  boolean_t noRedirect;
};

/* 1200 */
typedef IOSKRegion *IOSKRegionRef;

/* 1202 */
typedef IOSKMemoryRef IOSKMemoryBufferRef;

/* 2868 */
typedef void (*sksegment_ctor_fn_t)(sksegment *, IOSKMemoryBufferRef, void *);

/* 2867 */
typedef void (*sksegment_dtor_fn_t)(sksegment *, IOSKMemoryBufferRef, void *);

/* 2866 */
struct segfreehead
{
  sksegment *tqh_first;
  sksegment **tqh_last;
};

/* 2865 */
struct segtfreehead
{
  sksegment *rbh_root;
};

/* 2870 */
struct skmem_region
{
  lck_mtx_t skr_lock;
  uint64_t skr_meminuse;
  uint64_t skr_w_meminuse;
  uint64_t skr_memtotal;
  uint64_t skr_alloc;
  uint64_t skr_free;
  uint32_t skr_seginuse;
  uint32_t skr_rescale;
  skmem_region_params skr_params;
  struct
  {
    skmem_region *tqe_next;
    skmem_region **tqe_prev;
  } skr_link;
  char skr_name[64];
  uuid_t_1 skr_uuid;
  uint32_t skr_mode;
  uint32_t skr_size;
  IOSKMemoryBufferSpec skr_bufspec;
  IOSKRegionSpec skr_regspec;
  IOSKRegionRef skr_reg;
  zone *skr_zreg;
  void *skr_private;
  skmem_cache *skr_cache[3];
  sksegment_ctor_fn_t skr_seg_ctor;
  sksegment_dtor_fn_t skr_seg_dtor;
  uint32_t skr_seg_objs;
  uint32_t skr_seg_bmap_len;
  bitmap_t *skr_seg_bmap;
  uint32_t skr_seg_free_cnt;
  uint32_t skr_hash_initial;
  uint32_t skr_hash_limit;
  uint32_t skr_hash_shift;
  uint32_t skr_hash_mask;
  sksegment_bkt *skr_hash_table;
  segfreehead skr_seg_free;
  segtfreehead skr_seg_tfree;
  uint32_t skr_seg_waiters;
  uint32_t skr_refcnt;
  skmem_region *skr_mirror;
};

/* 2926 */
struct ifnet_interface_advisory_header
{
  _BYTE gap0[3];
  uint8_t reserved;
};

/* 2925 */
struct ifnet_interface_advisory_capacity
{
  _BYTE gap0[4];
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t timestamp;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t max_bandwidth;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t total_byte_count;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t average_throughput;
  uint32_t flushable_queue_size;
  uint32_t non_flushable_queue_size;
  uint32_t average_delay;
};

/* 2924 */
struct __attribute__((packed)) __attribute__((aligned(1))) ifnet_interface_advisory_wifi_context
{
  _BYTE gap0;
  uint8_t intermittent_state;
  uint16_t estimated_intermittent_period;
  uint16_t single_outage_period;
  uint8_t bt_coex;
  uint8_t quality_score_delay;
  uint8_t quality_score_loss;
  uint8_t quality_score_channel;
  uint8_t radio_coex;
  uint16_t wlan_duty_cycle;
  uint32_t wifi_observed_tx_bitrate[6];
};

/* 2923 */
struct ifnet_interface_advisory_cell_context
{
  uint8_t radio_access_technology;
  __attribute__((packed)) __attribute__((aligned(1))) int16_t reference_signal_level;
  __attribute__((packed)) __attribute__((aligned(1))) int16_t signal_level;
  int8_t signal_quality;
  uint8_t uplink_bler;
  uint8_t downlink_bler;
  uint8_t bandwidth_limitation_indication;
  uint8_t cdrx_state;
  uint16_t cdrx_cycle;
  uint16_t estimated_outage_period;
  uint8_t outage_state;
  uint8_t __pad;
};

/* 2927 */
struct __attribute__((aligned(8))) ifnet_interface_advisory
{
  union __attribute__((packed)) __attribute__((aligned(1)))
  {
    struct __attribute__((packed)) __attribute__((aligned(2)))
    {
      uint8_t version;
      uint8_t direction;
      uint16_t _reserved;
      int32_t rate_trend_suggestion;
      uint64_t timestamp;
      uint64_t max_bandwidth;
      uint64_t total_byte_count;
      uint64_t average_throughput;
      uint32_t flushable_queue_size;
      uint32_t non_flushable_queue_size;
      uint32_t average_delay;
      uint8_t frequency_band;
      uint8_t intermittent_state;
      uint16_t estimated_intermittent_period;
      uint16_t single_outage_period;
      uint8_t bt_coex;
      uint8_t quality_score_delay;
      uint8_t quality_score_loss;
      uint8_t quality_score_channel;
    };
    struct __attribute__((packed)) __attribute__((aligned(1)))
    {
      ifnet_interface_advisory_header header;
      ifnet_interface_advisory_capacity capacity;
      union __attribute__((packed)) __attribute__((aligned(1)))
      {
        ifnet_interface_advisory_wifi_context wifi_context;
        ifnet_interface_advisory_cell_context cell_context;
      };
    };
  };
};

/* 2928 */
struct __kern_netif_intf_advisory
{
  uint32_t cksum;
  uint32_t _reserved;
  ifnet_interface_advisory adv;
};

/* 2929 */
struct sk_nexusadv
{
  uint64_t nxadv_ver;
  uint64_t nxadv_fg_sendts;
  uint64_t nxadv_rt_sendts;
  union
  {
    __kern_netif_intf_advisory _nxadv_intf_adv;
    uint8_t _nxadv_reserved[104];
  };
};

/* 2922 */
struct netif_nexus_advisory
{
  uint64_t nna_version;
  union
  {
    __kern_netif_intf_advisory __kern_intf_adv;
    uint8_t __nna_intf_adv[104];
  };
};

/* 2921 */
struct nx_port_info
{
  uintptr_t npi_nah;
  nxbind *npi_nxb;
  void *npi_info;
};

/* 7778 */
struct __cppobj OSMetaClassBase_1
{
  int (**_vptr$OSMetaClassBase)(void);
};

/* 9201 */
struct __cppobj __attribute__((aligned(8))) OSObject_1 : OSMetaClassBase_1
{
  int retainCount;
};

/* 2525 */
typedef lck_mtx_t IOLock_0;

/* 1211 */
typedef uint32_t IOSKSize;

/* 1212 */
struct __cppobj __attribute__((aligned(8))) IOSKArena : OSObject_1
{
  IOLock_0 *fArenaLock;
  OSSet_0 *fMappers;
  OSArray_0 *fRegions;
  IOSKSize fArenaSize;
};

/* 5102 */
enum nexus_type_t : __int32
{
  NEXUS_TYPE_USER_PIPE = 0x0,
  NEXUS_TYPE_KERNEL_PIPE = 0x1,
  NEXUS_TYPE_NET_IF = 0x2,
  NEXUS_TYPE_FLOW_SWITCH = 0x3,
  NEXUS_TYPE_MONITOR = 0x4,
  NEXUS_TYPE_MAX = 0x5,
  NEXUS_TYPE_UNDEFINED = 0xFFFFFFFF,
};

/* 2988 */
struct nxp_bounds
{
  uint32_t nb_def;
  uint32_t nb_min;
  uint32_t nb_max;
};

/* 3021 */
struct nxdom
{
  struct
  {
    nxdom *stqe_next;
  } nxdom_link;
  struct
  {
    kern_nexus_domain_provider *stqh_first;
    kern_nexus_domain_provider **stqh_last;
  } nxdom_prov_head;
  nexus_type_t nxdom_type;
  nexus_meta_type_t nxdom_md_type;
  nexus_meta_subtype_t nxdom_md_subtype;
  uint32_t nxdom_flags;
  nxp_bounds nxdom_ports;
  nxp_bounds nxdom_tx_rings;
  nxp_bounds nxdom_rx_rings;
  nxp_bounds nxdom_tx_slots;
  nxp_bounds nxdom_rx_slots;
  nxp_bounds nxdom_buf_size;
  nxp_bounds nxdom_large_buf_size;
  nxp_bounds nxdom_meta_size;
  nxp_bounds nxdom_stats_size;
  nxp_bounds nxdom_pipes;
  nxp_bounds nxdom_extensions;
  nxp_bounds nxdom_mhints;
  nxp_bounds nxdom_flowadv_max;
  nxp_bounds nxdom_nexusadv_size;
  nxp_bounds nxdom_capabilities;
  nxp_bounds nxdom_qmap;
  nxp_bounds nxdom_max_frags;
  skmem_region_params nxdom_region_params[28];
  const char *nxdom_name;
  void (*nxdom_init)(nxdom *);
  void (*nxdom_terminate)(nxdom *);
  void (*nxdom_fini)(nxdom *);
  int (*nxdom_find_port)(kern_nexus *, boolean_t, nexus_port_t *);
  boolean_t (*nxdom_port_is_reserved)(kern_nexus *, nexus_port_t);
  int (*nxdom_bind_port)(kern_nexus *, nexus_port_t *, nxbind *, void *);
  int (*nxdom_unbind_port)(kern_nexus *, nexus_port_t);
  int (*nxdom_connect)(kern_nexus_domain_provider *, kern_nexus *, kern_channel *, chreq *, kern_channel *, nxbind *, proc *);
  void (*nxdom_disconnect)(kern_nexus_domain_provider *, kern_nexus *, kern_channel *);
  void (*nxdom_defunct)(kern_nexus_domain_provider *, kern_nexus *, kern_channel *, proc *);
  void (*nxdom_defunct_finalize)(kern_nexus_domain_provider *, kern_nexus *, kern_channel *, boolean_t);
};

/* 5097 */
typedef uint8_t nexus_name_t[64];

/* 5096 */
enum nexus_extension_t : __int32
{
  NEXUS_EXTENSION_TYPE_MAXTYPE = 0x0,
};

/* 5095 */
enum nexus_qmap_type_t : __int32
{
  NEXUS_QMAP_TYPE_INVALID = 0x0,
  NEXUS_QMAP_TYPE_DEFAULT = 0x1,
  NEXUS_QMAP_TYPE_WMM = 0x2,
};

/* 2981 */
struct __attribute__((aligned(64))) nxprov_params
{
  nexus_name_t nxp_name;
  uint32_t nxp_namelen;
  nexus_type_t nxp_type;
  nexus_meta_type_t nxp_md_type;
  nexus_meta_subtype_t nxp_md_subtype;
  uint32_t nxp_flags;
  uint32_t nxp_format;
  uint32_t nxp_tx_rings;
  uint32_t nxp_rx_rings;
  uint32_t nxp_tx_slots;
  uint32_t nxp_rx_slots;
  uint32_t nxp_buf_size;
  uint32_t nxp_meta_size;
  uint32_t nxp_stats_size;
  uint32_t nxp_pipes;
  nexus_extension_t nxp_extensions;
  uint32_t nxp_mhints;
  uint32_t nxp_ifindex;
  uint32_t nxp_flowadv_max;
  nexus_qmap_type_t nxp_qmap;
  uint32_t nxp_capabilities;
  uint32_t nxp_nexusadv_size;
  uint32_t nxp_max_frags;
  boolean_t nxp_reject_on_close;
  uint32_t nxp_large_buf_size;
};

/* 5094 */
enum nxcfg_cmd_t : __int32
{
  NXCFG_CMD_ATTACH = 0x0,
  NXCFG_CMD_DETACH = 0x1,
  NXCFG_CMD_FLOW_ADD = 0x14,
  NXCFG_CMD_FLOW_DEL = 0x15,
  NXCFG_CMD_NETEM = 0x1E,
  NXCFG_CMD_GET_LLINK_INFO = 0x28,
};

/* 2919 */
struct nx_cfg_req
{
  uuid_t_1 nc_nx_uuid;
  nxcfg_cmd_t nc_cmd;
  uint32_t nc_req_len;
  user_addr_t_0 nc_req;
};

/* 2917 */
struct info_tuple
{
  u_int8_t itpl_proto;
  union
  {
    sockaddr _itpl_sa;
    __sockaddr_header _itpl_sah;
    sockaddr_in _itpl_sin;
    sockaddr_in6 _itpl_sin6;
  } itpl_localaddr;
  union
  {
    sockaddr _itpl_sa;
    __sockaddr_header _itpl_sah;
    sockaddr_in _itpl_sin;
    sockaddr_in6 _itpl_sin6;
  } itpl_remoteaddr;
};

/* 2918 */
struct nexus_mib_filter
{
  uint32_t nmf_type;
  uint64_t nmf_bitmap;
  uuid_t_1 nmf_nx_uuid;
  uuid_t_1 nmf_flow_id;
  pid_t nmf_pid;
  info_tuple nmf_info_tuple;
};

/* 2939 */
struct __attribute__((aligned(64))) ch_info
{
  union
  {
    uint64_t cinfo_ch_id_64[2];
    uint32_t cinfo_ch_id_32[4];
    uuid_t_1 cinfo_ch_id;
  };
  uint32_t cinfo_ch_mode;
  ring_id_t cinfo_ch_ring_id;
  nxprov_params cinfo_nxprov_params;
  uuid_t_1 cinfo_nx_uuid;
  nexus_port_t cinfo_nx_port;
  uint32_t cinfo_num_bufs;
  mach_vm_size_t_0 cinfo_mem_map_size;
  mach_vm_address_t_0 cinfo_mem_base;
  mach_vm_offset_t cinfo_schema_offset;
  ring_id_t cinfo_first_tx_ring;
  ring_id_t cinfo_last_tx_ring;
  ring_id_t cinfo_first_rx_ring;
  ring_id_t cinfo_last_rx_ring;
  ch_ev_thresh cinfo_tx_lowat;
  ch_ev_thresh cinfo_rx_lowat;
};

/* 2938 */
struct __user_channel_schema
{
  const uint32_t csm_ver;
  const volatile uint32_t csm_flags;
  const char csm_kern_name[256];
  const uuid_t_1 csm_kern_uuid;
  const uint32_t csm_tx_rings;
  const uint32_t csm_rx_rings;
  const uint32_t csm_allocator_ring_pairs;
  const uint32_t csm_num_event_rings;
  const uint32_t csm_flowadv_max;
  const mach_vm_offset_t csm_flowadv_ofs;
  const uint64_t csm_md_redzone_cookie;
  const nexus_meta_type_t csm_md_type;
  const nexus_meta_subtype_t csm_md_subtype;
  const mach_vm_offset_t csm_stats_ofs;
  const nexus_stats_type_t csm_stats_type;
  const mach_vm_offset_t csm_nexusadv_ofs;
  struct {const mach_vm_offset_t ring_off;const mach_vm_offset_t sd_off;}; csm_ring_ofs[];
};

/* 2513 */
typedef struct task *task_t_0;

/* 2508 */
typedef _vm_map *vm_map_t_0;

/* 1213 */
struct __cppobj __attribute__((aligned(8))) IOSKMapper : OSObject_1
{
  task_t_0 fTask;
  vm_map_t_0 fTaskMap;
  IOSKArena *fArena;
  OSArray_0 *fSubMaps;
  mach_vm_address_t_0 fMapAddr;
  mach_vm_size_t_0 fMapSize;
  bool fRedirected;
};

/* 2920 */
struct nxbind
{
  uint32_t nxb_flags;
  pid_t nxb_pid;
  uint64_t nxb_uniqueid;
  uuid_t_1 nxb_exec_uuid;
  uint32_t nxb_key_len;
  void *nxb_key;
};

/* 3008 */
struct netif_agent_flow
{
  struct
  {
    netif_agent_flow *sle_next;
  } naf_link;
  uuid_t_1 naf_flow_uuid;
  uuid_t_1 naf_bind_key;
  nexus_port_t naf_nx_port;
  uint16_t naf_flags;
  pid_t naf_pid;
  sockaddr_in_4_6 naf_daddr;
  sockaddr_in_4_6 naf_saddr;
};

/* 3088 */
struct __attribute__((aligned(16))) fsw_stats
{
  uint64_t _arr[111];
};

/* 961 */
struct sysctl_oid_list_0
{
  sysctl_oid_0 *slh_first;
};

/* 962 */
struct sysctl_oid_0
{
  _BYTE gap0[8];
  struct
  {
    sysctl_oid_0 *sle_next;
  } oid_link;
  int oid_number;
  int oid_kind;
  void *oid_arg1;
  int oid_arg2;
  const char *oid_name;
  int (*oid_handler)(sysctl_oid_0 *, void *, int, sysctl_req_0 *);
  const char *oid_fmt;
  const char *oid_descr;
  int oid_version;
  int oid_refcnt;
};

/* 3087 */
struct skoid
{
  sysctl_oid_list_0 sko_oid_list;
  sysctl_oid_0 sko_oid;
  char sko_name[32];
};

/* 3086 */
struct flow_entry_linger_head
{
  flow_entry *tqh_first;
  flow_entry **tqh_last;
};

/* 3089 */
struct __attribute__((aligned(8))) nx_flowswitch
{
  lck_rw_t fsw_lock;
  uint32_t fsw_tx_rings;
  uint32_t fsw_rx_rings;
  kern_nexus *fsw_nx;
  classq_pkt_type_t fsw_classq_enq_ptype;
  boolean_t fsw_classq_enabled;
  pkt_copy_from_pkt_t *fsw_pkt_copy_from_pkt;
  pkt_copy_from_mbuf_t *fsw_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *fsw_pkt_copy_to_mbuf;
  uint8_t fsw_frame_headroom;
  uint32_t fsw_src_lla_gencnt;
  uint32_t fsw_pending_nonviable;
  uint32_t fsw_low_power_gencnt;
  flow_mgr *fsw_flow_mgr;
  netagent_session_t fsw_agent_session;
  uuid_t_1 fsw_agent_uuid;
  ifnet *fsw_ifp;
  nexus_adapter *fsw_nifna;
  uint32_t fsw_state_flags;
  union
  {
    uint64_t _buf[1];
    uint8_t _eth_src[6];
  } __fsw_slladdr;
  int (*fsw_resolve)(nx_flowswitch *, flow_route *, __kern_packet *);
  void (*fsw_frame)(nx_flowswitch *, flow_route *, __kern_packet *);
  sa_family_t (*fsw_demux)(nx_flowswitch *, __kern_packet *);
  fsw_stats fsw_stats;
  lck_mtx_t fsw_detach_barrier_lock;
  uint32_t fsw_detach_flags;
  uint32_t fsw_detach_barriers;
  uint32_t fsw_detach_waiters;
  uint32_t fsw_ifp_dlt;
  uint32_t fsw_rx_largest_size;
  void (*fsw_ctor)(nx_flowswitch *, flow_route *);
  __nx_stats_fsw *fsw_closed_na_stats;
  fsw_ip_frag_mgr *fsw_ipfm;
  skoid fsw_skoid;
  netem *fsw_input_netem;
  kern_channel *fsw_dev_ch;
  kern_channel *fsw_host_ch;
  lck_mtx_t fsw_reap_lock;
  uint32_t fsw_reap_flags;
  uint32_t fsw_reap_requests;
  thread *fsw_reap_thread;
  char fsw_reap_name[64];
  uint64_t fsw_reap_last;
  uint64_t fsw_drain_channel_chk_last;
  uint64_t fsw_drain_netif_chk_last;
  lck_mtx_t fsw_linger_lock;
  flow_entry_linger_head fsw_linger_head;
  uint32_t fsw_linger_cnt;
};

/* 9881 */
struct kern_pbufpool_1
{
  lck_mtx_t pp_lock;
  uint32_t pp_refcnt;
  uint32_t pp_flags;
  uint32_t pp_buf_obj_size[2];
  uint16_t pp_buf_size[2];
  uint16_t pp_max_frags;
  skmem_cache *pp_buf_cache[2];
  skmem_cache *pp_kmd_cache;
  skmem_cache *pp_kbft_cache[2];
  skmem_cache *pp_raw_kbft_cache;
  skmem_region *pp_buf_region[2];
  skmem_region *pp_kmd_region;
  skmem_region *pp_umd_region;
  skmem_region *pp_ubft_region;
  skmem_region *pp_kbft_region;
  kern_pbufpool_u_bkt *pp_u_hash_table;
  uint64_t pp_u_bufinuse;
  kern_pbufpool_u_bft_bkt *pp_u_bft_hash_table;
  uint64_t pp_u_bftinuse;
  void *pp_ctx;
  pbuf_ctx_retain_fn_t pp_ctx_retain;
  pbuf_ctx_release_fn_t pp_ctx_release;
  nexus_meta_type_t pp_md_type;
  nexus_meta_subtype_t pp_md_subtype;
  uint32_t pp_midx_start;
  uint32_t pp_bidx_start;
  pbufpool_name_t pp_name;
  pbuf_seg_ctor_fn_t_0 pp_pbuf_seg_ctor;
  pbuf_seg_dtor_fn_t_0 pp_pbuf_seg_dtor;
};

/* 3003 */
struct netif_flowtable
{
  netif_flowtable_ops *ft_ops;
  void *ft_internal;
};

/* 5089 */
typedef uint64_t kern_nexus_netif_llink_id_t;

/* 3030 */
struct kern_nexus_netif_llink_init
{
  uint32_t nli_flags;
  uint8_t nli_num_qsets;
  void *nli_ctx;
  kern_nexus_netif_llink_id_t nli_link_id;
  kern_nexus_netif_llink_qset_init *nli_qsets;
};

/* 3012 */
struct netif_llink
{
  nx_netif *nll_nif;
  struct
  {
    netif_llink *stqe_next;
  } nll_link;
  struct
  {
    netif_qset *slh_first;
  } nll_qset_list;
  netif_qset *nll_default_qset;
  ifclassq *nll_ifcq;
  os_refcnt nll_refcnt;
  kern_nexus_netif_llink_id_t nll_link_id;
  uint16_t nll_link_id_internal;
  uint16_t nll_qset_cnt;
  uint8_t nll_state;
  uint8_t nll_flags;
  void *nll_ctx;
};

/* 2993 */
struct ifnet_traffic_descriptor_common
{
  uint8_t itd_type;
  uint8_t _reserved;
  uint16_t itd_len;
  uint32_t itd_flags;
};

/* 2801 */
struct eventhandler_entry_arg
{
  uuid_t_1 ee_fm_uuid;
  uuid_t_1 ee_fr_uuid;
};

/* 2802 */
struct __attribute__((aligned(8))) eventhandler_entry
{
  struct
  {
    eventhandler_entry *tqe_next;
    eventhandler_entry **tqe_prev;
  } ee_link;
  int ee_priority;
  eventhandler_entry_arg ee_arg;
};

/* 960 */
struct sysctl_req_0
{
  proc *p;
  int lock;
  user_addr_t_0 oldptr;
  size_t oldlen;
  size_t oldidx;
  int (*oldfunc)(sysctl_req_0 *, const void *, size_t);
  user_addr_t_0 newptr;
  size_t newlen;
  size_t newidx;
  int (*newfunc)(sysctl_req_0 *, void *, size_t);
};

/* 3111 */
struct im6s_st
{
  uint16_t ex;
  uint16_t in;
};

/* 3112 */
struct __attribute__((aligned(8))) ip6_msource
{
  struct
  {
    ip6_msource *rbe_left;
    ip6_msource *rbe_right;
    ip6_msource *rbe_parent;
  } im6s_link;
  in6_addr_0 im6s_addr;
  im6s_st im6s_st[2];
  uint8_t im6s_stp;
};

/* 2859 */
struct kern_pbufpool_u_bkt
{
  struct
  {
    __kern_quantum *slh_first;
  } upp_head;
};

/* 2858 */
struct kern_pbufpool_u_bft_bkt
{
  struct
  {
    __kern_buflet_ext *slh_first;
  } upp_head;
};

/* 5130 */
enum sksegment_type_t : __int32
{
  SKSEG_TYPE_INVALID = 0x0,
  SKSEG_TYPE_ALLOC = 0x1,
  SKSEG_TYPE_FREE = 0x2,
  SKSEG_TYPE_DESTROYED = 0x3,
};

/* 5129 */
enum sksegment_state_t : __int32
{
  SKSEG_STATE_INVALID = 0x0,
  SKSEG_STATE_DETACHED = 0x1,
  SKSEG_STATE_MAPPED = 0x2,
  SKSEG_STATE_MAPPED_WIRED = 0x3,
};

/* 2871 */
struct __attribute__((aligned(8))) sksegment
{
  struct
  {
    sksegment *tqe_next;
    sksegment **tqe_prev;
  } sg_link;
  struct
  {
    sksegment *rbe_left;
    sksegment *rbe_right;
    sksegment *rbe_parent;
  } sg_node;
  skmem_region *sg_region;
  IOSKMemoryBufferRef sg_md;
  mach_vm_address_t_0 sg_start;
  mach_vm_address_t_0 sg_end;
  uint32_t sg_index;
  sksegment_type_t sg_type;
  sksegment_state_t sg_state;
};

/* 2559 */
typedef OSSet_0 *libkern::intrusive_shared_ptr<OSSet,intrusive_osobject_retainer>::pointer;

/* 7686 */
struct libkern::intrusive_shared_ptr<OSSet,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSSet,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7285 */
struct __cppobj OSSharedPtr<OSSet> : libkern::intrusive_shared_ptr<OSSet,intrusive_osobject_retainer>
{
};

/* 7772 */
typedef OSSharedPtr<OSSet> OSPtr<OSSet>_0;

/* 5464 */
typedef uint16_t vm_tag_t;

/* 2991 */
typedef vm_allocation_site kern_allocation_name;

/* 2992 */
typedef kern_allocation_name *kern_allocation_name_t;

/* 2518 */
struct __cppobj __attribute__((aligned(8))) IOMemoryDescriptor_0 : OSObject_1
{
  IOMemoryDescriptorReserved *reserved;
  OSPtr<OSSet>_0 _mappings;
  IOOptionBits _flags;
  IOMemoryReference *_memRef;
  vm_tag_t _kernelTag;
  vm_tag_t _userTag;
  int16_t _dmaReferences;
  uint16_t _internalFlags;
  kern_allocation_name_t _mapName;
  uint16_t _iomapperOptions;
  uint16_t __iomd_reserved3[3];
  uintptr_t __iomd_reserved4;
  IOByteCount _length;
  IOOptionBits _tag;
};

/* 2872 */
struct skmem_slab
{
  struct
  {
    skmem_slab *tqe_next;
    skmem_slab **tqe_prev;
  } sl_link;
  skmem_cache *sl_cache;
  void *sl_base;
  void *sl_basem;
  sksegment *sl_seg;
  sksegment *sl_segm;
  struct
  {
    skmem_bufctl *slh_first;
  } sl_head;
  uint32_t sl_refcnt;
  uint32_t sl_chunks;
};

/* 4226 */
typedef int rn_matchf_t(radix_node *, void *);

/* 4225 */
typedef int walktree_f_t(radix_node *, void *);

/* 4227 */
struct __attribute__((aligned(8))) radix_node_head
{
  radix_node *rnh_treetop;
  int rnh_addrsize;
  int rnh_pktsize;
  radix_node *(*rnh_addaddr)(void *, void *, radix_node_head *, radix_node *);
  radix_node *(*rnh_addpkt)(void *, void *, radix_node_head *, radix_node *);
  radix_node *(*rnh_deladdr)(void *, void *, radix_node_head *);
  radix_node *(*rnh_delpkt)(void *, void *, radix_node_head *);
  radix_node *(*rnh_matchaddr)(void *, radix_node_head *);
  radix_node *(*rnh_matchaddr_args)(void *, radix_node_head *, rn_matchf_t *, void *);
  radix_node *(*rnh_lookup)(void *, void *, radix_node_head *);
  radix_node *(*rnh_lookup_args)(void *, void *, radix_node_head *, rn_matchf_t *, void *);
  radix_node *(*rnh_matchpkt)(void *, radix_node_head *);
  int (*rnh_walktree)(radix_node_head *, walktree_f_t *, void *);
  int (*rnh_walktree_from)(radix_node_head *, void *, void *, walktree_f_t *, void *);
  void (*rnh_close)(radix_node *, radix_node_head *);
  radix_node rnh_nodes[3];
  int rnh_cnt;
};

/* 4311 */
struct pf_rulequeue
{
  pf_rule *tqh_first;
  pf_rule **tqh_last;
};

/* 4312 */
struct __attribute__((aligned(8))) pf_ruleset
{
  struct {pf_rulequeue queues[2];struct {pf_rulequeue *ptr;pf_rule **ptr_array;u_int32_t rcount;u_int32_t rsize;u_int32_t ticket;int open;} active;struct {pf_rulequeue *ptr;pf_rule **ptr_array;u_int32_t rcount;u_int32_t rsize;u_int32_t ticket;int open;} inactive;}; rules[6];
  pf_anchor *anchor;
  u_int32_t tticket;
  int tables;
  int topen;
};

/* 2874 */
struct __attribute__((packed)) __attribute__((aligned(4))) skmem_obj_info
{
  void *oi_addr;
  skmem_bufctl *oi_bc;
  uint32_t oi_size;
  obj_idx_t oi_idx_reg;
  obj_idx_t oi_idx_seg;
};

/* 2863 */
struct skmem_magtype
{
  int mt_magsize;
  int mt_align;
  size_t mt_minbuf;
  size_t mt_maxbuf;
  skmem_cache *mt_cache;
  char mt_cname[64];
};

/* 2862 */
struct skmem_mag
{
  struct
  {
    skmem_mag *sle_next;
  } mg_link;
  skmem_magtype *mg_magtype;
  void *mg_round[1];
};

/* 2861 */
struct skmem_bufctl_bkt
{
  struct
  {
    skmem_bufctl *slh_first;
  } bcb_head;
};

/* 2975 */
struct nxctl
{
  lck_mtx_t nxctl_lock;
  uint32_t nxctl_refcnt;
  uint32_t nxctl_flags;
  uuid_t_1 nxctl_uuid;
  uuid_t_1 nxctl_proc_uuid;
  uint64_t nxctl_proc_uniqueid;
  struct
  {
    nxctl *stqe_next;
  } nxctl_link;
  fileproc *nxctl_fp;
  kauth_cred_t nxctl_cred;
  void *nxctl_traffic_rule_storage;
};

/* 2935 */
struct kern_slot_prop
{
  uint32_t _sp_pad[16];
};

/* 2887 */
struct __attribute__((aligned(8))) pktq
{
  __kern_packet *kq_first;
  __kern_packet **kq_last;
  uint32_t kq_len;
};

/* 3010 */
struct netif_qstats
{
  uint64_t nq_total_pkts;
  uint64_t nq_total_bytes;
  uint64_t nq_num_xfers;
  uint32_t nq_min_pkts;
  uint32_t nq_max_pkts;
  uint32_t nq_pkts_ps;
  uint32_t nq_pkts_ps_ma;
  uint64_t nq_bytes_ps;
  uint64_t nq_bytes_ps_ma;
};

/* 3011 */
struct __attribute__((aligned(4))) netif_queue
{
  lck_mtx_t nq_lock;
  netif_qset *nq_qset;
  pktq nq_pktq;
  netif_qstats nq_stats;
  uint64_t nq_accumulated_bytes;
  uint64_t nq_accumulated_pkts;
  uint64_t nq_accumulate_start;
  void *nq_ctx;
  kern_packet_svc_class_t nq_svc;
  uint16_t nq_flags;
};

/* 3013 */
struct netif_qset
{
  netif_llink *nqs_llink;
  ifclassq *nqs_ifcq;
  struct
  {
    netif_qset *sle_next;
  } nqs_list;
  void *nqs_ctx;
  uint64_t nqs_id;
  uint8_t nqs_idx;
  uint16_t nqs_flags;
  uint8_t nqs_num_rx_queues;
  uint8_t nqs_num_tx_queues;
  netif_queue nqs_driver_queues[];
};

/* 1208 */
struct IOSKRegion::ArenaHead
{
  IOSKRegion::ArenaEntry *slh_first;
};

/* 1207 */
typedef uint32_t IOSKCount;

/* 1210 */
struct __cppobj IOSKRegion : OSObject_1
{
  IOSKRegionSpec fSpec;
  IOLock_0 *fRegionLock;
  IOSKRegion::ArenaHead fArenaHead;
  IOSKRegion::Segment *fSegments;
  IOSKCount fSegmentCount;
  IOSKSize fSegmentSize;
};

/* 2864 */
struct sksegment_bkt
{
  struct
  {
    sksegment *tqh_first;
    sksegment **tqh_last;
  } sgb_head;
};

/* 2578 */
struct __cppobj OSCollection_0 : OSObject_0
{
  unsigned int updateStamp;
  unsigned int fOptions;
};

/* 2561 */
typedef OSArray_0 *libkern::intrusive_shared_ptr<OSArray,intrusive_osobject_retainer>::pointer;

/* 7737 */
struct libkern::intrusive_shared_ptr<OSArray,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSArray,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7317 */
struct __cppobj OSSharedPtr<OSArray> : libkern::intrusive_shared_ptr<OSArray,intrusive_osobject_retainer>
{
};

/* 9402 */
typedef OSSharedPtr<OSArray> OSPtr<OSArray>_0;

/* 2523 */
struct __cppobj OSSet_0 : OSCollection_0
{
  OSPtr<OSArray>_0 members;
};

/* 2538 */
struct __cppobj OSArray_0 : OSCollection_0
{
  unsigned int count;
  unsigned int capacity;
  unsigned int capacityIncrement;
};

/* 5712 */
union lck_rw_word_t
{
  struct __attribute__((aligned(4)))
  {
    uint16_t shared_count;
  };
  uint32_t data;
};

/* 8205 */
struct lck_rw_t_0
{
  _BYTE gap0[4];
  uint32_t lck_rw_padding;
  lck_rw_word_t lck_rw;
  uint32_t lck_rw_owner;
};

/* 7020 */
typedef uint64_t vm_map_offset_t;

/* 5720 */
struct vm_map_links
{
  vm_map_entry *prev;
  vm_map_entry *next;
  vm_map_offset_t start;
  vm_map_offset_t end;
};

/* 5719 */
struct rb_head
{
  vm_map_store *rbh_root;
};

/* 5722 */
struct vm_map_header
{
  vm_map_links links;
  int nentries;
  uint16_t page_shift;
  rb_head rb_head_store;
};

/* 1469 */
typedef uint64_t vm_map_size_t;

/* 5721 */
typedef vm_map_entry *vm_map_entry_t;

/* 2506 */
struct _vm_map
{
  lck_rw_t_0 lock;
  vm_map_header hdr;
  _BYTE gap40[8];
  vm_map_size_t size;
  uint64_t size_limit;
  uint64_t data_limit;
  vm_map_size_t user_wire_limit;
  vm_map_size_t user_wire_size;
  vm_map_offset_t vmmap_high_start;
  union
  {
    vm_map_offset_t vmu1_highest_entry_end;
    vm_map_offset_t vmu1_lowest_unnestable_start;
  } vmu1;
  vm_map_entry_t hint;
  union
  {
    vm_map_links *vmmap_hole_hint;
    vm_map_corpse_footprint_header *vmmap_corpse_footprint;
  } vmmap_u_1;
  union
  {
    vm_map_entry_t _first_free;
    vm_map_links *_holes;
  } f_s;
  os_ref_atomic_t map_refcnt;
  __attribute__((aligned(8))) unsigned int timestamp;
};

/* 3085 */
struct flow_mgr
{
  char fm_name[16];
  uuid_t_1 fm_uuid;
  struct
  {
    flow_mgr *rbe_left;
    flow_mgr *rbe_right;
    flow_mgr *rbe_parent;
  } fm_link;
  cuckoo_hashtable *fm_flow_table;
  size_t fm_flow_hash_count[7];
  uint16_t fm_flow_hash_masks[7];
  void *fm_owner_buckets;
  const size_t fm_owner_buckets_cnt;
  const size_t fm_owner_bucket_sz;
  const size_t fm_owner_bucket_tot_sz;
  void *fm_route_buckets;
  const size_t fm_route_buckets_cnt;
  const size_t fm_route_bucket_sz;
  const size_t fm_route_bucket_tot_sz;
  void *fm_route_id_buckets;
  const size_t fm_route_id_buckets_cnt;
  const size_t fm_route_id_bucket_sz;
  const size_t fm_route_id_bucket_tot_sz;
};

/* 3081 */
struct ether_header
{
  u_char ether_dhost[6];
  u_char ether_shost[6];
  u_short ether_type;
};

/* 3082 */
union _flh_u
{
  uint64_t _buf[2];
  struct
  {
    uint16_t _eth_pad;
    ether_header _eth;
  } _eth_padded;
};

/* 3084 */
struct flow_llhdr
{
  uint32_t flh_gencnt;
  const uint8_t flh_off;
  const uint8_t flh_len;
  uint16_t flh_pad;
  _flh_u _flh;
};

/* 3083 */
typedef eventhandler_entry *eventhandler_tag;

/* 3057 */
struct flow_route
{
  struct
  {
    flow_route *rbe_left;
    flow_route *rbe_right;
    flow_route *rbe_parent;
  } fr_link;
  struct
  {
    flow_route *rbe_left;
    flow_route *rbe_right;
    flow_route *rbe_parent;
  } fr_id_link;
  sockaddr_in_4_6 fr_laddr;
  sockaddr_in_4_6 fr_faddr;
  sockaddr_in_4_6 fr_gaddr;
  flow_llhdr fr_llhdr;
  void *fr_addr_key;
  uuid_t_1 fr_uuid;
  lck_spin_t fr_reflock;
  uint64_t fr_expire;
  volatile uint32_t fr_usecnt;
  uint32_t fr_flags;
  uint32_t fr_laddr_gencnt;
  uint32_t fr_addr_len;
  volatile uint32_t fr_want_configure;
  volatile uint32_t fr_want_probe;
  lck_mtx_t fr_lock;
  eventhandler_tag fr_rt_evhdlr_tag;
  rtentry *fr_rt_dst;
  rtentry *fr_rt_gw;
  uuid_t_1 fr_nx_uuid;
  const flow_mgr *fr_mgr;
  const flow_route_bucket *fr_frb;
  const flow_route_id_bucket *fr_frib;
};

/* 3075 */
struct ip_stats
{
  uint64_t _arr[42];
};

/* 3074 */
struct ip6_stats
{
  uint64_t _arr[36];
};

/* 3073 */
struct tcp_stats
{
  uint64_t _arr[210];
};

/* 3072 */
struct udp_stats
{
  uint64_t _arr[22];
};

/* 3071 */
struct quic_stats
{
  uint64_t _arr[78];
};

/* 3076 */
struct __nx_stats_fsw
{
  ip_stats nxs_ipstat;
  ip6_stats nxs_ip6stat;
  tcp_stats nxs_tcpstat;
  udp_stats nxs_udpstat;
  quic_stats nxs_quicstat;
};

/* 9230 */
struct sysctl_oid_list_1
{
  sysctl_oid_0 *slh_first;
};

/* 9475 */
struct skoid_0
{
  sysctl_oid_list_1 sko_oid_list;
  sysctl_oid_0 sko_oid;
  char sko_name[32];
};

/* 3139 */
struct __attribute__((aligned(4))) ipf_key
{
  uint64_t ipfk_addr[4];
  uint32_t ipfk_ident;
  uint16_t ipfk_len;
};

/* 3140 */
struct __attribute__((aligned(4))) ipfq
{
  ipf *ipfq_down;
  ipf *ipfq_up;
  ipfq *ipfq_next;
  ipfq *ipfq_prev;
  uint64_t ipfq_timestamp;
  ipf_key ipfq_key;
  uint16_t ipfq_nfrag;
  uint16_t ipfq_unfraglen;
  bool ipfq_is_dirty;
};

/* 3141 */
struct fsw_ip_frag_mgr
{
  skoid_0 ipfm_skoid;
  ipfq ipfm_q;
  uint32_t ipfm_q_limit;
  uint32_t ipfm_q_count;
  uint32_t ipfm_f_limit;
  uint32_t ipfm_f_count;
  lck_mtx_t ipfm_lock;
  thread_call_t ipfm_timeout_tcall;
  ifnet *ipfm_ifp;
  fsw_stats *ipfm_stats;
};

/* 3052 */
struct flow_ip_addr
{
  union
  {
    in_addr _v4;
    in6_addr_0 _v6;
    uint8_t _addr8[16];
    uint16_t _addr16[8];
    uint32_t _addr32[4];
    uint64_t _addr64[2];
  };
};

/* 3054 */
struct flow_key
{
  uint16_t fk_mask;
  uint8_t fk_ipver;
  uint8_t fk_proto;
  uint16_t fk_sport;
  uint16_t fk_dport;
  flow_ip_addr fk_src;
  flow_ip_addr fk_dst;
  uint64_t fk_pad[1];
};

/* 3069 */
struct cuckoo_node
{
  cuckoo_node *next;
};

/* 3068 */
typedef void (*flow_action_t)(nx_flowswitch *, flow_entry *);

/* 3065 */
struct __attribute__((aligned(8))) flow_track_rtt
{
  uint64_t frtt_timestamp;
  uint64_t frtt_last;
  uint32_t frtt_seg_begin;
  uint32_t frtt_seg_end;
  uint32_t frtt_usec;
};

/* 3067 */
struct flow_track
{
  uint32_t fse_seqlo;
  uint32_t fse_seqhi;
  uint32_t fse_seqlast;
  uint16_t fse_max_win;
  uint16_t fse_mss;
  uint8_t fse_state;
  uint8_t fse_wscale;
  uint16_t fse_flags;
  uint32_t fse_syn_ts;
  uint32_t fse_syn_cnt;
  flow_track_rtt fse_rtt;
};

/* 5007 */
enum flow_qset_select_t : __int32
{
  FE_QSET_SELECT_NONE = 0x0,
  FE_QSET_SELECT_FIXED = 0x1,
  FE_QSET_SELECT_DYNAMIC = 0x2,
};

/* 3066 */
struct flow_entry_list
{
  flow_entry *tqh_first;
  flow_entry **tqh_last;
};

/* 3070 */
struct flow_entry
{
  os_refcnt_t fe_refcnt;
  __attribute__((aligned(16))) flow_key fe_key;
  uint32_t fe_flags;
  uint32_t fe_key_hash;
  cuckoo_node fe_cnode;
  uuid_t_1 fe_uuid;
  nexus_port_t fe_nx_port;
  uint32_t fe_laddr_gencnt;
  uint32_t fe_want_nonviable;
  uint32_t fe_want_withdraw;
  uint8_t fe_transport_protocol;
  uint16_t fe_rx_frag_count;
  uint32_t fe_rx_pktq_bytes;
  pktq fe_rx_pktq;
  struct
  {
    flow_entry *tqe_next;
    flow_entry **tqe_prev;
  } fe_rx_link;
  flow_action_t fe_rx_process;
  uint32_t fe_rx_largest_size;
  bool fe_tx_is_cont_frag;
  uint32_t fe_tx_frag_id;
  pktq fe_tx_pktq;
  struct
  {
    flow_entry *tqe_next;
    flow_entry **tqe_prev;
  } fe_tx_link;
  flow_action_t fe_tx_process;
  uuid_t_1 fe_eproc_uuid;
  flowadv_idx_t fe_adv_idx;
  kern_packet_svc_class_t fe_svc_class;
  uint32_t fe_policy_id;
  nx_flowswitch *const fe_fsw;
  ns_token *fe_port_reservation;
  protons_token *fe_proto_reservation;
  void *fe_ipsec_reservation;
  flow_track fe_ltrack;
  flow_track fe_rtrack;
  flow_stats *fe_stats;
  flow_route *fe_route;
  struct
  {
    flow_entry *rbe_left;
    flow_entry *rbe_right;
    flow_entry *rbe_parent;
  } fe_id_link;
  struct
  {
    flow_entry *tqe_next;
    flow_entry **tqe_prev;
  } fe_linger_link;
  uint64_t fe_linger_expire;
  uint32_t fe_linger_wait;
  pid_t fe_pid;
  pid_t fe_epid;
  char fe_proc_name[24];
  char fe_eproc_name[24];
  uint32_t fe_flowid;
  netif_qset *fe_qset;
  uint64_t fe_qset_id;
  flow_qset_select_t fe_qset_select;
  uint32_t fe_tr_genid;
  lck_rw_t fe_child_list_lock;
  flow_entry_list fe_child_list;
  struct
  {
    flow_entry *tqe_next;
    flow_entry **tqe_prev;
  } fe_child_link;
  uint8_t fe_demux_pattern_count;
  kern_flow_demux_pattern *fe_demux_patterns;
  uint8_t *fe_demux_pkt_data;
};

/* 3001 */
typedef int netif_flow_lookup_t(netif_flowtable *, __kern_packet *, uint32_t, netif_flow **);

/* 3000 */
typedef boolean_t netif_flow_match_t(netif_flow_desc *, netif_flow_desc *);

/* 2999 */
typedef int netif_flow_info_t(__kern_packet *, netif_flow_desc *, uint32_t);

/* 2998 */
typedef int netif_flow_insert_t(netif_flowtable *, netif_flow *);

/* 2997 */
typedef void netif_flow_remove_t(netif_flowtable *, netif_flow *);

/* 2996 */
typedef netif_flowtable *netif_flow_table_alloc_t(netif_flowtable_ops *);

/* 2995 */
typedef void netif_flow_table_free_t(netif_flowtable *);

/* 3002 */
struct netif_flowtable_ops
{
  netif_flow_lookup_t *nfo_lookup;
  netif_flow_match_t *nfo_match;
  netif_flow_info_t *nfo_info;
  netif_flow_insert_t *nfo_insert;
  netif_flow_remove_t *nfo_remove;
  netif_flow_table_alloc_t *nfo_table_alloc;
  netif_flow_table_free_t *nfo_table_free;
};

/* 3029 */
struct __attribute__((aligned(4))) kern_nexus_netif_llink_qset_init
{
  uint32_t nlqi_flags;
  uint8_t nlqi_num_rxqs;
  uint8_t nlqi_num_txqs;
};

/* 2857 */
struct __attribute__((packed)) __attribute__((aligned(4))) __kern_buflet_ext
{
  __kern_buflet_0 kbe_overlay;
  const __user_buflet *kbe_buf_user;
  struct
  {
    __kern_buflet_ext *sle_next;
  } kbe_buf_upp_link;
  pid_t kbe_buf_pid;
};

/* 2512 */
struct IOMemoryReference
{
  volatile SInt32 refCount;
  vm_prot_t prot;
  uint32_t capacity;
  uint32_t count;
  IOMemoryReference *mapRef;
  IOMemoryEntry entries[];
};

/* 2990 */
struct vm_allocation_total
{
  vm_tag_t tag;
  uint64_t total;
};

/* 9144 */
struct vm_allocation_site
{
  uint64_t total;
  uint64_t mapped;
  int16_t refcount;
  vm_tag_t tag;
  uint16_t flags;
  uint16_t subtotalscount;
  vm_allocation_total subtotals[];
};

/* 4305 */
struct __attribute__((aligned(8))) pf_addr_wrap
{
  union
  {
    struct
    {
      pf_addr addr;
      pf_addr mask;
    } a;
    char ifname[16];
    char tblname[32];
    char rtlabelname[32];
    u_int32_t rtlabel;
  } v;
  union
  {
    pfi_dynaddr *dyn;
    pfr_ktable *tbl;
    int dyncnt;
    int tblcnt;
  } p;
  u_int8_t type;
  u_int8_t iflags;
};

/* 4303 */
struct __attribute__((aligned(2))) pf_port_range
{
  u_int16_t port[2];
  u_int8_t op;
};

/* 4304 */
union __attribute__((aligned(4))) pf_rule_xport
{
  pf_port_range range;
  u_int16_t call_id;
  u_int32_t spi;
};

/* 4309 */
struct __attribute__((aligned(8))) pf_rule_addr
{
  pf_addr_wrap addr;
  pf_rule_xport xport;
  u_int8_t neg;
};

/* 4302 */
union pf_rule_ptr
{
  pf_rule *ptr;
  u_int32_t nr;
};

/* 5108 */
typedef u_int32_t pf_osfp_t;

/* 4307 */
struct pf_rule_uid
{
  uid_t uid[2];
  u_int8_t op;
  u_int8_t _pad[3];
};

/* 4306 */
struct pf_rule_gid
{
  uid_t gid[2];
  u_int8_t op;
  u_int8_t _pad[3];
};

/* 4310 */
struct pf_rule
{
  pf_rule_addr src;
  pf_rule_addr dst;
  pf_rule_ptr skip[8];
  char label[64];
  char ifname[16];
  char qname[64];
  char pqname[64];
  char tagname[64];
  char match_tagname[64];
  char overload_tblname[32];
  struct
  {
    pf_rule *tqe_next;
    pf_rule **tqe_prev;
  } entries;
  pf_pool rpool;
  u_int64_t evaluations;
  u_int64_t packets[2];
  u_int64_t bytes[2];
  u_int64_t ticket;
  char owner[64];
  u_int32_t priority;
  pfi_kif *kif;
  pf_anchor *anchor;
  pfr_ktable *overload_tbl;
  pf_osfp_t os_fingerprint;
  unsigned int rtableid;
  u_int32_t timeout[26];
  u_int32_t states;
  u_int32_t max_states;
  u_int32_t src_nodes;
  u_int32_t max_src_nodes;
  u_int32_t max_src_states;
  u_int32_t max_src_conn;
  struct
  {
    u_int32_t limit;
    u_int32_t seconds;
  } max_src_conn_rate;
  u_int32_t qid;
  u_int32_t pqid;
  u_int32_t rt_listid;
  u_int32_t nr;
  u_int32_t prob;
  uid_t cuid;
  pid_t cpid;
  u_int16_t return_icmp;
  u_int16_t return_icmp6;
  u_int16_t max_mss;
  u_int16_t tag;
  u_int16_t match_tag;
  pf_rule_uid uid;
  pf_rule_gid gid;
  u_int32_t rule_flag;
  u_int8_t action;
  u_int8_t direction;
  u_int8_t log;
  u_int8_t logif;
  u_int8_t quick;
  u_int8_t ifnot;
  u_int8_t match_tag_not;
  u_int8_t natpass;
  u_int8_t keep_state;
  sa_family_t af;
  u_int8_t proto;
  u_int8_t type;
  u_int8_t code;
  u_int8_t flags;
  u_int8_t flagset;
  u_int8_t min_ttl;
  u_int8_t allow_opts;
  u_int8_t rt;
  u_int8_t return_ttl;
  u_int8_t tos;
  u_int8_t anchor_relative;
  u_int8_t anchor_wildcard;
  u_int8_t flush;
  u_int8_t proto_variant;
  u_int8_t extfilter;
  u_int8_t extmap;
  u_int32_t dnpipe;
  u_int32_t dntype;
};

/* 4298 */
struct pf_anchor
{
  struct
  {
    pf_anchor *rbe_left;
    pf_anchor *rbe_right;
    pf_anchor *rbe_parent;
  } entry_global;
  struct
  {
    pf_anchor *rbe_left;
    pf_anchor *rbe_right;
    pf_anchor *rbe_parent;
  } entry_node;
  pf_anchor *parent;
  pf_anchor_node children;
  char name[64];
  char path[1024];
  pf_ruleset ruleset;
  int refcnt;
  int match;
  char owner[64];
};

/* 1206 */
typedef uint32_t IOSKOffset;

/* 1205 */
typedef uint32_t IOSKIndex;

/* 7333 */
struct IOSKRegion::ArenaEntry
{
  struct
  {
    IOSKRegion::ArenaEntry *sle_next;
  } link;
  IOSKArena *fArena;
  IOSKOffset fRegionOffset;
  IOSKIndex fRegionIndex;
};

/* 1204 */
typedef IOSKMemoryBuffer IOSKBuffer;

/* 7332 */
struct IOSKRegion::Segment
{
  IOSKBuffer *fBuffer;
};

/* 5717 */
struct vm_map_store
{
  struct
  {
    vm_map_store *rbe_left;
    vm_map_store *rbe_right;
    vm_map_store *rbe_parent;
  } entry;
};

/* 8212 */
typedef uint32_t vm_page_packed_t;

/* 7019 */
typedef vm_page_packed_t vm_page_object_t;

/* 5718 */
struct vm_map_entry
{
  vm_map_links links;
  vm_map_store store;
  union
  {
    vm_offset_t vme_object_value;
    struct
    {
      _BYTE gap0[8];
    };
    struct
    {
      _BYTE gap0[4];
      vm_page_object_t vme_object_or_delta;
    };
  };
  _BYTE gap40[12];
  unsigned __int16 wired_count;
  unsigned __int16 user_wired_count;
};

/* 6069 */
struct vm_map_corpse_footprint_header
{
  vm_size_t_0 cf_size;
  uint32_t cf_last_region;
  union
  {
    uint32_t cfu_last_zeroes;
    uint32_t cfu_hint_region;
  } cfu;
};

/* 3223 */
struct __attribute__((aligned(64))) cuckoo_hashtable
{
  uint32_t _bitmask;
  uint32_t _n_buckets;
  volatile uint32_t _n_entries;
  uint32_t _capacity;
  uint32_t _rcapacity;
  bool _busy;
  uint32_t _resize_waiters;
  lck_rw_t _resize_lock;
  lck_mtx_t _lock;
  _bucket *_buckets;
  int (*_obj_cmp)(cuckoo_node *, void *);
  void (*_obj_retain)(cuckoo_node *);
  void (*_obj_release)(cuckoo_node *);
};

/* 3079 */
struct flow_route_tree
{
  flow_route *rbh_root;
};

/* 3080 */
struct __attribute__((aligned(8))) flow_route_bucket
{
  lck_rw_t frb_lock;
  flow_route_tree frb_head;
  const uint32_t frb_idx;
};

/* 3077 */
struct flow_route_id_tree
{
  flow_route *rbh_root;
};

/* 3078 */
struct __attribute__((aligned(8))) flow_route_id_bucket
{
  lck_rw_t frib_lock;
  flow_route_id_tree frib_head;
  const uint32_t frib_idx;
};

/* 3138 */
struct __attribute__((aligned(8))) ipf
{
  ipf *ipf_down;
  ipf *ipf_up;
  __kern_packet *ipf_pkt;
  int ipf_len;
  int ipf_off;
  uint16_t ipf_mff;
};

/* 3246 */
struct __attribute__((aligned(4))) protons_token
{
  struct
  {
    protons_token *rbe_left;
    protons_token *rbe_right;
    protons_token *rbe_parent;
  } pt_link;
  os_refcnt_t pt_refcnt;
  pid_t pt_pid;
  pid_t pt_epid;
  uint8_t pt_protocol;
  uint8_t pt_flags;
};

/* 5006 */
enum packet_svc_class_t : __int32
{
  PKT_SC_BK_SYS = 0x80090,
  PKT_SC_BK = 0x100080,
  PKT_SC_BE = 0x0,
  PKT_SC_RD = 0x180010,
  PKT_SC_OAM = 0x200020,
  PKT_SC_AV = 0x280120,
  PKT_SC_RV = 0x300110,
  PKT_SC_VI = 0x380100,
  PKT_SC_SIG = 0x380130,
  PKT_SC_VO = 0x400180,
  PKT_SC_CTL = 0x480190,
};

/* 5005 */
enum sk_stats_flow_track_state_t : __int32
{
  SFT_STATE_CLOSED = 0x0,
  SFT_STATE_LISTEN = 0x1,
  SFT_STATE_SYN_SENT = 0x2,
  SFT_STATE_SYN_RECEIVED = 0x3,
  SFT_STATE_ESTABLISHED = 0x4,
  SFT_STATE_CLOSE_WAIT = 0x5,
  SFT_STATE_FIN_WAIT_1 = 0x6,
  SFT_STATE_CLOSING = 0x7,
  SFT_STATE_LAST_ACK = 0x8,
  SFT_STATE_FIN_WAIT_2 = 0x9,
  SFT_STATE_TIME_WAIT = 0xA,
  SFT_STATE_NO_TRAFFIC = 0x14,
  SFT_STATE_SINGLE = 0x15,
  SFT_STATE_MULTIPLE = 0x16,
  SFT_STATE_MAX = 0xFF,
};

/* 3051 */
struct __attribute__((aligned(2))) sk_stats_flow_track
{
  uint64_t sft_bytes;
  uint64_t sft_packets;
  uint64_t sft_spackets;
  sk_stats_flow_track_state_t sft_state;
  uint32_t sft_rtt;
  uint32_t sft_seq;
  uint16_t sft_max_win;
  uint8_t sft_wscale;
};

/* 9228 */
struct activity_bitmap
{
  uint64_t start;
  uint64_t bitmap[2];
};

/* 3053 */
typedef activity_bitmap activity_bitmap_t;

/* 3055 */
struct __attribute__((aligned(16))) sk_stats_flow
{
  uuid_t_1 sf_nx_uuid;
  char sf_if_name[16];
  uint32_t sf_if_index;
  uint32_t sf_bucket_idx;
  pid_t sf_pid;
  pid_t sf_epid;
  char sf_proc_name[32];
  char sf_eproc_name[32];
  uint32_t sf_flags;
  nexus_port_t sf_nx_port;
  uint8_t sf_protocol;
  packet_svc_class_t sf_svc_class;
  flowadv_idx_t sf_adv_idx;
  flow_key sf_key;
  volatile sk_stats_flow_track sf_ltrack;
  volatile sk_stats_flow_track sf_rtrack;
  activity_bitmap_t sf_activity;
};

/* 3056 */
struct __attribute__((aligned(16))) flow_stats
{
  sk_stats_flow fs_stats;
  os_refcnt_t fs_refcnt;
};

/* 3058 */
struct flow_demux_pattern
{
  uint16_t fdp_offset;
  uint16_t fdp_len;
  uint8_t fdp_mask[32];
  uint8_t fdp_value[32];
};

/* 5004 */
typedef int (*flow_demux_memcmp_mask_t)(const uint8_t *, const uint8_t *, const uint8_t *);

/* 3064 */
struct kern_flow_demux_pattern
{
  flow_demux_pattern fdp_demux_pattern;
  flow_demux_memcmp_mask_t fdp_memcmp_mask;
};

/* 2511 */
struct IOMemoryEntry
{
  ipc_port_t_0 entry;
  int64_t offset;
  uint64_t size;
  uint64_t start;
};

/* 4301 */
struct pf_palist
{
  pf_pooladdr *tqh_first;
  pf_pooladdr **tqh_last;
};

/* 4300 */
struct pf_poolhashkey
{
  union
  {
    u_int8_t key8[16];
    u_int16_t key16[8];
    u_int32_t key32[4];
  } pfk;
};

/* 4308 */
struct __attribute__((aligned(8))) pf_pool
{
  pf_palist list;
  pf_pooladdr *cur;
  pf_poolhashkey key;
  pf_addr counter;
  int tblidx;
  u_int16_t proxy_port[2];
  u_int8_t port_op;
  u_int8_t opts;
  sa_family_t af;
};

/* 4297 */
struct pf_anchor_node
{
  pf_anchor *rbh_root;
};

/* 2477 */
typedef IOVirtualRange_1 IOAddressRange_0;

/* 2517 */
union IOGeneralMemoryDescriptor::Ranges_0
{
  IOVirtualRange_0 *v;
  IOAddressRange_0 *v64;
  IOPhysicalRange_0 *p;
  void *uio;
};

/* 2472 */
typedef mach_vm_address_t_0 IOVirtualAddress_0;

/* 9879 */
struct IOVirtualRange_1
{
  IOVirtualAddress_0 address;
  IOByteCount length;
};

/* 2475 */
typedef IOPhysicalAddress64 IOPhysicalAddress_0;

/* 2474 */
typedef IOByteCount64 IOByteCount_0;

/* 2476 */
struct IOPhysicalRange_0
{
  IOPhysicalAddress_0 address;
  IOByteCount_0 length;
};

/* 2516 */
typedef _IOMemoryDescriptorMixedData *OSPtr<_IOMemoryDescriptorMixedData>;

/* 2486 */
typedef uint32_t ppnum_t_0;

/* 2521 */
struct __cppobj IOGeneralMemoryDescriptor_0 : IOMemoryDescriptor_0
{
  IOGeneralMemoryDescriptor::Ranges_0 _ranges;
  unsigned int _rangesCount;
  task_t_0 _task;
  union
  {
    IOVirtualRange_1 v;
    IOPhysicalRange_0 p;
  } _singleRange;
  unsigned int _wireCount;
  bool _initialized;
  OSPtr<_IOMemoryDescriptorMixedData> _memoryEntries;
  unsigned int _pages;
  ppnum_t_0 _highestPage;
  uint32_t __iomd_reservedA;
  uint32_t __iomd_reservedB;
  IOLock_0 *_prepareLock;
};

/* 2492 */
typedef UInt32 IOOptionBits_0;

/* 2522 */
struct __cppobj __attribute__((aligned(8))) IOBufferMemoryDescriptor_0 : IOGeneralMemoryDescriptor_0
{
  IOBufferMemoryDescriptor::ExpansionData_0 *reserved;
  void *_buffer;
  vm_size_t_0 _capacity;
  vm_offset_t _alignment;
  IOOptionBits_0 _options;
  uintptr_t _internalReserved;
  unsigned int _internalFlags;
};

/* 7331 */
struct __cppobj IOSKMemoryBuffer : IOBufferMemoryDescriptor_0
{
  IOSKMemoryBufferSpec fSpec;
  void *fKernelAddr;
  IOMemoryMap_1 *fKernelReadOnlyMapping;
};

/* 3221 */
struct _slot
{
  uint32_t _hash;
  cuckoo_node *_node;
};

/* 3222 */
struct __attribute__((aligned(16))) _bucket
{
  _slot _slots[6];
  lck_mtx_t _lock;
  uint8_t _inuse;
};

/* 4299 */
struct pf_pooladdr
{
  pf_addr_wrap addr;
  struct
  {
    pf_pooladdr *tqe_next;
    pf_pooladdr **tqe_prev;
  } entries;
  char ifname[16];
  pfi_kif *kif;
};

/* 2478 */
struct IOVirtualRange_0
{
  IOVirtualAddress_0 address;
  IOByteCount length;
};

/* 2473 */
struct __cppobj _IOMemoryDescriptorMixedData : OSObject_1
{
  void *_data;
  size_t _length;
  size_t _capacity;
};

/* 7768 */
struct IOBufferMemoryDescriptor::ExpansionData_0
{
  IOMemoryMap_0 *map;
};

/* 2558 */
typedef IOMemoryDescriptor_0 *libkern::intrusive_shared_ptr<IOMemoryDescriptor,intrusive_osobject_retainer>::pointer;

/* 7525 */
struct libkern::intrusive_shared_ptr<IOMemoryDescriptor,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOMemoryDescriptor,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7524 */
struct __cppobj OSSharedPtr<IOMemoryDescriptor> : libkern::intrusive_shared_ptr<IOMemoryDescriptor,intrusive_osobject_retainer>
{
};

/* 2501 */
typedef OSSharedPtr<IOMemoryDescriptor> OSPtr<IOMemoryDescriptor>;

/* 2557 */
typedef IOMemoryMap_0 *libkern::intrusive_shared_ptr<IOMemoryMap,intrusive_osobject_retainer>::pointer;

/* 7491 */
struct libkern::intrusive_shared_ptr<IOMemoryMap,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOMemoryMap,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7490 */
struct __cppobj OSSharedPtr<IOMemoryMap> : libkern::intrusive_shared_ptr<IOMemoryMap,intrusive_osobject_retainer>
{
};

/* 2509 */
typedef OSSharedPtr<IOMemoryMap> OSPtr<IOMemoryMap>;

/* 2507 */
typedef upl *upl_t;

/* 9878 */
struct __cppobj IOMemoryMap_1 : OSObject_1
{
  IOOptionBits fOptions;
  OSPtr<IOMemoryDescriptor> fMemory;
  OSPtr<IOMemoryMap> fSuperMap;
  mach_vm_size_t_0 fOffset;
  mach_vm_address_t_0 fAddress;
  mach_vm_size_t_0 fLength;
  task_t_0 fAddressTask;
  vm_map_t_0 fAddressMap;
  upl_t fRedirUPL;
  uint8_t fUserClientUnmap;
};

/* 2510 */
struct __cppobj IOMemoryMap_0 : OSObject_0
{
  IOOptionBits fOptions;
  OSPtr<IOMemoryDescriptor> fMemory;
  OSPtr<IOMemoryMap> fSuperMap;
  mach_vm_size_t_0 fOffset;
  mach_vm_address_t_0 fAddress;
  mach_vm_size_t_0 fLength;
  task_t_0 fAddressTask;
  vm_map_t_0 fAddressMap;
  upl_t fRedirUPL;
  uint8_t fUserClientUnmap;
};

/* 1364 */
typedef uint64_t vm_object_offset_t;

/* 7496 */
typedef uint32_t upl_size_t;

/* 1365 */
typedef vm_object *vm_object_t;

/* 5839 */
typedef _vector_upl *vector_upl_t;

/* 9355 */
struct __attribute__((aligned(8))) upl_page_info_1
{
  ppnum_t_0 phys_addr;
};

/* 2505 */
struct upl
{
  lck_mtx_t_0 Lock;
  int ref_count;
  int ext_ref_count;
  int flags;
  vm_object_offset_t u_offset;
  upl_size_t u_size;
  upl_size_t u_mapped_size;
  vm_offset_t kaddr;
  vm_object_t map_object;
  vector_upl_t vector_upl;
  upl_t associated_upl;
  upl_io_completion *upl_iodone;
  ppnum_t_0 highest_page;
  int upl_priority;
  uint64_t *upl_reprio_info;
  void *decmp_io_upl;
  thread_t_0 upl_creator;
  queue_chain_t_0 uplq;
  bitmap_t *lite_list;
  upl_page_info_1 page_list[];
};

/* 8451 */
struct vm_page_packed_queue_entry
{
  vm_page_packed_t next;
  vm_page_packed_t prev;
};

/* 5753 */
typedef vm_page_packed_queue_entry vm_page_queue_head_t;

/* 7015 */
typedef uint64_t vm_object_size_t;

/* 3289 */
typedef memory_object *memory_object_t;

/* 1369 */
typedef vm_object *memory_object_control_t;

/* 7014 */
typedef int memory_object_copy_strategy_t;

/* 1367 */
struct vm_object
{
  vm_page_queue_head_t memq;
  lck_rw_t_0 Lock;
  union
  {
    vm_object_size_t vou_size;
    int vou_cache_pages_to_scan;
  } vo_un1;
  vm_page *memq_hint;
  int ref_count;
  unsigned int resident_page_count;
  unsigned int wired_page_count;
  unsigned int reusable_page_count;
  vm_object *copy;
  vm_object *shadow;
  memory_object_t pager;
  union
  {
    vm_object_offset_t vou_shadow_offset;
    clock_sec_t vou_cache_ts;
    task_t_0 vou_owner;
  } vo_un2;
  vm_object_offset_t paging_offset;
  memory_object_control_t pager_control;
  memory_object_copy_strategy_t copy_strategy;
  unsigned __int16 paging_in_progress;
  unsigned __int16 vo_size_delta;
  unsigned int activity_in_progress;
  queue_chain_t_0 cached_list;
  vm_object_offset_t last_alloc;
  vm_offset_t cow_hint;
  int sequential;
  uint32_t pages_created;
  uint32_t pages_used;
  __attribute__((aligned(8))) uint8_t scan_collisions;
  uint8_t __object4_unused_bits[1];
  vm_tag_t wire_tag;
  queue_head_t_0 uplq;
  queue_chain_t_0 objq;
  queue_chain_t_0 task_objq;
};

/* 2479 */
typedef upl_page_info_0 upl_page_info_t_0;

/* 1355 */
typedef upl_page_info_t_0 *upl_page_info_array_t;

/* 7850 */
typedef uint32_t upl_offset_t;

/* 9354 */
struct _vector_upl_iostates
{
  upl_offset_t offset;
  upl_size_t size;
};

/* 5837 */
typedef _vector_upl_iostates vector_upl_iostates_t;

/* 5838 */
struct _vector_upl
{
  upl_size_t size;
  uint32_t num_upls;
  uint32_t invalid_upls;
  uint32_t max_upls;
  vm_map_t_0 submap;
  vm_offset_t submap_dst_addr;
  vm_object_offset_t offset;
  upl_page_info_array_t pagelist;
  struct {upl_t elem;vector_upl_iostates_t iostate;}; upls[];
};

/* 5836 */
struct __attribute__((aligned(8))) upl_io_completion
{
  void *io_context;
  void (*io_done)(void *, int);
  int io_error;
};

/* 5752 */
typedef vm_page_packed_queue_entry vm_page_queue_chain_t;

/* 2484 */
struct vm_page
{
  union
  {
    vm_page_queue_chain_t vmp_q_pageq;
    vm_page *vmp_q_snext;
  } vmp_q_un;
  vm_page_queue_chain_t vmp_listq;
  vm_page_queue_chain_t vmp_specialq;
  vm_object_offset_t vmp_offset;
  vm_page_object_t vmp_object;
  __attribute__((aligned(8))) vm_page_packed_t vmp_next_m;
};

/* 1371 */
typedef natural_t mo_ipc_object_bits_t;

/* 1372 */
struct memory_object
{
  mo_ipc_object_bits_t mo_ikot;
  os_ref_atomic_t mo_ref;
  const memory_object_pager_ops *mo_pager_ops;
  memory_object_control_t mo_control;
};

/* 8248 */
struct __attribute__((aligned(8))) upl_page_info_0
{
  ppnum_t_0 phys_addr;
};

/* 1368 */
typedef natural_t memory_object_cluster_size_t;

/* 5393 */
typedef unsigned __int64 memory_object_offset_t;

/* 1366 */
typedef natural_t *memory_object_fault_info_t;

/* 1370 */
struct memory_object_pager_ops
{
  void (*memory_object_reference)(memory_object_t);
  void (*memory_object_deallocate)(memory_object_t);
  kern_return_t (*memory_object_init)(memory_object_t, memory_object_control_t, memory_object_cluster_size_t);
  kern_return_t (*memory_object_terminate)(memory_object_t);
  kern_return_t (*memory_object_data_request)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t, vm_prot_t, memory_object_fault_info_t);
  kern_return_t (*memory_object_data_return)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t, memory_object_offset_t *, int *, boolean_t, boolean_t, int);
  kern_return_t (*memory_object_data_initialize)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t);
  void *__obsolete_memory_object_data_unlock;
  void *__obsolete_memory_object_synchronize;
  kern_return_t (*memory_object_map)(memory_object_t, vm_prot_t);
  kern_return_t (*memory_object_last_unmap)(memory_object_t);
  void *__obsolete_memory_object_data_reclaim;
  boolean_t (*memory_object_backing_object)(memory_object_t, memory_object_offset_t, vm_object_t *, vm_object_offset_t *);
  const char *memory_object_pager_name;
};

/* 529 */
typedef int mpo_vnode_check_uipc_bind_t(kauth_cred_t, vnode *, label *, componentname *, vnode_attr *);

/* 7268 */
typedef __uint16_t __darwin_mode_t;

/* 1111 */
typedef __darwin_mode_t mode_t;

/* 7246 */
enum vtype_0 : __int32
{
  vtype::VNON_0 = 0x0,
  vtype::VREG_0 = 0x1,
  vtype::VDIR_0 = 0x2,
  vtype::VBLK_0 = 0x3,
  vtype::VCHR_0 = 0x4,
  vtype::VLNK_0 = 0x5,
  vtype::VSOCK_0 = 0x6,
  vtype::VFIFO_0 = 0x7,
  vtype::VBAD_0 = 0x8,
  vtype::VSTR_0 = 0x9,
  vtype::VCPLX_0 = 0xA,
};

/* 8188 */
struct fsid
{
  int32_t val[2];
};

/* 589 */
typedef fsid fsid_t;

/* 590 */
struct vnode_attr
{
  uint64_t va_supported;
  uint64_t va_active;
  int va_vaflags;
  dev_t va_rdev;
  uint64_t va_nlink;
  uint64_t va_total_size;
  uint64_t va_total_alloc;
  uint64_t va_data_size;
  uint64_t va_data_alloc;
  uint32_t va_iosize;
  uid_t va_uid;
  gid_t va_gid;
  mode_t va_mode;
  uint32_t va_flags;
  kauth_acl *va_acl;
  timespec va_create_time;
  timespec va_access_time;
  timespec va_modify_time;
  timespec va_change_time;
  timespec va_backup_time;
  uint64_t va_fileid;
  uint64_t va_linkid;
  uint64_t va_parentid;
  uint32_t va_fsid;
  uint64_t va_filerev;
  uint32_t va_gen;
  uint32_t va_encoding;
  vtype_0 va_type;
  char *va_name;
  guid_t_0 va_uuuid;
  guid_t_0 va_guuid;
  uint64_t va_nchildren;
  uint64_t va_dirlinkcount;
  kauth_acl *va_base_acl;
  timespec va_addedtime;
  uint32_t va_dataprotect_class;
  uint32_t va_dataprotect_flags;
  uint32_t va_document_id;
  uint32_t va_devid;
  uint32_t va_objtype;
  uint32_t va_objtag;
  uint32_t va_user_access;
  uint8_t va_finderinfo[32];
  uint64_t va_rsrc_length;
  uint64_t va_rsrc_alloc;
  fsid_t va_fsid64;
  uint32_t va_write_gencount;
  uint64_t va_private_size;
  uint64_t va_clone_id;
  uint64_t va_extflags;
  uint64_t va_recursive_gencount;
};

/* 530 */
typedef int mpo_vnode_check_signature_t(vnode *, label *, cpu_type_t, cs_blob *, unsigned int *, unsigned int *, int, unsigned int, char **, size_t *);

/* 531 */
typedef int mpo_vnode_notify_create_t(kauth_cred_t, mount *, label *, vnode *, label *, vnode *, label *, componentname *);

/* 967 */
struct vnodelst
{
  vnode *tqh_first;
  vnode **tqh_last;
};

/* 966 */
struct __attribute__((packed)) __attribute__((aligned(4))) vfsstatfs
{
  uint32_t f_bsize;
  size_t f_iosize;
  uint64_t f_blocks;
  uint64_t f_bfree;
  uint64_t f_bavail;
  uint64_t f_bused;
  uint64_t f_files;
  uint64_t f_ffree;
  fsid_t f_fsid;
  uid_t f_owner;
  uint64_t f_flags;
  char f_fstypename[16];
  char f_mntonname[1024];
  char f_mntfromname[1024];
  uint32_t f_fssubtype;
  void *f_reserved[2];
};

/* 1079 */
typedef int64_t quad_t;

/* 1085 */
typedef quad_t *qaddr_t;

/* 1084 */
typedef uint32_t pending_io_t;

/* 1080 */
typedef mount *mount_t;

/* 1078 */
enum vfs_trigger_callback_op_t : __int32
{
  VTC_REPLACE = 0x0,
  VTC_RELEASE = 0x1,
};

/* 959 */
typedef void vfs_trigger_callback_t(mount_t, vfs_trigger_callback_op_t, void *, vfs_context_t);

/* 968 */
struct mount
{
  struct
  {
    mount *tqe_next;
    mount **tqe_prev;
  } mnt_list;
  int32_t mnt_count;
  lck_mtx_t mnt_mlock;
  __attribute__((aligned(32))) vnodelst mnt_vnodelist;
  vnodelst mnt_workerqueue;
  vnodelst mnt_newvnodes;
  uint32_t mnt_flag;
  uint32_t mnt_kern_flag;
  uint32_t mnt_compound_ops;
  uint32_t mnt_lflag;
  uint32_t mnt_maxsymlinklen;
  vfsstatfs mnt_vfsstat;
  qaddr_t mnt_data;
  uint32_t mnt_maxreadcnt;
  uint32_t mnt_maxwritecnt;
  uint32_t mnt_segreadcnt;
  uint32_t mnt_segwritecnt;
  uint32_t mnt_maxsegreadsize;
  uint32_t mnt_maxsegwritesize;
  uint32_t mnt_alignmentmask;
  uint32_t mnt_devblocksize;
  uint32_t mnt_ioqueue_depth;
  uint32_t mnt_ioscale;
  uint32_t mnt_ioflags;
  uint32_t mnt_minsaturationbytecount;
  pending_io_t mnt_pending_write_size;
  pending_io_t mnt_pending_read_size;
  timeval mnt_last_write_issued_timestamp;
  timeval mnt_last_write_completed_timestamp;
  int64_t mnt_max_swappin_available;
  lck_rw_t mnt_rwlock;
  lck_mtx_t mnt_renamelock;
  vnode_t mnt_devvp;
  uint32_t mnt_devbsdunit;
  uint64_t mnt_throttle_mask;
  void *mnt_throttle_info;
  int32_t mnt_crossref;
  int32_t mnt_iterref;
  int32_t mnt_numtriggers;
  vfs_trigger_callback_t *mnt_triggercallback;
  void *mnt_triggerdata;
  uid_t mnt_fsowner;
  gid_t mnt_fsgroup;
  label *mnt_mntlabel;
  vnode_t mnt_realrootvp;
  uint32_t mnt_realrootvp_vid;
  uint32_t mnt_generation;
  int mnt_authcache_ttl;
  char fstypename_override[16];
  uint32_t mnt_iobufinuse;
  void *mnt_disk_conditioner_info;
  lck_mtx_t mnt_iter_lock;
  uint64_t mnt_mount_id;
  uint32_t mnt_supl_kern_flag;
};

/* 532 */
typedef void mpo_vnode_label_update_t(kauth_cred_t, vnode *, label *, label *);

/* 533 */
typedef int mpo_vnode_label_update_extattr_t(mount *, label *, vnode *, label *, const char *);

/* 534 */
typedef int mpo_vnode_label_store_t(kauth_cred_t, vnode *, label *, label *);

/* 535 */
typedef void mpo_vnode_label_recycle_t(label *);

/* 536 */
typedef int mpo_vnode_label_internalize_t(label *, char *, char *);

/* 537 */
typedef void mpo_vnode_label_init_t(label *);

/* 538 */
typedef int mpo_vnode_label_externalize_t(label *, char *, sbuf *);

/* 803 */
struct __attribute__((aligned(8))) sbuf
{
  char *s_buf;
  void *s_unused;
  int s_size;
  int s_len;
  int s_flags;
};

/* 539 */
typedef int mpo_vnode_label_externalize_audit_t(label *, char *, sbuf *);

/* 540 */
typedef void mpo_vnode_label_destroy_t(label *);

/* 541 */
typedef void mpo_vnode_label_copy_t(label *, label *);

/* 542 */
typedef void mpo_vnode_label_associate_socket_t(kauth_cred_t, socket_t_0, label *, vnode *, label *);

/* 543 */
typedef void mpo_vnode_label_associate_singlelabel_t(mount *, label *, vnode *, label *);

/* 544 */
typedef void mpo_vnode_label_associate_posixshm_t(ucred *, pshminfo *, label *, vnode *, label *);

/* 945 */
struct pshminfo
{
  unsigned int pshm_flags;
  unsigned int pshm_usecount;
  off_t pshm_length;
  mode_t pshm_mode;
  uid_t pshm_uid;
  gid_t pshm_gid;
  char pshm_name[32];
  void *pshm_memobject;
  label *pshm_label;
};

/* 545 */
typedef void mpo_vnode_label_associate_posixsem_t(ucred *, pseminfo *, label *, vnode *, label *);

/* 946 */
struct pseminfo
{
  unsigned int psem_flags;
  unsigned int psem_usecount;
  mode_t psem_mode;
  uid_t psem_uid;
  gid_t psem_gid;
  char psem_name[32];
  void *psem_semobject;
  label *psem_label;
  pid_t psem_creator_pid;
  uint64_t psem_creator_uniqueid;
};

/* 546 */
typedef void mpo_vnode_label_associate_pipe_t(ucred *, pipe *, label *, vnode *, label *);

/* 930 */
struct __attribute__((aligned(8))) pipebuf
{
  u_int cnt;
  u_int in;
  u_int out;
  u_int size;
  _BYTE gap10[8];
};

/* 931 */
struct pipe
{
  pipebuf pipe_buffer;
  selinfo pipe_sel;
  pid_t pipe_pgid;
  pipe *pipe_peer;
  u_int pipe_state;
  int pipe_busy;
  lck_mtx_t *pipe_mtxp;
  timespec st_atimespec;
  timespec st_mtimespec;
  timespec st_ctimespec;
  label *pipe_label;
};

/* 547 */
typedef void mpo_vnode_label_associate_file_t(ucred *, mount *, label *, fileglob *, label *, vnode *, label *);

/* 548 */
typedef int mpo_vnode_label_associate_extattr_t(mount *, label *, vnode *, label *);

/* 549 */
typedef void mpo_vnode_label_associate_devfs_t(mount *, label *, devnode *, label *, vnode *, label *);

/* 985 */
enum devfstype_t : __int32
{
  DEV_DIR = 0x0,
  DEV_BDEV = 0x1,
  DEV_CDEV = 0x2,
  DEV_SLNK = 0x3,
  DEV_DEVFD = 0x4,
};

/* 979 */
typedef devdirent devdirent_t;

/* 986 */
typedef devnode devnode_t;

/* 7908 */
union devnode_type
{
  dev_t dev;
  struct __attribute__((aligned(8)))
  {
    devdirent_t *dirlist;
    devdirent_t **dirlast;
    devnode_t *parent;
    devdirent_t *myname;
    int entrycount;
  } Dir;
  struct
  {
    char *name;
    size_t namelen;
  } Slnk;
};

/* 984 */
typedef devnode_type devnode_type_t;

/* 7253 */
typedef __uint32_t __darwin_ino_t;

/* 983 */
typedef __darwin_ino_t ino_t;

/* 1044 */
struct devnode
{
  devfstype_t dn_type;
  os_ref_atomic_t dn_refcount;
  u_short dn_mode;
  uid_t dn_uid;
  gid_t dn_gid;
  timespec dn_atime;
  timespec dn_mtime;
  timespec dn_ctime;
  int (***dn_ops)(void *);
  int dn_links;
  devfsmount *dn_dvm;
  vnode *dn_vn;
  int dn_len;
  devdirent_t *dn_linklist;
  devnode_t *dn_nextsibling;
  devnode_t **dn_prevsiblingp;
  devnode_type_t dn_typeinfo;
  int dn_change;
  int dn_update;
  int dn_access;
  int dn_lflags;
  ino_t dn_ino;
  int (*dn_clone)(dev_t, int);
  label *dn_label;
};

/* 982 */
struct devfsmount
{
  mount *mount;
  devdirent_t *plane_root;
};

/* 7254 */
struct devdirent
{
  char de_name[32];
  devnode_t *de_dnp;
  devnode_t *de_parent;
  devdirent_t *de_next;
  devdirent_t **de_prevp;
  devdirent_t *de_nextlink;
  devdirent_t **de_prevlinkp;
};

/* 550 */
typedef int mpo_vnode_check_write_t(kauth_cred_t, kauth_cred_t, vnode *, label *);

/* 551 */
typedef int mpo_vnode_check_unlink_t(kauth_cred_t, vnode *, label *, vnode *, label *, componentname *);

/* 552 */
typedef int mpo_vnode_check_truncate_t(kauth_cred_t, kauth_cred_t, vnode *, label *);

/* 553 */
typedef int mpo_vnode_check_stat_t(ucred *, ucred *, vnode *, label *);

/* 554 */
typedef int mpo_vnode_check_setutimes_t(kauth_cred_t, vnode *, label *, timespec, timespec);

/* 555 */
typedef int mpo_vnode_check_setowner_t(kauth_cred_t, vnode *, label *, uid_t, gid_t);

/* 556 */
typedef int mpo_vnode_check_setmode_t(kauth_cred_t, vnode *, label *, mode_t);

/* 557 */
typedef int mpo_vnode_check_setflags_t(kauth_cred_t, vnode *, label *, u_long);

/* 558 */
typedef int mpo_vnode_check_setextattr_t(kauth_cred_t, vnode *, label *, const char *, uio *);

/* 559 */
typedef int mpo_vnode_check_setattrlist_t(kauth_cred_t, vnode *, label *, attrlist *);

/* 560 */
typedef int mpo_vnode_check_select_t(kauth_cred_t, vnode *, label *, int);

/* 561 */
typedef int mpo_vnode_check_revoke_t(kauth_cred_t, vnode *, label *);

/* 562 */
typedef int mpo_vnode_check_rename_to_t(kauth_cred_t, vnode *, label *, vnode *, label *, int, componentname *);

/* 563 */
typedef int mpo_vnode_check_rename_from_t(kauth_cred_t, vnode *, label *, vnode *, label *, componentname *);

/* 564 */
typedef int mpo_vnode_check_readlink_t(kauth_cred_t, vnode *, label *);

/* 565 */
typedef int mpo_vnode_check_readdir_t(kauth_cred_t, vnode *, label *);

/* 566 */
typedef int mpo_vnode_check_read_t(kauth_cred_t, kauth_cred_t, vnode *, label *);

/* 567 */
typedef int mpo_vnode_check_open_t(kauth_cred_t, vnode *, label *, int);

/* 568 */
typedef int mpo_vnode_check_lookup_t(kauth_cred_t, vnode *, label *, componentname *);

/* 569 */
typedef int mpo_vnode_check_listextattr_t(kauth_cred_t, vnode *, label *);

/* 570 */
typedef int mpo_vnode_check_link_t(kauth_cred_t, vnode *, label *, vnode *, label *, componentname *);

/* 571 */
typedef int mpo_vnode_check_label_update_t(ucred *, vnode *, label *, label *);

/* 572 */
typedef int mpo_vnode_check_kqfilter_t(kauth_cred_t, kauth_cred_t, knote *, vnode *, label *);

/* 573 */
typedef int mpo_vnode_check_ioctl_t(kauth_cred_t, vnode *, label *, unsigned __int64);

/* 574 */
typedef int mpo_vnode_check_getextattr_t(kauth_cred_t, vnode *, label *, const char *, uio *);

/* 575 */
typedef int mpo_vnode_check_getattrlist_t(kauth_cred_t, vnode *, label *, attrlist *, uint64_t);

/* 576 */
typedef int mpo_vnode_check_exec_t(kauth_cred_t, vnode *, vnode *, label *, label *, label *, componentname *, u_int *, void *, size_t);

/* 577 */
typedef int mpo_vnode_check_exchangedata_t(kauth_cred_t, vnode *, label *, vnode *, label *);

/* 578 */
typedef int mpo_vnode_check_deleteextattr_t(kauth_cred_t, vnode *, label *, const char *);

/* 579 */
typedef int mpo_vnode_check_create_t(kauth_cred_t, vnode *, label *, componentname *, vnode_attr *);

/* 580 */
typedef int mpo_vnode_check_chroot_t(kauth_cred_t, vnode *, label *, componentname *);

/* 581 */
typedef int mpo_vnode_check_chdir_t(kauth_cred_t, vnode *, label *);

/* 582 */
typedef int mpo_vnode_check_access_t(kauth_cred_t, vnode *, label *, int);

/* 583 */
typedef int mpo_iokit_check_hid_control_t(kauth_cred_t);

/* 584 */
typedef int mpo_proc_check_set_cs_info_t(kauth_cred_t, struct proc *, unsigned int);

/* 585 */
typedef int mpo_proc_check_get_cs_info_t(kauth_cred_t, struct proc *, unsigned int);

/* 586 */
typedef int mpo_vnode_check_clone_t(kauth_cred_t, vnode *, label *, vnode *, label *, componentname *);

/* 587 */
typedef int mpo_mount_check_snapshot_delete_t(kauth_cred_t, mount *, const char *);

/* 588 */
typedef int mpo_mount_check_snapshot_create_t(kauth_cred_t, mount *, const char *);

/* 591 */
typedef int mpo_vnode_check_getattr_t(kauth_cred_t, kauth_cred_t, vnode *, label *, vnode_attr *);

/* 592 */
typedef int mpo_mount_check_snapshot_revert_t(kauth_cred_t, mount *, const char *);

/* 593 */
typedef void mpo_proc_notify_exit_t(struct proc *);

/* 594 */
typedef void mpo_sysvshm_label_recycle_t(label *);

/* 595 */
typedef void mpo_sysvshm_label_init_t(label *);

/* 596 */
typedef void mpo_sysvshm_label_destroy_t(label *);

/* 597 */
typedef void mpo_sysvshm_label_associate_t(kauth_cred_t, shmid_kernel *, label *);

/* 1103 */
typedef __int32_t key_t;

/* 949 */
struct ipc_perm
{
  uid_t uid;
  gid_t gid;
  uid_t cuid;
  gid_t cgid;
  mode_t mode;
  unsigned __int16 _seq;
  key_t _key;
};

/* 1033 */
typedef int64_t user_time_t;

/* 953 */
struct __attribute__((packed)) __attribute__((aligned(4))) user_shmid_ds
{
  ipc_perm shm_perm;
  user_size_t shm_segsz;
  pid_t shm_lpid;
  pid_t shm_cpid;
  short shm_nattch;
  __attribute__((aligned(4))) user_time_t shm_atime;
  user_time_t shm_dtime;
  user_time_t shm_ctime;
  user_addr_t_0 shm_internal;
};

/* 954 */
struct shmid_kernel
{
  user_shmid_ds u;
  label *label;
};

/* 598 */
typedef int mpo_sysvshm_check_shmget_t(kauth_cred_t, shmid_kernel *, label *, int);

/* 599 */
typedef int mpo_sysvshm_check_shmdt_t(kauth_cred_t, shmid_kernel *, label *);

/* 600 */
typedef int mpo_sysvshm_check_shmctl_t(kauth_cred_t, shmid_kernel *, label *, int);

/* 601 */
typedef int mpo_sysvshm_check_shmat_t(kauth_cred_t, shmid_kernel *, label *, int);

/* 602 */
typedef void mpo_sysvsem_label_recycle_t(label *);

/* 603 */
typedef void mpo_sysvsem_label_init_t(label *);

/* 604 */
typedef void mpo_sysvsem_label_destroy_t(label *);

/* 605 */
typedef void mpo_sysvsem_label_associate_t(kauth_cred_t, semid_kernel *, label *);

/* 956 */
struct __attribute__((aligned(8))) user_semid_ds
{
  ipc_perm sem_perm;
  sem *sem_base;
  unsigned __int16 sem_nsems;
  user_time_t sem_otime;
  __int32_t sem_pad1;
  user_time_t sem_ctime;
  __int32_t sem_pad2;
  __int32_t sem_pad3[4];
};

/* 929 */
struct semid_kernel
{
  user_semid_ds u;
  label *label;
};

/* 955 */
struct sem
{
  unsigned __int16 semval;
  pid_t sempid;
  unsigned __int16 semncnt;
  unsigned __int16 semzcnt;
};

/* 606 */
typedef int mpo_sysvsem_check_semop_t(kauth_cred_t, semid_kernel *, label *, size_t);

/* 607 */
typedef int mpo_sysvsem_check_semget_t(kauth_cred_t, semid_kernel *, label *);

/* 608 */
typedef int mpo_sysvsem_check_semctl_t(kauth_cred_t, semid_kernel *, label *, int);

/* 609 */
typedef void mpo_sysvmsq_label_recycle_t(label *);

/* 610 */
typedef void mpo_sysvmsq_label_init_t(label *);

/* 611 */
typedef void mpo_sysvmsq_label_destroy_t(label *);

/* 612 */
typedef void mpo_sysvmsq_label_associate_t(kauth_cred_t, msqid_kernel *, label *);

/* 1064 */
typedef u_int64_t user_ulong_t;

/* 947 */
typedef user_ulong_t user_msglen_t;

/* 948 */
typedef user_ulong_t user_msgqnum_t;

/* 950 */
struct __attribute__((aligned(8))) user_msqid_ds
{
  ipc_perm msg_perm;
  msg *msg_first;
  msg *msg_last;
  user_msglen_t msg_cbytes;
  user_msgqnum_t msg_qnum;
  user_msglen_t msg_qbytes;
  pid_t msg_lspid;
  pid_t msg_lrpid;
  user_time_t msg_stime;
  __int32_t msg_pad1;
  user_time_t msg_rtime;
  __int32_t msg_pad2;
  user_time_t msg_ctime;
  __int32_t msg_pad3;
  __int32_t msg_pad4[4];
};

/* 951 */
struct msqid_kernel
{
  user_msqid_ds u;
  label *label;
};

/* 952 */
struct msg
{
  msg *msg_next;
  long msg_type;
  unsigned __int16 msg_ts;
  short msg_spot;
  label *label;
};

/* 613 */
typedef int mpo_sysvmsq_check_msqsnd_t(kauth_cred_t, msqid_kernel *, label *);

/* 614 */
typedef int mpo_sysvmsq_check_msqrcv_t(kauth_cred_t, msqid_kernel *, label *);

/* 615 */
typedef int mpo_sysvmsq_check_msqget_t(kauth_cred_t, msqid_kernel *, label *);

/* 616 */
typedef int mpo_sysvmsq_check_msqctl_t(kauth_cred_t, msqid_kernel *, label *, int);

/* 617 */
typedef int mpo_sysvmsq_check_msgrmid_t(kauth_cred_t, msg *, label *);

/* 618 */
typedef int mpo_sysvmsq_check_msgrcv_t(kauth_cred_t, msg *, label *);

/* 619 */
typedef int mpo_sysvmsq_check_enqueue_t(kauth_cred_t, msg *, label *, msqid_kernel *, label *);

/* 620 */
typedef void mpo_sysvmsg_label_recycle_t(label *);

/* 621 */
typedef void mpo_sysvmsg_label_init_t(label *);

/* 622 */
typedef void mpo_sysvmsg_label_destroy_t(label *);

/* 623 */
typedef void mpo_sysvmsg_label_associate_t(kauth_cred_t, msqid_kernel *, label *, msg *, label *);

/* 624 */
typedef int mpo_socket_check_ioctl_t(kauth_cred_t, socket_t_0, unsigned __int64, label *);

/* 625 */
typedef int mpo_system_check_swapon_t(kauth_cred_t, vnode *, label *);

/* 626 */
typedef int mpo_system_check_swapoff_t(kauth_cred_t, vnode *, label *);

/* 627 */
typedef int mpo_system_check_settime_t(kauth_cred_t);

/* 628 */
typedef int mpo_system_check_reboot_t(kauth_cred_t, int);

/* 629 */
typedef int mpo_system_check_nfsd_t(kauth_cred_t);

/* 630 */
typedef int mpo_system_check_host_priv_t(kauth_cred_t);

/* 631 */
typedef int mpo_system_check_auditon_t(kauth_cred_t, int);

/* 632 */
typedef int mpo_system_check_auditctl_t(kauth_cred_t, vnode *, label *);

/* 633 */
typedef int mpo_system_check_audit_t(kauth_cred_t, void *, int);

/* 634 */
typedef int mpo_system_check_acct_t(kauth_cred_t, vnode *, label *);

/* 635 */
typedef int mpo_iokit_check_open_service_t(kauth_cred_t, io_object_t_0, unsigned int);

/* 636 */
typedef int mpo_proc_check_memorystatus_control_t(kauth_cred_t, int32_t, pid_t);

/* 637 */
typedef int mpo_proc_check_settid_t(kauth_cred_t, kauth_cred_t, uid_t, gid_t);

/* 638 */
typedef int mpo_proc_check_setregid_t(kauth_cred_t, gid_t, gid_t);

/* 639 */
typedef int mpo_proc_check_setegid_t(kauth_cred_t, gid_t);

/* 640 */
typedef int mpo_proc_check_setgid_t(kauth_cred_t, gid_t);

/* 641 */
typedef int mpo_proc_check_setreuid_t(kauth_cred_t, uid_t, uid_t);

/* 642 */
typedef int mpo_proc_check_seteuid_t(kauth_cred_t, uid_t);

/* 643 */
typedef int mpo_proc_check_setuid_t(kauth_cred_t, uid_t);

/* 644 */
typedef int mpo_proc_check_dyld_process_info_notify_register_t(kauth_cred_t);

/* 645 */
typedef int mpo_proc_check_get_movable_control_port_t(kauth_cred_t);

/* 646 */
typedef int mpo_socket_check_getsockopt_t(kauth_cred_t, socket_t_0, label *, sockopt *);

/* 648 */
typedef int mpo_socket_check_setsockopt_t(kauth_cred_t, socket_t_0, label *, sockopt *);

/* 649 */
typedef int mpo_socket_check_stat_t(kauth_cred_t, socket_t_0, label *);

/* 650 */
typedef int mpo_socket_check_send_t(kauth_cred_t, socket_t_0, label *, sockaddr *);

/* 655 */
typedef int mpo_socket_check_received_t(kauth_cred_t, socket *, label *, sockaddr *);

/* 656 */
typedef int mpo_socket_check_receive_t(kauth_cred_t, socket_t_0, label *);

/* 657 */
typedef int mpo_socket_check_listen_t(kauth_cred_t, socket_t_0, label *);

/* 658 */
typedef int mpo_socket_check_create_t(kauth_cred_t, int, int, int);

/* 659 */
typedef int mpo_socket_check_connect_t(kauth_cred_t, socket_t_0, label *, sockaddr *);

/* 660 */
typedef int mpo_socket_check_bind_t(kauth_cred_t, socket_t_0, label *, sockaddr *);

/* 661 */
typedef int mpo_socket_check_accepted_t(kauth_cred_t, socket_t_0, label *, sockaddr *);

/* 662 */
typedef int mpo_socket_check_accept_t(kauth_cred_t, socket_t_0, label *);

/* 1039 */
typedef natural_t *thread_state_t;

/* 7170 */
typedef natural_t mach_msg_type_number_t;

/* 663 */
typedef int mpo_proc_check_remote_thread_create_t(kauth_cred_t, struct proc *, int, thread_state_t, mach_msg_type_number_t);

/* 664 */
typedef int mpo_proc_check_dump_core_t(struct proc *);

/* 665 */
typedef int mpo_proc_check_wait_t(kauth_cred_t, struct proc *);

/* 666 */
typedef int mpo_proc_check_signal_t(kauth_cred_t, struct proc *, int);

/* 667 */
typedef int mpo_proc_check_setlcid_t(struct proc *, struct proc *, pid_t, pid_t);

/* 668 */
typedef int mpo_proc_check_setauid_t(kauth_cred_t, uid_t);

/* 669 */
typedef int mpo_proc_check_setaudit_t(kauth_cred_t, auditinfo_addr *);

/* 670 */
typedef int mpo_proc_check_sched_t(kauth_cred_t, struct proc *);

/* 671 */
typedef int mpo_proc_check_mprotect_t(kauth_cred_t, struct proc *, user_addr_t_0, user_size_t, int);

/* 672 */
typedef int mpo_proc_check_getlcid_t(struct proc *, struct proc *, pid_t);

/* 673 */
typedef int mpo_proc_check_getauid_t(kauth_cred_t);

/* 674 */
typedef int mpo_proc_check_getaudit_t(kauth_cred_t);

/* 675 */
typedef int mpo_proc_check_fork_t(kauth_cred_t, struct proc *);

/* 676 */
typedef int mpo_proc_check_debug_t(kauth_cred_t, proc_ident *);

/* 904 */
struct proc_ident
{
  uint64_t p_uniqueid;
  pid_t p_pid;
  int p_idversion;
};

/* 677 */
typedef void mpo_posixshm_label_init_t(label *);

/* 678 */
typedef void mpo_posixshm_label_destroy_t(label *);

/* 679 */
typedef void mpo_posixshm_label_associate_t(kauth_cred_t, pshminfo *, label *, const char *);

/* 680 */
typedef int mpo_posixshm_check_unlink_t(kauth_cred_t, pshminfo *, label *, const char *);

/* 681 */
typedef int mpo_posixshm_check_truncate_t(kauth_cred_t, pshminfo *, label *, off_t);

/* 682 */
typedef int mpo_posixshm_check_stat_t(kauth_cred_t, pshminfo *, label *);

/* 683 */
typedef int mpo_posixshm_check_open_t(kauth_cred_t, pshminfo *, label *, int);

/* 684 */
typedef int mpo_posixshm_check_mmap_t(kauth_cred_t, pshminfo *, label *, int, int);

/* 685 */
typedef int mpo_posixshm_check_create_t(kauth_cred_t, const char *);

/* 686 */
typedef void mpo_posixsem_label_init_t(label *);

/* 687 */
typedef void mpo_posixsem_label_destroy_t(label *);

/* 688 */
typedef void mpo_posixsem_label_associate_t(kauth_cred_t, pseminfo *, label *, const char *);

/* 689 */
typedef int mpo_posixsem_check_wait_t(kauth_cred_t, pseminfo *, label *);

/* 690 */
typedef int mpo_posixsem_check_unlink_t(kauth_cred_t, pseminfo *, label *, const char *);

/* 691 */
typedef int mpo_posixsem_check_post_t(kauth_cred_t, pseminfo *, label *);

/* 692 */
typedef int mpo_posixsem_check_open_t(kauth_cred_t, pseminfo *, label *);

/* 693 */
typedef int mpo_posixsem_check_create_t(kauth_cred_t, const char *);

/* 694 */
typedef int mpo_skywalk_flow_check_listen_t(kauth_cred_t, void *, const sockaddr *, int, int);

/* 696 */
typedef int mpo_skywalk_flow_check_connect_t(kauth_cred_t, void *, const sockaddr *, int, int);

/* 697 */
typedef void mpo_vnode_notify_reclaim_t(vnode *);

/* 698 */
typedef int mpo_mount_check_snapshot_mount_t(kauth_cred_t, vnode *, vnode *, componentname *, const char *, const char *);

/* 699 */
typedef int mpo_mount_check_mount_late_t(kauth_cred_t, mount *);

/* 700 */
typedef int mpo_vnode_check_trigger_resolve_t(kauth_cred_t, vnode *, label *, componentname *);

/* 701 */
typedef int mpo_exc_action_label_update_t(exception_action *, label *, label *);

/* 3965 */
typedef int thread_state_flavor_t;

/* 3966 */
typedef int exception_behavior_t;

/* 902 */
struct exception_action
{
  _BYTE gap0[8];
  thread_state_flavor_t flavor;
  exception_behavior_t behavior;
  boolean_t privileged;
  label *label;
};

/* 702 */
typedef int mpo_exc_action_label_init_t(label *);

/* 703 */
typedef void mpo_exc_action_label_destroy_t(label *);

/* 704 */
typedef void mpo_exc_action_label_populate_t(label *, struct proc *);

/* 705 */
typedef void mpo_exc_action_label_associate_t(exception_action *, label *);

/* 706 */
typedef int mpo_exc_action_check_exception_send_t(label *, exception_action *, label *);

/* 707 */
typedef int mpo_proc_check_set_host_exception_port_t(kauth_cred_t, unsigned int);

/* 708 */
typedef int mpo_proc_check_set_host_special_port_t(kauth_cred_t, int, struct ipc_port *);

/* 709 */
typedef int mpo_proc_check_syscall_unix_t(struct proc *, int);

/* 710 */
typedef void mpo_proc_notify_cs_invalidated_t(struct proc *);

/* 711 */
typedef void mpo_proc_notify_exec_complete_t(struct proc *);

/* 712 */
typedef int mpo_kext_check_query_t(kauth_cred_t);

/* 713 */
typedef int mpo_vnode_check_rename_t(kauth_cred_t, vnode *, label *, vnode *, label *, componentname *, vnode *, label *, vnode *, label *, componentname *);

/* 714 */
typedef int mpo_proc_check_inherit_ipc_ports_t(struct proc *, vnode *, off_t, vnode *, off_t, vnode *);

/* 715 */
typedef int mpo_system_check_sysctlbyname_t(kauth_cred_t, const char *, int *, size_t, user_addr_t_0, size_t, user_addr_t_0, size_t);

/* 716 */
typedef int mpo_policy_syscall_t(struct proc *, int, user_addr_t_0);

/* 717 */
typedef void mpo_policy_initbsd_t(mac_policy_conf *);

/* 817 */
struct mac_policy_conf
{
  const char *mpc_name;
  const char *mpc_fullname;
  const char *const *mpc_labelnames;
  unsigned int mpc_labelname_count;
  const mac_policy_ops *mpc_ops;
  int mpc_loadtime_flags;
  int *mpc_field_off;
  int mpc_runtime_flags;
  mac_policy_conf *mpc_list;
  void *mpc_data;
};

/* 815 */
typedef int mpo_audit_check_postselect_t(kauth_cred_t, unsigned __int16, void *, int, int);

/* 814 */
typedef int mpo_audit_check_preselect_t(kauth_cred_t, unsigned __int16, void *);

/* 1045 */
typedef void mpo_reserved_hook_t(void);

/* 813 */
typedef int mpo_cred_check_label_update_execve_t(kauth_cred_t, vnode *, off_t, vnode *, label *, label *, label *, struct proc *, void *, size_t);

/* 812 */
typedef int mpo_cred_check_label_update_t(kauth_cred_t, label *);

/* 811 */
typedef int mpo_cred_check_visible_t(kauth_cred_t, kauth_cred_t);

/* 810 */
typedef void mpo_cred_label_associate_fork_t(kauth_cred_t, proc_t);

/* 808 */
typedef void mpo_cred_label_associate_kernel_t(kauth_cred_t);

/* 807 */
typedef void mpo_cred_label_associate_t(kauth_cred_t, kauth_cred_t);

/* 806 */
typedef void mpo_cred_label_associate_user_t(kauth_cred_t);

/* 805 */
typedef void mpo_cred_label_destroy_t(label *);

/* 804 */
typedef int mpo_cred_label_externalize_audit_t(label *, char *, sbuf *);

/* 802 */
typedef int mpo_cred_label_externalize_t(label *, char *, sbuf *);

/* 801 */
typedef void mpo_cred_label_init_t(label *);

/* 800 */
typedef int mpo_cred_label_internalize_t(label *, char *, char *);

/* 799 */
typedef int mpo_cred_label_update_execve_t(kauth_cred_t, kauth_cred_t, struct proc *, vnode *, off_t, vnode *, label *, label *, label *, u_int *, void *, size_t, int *);

/* 798 */
typedef void mpo_cred_label_update_t(kauth_cred_t, label *);

/* 797 */
typedef void mpo_devfs_label_associate_device_t(dev_t, devnode *, label *, const char *);

/* 796 */
typedef void mpo_devfs_label_associate_directory_t(const char *, int, devnode *, label *, const char *);

/* 795 */
typedef void mpo_devfs_label_copy_t(label *, label *);

/* 794 */
typedef void mpo_devfs_label_destroy_t(label *);

/* 793 */
typedef void mpo_devfs_label_init_t(label *);

/* 792 */
typedef void mpo_devfs_label_update_t(mount *, devnode *, label *, vnode *, label *);

/* 791 */
typedef int mpo_file_check_change_offset_t(kauth_cred_t, fileglob *, label *);

/* 790 */
typedef int mpo_file_check_create_t(kauth_cred_t);

/* 789 */
typedef int mpo_file_check_dup_t(kauth_cred_t, fileglob *, label *, int);

/* 1043 */
typedef int64_t user_long_t;

/* 788 */
typedef int mpo_file_check_fcntl_t(kauth_cred_t, fileglob *, label *, int, user_long_t);

/* 787 */
typedef int mpo_file_check_get_offset_t(kauth_cred_t, fileglob *, label *);

/* 786 */
typedef int mpo_file_check_get_t(kauth_cred_t, fileglob *, char *, size_t);

/* 785 */
typedef int mpo_file_check_inherit_t(kauth_cred_t, fileglob *, label *);

/* 784 */
typedef int mpo_file_check_ioctl_t(kauth_cred_t, fileglob *, label *, unsigned __int64);

/* 783 */
typedef int mpo_file_check_lock_t(kauth_cred_t, fileglob *, label *, int, flock *);

/* 781 */
typedef void mpo_file_check_mmap_downgrade_t(kauth_cred_t, fileglob *, label *, int *);

/* 780 */
typedef int mpo_file_check_mmap_t(kauth_cred_t, fileglob *, label *, int, int, uint64_t, int *);

/* 779 */
typedef int mpo_file_check_receive_t(kauth_cred_t, fileglob *, label *);

/* 778 */
typedef int mpo_file_check_set_t(kauth_cred_t, fileglob *, char *, size_t);

/* 777 */
typedef void mpo_file_label_init_t(label *);

/* 776 */
typedef void mpo_file_label_destroy_t(label *);

/* 775 */
typedef void mpo_file_label_associate_t(kauth_cred_t, fileglob *, label *);

/* 774 */
typedef void mpo_file_notify_close_t(kauth_cred_t, fileglob *, label *, int);

/* 772 */
typedef launch_constraint_data *launch_constraint_data_t;

/* 773 */
typedef int mpo_proc_check_launch_constraints_t(proc_t, pid_t, pid_t, void *, size_t, launch_constraint_data_t, char **, size_t *);

/* 770 */
typedef int mpo_necp_check_open_t(kauth_cred_t, int);

/* 769 */
typedef int mpo_necp_check_client_action_t(kauth_cred_t, fileglob *, uint32_t);

/* 768 */
typedef int mpo_file_check_library_validation_t(struct proc *, fileglob *, off_t, user_long_t, size_t);

/* 767 */
typedef void mpo_vnode_notify_setacl_t(kauth_cred_t, vnode *, label *, kauth_acl *);

/* 763 */
typedef void mpo_vnode_notify_setattrlist_t(kauth_cred_t, vnode *, label *, attrlist *);

/* 762 */
typedef void mpo_vnode_notify_setextattr_t(kauth_cred_t, vnode *, label *, const char *, uio *);

/* 761 */
typedef void mpo_vnode_notify_setflags_t(kauth_cred_t, vnode *, label *, u_long);

/* 760 */
typedef void mpo_vnode_notify_setmode_t(kauth_cred_t, vnode *, label *, mode_t);

/* 759 */
typedef void mpo_vnode_notify_setowner_t(kauth_cred_t, vnode *, label *, uid_t, gid_t);

/* 758 */
typedef void mpo_vnode_notify_setutimes_t(kauth_cred_t, vnode *, label *, timespec, timespec);

/* 756 */
typedef void mpo_vnode_notify_truncate_t(kauth_cred_t, kauth_cred_t, vnode *, label *);

/* 755 */
typedef int mpo_vnode_check_getattrlistbulk_t(kauth_cred_t, vnode *, attrlist *, uint64_t);

/* 754 */
typedef int mpo_proc_check_get_task_special_port_t(kauth_cred_t, proc_ident *, int);

/* 753 */
typedef int mpo_proc_check_set_task_special_port_t(kauth_cred_t, proc_ident *, int, struct ipc_port *);

/* 752 */
typedef void mpo_vnode_notify_swap_t(kauth_cred_t, vnode *, label *, vnode *, label *);

/* 751 */
typedef void mpo_vnode_notify_unlink_t(kauth_cred_t, vnode *, label *, vnode *, label *, componentname *);

/* 747 */
typedef int mpo_vnode_check_copyfile_t(kauth_cred_t, vnode *, label *, vnode *, label *, vnode *, label *, componentname *, mode_t, int);

/* 746 */
typedef int mpo_mount_check_quotactl_t(kauth_cred_t, mount *, int, int);

/* 745 */
typedef int mpo_mount_check_fsctl_t(kauth_cred_t, mount *, label *, unsigned __int64);

/* 744 */
typedef int mpo_mount_check_getattr_t(kauth_cred_t, mount *, label *, vfs_attr *);

/* 743 */
typedef int mpo_mount_check_label_update_t(kauth_cred_t, mount *, label *);

/* 742 */
typedef int mpo_mount_check_mount_t(kauth_cred_t, vnode *, label *, componentname *, const char *);

/* 741 */
typedef int mpo_mount_check_remount_t(kauth_cred_t, mount *, label *);

/* 740 */
typedef int mpo_mount_check_setattr_t(kauth_cred_t, mount *, label *, vfs_attr *);

/* 739 */
typedef int mpo_mount_check_stat_t(kauth_cred_t, mount *, label *);

/* 738 */
typedef int mpo_mount_check_umount_t(kauth_cred_t, mount *, label *);

/* 737 */
typedef void mpo_mount_label_associate_t(kauth_cred_t, mount *, label *);

/* 736 */
typedef void mpo_mount_label_destroy_t(label *);

/* 735 */
typedef int mpo_mount_label_externalize_t(label *, char *, sbuf *);

/* 734 */
typedef void mpo_mount_label_init_t(label *);

/* 733 */
typedef int mpo_mount_label_internalize_t(label *, char *, char *);

/* 1040 */
typedef unsigned int mach_task_flavor_t;

/* 732 */
typedef int mpo_proc_check_expose_task_with_flavor_t(kauth_cred_t, proc_ident *, mach_task_flavor_t);

/* 731 */
typedef int mpo_proc_check_get_task_with_flavor_t(kauth_cred_t, proc_ident *, mach_task_flavor_t);

/* 730 */
typedef int mpo_proc_check_task_id_token_get_task_t(kauth_cred_t, proc_ident *, mach_task_flavor_t);

/* 729 */
typedef int mpo_pipe_check_ioctl_t(kauth_cred_t, pipe *, label *, unsigned __int64);

/* 728 */
typedef int mpo_pipe_check_kqfilter_t(kauth_cred_t, knote *, pipe *, label *);

/* 727 */
typedef int mpo_pipe_check_read_t(kauth_cred_t, pipe *, label *);

/* 726 */
typedef int mpo_pipe_check_select_t(kauth_cred_t, pipe *, label *, int);

/* 725 */
typedef int mpo_pipe_check_stat_t(kauth_cred_t, pipe *, label *);

/* 724 */
typedef int mpo_pipe_check_write_t(kauth_cred_t, pipe *, label *);

/* 723 */
typedef void mpo_pipe_label_associate_t(kauth_cred_t, pipe *, label *);

/* 722 */
typedef void mpo_pipe_label_destroy_t(label *);

/* 721 */
typedef void mpo_pipe_label_init_t(label *);

/* 720 */
typedef int mpo_proc_check_syscall_mac_t(struct proc *, const char *, int);

/* 719 */
typedef void mpo_policy_destroy_t(mac_policy_conf *);

/* 718 */
typedef void mpo_policy_init_t(mac_policy_conf *);

/* 1036 */
typedef void mpo_thread_telemetry_t(struct thread *, int, const void *, size_t);

/* 1032 */
typedef void mpo_thread_userret_t(struct thread *);

/* 816 */
struct mac_policy_ops
{
  mpo_audit_check_postselect_t *mpo_audit_check_postselect;
  mpo_audit_check_preselect_t *mpo_audit_check_preselect;
  mpo_reserved_hook_t *mpo_reserved01;
  mpo_reserved_hook_t *mpo_reserved02;
  mpo_reserved_hook_t *mpo_reserved03;
  mpo_reserved_hook_t *mpo_reserved04;
  mpo_cred_check_label_update_execve_t *mpo_cred_check_label_update_execve;
  mpo_cred_check_label_update_t *mpo_cred_check_label_update;
  mpo_cred_check_visible_t *mpo_cred_check_visible;
  mpo_cred_label_associate_fork_t *mpo_cred_label_associate_fork;
  mpo_cred_label_associate_kernel_t *mpo_cred_label_associate_kernel;
  mpo_cred_label_associate_t *mpo_cred_label_associate;
  mpo_cred_label_associate_user_t *mpo_cred_label_associate_user;
  mpo_cred_label_destroy_t *mpo_cred_label_destroy;
  mpo_cred_label_externalize_audit_t *mpo_cred_label_externalize_audit;
  mpo_cred_label_externalize_t *mpo_cred_label_externalize;
  mpo_cred_label_init_t *mpo_cred_label_init;
  mpo_cred_label_internalize_t *mpo_cred_label_internalize;
  mpo_cred_label_update_execve_t *mpo_cred_label_update_execve;
  mpo_cred_label_update_t *mpo_cred_label_update;
  mpo_devfs_label_associate_device_t *mpo_devfs_label_associate_device;
  mpo_devfs_label_associate_directory_t *mpo_devfs_label_associate_directory;
  mpo_devfs_label_copy_t *mpo_devfs_label_copy;
  mpo_devfs_label_destroy_t *mpo_devfs_label_destroy;
  mpo_devfs_label_init_t *mpo_devfs_label_init;
  mpo_devfs_label_update_t *mpo_devfs_label_update;
  mpo_file_check_change_offset_t *mpo_file_check_change_offset;
  mpo_file_check_create_t *mpo_file_check_create;
  mpo_file_check_dup_t *mpo_file_check_dup;
  mpo_file_check_fcntl_t *mpo_file_check_fcntl;
  mpo_file_check_get_offset_t *mpo_file_check_get_offset;
  mpo_file_check_get_t *mpo_file_check_get;
  mpo_file_check_inherit_t *mpo_file_check_inherit;
  mpo_file_check_ioctl_t *mpo_file_check_ioctl;
  mpo_file_check_lock_t *mpo_file_check_lock;
  mpo_file_check_mmap_downgrade_t *mpo_file_check_mmap_downgrade;
  mpo_file_check_mmap_t *mpo_file_check_mmap;
  mpo_file_check_receive_t *mpo_file_check_receive;
  mpo_file_check_set_t *mpo_file_check_set;
  mpo_file_label_init_t *mpo_file_label_init;
  mpo_file_label_destroy_t *mpo_file_label_destroy;
  mpo_file_label_associate_t *mpo_file_label_associate;
  mpo_file_notify_close_t *mpo_file_notify_close;
  mpo_proc_check_launch_constraints_t *mpo_proc_check_launch_constraints;
  mpo_reserved_hook_t *mpo_reserved07;
  mpo_reserved_hook_t *mpo_reserved08;
  mpo_reserved_hook_t *mpo_reserved09;
  mpo_reserved_hook_t *mpo_reserved10;
  mpo_reserved_hook_t *mpo_reserved11;
  mpo_reserved_hook_t *mpo_reserved12;
  mpo_reserved_hook_t *mpo_reserved13;
  mpo_reserved_hook_t *mpo_reserved14;
  mpo_reserved_hook_t *mpo_reserved15;
  mpo_reserved_hook_t *mpo_reserved16;
  mpo_reserved_hook_t *mpo_reserved17;
  mpo_reserved_hook_t *mpo_reserved18;
  mpo_reserved_hook_t *mpo_reserved19;
  mpo_reserved_hook_t *mpo_reserved20;
  mpo_reserved_hook_t *mpo_reserved21;
  mpo_reserved_hook_t *mpo_reserved22;
  mpo_reserved_hook_t *mpo_reserved23;
  mpo_reserved_hook_t *mpo_reserved24;
  mpo_necp_check_open_t *mpo_necp_check_open;
  mpo_necp_check_client_action_t *mpo_necp_check_client_action;
  mpo_file_check_library_validation_t *mpo_file_check_library_validation;
  mpo_vnode_notify_setacl_t *mpo_vnode_notify_setacl;
  mpo_vnode_notify_setattrlist_t *mpo_vnode_notify_setattrlist;
  mpo_vnode_notify_setextattr_t *mpo_vnode_notify_setextattr;
  mpo_vnode_notify_setflags_t *mpo_vnode_notify_setflags;
  mpo_vnode_notify_setmode_t *mpo_vnode_notify_setmode;
  mpo_vnode_notify_setowner_t *mpo_vnode_notify_setowner;
  mpo_vnode_notify_setutimes_t *mpo_vnode_notify_setutimes;
  mpo_vnode_notify_truncate_t *mpo_vnode_notify_truncate;
  mpo_vnode_check_getattrlistbulk_t *mpo_vnode_check_getattrlistbulk;
  mpo_proc_check_get_task_special_port_t *mpo_proc_check_get_task_special_port;
  mpo_proc_check_set_task_special_port_t *mpo_proc_check_set_task_special_port;
  mpo_vnode_notify_swap_t *mpo_vnode_notify_swap;
  mpo_vnode_notify_unlink_t *mpo_vnode_notify_unlink;
  mpo_reserved_hook_t *mpo_reserved32;
  mpo_reserved_hook_t *mpo_reserved33;
  mpo_reserved_hook_t *mpo_reserved34;
  mpo_reserved_hook_t *mpo_reserved35;
  mpo_vnode_check_copyfile_t *mpo_vnode_check_copyfile;
  mpo_mount_check_quotactl_t *mpo_mount_check_quotactl;
  mpo_mount_check_fsctl_t *mpo_mount_check_fsctl;
  mpo_mount_check_getattr_t *mpo_mount_check_getattr;
  mpo_mount_check_label_update_t *mpo_mount_check_label_update;
  mpo_mount_check_mount_t *mpo_mount_check_mount;
  mpo_mount_check_remount_t *mpo_mount_check_remount;
  mpo_mount_check_setattr_t *mpo_mount_check_setattr;
  mpo_mount_check_stat_t *mpo_mount_check_stat;
  mpo_mount_check_umount_t *mpo_mount_check_umount;
  mpo_mount_label_associate_t *mpo_mount_label_associate;
  mpo_mount_label_destroy_t *mpo_mount_label_destroy;
  mpo_mount_label_externalize_t *mpo_mount_label_externalize;
  mpo_mount_label_init_t *mpo_mount_label_init;
  mpo_mount_label_internalize_t *mpo_mount_label_internalize;
  mpo_proc_check_expose_task_with_flavor_t *mpo_proc_check_expose_task_with_flavor;
  mpo_proc_check_get_task_with_flavor_t *mpo_proc_check_get_task_with_flavor;
  mpo_proc_check_task_id_token_get_task_t *mpo_proc_check_task_id_token_get_task;
  mpo_pipe_check_ioctl_t *mpo_pipe_check_ioctl;
  mpo_pipe_check_kqfilter_t *mpo_pipe_check_kqfilter;
  mpo_reserved_hook_t *mpo_reserved41;
  mpo_pipe_check_read_t *mpo_pipe_check_read;
  mpo_pipe_check_select_t *mpo_pipe_check_select;
  mpo_pipe_check_stat_t *mpo_pipe_check_stat;
  mpo_pipe_check_write_t *mpo_pipe_check_write;
  mpo_pipe_label_associate_t *mpo_pipe_label_associate;
  mpo_reserved_hook_t *mpo_reserved42;
  mpo_pipe_label_destroy_t *mpo_pipe_label_destroy;
  mpo_reserved_hook_t *mpo_reserved43;
  mpo_pipe_label_init_t *mpo_pipe_label_init;
  mpo_reserved_hook_t *mpo_reserved44;
  mpo_proc_check_syscall_mac_t *mpo_proc_check_syscall_mac;
  mpo_policy_destroy_t *mpo_policy_destroy;
  mpo_policy_init_t *mpo_policy_init;
  mpo_policy_initbsd_t *mpo_policy_initbsd;
  mpo_policy_syscall_t *mpo_policy_syscall;
  mpo_system_check_sysctlbyname_t *mpo_system_check_sysctlbyname;
  mpo_proc_check_inherit_ipc_ports_t *mpo_proc_check_inherit_ipc_ports;
  mpo_vnode_check_rename_t *mpo_vnode_check_rename;
  mpo_kext_check_query_t *mpo_kext_check_query;
  mpo_proc_notify_exec_complete_t *mpo_proc_notify_exec_complete;
  mpo_proc_notify_cs_invalidated_t *mpo_proc_notify_cs_invalidated;
  mpo_proc_check_syscall_unix_t *mpo_proc_check_syscall_unix;
  mpo_reserved_hook_t *mpo_reserved45;
  mpo_proc_check_set_host_special_port_t *mpo_proc_check_set_host_special_port;
  mpo_proc_check_set_host_exception_port_t *mpo_proc_check_set_host_exception_port;
  mpo_exc_action_check_exception_send_t *mpo_exc_action_check_exception_send;
  mpo_exc_action_label_associate_t *mpo_exc_action_label_associate;
  mpo_exc_action_label_populate_t *mpo_exc_action_label_populate;
  mpo_exc_action_label_destroy_t *mpo_exc_action_label_destroy;
  mpo_exc_action_label_init_t *mpo_exc_action_label_init;
  mpo_exc_action_label_update_t *mpo_exc_action_label_update;
  mpo_vnode_check_trigger_resolve_t *mpo_vnode_check_trigger_resolve;
  mpo_mount_check_mount_late_t *mpo_mount_check_mount_late;
  mpo_mount_check_snapshot_mount_t *mpo_mount_check_snapshot_mount;
  mpo_vnode_notify_reclaim_t *mpo_vnode_notify_reclaim;
  mpo_skywalk_flow_check_connect_t *mpo_skywalk_flow_check_connect;
  mpo_skywalk_flow_check_listen_t *mpo_skywalk_flow_check_listen;
  mpo_posixsem_check_create_t *mpo_posixsem_check_create;
  mpo_posixsem_check_open_t *mpo_posixsem_check_open;
  mpo_posixsem_check_post_t *mpo_posixsem_check_post;
  mpo_posixsem_check_unlink_t *mpo_posixsem_check_unlink;
  mpo_posixsem_check_wait_t *mpo_posixsem_check_wait;
  mpo_posixsem_label_associate_t *mpo_posixsem_label_associate;
  mpo_posixsem_label_destroy_t *mpo_posixsem_label_destroy;
  mpo_posixsem_label_init_t *mpo_posixsem_label_init;
  mpo_posixshm_check_create_t *mpo_posixshm_check_create;
  mpo_posixshm_check_mmap_t *mpo_posixshm_check_mmap;
  mpo_posixshm_check_open_t *mpo_posixshm_check_open;
  mpo_posixshm_check_stat_t *mpo_posixshm_check_stat;
  mpo_posixshm_check_truncate_t *mpo_posixshm_check_truncate;
  mpo_posixshm_check_unlink_t *mpo_posixshm_check_unlink;
  mpo_posixshm_label_associate_t *mpo_posixshm_label_associate;
  mpo_posixshm_label_destroy_t *mpo_posixshm_label_destroy;
  mpo_posixshm_label_init_t *mpo_posixshm_label_init;
  mpo_proc_check_debug_t *mpo_proc_check_debug;
  mpo_proc_check_fork_t *mpo_proc_check_fork;
  mpo_reserved_hook_t *mpo_reserved61;
  mpo_reserved_hook_t *mpo_reserved62;
  mpo_proc_check_getaudit_t *mpo_proc_check_getaudit;
  mpo_proc_check_getauid_t *mpo_proc_check_getauid;
  mpo_proc_check_getlcid_t *mpo_proc_check_getlcid;
  mpo_proc_check_mprotect_t *mpo_proc_check_mprotect;
  mpo_proc_check_sched_t *mpo_proc_check_sched;
  mpo_proc_check_setaudit_t *mpo_proc_check_setaudit;
  mpo_proc_check_setauid_t *mpo_proc_check_setauid;
  mpo_proc_check_setlcid_t *mpo_proc_check_setlcid;
  mpo_proc_check_signal_t *mpo_proc_check_signal;
  mpo_proc_check_wait_t *mpo_proc_check_wait;
  mpo_proc_check_dump_core_t *mpo_proc_check_dump_core;
  mpo_proc_check_remote_thread_create_t *mpo_proc_check_remote_thread_create;
  mpo_socket_check_accept_t *mpo_socket_check_accept;
  mpo_socket_check_accepted_t *mpo_socket_check_accepted;
  mpo_socket_check_bind_t *mpo_socket_check_bind;
  mpo_socket_check_connect_t *mpo_socket_check_connect;
  mpo_socket_check_create_t *mpo_socket_check_create;
  mpo_reserved_hook_t *mpo_reserved46;
  mpo_reserved_hook_t *mpo_reserved47;
  mpo_reserved_hook_t *mpo_reserved48;
  mpo_socket_check_listen_t *mpo_socket_check_listen;
  mpo_socket_check_receive_t *mpo_socket_check_receive;
  mpo_socket_check_received_t *mpo_socket_check_received;
  mpo_reserved_hook_t *mpo_reserved49;
  mpo_socket_check_send_t *mpo_socket_check_send;
  mpo_socket_check_stat_t *mpo_socket_check_stat;
  mpo_socket_check_setsockopt_t *mpo_socket_check_setsockopt;
  mpo_socket_check_getsockopt_t *mpo_socket_check_getsockopt;
  mpo_proc_check_get_movable_control_port_t *mpo_proc_check_get_movable_control_port;
  mpo_proc_check_dyld_process_info_notify_register_t *mpo_proc_check_dyld_process_info_notify_register;
  mpo_proc_check_setuid_t *mpo_proc_check_setuid;
  mpo_proc_check_seteuid_t *mpo_proc_check_seteuid;
  mpo_proc_check_setreuid_t *mpo_proc_check_setreuid;
  mpo_proc_check_setgid_t *mpo_proc_check_setgid;
  mpo_proc_check_setegid_t *mpo_proc_check_setegid;
  mpo_proc_check_setregid_t *mpo_proc_check_setregid;
  mpo_proc_check_settid_t *mpo_proc_check_settid;
  mpo_proc_check_memorystatus_control_t *mpo_proc_check_memorystatus_control;
  mpo_reserved_hook_t *mpo_reserved60;
  mpo_thread_telemetry_t *mpo_thread_telemetry;
  mpo_iokit_check_open_service_t *mpo_iokit_check_open_service;
  mpo_system_check_acct_t *mpo_system_check_acct;
  mpo_system_check_audit_t *mpo_system_check_audit;
  mpo_system_check_auditctl_t *mpo_system_check_auditctl;
  mpo_system_check_auditon_t *mpo_system_check_auditon;
  mpo_system_check_host_priv_t *mpo_system_check_host_priv;
  mpo_system_check_nfsd_t *mpo_system_check_nfsd;
  mpo_system_check_reboot_t *mpo_system_check_reboot;
  mpo_system_check_settime_t *mpo_system_check_settime;
  mpo_system_check_swapoff_t *mpo_system_check_swapoff;
  mpo_system_check_swapon_t *mpo_system_check_swapon;
  mpo_socket_check_ioctl_t *mpo_socket_check_ioctl;
  mpo_sysvmsg_label_associate_t *mpo_sysvmsg_label_associate;
  mpo_sysvmsg_label_destroy_t *mpo_sysvmsg_label_destroy;
  mpo_sysvmsg_label_init_t *mpo_sysvmsg_label_init;
  mpo_sysvmsg_label_recycle_t *mpo_sysvmsg_label_recycle;
  mpo_sysvmsq_check_enqueue_t *mpo_sysvmsq_check_enqueue;
  mpo_sysvmsq_check_msgrcv_t *mpo_sysvmsq_check_msgrcv;
  mpo_sysvmsq_check_msgrmid_t *mpo_sysvmsq_check_msgrmid;
  mpo_sysvmsq_check_msqctl_t *mpo_sysvmsq_check_msqctl;
  mpo_sysvmsq_check_msqget_t *mpo_sysvmsq_check_msqget;
  mpo_sysvmsq_check_msqrcv_t *mpo_sysvmsq_check_msqrcv;
  mpo_sysvmsq_check_msqsnd_t *mpo_sysvmsq_check_msqsnd;
  mpo_sysvmsq_label_associate_t *mpo_sysvmsq_label_associate;
  mpo_sysvmsq_label_destroy_t *mpo_sysvmsq_label_destroy;
  mpo_sysvmsq_label_init_t *mpo_sysvmsq_label_init;
  mpo_sysvmsq_label_recycle_t *mpo_sysvmsq_label_recycle;
  mpo_sysvsem_check_semctl_t *mpo_sysvsem_check_semctl;
  mpo_sysvsem_check_semget_t *mpo_sysvsem_check_semget;
  mpo_sysvsem_check_semop_t *mpo_sysvsem_check_semop;
  mpo_sysvsem_label_associate_t *mpo_sysvsem_label_associate;
  mpo_sysvsem_label_destroy_t *mpo_sysvsem_label_destroy;
  mpo_sysvsem_label_init_t *mpo_sysvsem_label_init;
  mpo_sysvsem_label_recycle_t *mpo_sysvsem_label_recycle;
  mpo_sysvshm_check_shmat_t *mpo_sysvshm_check_shmat;
  mpo_sysvshm_check_shmctl_t *mpo_sysvshm_check_shmctl;
  mpo_sysvshm_check_shmdt_t *mpo_sysvshm_check_shmdt;
  mpo_sysvshm_check_shmget_t *mpo_sysvshm_check_shmget;
  mpo_sysvshm_label_associate_t *mpo_sysvshm_label_associate;
  mpo_sysvshm_label_destroy_t *mpo_sysvshm_label_destroy;
  mpo_sysvshm_label_init_t *mpo_sysvshm_label_init;
  mpo_sysvshm_label_recycle_t *mpo_sysvshm_label_recycle;
  mpo_proc_notify_exit_t *mpo_proc_notify_exit;
  mpo_mount_check_snapshot_revert_t *mpo_mount_check_snapshot_revert;
  mpo_vnode_check_getattr_t *mpo_vnode_check_getattr;
  mpo_mount_check_snapshot_create_t *mpo_mount_check_snapshot_create;
  mpo_mount_check_snapshot_delete_t *mpo_mount_check_snapshot_delete;
  mpo_vnode_check_clone_t *mpo_vnode_check_clone;
  mpo_proc_check_get_cs_info_t *mpo_proc_check_get_cs_info;
  mpo_proc_check_set_cs_info_t *mpo_proc_check_set_cs_info;
  mpo_iokit_check_hid_control_t *mpo_iokit_check_hid_control;
  mpo_vnode_check_access_t *mpo_vnode_check_access;
  mpo_vnode_check_chdir_t *mpo_vnode_check_chdir;
  mpo_vnode_check_chroot_t *mpo_vnode_check_chroot;
  mpo_vnode_check_create_t *mpo_vnode_check_create;
  mpo_vnode_check_deleteextattr_t *mpo_vnode_check_deleteextattr;
  mpo_vnode_check_exchangedata_t *mpo_vnode_check_exchangedata;
  mpo_vnode_check_exec_t *mpo_vnode_check_exec;
  mpo_vnode_check_getattrlist_t *mpo_vnode_check_getattrlist;
  mpo_vnode_check_getextattr_t *mpo_vnode_check_getextattr;
  mpo_vnode_check_ioctl_t *mpo_vnode_check_ioctl;
  mpo_vnode_check_kqfilter_t *mpo_vnode_check_kqfilter;
  mpo_vnode_check_label_update_t *mpo_vnode_check_label_update;
  mpo_vnode_check_link_t *mpo_vnode_check_link;
  mpo_vnode_check_listextattr_t *mpo_vnode_check_listextattr;
  mpo_vnode_check_lookup_t *mpo_vnode_check_lookup;
  mpo_vnode_check_open_t *mpo_vnode_check_open;
  mpo_vnode_check_read_t *mpo_vnode_check_read;
  mpo_vnode_check_readdir_t *mpo_vnode_check_readdir;
  mpo_vnode_check_readlink_t *mpo_vnode_check_readlink;
  mpo_vnode_check_rename_from_t *mpo_vnode_check_rename_from;
  mpo_vnode_check_rename_to_t *mpo_vnode_check_rename_to;
  mpo_vnode_check_revoke_t *mpo_vnode_check_revoke;
  mpo_vnode_check_select_t *mpo_vnode_check_select;
  mpo_vnode_check_setattrlist_t *mpo_vnode_check_setattrlist;
  mpo_vnode_check_setextattr_t *mpo_vnode_check_setextattr;
  mpo_vnode_check_setflags_t *mpo_vnode_check_setflags;
  mpo_vnode_check_setmode_t *mpo_vnode_check_setmode;
  mpo_vnode_check_setowner_t *mpo_vnode_check_setowner;
  mpo_vnode_check_setutimes_t *mpo_vnode_check_setutimes;
  mpo_vnode_check_stat_t *mpo_vnode_check_stat;
  mpo_vnode_check_truncate_t *mpo_vnode_check_truncate;
  mpo_vnode_check_unlink_t *mpo_vnode_check_unlink;
  mpo_vnode_check_write_t *mpo_vnode_check_write;
  mpo_vnode_label_associate_devfs_t *mpo_vnode_label_associate_devfs;
  mpo_vnode_label_associate_extattr_t *mpo_vnode_label_associate_extattr;
  mpo_vnode_label_associate_file_t *mpo_vnode_label_associate_file;
  mpo_vnode_label_associate_pipe_t *mpo_vnode_label_associate_pipe;
  mpo_vnode_label_associate_posixsem_t *mpo_vnode_label_associate_posixsem;
  mpo_vnode_label_associate_posixshm_t *mpo_vnode_label_associate_posixshm;
  mpo_vnode_label_associate_singlelabel_t *mpo_vnode_label_associate_singlelabel;
  mpo_vnode_label_associate_socket_t *mpo_vnode_label_associate_socket;
  mpo_vnode_label_copy_t *mpo_vnode_label_copy;
  mpo_vnode_label_destroy_t *mpo_vnode_label_destroy;
  mpo_vnode_label_externalize_audit_t *mpo_vnode_label_externalize_audit;
  mpo_vnode_label_externalize_t *mpo_vnode_label_externalize;
  mpo_vnode_label_init_t *mpo_vnode_label_init;
  mpo_vnode_label_internalize_t *mpo_vnode_label_internalize;
  mpo_vnode_label_recycle_t *mpo_vnode_label_recycle;
  mpo_vnode_label_store_t *mpo_vnode_label_store;
  mpo_vnode_label_update_extattr_t *mpo_vnode_label_update_extattr;
  mpo_vnode_label_update_t *mpo_vnode_label_update;
  mpo_vnode_notify_create_t *mpo_vnode_notify_create;
  mpo_vnode_check_signature_t *mpo_vnode_check_signature;
  mpo_vnode_check_uipc_bind_t *mpo_vnode_check_uipc_bind;
  mpo_vnode_check_uipc_connect_t *mpo_vnode_check_uipc_connect;
  mpo_proc_check_run_cs_invalid_t *mpo_proc_check_run_cs_invalid;
  mpo_proc_check_suspend_resume_t *mpo_proc_check_suspend_resume;
  mpo_thread_userret_t *mpo_thread_userret;
  mpo_iokit_check_set_properties_t *mpo_iokit_check_set_properties;
  mpo_vnode_check_supplemental_signature_t *mpo_vnode_check_supplemental_signature;
  mpo_vnode_check_searchfs_t *mpo_vnode_check_searchfs;
  mpo_priv_check_t *mpo_priv_check;
  mpo_priv_grant_t *mpo_priv_grant;
  mpo_proc_check_map_anon_t *mpo_proc_check_map_anon;
  mpo_vnode_check_fsgetpath_t *mpo_vnode_check_fsgetpath;
  mpo_iokit_check_open_t *mpo_iokit_check_open;
  mpo_proc_check_ledger_t *mpo_proc_check_ledger;
  mpo_vnode_notify_rename_t *mpo_vnode_notify_rename;
  mpo_vnode_check_setacl_t *mpo_vnode_check_setacl;
  mpo_vnode_notify_deleteextattr_t *mpo_vnode_notify_deleteextattr;
  mpo_system_check_kas_info_t *mpo_system_check_kas_info;
  mpo_vnode_check_lookup_preflight_t *mpo_vnode_check_lookup_preflight;
  mpo_vnode_notify_open_t *mpo_vnode_notify_open;
  mpo_system_check_info_t *mpo_system_check_info;
  mpo_pty_notify_grant_t *mpo_pty_notify_grant;
  mpo_pty_notify_close_t *mpo_pty_notify_close;
  mpo_vnode_find_sigs_t *mpo_vnode_find_sigs;
  mpo_kext_check_load_t *mpo_kext_check_load;
  mpo_kext_check_unload_t *mpo_kext_check_unload;
  mpo_proc_check_proc_info_t *mpo_proc_check_proc_info;
  mpo_vnode_notify_link_t *mpo_vnode_notify_link;
  mpo_iokit_check_filter_properties_t *mpo_iokit_check_filter_properties;
  mpo_iokit_check_get_property_t *mpo_iokit_check_get_property;
};

/* 782 */
struct flock
{
  off_t l_start;
  off_t l_len;
  pid_t l_pid;
  short l_type;
  short l_whence;
};

/* 771 */
struct launch_constraint_data
{
  _BYTE gap0;
};

/* 1083 */
typedef u_int32_t vol_capabilities_set_t[4];

/* 9155 */
struct vol_capabilities_attr
{
  vol_capabilities_set_t capabilities;
  vol_capabilities_set_t valid;
};

/* 907 */
typedef vol_capabilities_attr vol_capabilities_attr_t;

/* 7262 */
struct attribute_set
{
  attrgroup_t commonattr;
  attrgroup_t volattr;
  attrgroup_t dirattr;
  attrgroup_t fileattr;
  attrgroup_t forkattr;
};

/* 905 */
typedef attribute_set attribute_set_t;

/* 7263 */
struct vol_attributes_attr
{
  attribute_set_t validattr;
  attribute_set_t nativeattr;
};

/* 906 */
typedef vol_attributes_attr vol_attributes_attr_t;

/* 908 */
struct vfs_attr
{
  uint64_t f_supported;
  uint64_t f_active;
  uint64_t f_objcount;
  uint64_t f_filecount;
  uint64_t f_dircount;
  uint64_t f_maxobjcount;
  uint32_t f_bsize;
  __attribute__((packed)) __attribute__((aligned(1))) size_t f_iosize;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_blocks;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_bfree;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_bavail;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_bused;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_files;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_ffree;
  fsid_t f_fsid;
  uid_t f_owner;
  vol_capabilities_attr_t f_capabilities;
  vol_attributes_attr_t f_attributes;
  timespec f_create_time;
  timespec f_modify_time;
  timespec f_access_time;
  timespec f_backup_time;
  uint32_t f_fssubtype;
  __attribute__((packed)) __attribute__((aligned(1))) char *f_vol_name;
  uint16_t f_signature;
  uint16_t f_carbon_fsid;
  uuid_t_0 f_uuid;
  uint64_t f_quota;
  uint64_t f_reserved;
};

/* 818 */
struct workq_threadreq_tailq
{
  workq_threadreq_s *stqh_first;
  workq_threadreq_s **stqh_last;
};

/* 1122 */
typedef uint8_t thread_qos_t;

/* 1121 */
typedef uint8_t kq_index_t;

/* 859 */
struct workq_threadreq_s
{
  union
  {
    priority_queue_entry_sched tr_entry;
    struct
    {
      workq_threadreq_s *stqe_next;
    } tr_link;
    thread_t_0 tr_thread;
  };
  uint16_t tr_count;
  __attribute__((aligned(4))) thread_qos_t tr_qos;
  kq_index_t tr_kq_override_index;
  kq_index_t tr_kq_qos_index;
};

/* 819 */
struct workq_uthread_head
{
  uthread *tqh_first;
  uthread **tqh_last;
};

/* 5619 */
typedef int64_t mach_exception_data_type_t;

/* 1131 */
typedef mach_exception_data_type_t mach_exception_code_t;

/* 1130 */
typedef mach_exception_data_type_t mach_exception_subcode_t;

/* 885 */
struct _select_data
{
  u_int64_t abstime;
  int count;
  select_nocancel_args *args;
  int32_t *retval;
};

/* 884 */
struct kevent_ctx_s
{
  uint64_t kec_data_avail;
  user_addr_t_0 kec_data_out;
  user_size_t kec_data_size;
  user_size_t kec_data_resid;
  uint64_t kec_deadline;
  fileproc *kec_fp;
  int kec_fd;
  int kec_process_nevents;
  int kec_process_noutputs;
  unsigned int kec_process_flags;
  user_addr_t_0 kec_process_eventlist;
};

/* 868 */
struct kevent_qos_s
{
  uint64_t ident;
  int16_t filter;
  uint16_t flags;
  int32_t qos;
  uint64_t udata;
  uint32_t fflags;
  uint32_t xflags;
  int64_t data;
  uint64_t ext[4];
};

/* 883 */
struct _kevent_register
{
  kevent_qos_s kev;
  thread_t_0 handoff_thread;
  kqworkloop *kqwl;
  int eventout;
  user_addr_t_0 ueventlist;
};

/* 882 */
struct _kauth
{
  user_addr_t_0 message;
};

/* 881 */
struct ksyn_waitq_element
{
  char opaque[48];
};

/* 880 */
struct _waitid_data
{
  waitid_nocancel_args *args;
  int32_t *retval;
};

/* 879 */
struct _wait4_data
{
  wait4_nocancel_args *args;
  int32_t *retval;
};

/* 878 */
struct __attribute__((aligned(4))) _workq_park_data
{
  uint64_t idle_stamp;
  uint64_t workloop_params;
  uint32_t fulfilled_snapshot;
  uint32_t yields;
  void *thread_request;
  uint32_t upcall_flags;
  bool has_stack;
  thread_qos_t qos;
};

/* 1117 */
typedef unsigned int uint;

/* 877 */
struct __attribute__((aligned(8))) _ulock_wait_data
{
  ull *ull;
  thread_t_0 owner_thread;
  thread_t_0 old_owner;
  int32_t *retval;
  uint flags;
};

/* 7169 */
typedef natural_t mach_port_name_t_0;

/* 876 */
struct __attribute__((aligned(8))) _bsdthread_terminate
{
  user_addr_t_0 ulock_addr;
  mach_port_name_t_0 kport;
};

/* 875 */
struct _exec_data
{
  image_params *imgp;
};

/* 874 */
struct __attribute__((aligned(8))) _select
{
  u_int32_t *ibits;
  u_int32_t *obits;
  uint nbytes;
};

/* 7755 */
typedef __uint32_t __darwin_sigset_t;

/* 2348 */
typedef __darwin_sigset_t sigset_t;

/* 873 */
struct __attribute__((aligned(8))) kern_sigaltstack
{
  user_addr_t_0 ss_sp;
  user_size_t ss_size;
  int ss_flags;
};

/* 871 */
struct uu_workq_policy
{
  _BYTE gap0[2];
};

/* 851 */
union sigval
{
  int sival_int;
  void *sival_ptr;
};

/* 9152 */
struct __siginfo
{
  int si_signo;
  int si_errno;
  int si_code;
  pid_t si_pid;
  uid_t si_uid;
  int si_status;
  void *si_addr;
  sigval si_value;
  long si_band;
  unsigned __int64 __pad[7];
};

/* 870 */
typedef __siginfo siginfo_t;

/* 850 */
struct __tds
{
  uint8_t _t_dtrace_on;
  uint8_t _t_dtrace_step;
  uint8_t _t_dtrace_ret;
  uint8_t _t_dtrace_ast;
  uint8_t _t_dtrace_reg;
};

/* 869 */
union __attribute__((aligned(4))) __tdu
{
  __tds _tds;
  u_int32_t _t_dtrace_ft;
};

/* 886 */
struct uthread
{
  u_int64_t uu_arg[8];
  int uu_rval[2];
  char uu_cursig;
  bool uu_workq_pthread_kill_allowed;
  uint16_t syscall_code;
  int uu_exception;
  mach_exception_code_t uu_code;
  mach_exception_subcode_t uu_subcode;
  union
  {
    _select_data uus_select_data;
    kevent_ctx_s uus_kevent;
    _kevent_register uus_kevent_register;
    _kauth uus_kauth;
    ksyn_waitq_element uus_kwe;
    _waitid_data uus_waitid_data;
    _wait4_data uus_wait4_data;
    _workq_park_data uus_workq_park_data;
    _ulock_wait_data uus_ulock_wait_data;
    _bsdthread_terminate uus_bsdthread_terminate;
    _exec_data uus_exec_data;
  } uu_save;
  _select uu_select;
  void *uu_userstate;
  select_set *uu_selset;
  int uu_flag;
  sigset_t uu_siglist;
  sigset_t uu_sigwait;
  sigset_t uu_sigmask;
  sigset_t uu_oldmask;
  user_addr_t_0 uu_sigreturn_token;
  uint32_t uu_sigreturn_diversifier;
  int uu_pending_sigreturn;
  struct
  {
    uthread *tqe_next;
    uthread **tqe_prev;
  } uu_list;
  kaudit_record *uu_ar;
  task *uu_aio_task;
  union
  {
    lck_mtx_t *uu_mtx;
    knote_lock_ctx *uu_knlock;
  };
  lck_spin_t uu_rethrottle_lock;
  struct
  {
    uthread *tqe_next;
    uthread **tqe_prev;
  } uu_throttlelist;
  void *uu_throttle_info;
  int8_t uu_on_throttlelist;
  bool uu_lowpri_window;
  bool uu_was_rethrottled;
  bool uu_is_throttled;
  bool uu_throttle_bc;
  bool uu_defer_reclaims;
  uint16_t uu_pri;
  caddr_t uu_wchan;
  int (*uu_continuation)(int);
  const char *uu_wmesg;
  kern_sigaltstack uu_sigstk;
  vnode_t uu_vreclaims;
  vnode_t uu_cdir;
  int uu_dupfd;
  u_int32_t uu_network_marks;
  workq_threadreq_s *uu_kqr_bound;
  struct
  {
    uthread *tqe_next;
    uthread **tqe_prev;
  } uu_workq_entry;
  vm_offset_t uu_workq_stackaddr;
  mach_port_name_t_0 uu_workq_thport;
  uu_workq_policy uu_workq_pri;
  uint16_t uu_workq_flags;
  kq_index_t uu_kqueue_override;
  int uu_proc_refcount;
  uint32_t t_dtrace_errno;
  siginfo_t t_dtrace_siginfo;
  uint64_t t_dtrace_resumepid;
  uint8_t t_dtrace_stop;
  uint8_t t_dtrace_sig;
  __tdu _tdu;
  user_addr_t_0 t_dtrace_pc;
  user_addr_t_0 t_dtrace_npc;
  user_addr_t_0 t_dtrace_scrpc;
  user_addr_t_0 t_dtrace_astpc;
  dtrace_ptss_page_entry *t_dtrace_scratch;
  uint64_t t_dtrace_regv;
  void *t_dtrace_syscall_args;
  char *pth_name;
  doc_tombstone *t_tombstone;
  uint64_t t_fs_private;
  os_reason *uu_exit_reason;
};

/* 1003 */
struct select_nocancel_args
{
  int nd;
  char nd_r_[4];
  user_addr_t_0 in;
  user_addr_t_0 ou;
  user_addr_t_0 ex;
  user_addr_t_0 tv;
  char tv_r_[];
};

/* 864 */
struct knote_locks
{
  knote_lock_ctx *lh_first;
};

/* 866 */
struct kqueue
{
  lck_spin_t kq_lock;
  _BYTE gap10[2];
  uint16_t kq_level;
  uint32_t kq_count;
  proc *kq_p;
  knote_locks kq_knlocks;
};

/* 860 */
struct kqtailq
{
  knote *tqh_first;
  knote **tqh_last;
};

/* 1124 */
typedef thread_group *thread_group_qos_t;

/* 1123 */
typedef uint64_t kqueue_id_t;

/* 867 */
struct kqworkloop
{
  kqueue kqwl_kqueue;
  kqtailq kqwl_queue[6];
  kqtailq kqwl_suppressed;
  workq_threadreq_s kqwl_request;
  thread_group_qos_t kqwl_preadopt_tg;
  lck_spin_t kqwl_statelock;
  thread_t_0 kqwl_owner;
  os_ref_atomic_t kqwl_retains;
  thread_qos_t kqwl_wakeup_qos;
  uint8_t kqwl_iotier_override;
  uint16_t kqwl_preadopt_tg_needs_redrive;
  turnstile *kqwl_turnstile;
  kqueue_id_t kqwl_dynamicid;
  uint64_t kqwl_params;
  struct
  {
    kqworkloop *le_next;
    kqworkloop **le_prev;
  } kqwl_hashlink;
};

/* 1119 */
enum idtype_t : __int32
{
  P_ALL = 0x0,
  P_PID = 0x1,
  P_PGID = 0x2,
};

/* 7269 */
typedef __uint32_t __darwin_id_t;

/* 1118 */
typedef __darwin_id_t id_t;

/* 1002 */
struct waitid_nocancel_args
{
  idtype_t idtype;
  char idtype_r_[4];
  id_t id;
  char id_r_[4];
  user_addr_t_0 infop;
  int options;
  char options_r_[4];
};

/* 1001 */
struct wait4_nocancel_args
{
  int pid;
  char pid_r_[4];
  user_addr_t_0 status;
  int options;
  char options_r_[4];
  user_addr_t_0 rusage;
  char rusage_r_[];
};

/* 3687 */
enum ulk_type : __int32
{
  ULK_INVALID = 0x0,
  ULK_UADDR = 0x1,
  ULK_XPROC = 0x2,
};

/* 3689 */
struct __attribute__((packed)) __attribute__((aligned(4))) ulk_t
{
  union
  {
    struct
    {
      user_addr_t_0 ulk_addr;
      task_t_1 ulk_task;
    };
    struct
    {
      uint64_t ulk_object;
      uint64_t ulk_offset;
    };
  };
  ulk_type ulk_key_type;
};

/* 3688 */
typedef lck_spin_t ull_lock_t;

/* 1116 */
struct ull
{
  thread_t_0 ull_owner;
  ulk_t ull_key;
  ull_lock_t ull_lock;
  uint ull_bucket_index;
  int32_t ull_nwaiters;
  int32_t ull_refcount;
  uint8_t ull_opcode;
  turnstile *ull_turnstile;
  queue_chain_t_0 ull_hash_link;
};

/* 980 */
struct ip_px_smpx_s
{
  void *array;
  void *data;
  uint64_t datalen;
};

/* 981 */
struct __attribute__((aligned(8))) image_params
{
  user_addr_t_0 ip_user_fname;
  user_addr_t_0 ip_user_argv;
  user_addr_t_0 ip_user_envv;
  int ip_seg;
  vnode *ip_vp;
  vnode_attr *ip_vattr;
  vnode_attr *ip_origvattr;
  cpu_type_t ip_origcputype;
  cpu_subtype_t_0 ip_origcpusubtype;
  char *ip_vdata;
  int ip_flags;
  int ip_argc;
  int ip_envc;
  int ip_applec;
  char *ip_startargv;
  char *ip_endargv;
  char *ip_endenvv;
  char *ip_strings;
  char *ip_strendp;
  char *ip_subsystem_root_path;
  int ip_argspace;
  int ip_strspace;
  user_size_t ip_arch_offset;
  user_size_t ip_arch_size;
  char ip_interp_buffer[512];
  int ip_interp_sugid_fd;
  vfs_context *ip_vfs_context;
  nameidata *ip_ndp;
  thread_t_0 ip_new_thread;
  label *ip_execlabelp;
  label *ip_scriptlabelp;
  vnode *ip_scriptvp;
  unsigned int ip_csflags;
  int ip_mac_return;
  void *ip_px_sa;
  void *ip_px_sfa;
  void *ip_px_spa;
  ip_px_smpx_s ip_px_smpx;
  void *ip_px_persona;
  void *ip_px_pcred_info;
  void *ip_cs_error;
  char *ip_inherited_shared_region_id;
  uint64_t ip_dyld_fsid;
  uint64_t ip_dyld_fsobjid;
  uint64_t ip_inherited_jop_pid;
  unsigned int ip_simulator_binary;
};

/* 1114 */
struct xucred
{
  u_int cr_version;
  uid_t cr_uid;
  short cr_ngroups;
  gid_t cr_groups[16];
};

/* 1113 */
struct au_tid
{
  dev_t port;
  u_int32_t machine;
};

/* 1112 */
struct groupset
{
  gid_t gidset[16];
  u_int gidset_size;
};

/* 1105 */
struct sockaddr_storage
{
  __uint8_t ss_len;
  sa_family_t ss_family;
  char __ss_pad1[6];
  __int64_t __ss_align;
  char __ss_pad2[112];
};

/* 1110 */
struct socket_au_info
{
  int sai_domain;
  int sai_type;
  int sai_protocol;
  sockaddr_storage sai_faddr;
  sockaddr_storage sai_laddr;
};

/* 1109 */
struct vnode_au_info
{
  mode_t vn_mode;
  uid_t vn_uid;
  gid_t vn_gid;
  dev_t vn_dev;
  long vn_fsid;
  long vn_fileid;
  long vn_gen;
};

/* 1108 */
struct __attribute__((aligned(4))) posix_ipc_perm
{
  uid_t pipc_uid;
  gid_t pipc_gid;
  mode_t pipc_mode;
};

/* 1092 */
typedef u_int16_t au_event_t;

/* 1091 */
typedef u_int32_t au_class_t;

/* 7267 */
struct au_evclass_map
{
  au_event_t ec_number;
  au_class_t ec_class;
};

/* 1102 */
typedef au_evclass_map au_evclass_map_t;

/* 1090 */
typedef au_tid au_tid_t;

/* 9271 */
struct auditinfo
{
  au_id_t ai_auid;
  au_mask_t ai_mask;
  au_tid_t ai_termid;
  au_asid_t ai_asid;
};

/* 1101 */
typedef auditinfo auditinfo_t;

/* 9483 */
struct auditpinfo
{
  pid_t ap_pid;
  au_id_t ap_auid;
  au_mask_t ap_mask;
  au_tid_t ap_termid;
  au_asid_t ap_asid;
};

/* 1100 */
typedef auditpinfo auditpinfo_t;

/* 9408 */
struct auditpinfo_addr
{
  pid_t ap_pid;
  au_id_t ap_auid;
  au_mask_t ap_mask;
  au_tid_addr_t ap_termid;
  au_asid_t ap_asid;
  au_asflgs_t ap_flags;
};

/* 1099 */
typedef auditpinfo_addr auditpinfo_addr_t;

/* 1089 */
struct au_qctrl
{
  int aq_hiwater;
  int aq_lowater;
  int aq_bufsz;
  int aq_delay;
  int aq_minfree;
};

/* 1098 */
typedef au_qctrl au_qctrl_t;

/* 7266 */
struct au_qctrl64
{
  u_int64_t aq64_hiwater;
  u_int64_t aq64_lowater;
  u_int64_t aq64_bufsz;
  u_int64_t aq64_delay;
  int64_t aq64_minfree;
};

/* 1097 */
typedef au_qctrl64 au_qctrl64_t;

/* 1088 */
struct audit_stat
{
  unsigned int as_version;
  unsigned int as_numevent;
  int as_generated;
  int as_nonattrib;
  int as_kernel;
  int as_audit;
  int as_auditctl;
  int as_enqueue;
  int as_written;
  int as_wblocked;
  int as_rblocked;
  int as_dropped;
  int as_totalsize;
  unsigned int as_memused;
};

/* 1096 */
typedef audit_stat au_stat_t;

/* 7265 */
struct audit_fstat
{
  u_int64_t af_filesz;
  u_int64_t af_currsz;
};

/* 1095 */
typedef audit_fstat au_fstat_t;

/* 1094 */
typedef unsigned __int8 au_ctlmode_t;

/* 7264 */
struct __attribute__((aligned(8))) au_expire_after
{
  time_t age;
  size_t size;
  unsigned __int8 op_type;
};

/* 1093 */
typedef au_expire_after au_expire_after_t;

/* 1107 */
union auditon_udata
{
  char *au_path;
  int au_cond;
  int au_policy;
  int64_t au_cond64;
  int64_t au_policy64;
  int au_trigger;
  au_evclass_map_t au_evclass;
  au_mask_t au_mask;
  au_asflgs_t au_flags;
  auditinfo_t au_auinfo;
  auditpinfo_t au_aupinfo;
  auditpinfo_addr_t au_aupinfo_addr;
  au_qctrl_t au_qctrl;
  au_qctrl64_t au_qctrl64;
  au_stat_t au_stat;
  au_fstat_t au_fstat;
  auditinfo_addr_t au_kau_info;
  au_ctlmode_t au_ctl_mode;
  au_expire_after_t au_expire_after;
};

/* 1106 */
struct __attribute__((aligned(8))) au_identity_info
{
  u_int32_t signer_type;
  char *signing_id;
  u_char signing_id_trunc;
  char *team_id;
  u_char team_id_trunc;
  u_int8_t *cdhash;
  u_int16_t cdhash_len;
};

/* 1115 */
struct audit_record
{
  u_int32_t ar_magic;
  int ar_event;
  int ar_retval;
  int ar_errno;
  timespec ar_starttime;
  timespec ar_endtime;
  u_int64_t ar_valid_arg;
  xucred ar_subj_cred;
  uid_t ar_subj_ruid;
  gid_t ar_subj_rgid;
  gid_t ar_subj_egid;
  uid_t ar_subj_auid;
  pid_t ar_subj_asid;
  pid_t ar_subj_pid;
  au_tid ar_subj_term;
  au_tid_addr ar_subj_term_addr;
  au_mask ar_subj_amask;
  uid_t ar_arg_euid;
  uid_t ar_arg_ruid;
  uid_t ar_arg_suid;
  gid_t ar_arg_egid;
  gid_t ar_arg_rgid;
  gid_t ar_arg_sgid;
  pid_t ar_arg_pid;
  pid_t ar_arg_asid;
  au_tid ar_arg_termid;
  au_tid_addr ar_arg_termid_addr;
  uid_t ar_arg_uid;
  uid_t ar_arg_auid;
  gid_t ar_arg_gid;
  groupset ar_arg_groups;
  int ar_arg_fd;
  int ar_arg_fflags;
  mode_t ar_arg_mode;
  uint32_t ar_arg_value32;
  uint64_t ar_arg_value64;
  user_addr_t_0 ar_arg_addr;
  user_size_t ar_arg_len;
  int ar_arg_mask;
  u_int ar_arg_signum;
  char ar_arg_login[255];
  int ar_arg_ctlname[12];
  socket_au_info ar_arg_sockinfo;
  char *ar_arg_upath1;
  char *ar_arg_upath2;
  char *ar_arg_kpath1;
  char *ar_arg_kpath2;
  char *ar_vnode1_mac_labels;
  char *ar_vnode2_mac_labels;
  char *ar_cred_mac_labels;
  char *ar_arg_mac_string;
  char *ar_arg_text;
  void *ar_arg_opaque;
  void *ar_arg_data;
  u_int16_t ar_arg_opq_size;
  u_char ar_arg_data_type;
  u_char ar_arg_data_count;
  au_mask ar_arg_amask;
  vnode_au_info ar_arg_vnode1;
  vnode_au_info ar_arg_vnode2;
  int ar_arg_cmd;
  int ar_arg_svipc_cmd;
  ipc_perm ar_arg_svipc_perm;
  int ar_arg_svipc_id;
  user_addr_t_0 ar_arg_svipc_addr;
  posix_ipc_perm ar_arg_pipc_perm;
  mach_port_name_t ar_arg_mach_port1;
  mach_port_name_t ar_arg_mach_port2;
  auditon_udata ar_arg_auditon;
  char *ar_arg_argv;
  int ar_arg_argc;
  char *ar_arg_envv;
  int ar_arg_envc;
  int ar_arg_exitstatus;
  int ar_arg_exitretval;
  sockaddr_storage ar_arg_sockaddr;
  int ar_arg_fd2;
  mac_audit_record_list_t *ar_mac_records;
  int ar_forced_by_mac;
  au_identity_info ar_arg_identity;
};

/* 1000 */
struct kaudit_record
{
  audit_record k_ar;
  u_int32_t k_ar_commit;
  void *k_udata;
  u_int k_ulen;
  uthread *k_uthread;
  struct
  {
    kaudit_record *tqe_next;
    kaudit_record **tqe_prev;
  } k_q;
};

/* 863 */
struct knote_lock_ctx
{
  knote *knlc_knote;
  thread_t_0 knlc_thread;
  uintptr_t knlc_waiters;
  struct
  {
    knote_lock_ctx *le_next;
    knote_lock_ctx **le_prev;
  } knlc_link;
};

/* 1067 */
struct dtrace_ptss_page_entry
{
  dtrace_ptss_page_entry *next;
  user_addr_t_0 addr;
  user_addr_t_0 write_addr;
};

/* 1066 */
struct doc_tombstone
{
  vnode *t_lastop_parent;
  vnode *t_lastop_item;
  uint32_t t_lastop_parent_vid;
  uint32_t t_lastop_item_vid;
  uint64_t t_lastop_fileid;
  uint64_t t_lastop_document_id;
  unsigned __int8 t_lastop_filename[256];
};

/* 2339 */
typedef unsigned __int8 Byte;

/* 2340 */
typedef Byte Bytef;

/* 2344 */
typedef unsigned int uInt;

/* 2341 */
typedef unsigned __int64 uLong;

/* 2338 */
typedef void *voidpf;

/* 2343 */
typedef voidpf (*alloc_func)(voidpf, uInt, uInt);

/* 2342 */
typedef void (*free_func)(voidpf, voidpf);

/* 7754 */
struct z_stream_s
{
  Bytef *next_in;
  uInt avail_in;
  uLong total_in;
  Bytef *next_out;
  uInt avail_out;
  uLong total_out;
  char *msg;
  internal_state *state;
  alloc_func zalloc;
  free_func zfree;
  voidpf opaque;
  int data_type;
  uLong adler;
  uLong reserved;
};

/* 846 */
typedef z_stream_s z_stream;

/* 847 */
struct kcdata_compress_descriptor
{
  z_stream kcd_cd_zs;
  void *kcd_cd_base;
  uint64_t kcd_cd_offset;
  size_t kcd_cd_maxoffset;
  uint64_t kcd_cd_mark_begin;
  _BYTE gap90[16];
  void (*kcd_cd_memcpy_f)(void *, const void *, size_t);
  mach_vm_address_t_0 kcd_cd_totalout_addr;
  mach_vm_address_t_0 kcd_cd_totalin_addr;
};

/* 848 */
struct __attribute__((aligned(8))) kcdata_descriptor
{
  uint32_t kcd_length;
  uint16_t kcd_flags;
  uint16_t kcd_user_flags;
  mach_vm_address_t_0 kcd_addr_begin;
  mach_vm_address_t_0 kcd_addr_end;
  kcdata_compress_descriptor kcd_comp_d;
  uint32_t kcd_endalloced;
};

/* 849 */
struct os_reason
{
  lck_mtx_t osr_lock;
  os_refcnt_t osr_refcount;
  uint32_t osr_namespace;
  uint64_t osr_code;
  uint64_t osr_flags;
  uint32_t osr_bufsize;
  kcdata_descriptor osr_kcd_descriptor;
  char *osr_kcd_buf;
};

/* 4086 */
enum cluster_type_t_0 : __int32
{
  CLUSTER_TYPE_SMP = 0x0,
  CLUSTER_TYPE_E = 0x1,
  CLUSTER_TYPE_P = 0x2,
  MAX_CPU_TYPES = 0x3,
};

/* 9012 */
union sched_clutch_counter_time
{
  struct
  {
    uint64_t scct_count;
    uint64_t scct_timestamp;
  };
  unsigned __int128 scct_packed;
};

/* 6575 */
typedef sched_clutch_counter_time sched_clutch_counter_time_t;

/* 6673 */
typedef uint64_t clutch_cpu_data_t;

/* 6672 */
typedef unsigned __int128 clutch_cpu_data_wide_t;

/* 9042 */
union sched_clutch_bucket_cpu_data
{
  struct
  {
    clutch_cpu_data_t scbcd_cpu_used;
    clutch_cpu_data_t scbcd_cpu_blocked;
  } cpu_data;
  clutch_cpu_data_wide_t scbcd_cpu_data_packed;
};

/* 6574 */
typedef sched_clutch_bucket_cpu_data sched_clutch_bucket_cpu_data_t;

/* 6576 */
struct __attribute__((aligned(16))) sched_clutch_bucket_group
{
  uint8_t scbg_bucket;
  uint32_t scbg_timeshare_tick;
  uint32_t scbg_pri_shift;
  uint32_t scbg_preferred_cluster;
  uint32_t scbg_amp_rebalance_last_chosen;
  sched_clutch *scbg_clutch;
  sched_clutch_counter_time_t scbg_blocked_data;
  sched_clutch_counter_time_t scbg_pending_data;
  sched_clutch_counter_time_t scbg_interactivity_data;
  sched_clutch_bucket_cpu_data_t scbg_cpu_data;
  sched_clutch_bucket *scbg_clutch_buckets;
};

/* 6577 */
struct sched_clutch
{
  uint16_t sc_thr_count;
  union
  {
    thread_group *sc_tg;
  };
  sched_clutch_bucket_group sc_clutch_groups[6];
};

/* 1120 */
struct thread_group
{
  uint64_t tg_id;
  char tg_name[32];
  os_refcnt tg_refcount;
  struct
  {
    uint32_t tg_flags;
    cluster_type_t_0 tg_recommendation;
  };
  mpsc_queue_chain tg_destroy_link;
  queue_chain_t_0 tg_queue_chain;
  sched_clutch tg_sched_clutch;
  uint8_t tg_machine_data[];
};

/* 1087 */
struct mac_audit_record_list_t
{
  mac_audit_record *lh_first;
};

/* 845 */
struct internal_state
{
  int dummy;
};

/* 2217 */
struct priority_queue_sched_stable_max
{
  priority_queue_entry_stable *pq_root;
};

/* 6573 */
struct sched_clutch_bucket
{
  uint8_t scb_bucket;
  uint8_t scb_priority;
  uint16_t scb_thr_count;
  sched_clutch_bucket_group *scb_group;
  sched_clutch_root *scb_root;
  priority_queue_sched_max scb_clutchpri_prioq;
  priority_queue_sched_stable_max scb_thread_runq;
  queue_chain_t_0 scb_listlink;
  queue_chain_t_0 scb_runqlink;
  queue_head_t_0 scb_thread_timeshare_queue;
};

/* 1086 */
struct mac_audit_record
{
  int type;
  int length;
  u_char *data;
  struct
  {
    mac_audit_record *le_next;
    mac_audit_record **le_prev;
  } records;
};

/* 5696 */
typedef processor_set *processor_set_t;

/* 2214 */
struct priority_queue_deadline_min
{
  priority_queue_entry_deadline *pq_root;
};

/* 5683 */
struct sched_clutch_bucket_runq
{
  int scbrq_highq;
  int scbrq_count;
  bitmap_t scbrq_bitmap[2];
  circle_queue_head_t scbrq_queues[128];
};

/* 5688 */
struct runq_stats
{
  uint64_t count_sum;
  uint64_t last_change_timestamp;
};

/* 5693 */
struct run_queue
{
  int highq;
  bitmap_t bitmap[2];
  int count;
  int urgency;
  circle_queue_head_t queues[96];
  runq_stats runq_stats;
};

/* 5684 */
struct sched_clutch_root_bucket
{
  uint8_t scrb_bucket;
  bool scrb_bound;
  bool scrb_starvation_avoidance;
  union
  {
    sched_clutch_bucket_runq scrb_clutch_buckets;
    run_queue scrb_bound_thread_runq;
  };
  priority_queue_entry_deadline scrb_pqlink;
  uint64_t scrb_warped_deadline;
  uint64_t scrb_warp_remaining;
  uint64_t scrb_starvation_ts;
};

/* 5691 */
struct sched_clutch_root
{
  int16_t scr_priority;
  uint16_t scr_thr_count;
  int16_t scr_urgency;
  uint16_t scr_shared_rsrc_load_runnable[2];
  uint32_t scr_cluster_id;
  processor_set_t scr_pset;
  queue_head_t_0 scr_clutch_buckets;
  priority_queue_sched_max scr_foreign_buckets;
  bitmap_t scr_unbound_runnable_bitmap[1];
  bitmap_t scr_unbound_warp_available[1];
  bitmap_t scr_bound_runnable_bitmap[1];
  bitmap_t scr_bound_warp_available[1];
  priority_queue_deadline_min scr_unbound_root_buckets;
  priority_queue_deadline_min scr_bound_root_buckets;
  uint16_t scr_cumulative_run_count[6];
  sched_clutch_root_bucket scr_unbound_buckets[6];
  sched_clutch_root_bucket scr_bound_buckets[6];
};

/* 2218 */
struct priority_queue_entry_stable
{
  priority_queue_entry_stable *next;
  priority_queue_entry_stable *prev;
  _BYTE gap10[8];
  uint64_t stamp;
};

/* 7096 */
typedef bitmap_t cpumap_t;

/* 8204 */
struct lck_ticket_t_0
{
  _BYTE gap0[4];
  uint32_t lck_ticket_padding;
  hw_lck_ticket_t tu;
  uint32_t lck_ticket_owner;
};

/* 5685 */
struct rt_queue_pri_t
{
  queue_head_t_0 pri_queue;
  uint64_t pri_earliest_deadline;
  int pri_count;
  uint32_t pri_constraint;
};

/* 5692 */
struct rt_queue
{
  uint64_t earliest_deadline;
  int count;
  uint32_t constraint;
  int ed_index;
  bitmap_t bitmap[1];
  rt_queue_pri_t rt_queue_pri[31];
  runq_stats runq_stats;
};

/* 5690 */
typedef pset_node *pset_node_t;

/* 7095 */
enum pset_cluster_type_t : __int32
{
  PSET_SMP = 0x0,
};

/* 5694 */
struct processor_set
{
  int pset_id;
  int online_processor_count;
  int cpu_set_low;
  int cpu_set_hi;
  int cpu_set_count;
  int last_chosen;
  uint64_t load_average;
  uint64_t pset_load_average[6];
  uint64_t pset_load_last_update;
  cpumap_t cpu_bitmask;
  cpumap_t recommended_bitmask;
  cpumap_t cpu_state_map[7];
  cpumap_t primary_map;
  cpumap_t realtime_map;
  cpumap_t cpu_available_map;
  __attribute__((aligned(128))) lck_ticket_t_0 sched_lock;
  run_queue pset_runq;
  rt_queue rt_runq;
  uint64_t stealable_rt_threads_earliest_deadline;
  sched_clutch_root pset_clutch_root;
  int pset_runq_bound_count;
  cpumap_t pending_AST_URGENT_cpu_mask;
  cpumap_t pending_AST_PREEMPT_cpu_mask;
  cpumap_t pending_deferred_AST_cpu_mask;
  cpumap_t pending_spill_cpu_mask;
  cpumap_t rt_pending_spill_cpu_mask;
  ipc_port *pset_self;
  ipc_port *pset_name_self;
  processor_set_t pset_list;
  pset_node_t node;
  uint32_t pset_cluster_id;
  pset_cluster_type_t pset_cluster_type;
  cluster_type_t_0 pset_type;
  bool is_SMT;
};

/* 7094 */
typedef bitmap_t pset_map_t;

/* 5659 */
struct pset_node
{
  processor_set_t psets;
  pset_node_t nodes;
  pset_node_t node_list;
  pset_node_t parent;
  pset_cluster_type_t pset_cluster_type;
  pset_map_t pset_map;
  pset_map_t pset_idle_map;
  pset_map_t pset_idle_primary_map;
  pset_map_t pset_non_rt_map;
  pset_map_t pset_non_rt_primary_map;
};

/* 820 */
typedef workq_threadreq_s *workq_threadreq_t;

/* 821 */
struct lck_ticket_t
{
  uint32_t opaque0;
  uint32_t opaque1;
  uint32_t opaque2;
  uint32_t opaque3;
};

/* 1054 */
typedef unsigned __int128 wq_thactive_t;

/* 5606 */
typedef void *turnstile_inheritor_t;

/* 822 */
struct workqueue
{
  thread_call_t wq_delayed_call;
  thread_call_t wq_immediate_call;
  thread_call_t wq_death_call;
  union
  {
    turnstile *wq_turnstile;
    mpsc_queue_chain wq_destroy_link;
  };
  lck_ticket_t wq_lock;
  uint64_t wq_thread_call_last_run;
  os_refcnt wq_refcnt;
  __attribute__((aligned(8))) uint32_t wq_fulfilled;
  uint32_t wq_creations;
  uint32_t wq_timer_interval;
  uint32_t wq_event_manager_priority;
  uint32_t wq_reqcount;
  uint16_t wq_thdying_count;
  uint16_t wq_threads_scheduled;
  uint16_t wq_constrained_threads_scheduled;
  uint16_t wq_nthreads;
  uint16_t wq_thidlecount;
  uint16_t wq_thscheduled_count[7];
  workq_threadreq_t wq_event_manager_threadreq;
  wq_thactive_t wq_thactive;
  uint64_t wq_lastblocked_ts[6];
  proc *wq_proc;
  uthread *wq_creator;
  turnstile_inheritor_t wq_inheritor;
  thread_t_0 wq_turnstile_updater;
  workq_uthread_head wq_thrunlist;
  workq_uthread_head wq_thnewlist;
  workq_uthread_head wq_thidlelist;
  priority_queue_sched_max wq_overcommit_queue;
  priority_queue_sched_max wq_constrained_queue;
  priority_queue_sched_max wq_special_queue;
  uint8_t wq_cooperative_queue_scheduled_count[6];
  workq_threadreq_tailq wq_cooperative_queue[6];
};

/* 823 */
typedef rusage_info_v6 rusage_info_current;

/* 9151 */
struct rusage_info_v6
{
  uint8_t ri_uuid[16];
  uint64_t ri_user_time;
  uint64_t ri_system_time;
  uint64_t ri_pkg_idle_wkups;
  uint64_t ri_interrupt_wkups;
  uint64_t ri_pageins;
  uint64_t ri_wired_size;
  uint64_t ri_resident_size;
  uint64_t ri_phys_footprint;
  uint64_t ri_proc_start_abstime;
  uint64_t ri_proc_exit_abstime;
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
  uint64_t ri_diskio_bytesread;
  uint64_t ri_diskio_byteswritten;
  uint64_t ri_cpu_time_qos_default;
  uint64_t ri_cpu_time_qos_maintenance;
  uint64_t ri_cpu_time_qos_background;
  uint64_t ri_cpu_time_qos_utility;
  uint64_t ri_cpu_time_qos_legacy;
  uint64_t ri_cpu_time_qos_user_initiated;
  uint64_t ri_cpu_time_qos_user_interactive;
  uint64_t ri_billed_system_time;
  uint64_t ri_serviced_system_time;
  uint64_t ri_logical_writes;
  uint64_t ri_lifetime_max_phys_footprint;
  uint64_t ri_instructions;
  uint64_t ri_cycles;
  uint64_t ri_billed_energy;
  uint64_t ri_serviced_energy;
  uint64_t ri_interval_max_phys_footprint;
  uint64_t ri_runnable_time;
  uint64_t ri_flags;
  uint64_t ri_user_ptime;
  uint64_t ri_system_ptime;
  uint64_t ri_pinstructions;
  uint64_t ri_pcycles;
  uint64_t ri_energy_nj;
  uint64_t ri_penergy_nj;
  uint64_t ri_reserved[14];
};

/* 838 */
struct rusage
{
  timeval ru_utime;
  timeval ru_stime;
  long ru_maxrss;
  long ru_ixrss;
  long ru_idrss;
  long ru_isrss;
  long ru_minflt;
  long ru_majflt;
  long ru_nswap;
  long ru_inblock;
  long ru_oublock;
  long ru_msgsnd;
  long ru_msgrcv;
  long ru_nsignals;
  long ru_nvcsw;
  long ru_nivcsw;
};

/* 824 */
struct rusage_superset
{
  rusage ru;
  rusage_info_current ri;
};

/* 1063 */
typedef __uint64_t rlim_t;

/* 832 */
struct rlimit
{
  rlim_t rlim_cur;
  rlim_t rlim_max;
};

/* 833 */
struct __attribute__((aligned(8))) plimit
{
  rlimit pl_rlimit[9];
  os_refcnt_t pl_refcnt;
};

/* 835 */
struct user_uprof
{
  user_uprof *pr_next;
  user_addr_t_0 pr_base;
  user_size_t pr_size;
  user_ulong_t pr_off;
  user_ulong_t pr_scale;
  user_ulong_t pr_addr;
  user_ulong_t pr_ticks;
};

/* 836 */
struct rusage_info_child
{
  uint64_t ri_child_user_time;
  uint64_t ri_child_system_time;
  uint64_t ri_child_pkg_idle_wkups;
  uint64_t ri_child_interrupt_wkups;
  uint64_t ri_child_pageins;
  uint64_t ri_child_elapsed_abstime;
};

/* 837 */
struct __attribute__((aligned(8))) uprof
{
  uprof *pr_next;
  caddr_t pr_base;
  u_int32_t pr_size;
  u_int32_t pr_off;
  u_int32_t pr_scale;
  u_int32_t pr_addr;
  u_int32_t pr_ticks;
};

/* 839 */
struct pstats
{
  rusage p_ru;
  rusage p_cru;
  uprof p_prof;
  uint64_t ps_start;
  rusage_info_child ri_child;
  user_uprof user_p_prof;
};

/* 840 */
struct kqwllist
{
  kqworkloop *lh_first;
};

/* 841 */
struct kqworkq
{
  kqueue kqwq_kqueue;
  kqtailq kqwq_queue[7];
  kqtailq kqwq_suppressed[7];
  workq_threadreq_s kqwq_request[7];
};

/* 887 */
struct audit_token_t
{
  unsigned int val[8];
};

/* 888 */
struct security_token_t
{
  unsigned int val[2];
};

/* 891 */
struct task_token_ro_data
{
  security_token_t sec_token;
  audit_token_t audit_token;
};

/* 890 */
struct task_filter_ro_data
{
  uint8_t *mach_trap_filter_mask;
  uint8_t *mach_kobj_filter_mask;
};

/* 889 */
struct task_ro_data
{
  task_token_ro_data task_tokens;
  task_filter_ro_data task_filters;
  uint32_t t_flags_ro;
  uint32_t task_control_port_options;
};

/* 893 */
struct proc_platform_ro_data
{
  uint32_t p_platform;
  uint32_t p_min_sdk;
  uint32_t p_sdk;
};

/* 892 */
struct __attribute__((aligned(8))) proc_ro_data
{
  uint64_t p_uniqueid;
  int p_idversion;
  uint32_t p_csflags;
  ucred *p_ucred;
  uint8_t *syscall_filter_mask;
  proc_platform_ro_data p_platform_data;
};

/* 894 */
struct proc_ro
{
  proc *pr_proc;
  task *pr_task;
  union
  {
    struct __attribute__((aligned(8)))
    {
      uint64_t p_uniqueid;
      int p_idversion;
      uint32_t p_csflags;
      ucred *p_ucred;
      uint8_t *syscall_filter_mask;
      proc_platform_ro_data p_platform_data;
    };
    proc_ro_data proc_data;
  };
  union
  {
    struct
    {
      task_token_ro_data task_tokens;
      task_filter_ro_data task_filters;
      uint32_t t_flags_ro;
      uint32_t task_control_port_options;
    };
    task_ro_data task_data;
  };
};

/* 5625 */
typedef char command_t[17];

/* 5624 */
typedef char proc_name_t[33];

/* 895 */
struct __attribute__((aligned(8))) proc_forkcopy_data
{
  u_int p_argslen;
  int p_argc;
  user_addr_t_0 user_stack;
  _BYTE gap10[8];
  off_t p_textoff;
  sigset_t p_sigmask;
  sigset_t p_sigignore;
  sigset_t p_sigcatch;
  u_char p_priority;
  u_char p_resv0;
  char p_nice;
  u_char p_resv1;
  command_t p_comm;
  proc_name_t p_name;
  uint8_t p_xhighbits;
  pid_t p_contproc;
  uint32_t p_pcaction;
  uint8_t p_uuid[16];
  cpu_type_t p_cputype;
  cpu_subtype_t_0 p_cpusubtype;
};

/* 897 */
struct itimerval
{
  timeval it_interval;
  timeval it_value;
};

/* 898 */
struct __attribute__((aligned(8))) sigacts
{
  user_addr_t_0 ps_sigact[32];
  user_addr_t_0 ps_trampact[32];
  sigset_t ps_catchmask[32];
  sigset_t ps_sigonstack;
  sigset_t ps_sigintr;
  sigset_t ps_sigreset;
  sigset_t ps_signodefer;
  sigset_t ps_siginfo;
  sigset_t ps_oldmask;
  uint32_t ps_sigreturn_validation;
  int ps_flags;
  int ps_sig;
  int ps_code;
  int ps_addr;
};

/* 899 */
struct filedesc
{
  lck_mtx_t fd_lock;
  uint8_t fd_fpdrainwait;
  u_short fd_cmask;
  int fd_nfiles;
  int fd_afterlast;
  int fd_freefile;
  int fd_knlistsize;
  _BYTE gap24[12];
  char *fd_ofileflags;
  klist *fd_knlist;
  kqworkq *fd_wqkqueue;
  vnode *fd_cdir;
  vnode *fd_rdir;
  lck_rw_t fd_dirs_lock;
  lck_mtx_t fd_kqhashlock;
  u_long fd_kqhashmask;
  kqwllist *fd_kqhash;
  lck_mtx_t fd_knhashlock;
  u_long fd_knhashmask;
  klist *fd_knhash;
};

/* 901 */
typedef proc_ro *proc_ro_t;

/* 918 */
struct __attribute__((aligned(8))) fd_vn_data
{
  lck_mtx_t fv_lock;
  off_t fv_offset;
  void *fv_dircookie;
  caddr_t fv_buf;
  size_t fv_bufsiz;
  size_t fv_bufdone;
  size_t fv_bufallocsiz;
  off_t fv_soff;
  off_t fv_eoff;
  int fv_eofflag;
};

/* 1128 */
enum file_type_t : __int32
{
  DTYPE_VNODE = 0x1,
  DTYPE_SOCKET = 0x2,
  DTYPE_PSXSHM = 0x3,
  DTYPE_PSXSEM = 0x4,
  DTYPE_KQUEUE = 0x5,
  DTYPE_PIPE = 0x6,
  DTYPE_FSEVENTS = 0x7,
  DTYPE_ATALK = 0x8,
  DTYPE_NETPOLICY = 0x9,
  DTYPE_CHANNEL = 0xA,
  DTYPE_NEXUS = 0xB,
};

/* 919 */
struct fileops
{
  file_type_t fo_type;
  int (*fo_read)(fileproc *, uio *, int, vfs_context_t);
  int (*fo_write)(fileproc *, uio *, int, vfs_context_t);
  int (*fo_ioctl)(fileproc *, u_long, caddr_t, vfs_context_t);
  int (*fo_select)(fileproc *, int, void *, vfs_context_t);
  int (*fo_close)(fileglob *, vfs_context_t);
  int (*fo_kqfilter)(fileproc *, knote *, kevent_qos_s *);
  int (*fo_drain)(fileproc *, vfs_context_t);
};

/* 944 */
struct __block_literal_2
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(label *);
  __block_descriptor *__descriptor;
};

/* 958 */
typedef char uio_stackbuf_t;

/* 963 */
struct vfstable
{
  const vfsops *vfc_vfsops;
  char vfc_name[15];
  int vfc_typenum;
  int vfc_refcount;
  int vfc_flags;
  int (*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);
  vfstable *vfc_next;
  int32_t vfc_reserved1;
  int32_t vfc_reserved2;
  int vfc_vfsflags;
  void *vfc_descptr;
  uint32_t vfc_descsize;
  sysctl_oid_0 *vfc_sysctl;
};

/* 7261 */
typedef __uint64_t __darwin_ino64_t;

/* 1081 */
typedef __darwin_ino64_t ino64_t;

/* 965 */
struct vfsops
{
  int (*vfs_mount)(mount *, vnode_t, user_addr_t_0, vfs_context_t);
  int (*vfs_start)(mount *, int, vfs_context_t);
  int (*vfs_unmount)(mount *, int, vfs_context_t);
  int (*vfs_root)(mount *, vnode **, vfs_context_t);
  int (*vfs_quotactl)(mount *, int, uid_t, caddr_t, vfs_context_t);
  int (*vfs_getattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_sync)(mount *, int, vfs_context_t);
  int (*vfs_vget)(mount *, ino64_t, vnode **, vfs_context_t);
  int (*vfs_fhtovp)(mount *, int, unsigned __int8 *, vnode **, vfs_context_t);
  int (*vfs_vptofh)(vnode *, int *, unsigned __int8 *, vfs_context_t);
  int (*vfs_init)(vfsconf *);
  int (*vfs_sysctl)(int *, u_int, user_addr_t_0, size_t *, user_addr_t_0, size_t, vfs_context_t);
  int (*vfs_setattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_ioctl)(mount *, u_long, caddr_t, int, vfs_context_t);
  int (*vfs_vget_snapdir)(mount *, vnode **, vfs_context_t);
  void *vfs_reserved5;
  void *vfs_reserved4;
  void *vfs_reserved3;
  void *vfs_reserved2;
  void *vfs_reserved1;
};

/* 964 */
struct vfsconf
{
  uint32_t vfc_reserved1;
  char vfc_name[15];
  int vfc_typenum;
  int vfc_refcount;
  int vfc_flags;
  uint32_t vfc_reserved2;
  uint32_t vfc_reserved3;
};

/* 2278 */
typedef uint16_t zone_id_t;

/* 969 */
struct kalloc_heap
{
  zone_stats_t kh_stats;
  const char *kh_name;
  _BYTE gap10[2];
  vm_tag_t kh_tag;
  uint16_t kh_type_hash;
  zone_id_t kh_zstart;
  kalloc_heap *kh_views;
};

/* 972 */
struct __block_literal_6
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(label *);
  __block_descriptor *__descriptor;
};

/* 973 */
struct __block_literal_5
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(label *);
  __block_descriptor *__descriptor;
};

/* 974 */
struct __block_literal_4
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(label *);
  __block_descriptor *__descriptor;
};

/* 975 */
struct __block_literal_3
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(label *);
  __block_descriptor *__descriptor;
};

/* 976 */
struct mac
{
  size_t m_buflen;
  char *m_string;
};

/* 977 */
enum fdntype : __int32
{
  Fdesc = 0x0,
};

/* 978 */
struct __attribute__((aligned(8))) fdescnode
{
  struct
  {
    fdescnode *le_next;
    fdescnode **le_prev;
  } fd_hash;
  vnode *fd_vnode;
  fdntype fd_type;
  int fd_fd;
  const char *fd_link;
  int fd_ix;
};

/* 987 */
typedef os_reason *os_reason_t;

/* 988 */
typedef proc_ident *proc_ident_t;

/* 989 */
struct _posix_spawn_posix_cred_info
{
  uint32_t pspci_flags;
  uid_t pspci_uid;
  gid_t pspci_gid;
  uint32_t pspci_ngroups;
  gid_t pspci_groups[16];
  uid_t pspci_gmuid;
  char pspci_login[256];
};

/* 990 */
struct _posix_spawn_persona_info
{
  uid_t pspi_id;
  uint32_t pspi_flags;
  uid_t pspi_uid;
  gid_t pspi_gid;
  uint32_t pspi_ngroups;
  gid_t pspi_groups[16];
  uid_t pspi_gmuid;
};

/* 991 */
struct _posix_spawn_coalition_info
{
  struct {uint64_t psci_id;uint32_t psci_role;uint32_t psci_reserved1;uint64_t psci_reserved2;}; psci_info[2];
};

/* 992 */
typedef _ps_mac_policy_extension _ps_mac_policy_extension_t;

/* 7256 */
struct _ps_mac_policy_extension
{
  char policyname[128];
  union
  {
    uint64_t data;
    uint64_t dataoff;
  };
  uint64_t datalen;
};

/* 993 */
struct _posix_spawn_mac_policy_extensions
{
  int psmx_alloc;
  int psmx_count;
  _ps_mac_policy_extension_t psmx_extensions[];
};

/* 994 */
enum pspa_t : __int32
{
  PSPA_SPECIAL = 0x0,
  PSPA_EXCEPTION = 0x1,
  PSPA_AU_SESSION = 0x2,
  PSPA_IMP_WATCHPORTS = 0x3,
  PSPA_REGISTERED_PORTS = 0x4,
  PSPA_PTRAUTH_TASK_PORT = 0x5,
};

/* 995 */
typedef _ps_port_action _ps_port_action_t;

/* 3967 */
typedef unsigned int exception_mask_t;

/* 7948 */
struct _ps_port_action
{
  pspa_t port_type;
  exception_mask_t mask;
  mach_port_name_t new_port;
  exception_behavior_t behavior;
  thread_state_flavor_t flavor;
  int which;
};

/* 9153 */
struct _ps_port_action_0
{
  pspa_t port_type;
  exception_mask_t mask;
  mach_port_name_t_0 new_port;
  exception_behavior_t behavior;
  thread_state_flavor_t flavor;
  int which;
};

/* 9154 */
typedef _ps_port_action_0 _ps_port_action_t_0;

/* 996 */
struct _posix_spawn_port_actions
{
  int pspa_alloc;
  int pspa_count;
  _ps_port_action_t_0 pspa_actions[];
};

/* 997 */
typedef _posix_spawn_mac_policy_extensions *_posix_spawn_mac_policy_extensions_t;

/* 998 */
typedef _posix_spawn_port_actions *_posix_spawn_port_actions_t;

/* 7949 */
enum task_role : __int32
{
  task_role::TASK_RENICED = 0xFFFFFFFF,
  task_role::TASK_UNSPECIFIED = 0x0,
  task_role::TASK_FOREGROUND_APPLICATION = 0x1,
  task_role::TASK_BACKGROUND_APPLICATION = 0x2,
  task_role::TASK_CONTROL_APPLICATION = 0x3,
  task_role::TASK_GRAPHICS_SERVER = 0x4,
  task_role::TASK_THROTTLE_APPLICATION = 0x5,
  task_role::TASK_NONUI_APPLICATION = 0x6,
  task_role::TASK_DEFAULT_APPLICATION = 0x7,
  task_role::TASK_DARWINBG_APPLICATION = 0x8,
};

/* 3968 */
typedef task_role task_role_t;

/* 999 */
struct _posix_spawnattr
{
  short psa_flags;
  short flags_padding;
  sigset_t psa_sigdefault;
  sigset_t psa_sigmask;
  pid_t psa_pgroup;
  cpu_type_t psa_binprefs[4];
  int psa_pcontrol;
  int psa_apptype;
  uint64_t psa_cpumonitor_percent;
  uint64_t psa_cpumonitor_interval;
  uint64_t psa_reserved;
  short psa_jetsam_flags;
  short short_padding;
  int psa_priority;
  int psa_memlimit_active;
  int psa_memlimit_inactive;
  uint64_t psa_qos_clamp;
  task_role_t psa_darwin_role;
  int psa_thread_limit;
  uint64_t psa_max_addr;
  bool psa_no_smt;
  bool psa_tecs;
  int psa_platform;
  cpu_subtype_t_0 psa_subcpuprefs[4];
  uint32_t psa_options;
  uint32_t psa_port_soft_limit;
  uint32_t psa_port_hard_limit;
  uint32_t psa_filedesc_soft_limit;
  uint32_t psa_filedesc_hard_limit;
  uint32_t psa_crash_behavior;
  int psa_dataless_iopolicy;
  uint64_t psa_crash_behavior_deadline;
  uint8_t psa_launch_type;
  uint32_t psa_crash_count;
  uint32_t psa_throttle_timeout;
  _posix_spawn_port_actions_t psa_ports;
  _posix_spawn_mac_policy_extensions_t psa_mac_extensions;
  _posix_spawn_coalition_info *psa_coalition_info;
  _posix_spawn_persona_info *psa_persona_info;
  _posix_spawn_posix_cred_info *psa_posix_cred_info;
  char *psa_subsystem_root_path;
};

/* 1004 */
struct startup_entry
{
  _BYTE gap0[8];
  void (*func)(const void *);
  const void *arg;
};

/* 1005 */
struct __mac_get_mount_args
{
  user_addr_t_0 path;
  user_addr_t_0 mac_p;
  char mac_p_r_[];
};

/* 1006 */
struct __mac_syscall_args
{
  user_addr_t_0 policy;
  int call;
  char call_r_[4];
  user_addr_t_0 arg;
  char arg_r_[];
};

/* 1007 */
struct __mac_set_link_args
{
  user_addr_t_0 path_p;
  user_addr_t_0 mac_p;
  char mac_p_r_[];
};

/* 1008 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_8
{
  void *__isa;
  int __flags;
  int __reserved;
  int (*__FuncPtr)(char *, size_t);
  __block_descriptor *__descriptor;
  user_addr_t_0 path_p;
  int follow;
};

/* 1009 */
struct __mac_set_file_args
{
  user_addr_t_0 path_p;
  user_addr_t_0 mac_p;
  char mac_p_r_[];
};

/* 1010 */
struct __mac_set_fd_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 mac_p;
  char mac_p_r_[];
};

/* 1011 */
struct __mac_get_link_args
{
  user_addr_t_0 path_p;
  user_addr_t_0 mac_p;
  char mac_p_r_[];
};

/* 1012 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_7
{
  void *__isa;
  int __flags;
  int __reserved;
  int (*__FuncPtr)(char *, char *, size_t);
  __block_descriptor *__descriptor;
  user_addr_t_0 path_p;
  int follow;
};

/* 1013 */
struct __mac_get_file_args
{
  user_addr_t_0 path_p;
  user_addr_t_0 mac_p;
  char mac_p_r_[];
};

/* 1014 */
struct __mac_get_fd_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 mac_p;
  char mac_p_r_[];
};

/* 1015 */
struct __mac_set_proc_args
{
  user_addr_t_0 mac_p;
  char mac_p_r_[];
};

/* 1016 */
struct __mac_get_proc_args
{
  user_addr_t_0 mac_p;
  char mac_p_r_[];
};

/* 1017 */
struct __mac_get_pid_args
{
  pid_t pid;
  char pid_r_[4];
  user_addr_t_0 mac_p;
  char mac_p_r_[];
};

/* 1018 */
typedef struct *mac_setter_t;

/* 1019 */
typedef struct *mac_getter_t;

/* 1020 */
struct user_mac
{
  user_size_t m_buflen;
  user_addr_t_0 m_string;
};

/* 1021 */
typedef kalloc_heap *kalloc_heap_t;

/* 1022 */
typedef kalloc_type_view *kalloc_type_view_t;

/* 1047 */
struct kalloc_type_view
{
  zone_view kt_zv;
  const char *kt_signature;
  _BYTE gap28[4];
  uint32_t kt_size;
  void *unused1;
  void *unused2;
};

/* 1023 */
typedef zone_or_view zone_or_view_t;

/* 6511 */
union zone_or_view
{
  kalloc_type_view *zov_kt_heap;
  zone_view *zov_view;
  zone *zov_zone;
};

/* 1024 */
typedef kalloc_type_var_view *kalloc_type_var_view_t;

/* 1048 */
struct __attribute__((aligned(16))) kalloc_type_var_view
{
  _BYTE gap0[2];
  uint16_t kt_size_hdr;
  uint32_t kt_size_type;
  zone_stats_t kt_stats;
  const char *kt_name;
  zone_view_t kt_next;
  zone_id_t kt_heap_start;
  uint8_t kt_zones[22];
  const char *kt_sig_hdr;
  const char *kt_sig_type;
};

/* 1026 */
struct mac_module_data_element
{
  unsigned int key_size;
  unsigned int value_size;
  unsigned int value_type;
  char *key;
  char *value;
};

/* 1025 */
struct mac_module_data_list
{
  unsigned int count;
  unsigned int type;
  mac_module_data_element list[1];
};

/* 1027 */
struct mac_module_data
{
  void *base_addr;
  unsigned int size;
  unsigned int count;
  mac_module_data_element data[1];
};

/* 1028 */
typedef unsigned int mac_policy_handle_t;

/* 1029 */
struct mac_label_listener
{
  mac_policy_handle_t mll_handle;
  struct
  {
    mac_label_listener *sle_next;
  } mll_list;
};

/* 1030 */
struct mac_label_listeners_t
{
  mac_label_listener *slh_first;
};

/* 1031 */
struct mac_label_element
{
  char mle_name[32];
  mac_label_listeners_t mle_listeners;
  struct
  {
    mac_label_element *sle_next;
  } mle_list;
};

/* 1042 */
typedef launch_constraint_data *launch_constraint_data_t_0;

/* 1046 */
struct mac_policy_list_element
{
  mac_policy_conf *mpc;
};

/* 1049 */
struct _lck_attr_
{
  unsigned int lck_attr_val;
};

/* 1050 */
typedef _lck_attr_ lck_attr_t;

/* 2697 */
union user_sigval
{
  struct
  {
    uint32_t pad;
    int32_t sival_int;
  } size_equivalent;
  user_addr_t_0 sival_ptr;
};

/* 4076 */
struct user_sigevent
{
  int sigev_notify;
  int sigev_signo;
  user_sigval sigev_value;
  user_addr_t_0 sigev_notify_function;
  user_addr_t_0 sigev_notify_attributes;
};

/* 4077 */
struct __attribute__((aligned(8))) user_aiocb
{
  int aio_fildes;
  off_t aio_offset;
  user_addr_t_0 aio_buf;
  user_size_t aio_nbytes;
  int aio_reqprio;
  user_sigevent aio_sigevent;
  int aio_lio_opcode;
};

/* 1056 */
struct aio_workq_entry
{
  struct
  {
    aio_workq_entry *tqe_next;
    aio_workq_entry **tqe_prev;
  } aio_workq_link;
  struct
  {
    aio_workq_entry *tqe_next;
    aio_workq_entry **tqe_prev;
  } aio_proc_link;
  user_ssize_t returnval;
  errno_t errorval;
  os_refcnt_t aio_refcount;
  _BYTE gap30[4];
  int lio_pending;
  aio_workq_entry *lio_leader;
  proc *procp;
  user_addr_t_0 uaiocbp;
  user_aiocb aiocb;
  vfs_context context;
  vm_map_t_0 aio_map;
};

/* 7784 */
struct dof_helper
{
  char dofhp_mod[64];
  uint64_t dofhp_addr;
  uint64_t dofhp_dof;
};

/* 2651 */
typedef dof_helper dof_helper_t;

/* 1057 */
struct dof_ioctl_data
{
  uint64_t dofiod_count;
  dof_helper_t dofiod_helpers[1];
};

/* 2680 */
typedef dtrace_helper_action dtrace_helper_action_t;

/* 2675 */
typedef dtrace_state dtrace_state_t;

/* 2658 */
typedef dtrace_statvar dtrace_statvar_t;

/* 2678 */
typedef dtrace_difv dtrace_difv_t;

/* 2657 */
typedef dtrace_dynhash dtrace_dynhash_t;

/* 5522 */
enum dtrace_dstate_state : __int32
{
  dtrace_dstate_state::DTRACE_DSTATE_CLEAN = 0x0,
  dtrace_dstate_state::DTRACE_DSTATE_EMPTY = 0x1,
  dtrace_dstate_state::DTRACE_DSTATE_DIRTY = 0x2,
  dtrace_dstate_state::DTRACE_DSTATE_RINSING = 0x3,
};

/* 5523 */
typedef dtrace_dstate_state dtrace_dstate_state_t;

/* 2653 */
typedef dtrace_dstate_percpu dtrace_dstate_percpu_t;

/* 7790 */
struct dtrace_dstate
{
  void *dtds_base;
  size_t dtds_size;
  size_t dtds_hashsize;
  size_t dtds_chunksize;
  dtrace_dynhash_t *dtds_hash;
  dtrace_dstate_state_t dtds_state;
  dtrace_dstate_percpu_t *dtds_percpu;
};

/* 2676 */
typedef dtrace_dstate dtrace_dstate_t;

/* 7797 */
struct dtrace_vstate
{
  dtrace_state_t *dtvs_state;
  dtrace_statvar_t **dtvs_globals;
  int dtvs_nglobals;
  dtrace_difv_t *dtvs_tlocals;
  int dtvs_ntlocals;
  dtrace_statvar_t **dtvs_locals;
  int dtvs_nlocals;
  dtrace_dstate_t dtvs_dynvars;
};

/* 2681 */
typedef dtrace_vstate dtrace_vstate_t;

/* 2652 */
typedef dtrace_helper_provider dtrace_helper_provider_t;

/* 8169 */
typedef uint32_t uint_t_0;

/* 1058 */
struct dtrace_helpers
{
  dtrace_helper_action_t **dthps_actions;
  dtrace_vstate_t dthps_vstate;
  dtrace_helper_provider_t **dthps_provs;
  uint_t_0 dthps_nprovs;
  uint_t_0 dthps_maxprovs;
  int dthps_generation;
  pid_t dthps_pid;
  int dthps_deferred;
  dtrace_helpers *dthps_next;
  dtrace_helpers *dthps_prev;
};

/* 2679 */
typedef dtrace_difo dtrace_difo_t;

/* 7798 */
struct dtrace_helper_action
{
  int dtha_generation;
  int dtha_nactions;
  dtrace_difo_t *dtha_predicate;
  dtrace_difo_t **dtha_actions;
  dtrace_helper_action *dtha_next;
};

/* 2673 */
typedef dtrace_ecb dtrace_ecb_t;

/* 5538 */
typedef uint32_t dtrace_epid_t;

/* 5528 */
enum dtrace_activity : __int32
{
  dtrace_activity::DTRACE_ACTIVITY_INACTIVE = 0x0,
  dtrace_activity::DTRACE_ACTIVITY_WARMUP = 0x1,
  dtrace_activity::DTRACE_ACTIVITY_ACTIVE = 0x2,
  dtrace_activity::DTRACE_ACTIVITY_DRAINING = 0x3,
  dtrace_activity::DTRACE_ACTIVITY_COOLDOWN = 0x4,
  dtrace_activity::DTRACE_ACTIVITY_STOPPED = 0x5,
  dtrace_activity::DTRACE_ACTIVITY_KILLED = 0x6,
};

/* 5540 */
typedef dtrace_activity dtrace_activity_t;

/* 2663 */
typedef dtrace_buffer dtrace_buffer_t;

/* 2662 */
typedef dtrace_speculation dtrace_speculation_t;

/* 2661 */
typedef dtrace_aggregation dtrace_aggregation_t;

/* 5524 */
typedef void vmem_t;

/* 7796 */
typedef int64_t hrtime_t;

/* 5539 */
typedef uintptr_t cyclic_id_t;

/* 2660 */
typedef dtrace_format dtrace_format_t;

/* 8143 */
typedef int64_t dtrace_optval_t;

/* 2659 */
typedef ucred cred_t;

/* 7791 */
struct __attribute__((aligned(8))) dtrace_cred
{
  cred_t *dcr_cred;
  uint8_t dcr_destructive;
  uint8_t dcr_visible;
  uint16_t dcr_action;
};

/* 2674 */
typedef dtrace_cred dtrace_cred_t;

/* 7794 */
struct dtrace_state
{
  dev_t dts_dev;
  int dts_necbs;
  dtrace_ecb_t **dts_ecbs;
  dtrace_epid_t dts_epid;
  size_t dts_needed;
  dtrace_state *dts_anon;
  dtrace_activity_t dts_activity;
  dtrace_vstate_t dts_vstate;
  dtrace_buffer_t *dts_buffer;
  dtrace_buffer_t *dts_aggbuffer;
  dtrace_speculation_t *dts_speculations;
  int dts_nspeculations;
  int dts_naggregations;
  dtrace_aggregation_t **dts_aggregations;
  vmem_t *dts_aggid_arena;
  uint64_t dts_errors;
  uint32_t dts_speculations_busy;
  uint32_t dts_speculations_unavail;
  uint32_t dts_stkstroverflows;
  uint32_t dts_dblerrors;
  uint32_t dts_reserve;
  hrtime_t dts_laststatus;
  cyclic_id_t dts_cleaner;
  cyclic_id_t dts_deadman;
  hrtime_t dts_alive;
  char dts_speculates;
  char dts_destructive;
  int dts_nformats;
  dtrace_format_t **dts_formats;
  dtrace_optval_t dts_options[33];
  dtrace_cred_t dts_cred;
  size_t dts_nretained;
  uint64_t dts_arg_error_illval;
  uint32_t dts_buf_over_limit;
  uint64_t **dts_rstate;
};

/* 7799 */
struct dtrace_diftype
{
  uint8_t dtdt_kind;
  uint8_t dtdt_ckind;
  uint8_t dtdt_flags;
  uint8_t dtdt_pad;
  uint32_t dtdt_size;
};

/* 2677 */
typedef dtrace_diftype dtrace_diftype_t;

/* 7800 */
struct dtrace_difv
{
  uint32_t dtdv_name;
  uint32_t dtdv_id;
  uint8_t dtdv_kind;
  uint8_t dtdv_scope;
  uint16_t dtdv_flags;
  dtrace_diftype_t dtdv_type;
};

/* 9205 */
struct dtrace_statvar
{
  uint64_t dtsv_data;
  size_t dtsv_size;
  int dtsv_refcnt;
  dtrace_difv_t dtsv_var;
};

/* 2656 */
typedef dtrace_dynvar dtrace_dynvar_t;

/* 8163 */
struct dtrace_dynhash
{
  dtrace_dynvar_t *dtdh_chain;
  uintptr_t dtdh_lock;
  uintptr_t dtdh_pad[6];
};

/* 7786 */
struct dtrace_dstate_percpu
{
  dtrace_dynvar_t *dtdsc_free;
  dtrace_dynvar_t *dtdsc_dirty;
  dtrace_dynvar_t *dtdsc_rinsing;
  dtrace_dynvar_t *dtdsc_clean;
  uint64_t dtdsc_drops;
  uint64_t dtdsc_dirty_drops;
  uint64_t dtdsc_rinsing_drops;
};

/* 7785 */
struct dtrace_helper_provider
{
  int dthp_generation;
  uint32_t dthp_ref;
  dof_helper_t dthp_prov;
};

/* 5541 */
typedef uint32_t dif_instr_t;

/* 9211 */
struct dtrace_difo
{
  dif_instr_t *dtdo_buf;
  uint64_t *dtdo_inttab;
  char *dtdo_strtab;
  dtrace_difv_t *dtdo_vartab;
  uint_t_0 dtdo_len;
  uint_t_0 dtdo_intlen;
  uint_t_0 dtdo_strlen;
  uint_t_0 dtdo_varlen;
  dtrace_diftype_t dtdo_rtype;
  uint_t_0 dtdo_refcnt;
  uint_t_0 dtdo_destructive;
};

/* 2672 */
typedef dtrace_predicate dtrace_predicate_t;

/* 2671 */
typedef dtrace_action dtrace_action_t;

/* 2669 */
typedef dtrace_probe dtrace_probe_t;

/* 8168 */
struct dtrace_ecb
{
  dtrace_epid_t dte_epid;
  uint32_t dte_alignment;
  size_t dte_needed;
  size_t dte_size;
  dtrace_predicate_t *dte_predicate;
  dtrace_action_t *dte_action;
  dtrace_ecb_t *dte_next;
  dtrace_state_t *dte_state;
  uint32_t dte_cond;
  dtrace_probe_t *dte_probe;
  dtrace_action_t *dte_action_last;
  uint64_t dte_uarg;
};

/* 9206 */
struct dtrace_buffer
{
  uint64_t dtb_offset;
  uint64_t dtb_cur_limit;
  uint64_t dtb_limit;
  uint64_t dtb_size;
  uint32_t dtb_flags;
  uint32_t dtb_drops;
  caddr_t dtb_tomax;
  caddr_t dtb_xamot;
  uint32_t dtb_xamot_flags;
  uint32_t dtb_xamot_drops;
  uint64_t dtb_xamot_offset;
  uint32_t dtb_errors;
  uint32_t dtb_xamot_errors;
  uint64_t dtb_switched;
  uint64_t dtb_interval;
  uint64_t dtb_pad2[4];
};

/* 5526 */
enum dtrace_speculation_state : __int32
{
  dtrace_speculation_state::DTRACESPEC_INACTIVE = 0x0,
  dtrace_speculation_state::DTRACESPEC_ACTIVE = 0x1,
  dtrace_speculation_state::DTRACESPEC_ACTIVEONE = 0x2,
  dtrace_speculation_state::DTRACESPEC_ACTIVEMANY = 0x3,
  dtrace_speculation_state::DTRACESPEC_COMMITTING = 0x4,
  dtrace_speculation_state::DTRACESPEC_COMMITTINGMANY = 0x5,
  dtrace_speculation_state::DTRACESPEC_DISCARDING = 0x6,
};

/* 5527 */
typedef dtrace_speculation_state dtrace_speculation_state_t;

/* 7793 */
struct dtrace_speculation
{
  dtrace_speculation_state_t dtsp_state;
  int dtsp_cleaning;
  dtrace_buffer_t *dtsp_buffer;
};

/* 5536 */
typedef uint16_t dtrace_actkind_t;

/* 9209 */
struct dtrace_recdesc
{
  dtrace_actkind_t dtrd_action;
  uint32_t dtrd_size;
  uint32_t dtrd_offset;
  uint16_t dtrd_alignment;
  uint16_t dtrd_format;
  uint64_t dtrd_arg;
  uint64_t dtrd_uarg;
};

/* 2670 */
typedef dtrace_recdesc dtrace_recdesc_t;

/* 9210 */
struct dtrace_action
{
  dtrace_actkind_t dta_kind;
  uint16_t dta_intuple;
  uint32_t dta_refcnt;
  dtrace_difo_t *dta_difo;
  dtrace_recdesc_t dta_rec;
  dtrace_action_t *dta_prev;
  dtrace_action_t *dta_next;
};

/* 5525 */
typedef uint32_t dtrace_aggid_t;

/* 9470 */
struct dtrace_aggregation
{
  dtrace_action_t dtag_action;
  dtrace_aggid_t dtag_id;
  dtrace_ecb_t *dtag_ecb;
  dtrace_action_t *dtag_first;
  uint32_t dtag_base;
  uint8_t dtag_hasarg;
  uint64_t dtag_initial;
  void (*dtag_aggregate)(uint64_t *, uint64_t, uint64_t);
};

/* 7792 */
struct dtrace_format
{
  uint64_t dtf_refcount;
  char dtf_str[];
};

/* 7787 */
struct dtrace_key
{
  uint64_t dttk_value;
  uint64_t dttk_size;
};

/* 2654 */
typedef dtrace_key dtrace_key_t;

/* 7788 */
struct dtrace_tuple
{
  uint32_t dtt_nkeys;
  uint32_t dtt_pad;
  dtrace_key_t dtt_key[1];
};

/* 2655 */
typedef dtrace_tuple dtrace_tuple_t;

/* 7789 */
struct dtrace_dynvar
{
  uint64_t dtdv_hashval;
  dtrace_dynvar *dtdv_next;
  void *dtdv_data;
  dtrace_tuple_t dtdv_tuple;
};

/* 5537 */
typedef uint32_t dtrace_cacheid_t;

/* 8154 */
struct dtrace_predicate
{
  dtrace_difo_t *dtp_difo;
  dtrace_cacheid_t dtp_cacheid;
  int dtp_refcnt;
};

/* 5535 */
typedef uint32_t dtrace_id_t;

/* 2668 */
typedef dtrace_provider dtrace_provider_t;

/* 5534 */
typedef uint64_t dtrace_genid_t;

/* 7804 */
struct dtrace_probe
{
  dtrace_id_t dtpr_id;
  dtrace_ecb_t *dtpr_ecb;
  dtrace_ecb_t *dtpr_ecb_last;
  void *dtpr_arg;
  dtrace_cacheid_t dtpr_predcache;
  int dtpr_aframes;
  dtrace_provider_t *dtpr_provider;
  char *dtpr_mod;
  char *dtpr_func;
  char *dtpr_name;
  dtrace_probe_t *dtpr_nextprov;
  dtrace_probe_t *dtpr_prevprov;
  dtrace_probe_t *dtpr_nextmod;
  dtrace_probe_t *dtpr_prevmod;
  dtrace_probe_t *dtpr_nextfunc;
  dtrace_probe_t *dtpr_prevfunc;
  dtrace_probe_t *dtpr_nextname;
  dtrace_probe_t *dtpr_prevname;
  dtrace_genid_t dtpr_gen;
};

/* 5533 */
typedef uint8_t dtrace_stability_t;

/* 5532 */
typedef uint8_t dtrace_class_t;

/* 8166 */
struct dtrace_attribute
{
  dtrace_stability_t dtat_name;
  dtrace_stability_t dtat_data;
  dtrace_class_t dtat_class;
};

/* 2632 */
typedef dtrace_attribute dtrace_attribute_t;

/* 8167 */
struct dtrace_pattr
{
  dtrace_attribute_t dtpa_provider;
  dtrace_attribute_t dtpa_mod;
  dtrace_attribute_t dtpa_func;
  dtrace_attribute_t dtpa_name;
  dtrace_attribute_t dtpa_args;
};

/* 2633 */
typedef dtrace_pattr dtrace_pattr_t;

/* 5531 */
typedef uint32_t zoneid_t;

/* 8165 */
struct dtrace_ppriv
{
  uint32_t dtpp_flags;
  uid_t dtpp_uid;
  zoneid_t dtpp_zoneid;
};

/* 2667 */
typedef dtrace_ppriv dtrace_ppriv_t;

/* 2665 */
typedef dtrace_probedesc dtrace_probedesc_t;

/* 2664 */
typedef dtrace_argdesc dtrace_argdesc_t;

/* 8164 */
struct dtrace_pops
{
  void (*dtps_provide)(void *, const dtrace_probedesc_t *);
  void (*dtps_provide_module)(void *, modctl *);
  int (*dtps_enable)(void *, dtrace_id_t, void *);
  void (*dtps_disable)(void *, dtrace_id_t, void *);
  void (*dtps_suspend)(void *, dtrace_id_t, void *);
  void (*dtps_resume)(void *, dtrace_id_t, void *);
  void (*dtps_getargdesc)(void *, dtrace_id_t, void *, dtrace_argdesc_t *);
  uint64_t (*dtps_getargval)(void *, dtrace_id_t, void *, int, int);
  int (*dtps_usermode)(void *, dtrace_id_t, void *);
  void (*dtps_destroy)(void *, dtrace_id_t, void *);
};

/* 2666 */
typedef dtrace_pops dtrace_pops_t;

/* 7795 */
struct dtrace_provider
{
  dtrace_pattr_t dtpv_attr;
  dtrace_ppriv_t dtpv_priv;
  dtrace_pops_t dtpv_pops;
  char *dtpv_name;
  void *dtpv_arg;
  uint_t_0 dtpv_defunct;
  dtrace_provider *dtpv_next;
  uint64_t dtpv_probe_count;
  uint64_t dtpv_ecb_count;
};

/* 9208 */
struct dtrace_probedesc
{
  dtrace_id_t dtpd_id;
  char dtpd_provider[64];
  char dtpd_mod[64];
  char dtpd_func[128];
  char dtpd_name[64];
};

/* 9333 */
typedef vm_offset_t_0 vm_address_t_1;

/* 5529 */
typedef uint8_t UUID[16];

/* 2631 */
struct modctl
{
  modctl *mod_next;
  modctl *mod_stale;
  uint32_t mod_id;
  char mod_modname[64];
  int mod_loadcnt;
  char mod_loaded;
  uint16_t mod_flags;
  int mod_nenabled;
  vm_address_t_1 mod_address;
  vm_size_t_0 mod_size;
  UUID mod_uuid;
  dtrace_module_symbols *mod_user_symbols;
  int mod_sdtprobecnt;
  void *mod_sdtdesc;
};

/* 9207 */
struct dtrace_argdesc
{
  dtrace_id_t dtargd_id;
  int dtargd_ndx;
  int dtargd_mapping;
  char dtargd_native[128];
  char dtargd_xlate[128];
};

/* 7782 */
struct dtrace_symbol
{
  uint64_t dtsym_addr;
  uint64_t dtsym_size;
  char dtsym_name[128];
};

/* 2629 */
typedef dtrace_symbol dtrace_symbol_t;

/* 2630 */
struct dtrace_module_symbols
{
  UUID dtmodsyms_uuid;
  uint64_t dtmodsyms_count;
  dtrace_symbol_t dtmodsyms_symbols[1];
};

/* 1059 */
struct dtrace_ptss_page
{
  dtrace_ptss_page *next;
  dtrace_ptss_page_entry entries[256];
};

/* 3969 */
enum persona_type_t : __int32
{
  PERSONA_INVALID = 0x0,
  PERSONA_GUEST = 0x1,
  PERSONA_MANAGED = 0x2,
  PERSONA_PRIV = 0x3,
  PERSONA_SYSTEM = 0x4,
  PERSONA_DEFAULT = 0x5,
  PERSONA_SYSTEM_PROXY = 0x6,
  PERSONA_SYS_EXT = 0x7,
  PERSONA_ENTERPRISE = 0x8,
  PERSONA_TYPE_MAX = 0x8,
};

/* 1065 */
struct persona
{
  os_refcnt_t pna_refcount;
  int32_t pna_valid;
  uid_t pna_id;
  persona_type_t pna_type;
  char pna_login[256];
  char *pna_path;
  uid_t pna_uid;
  struct
  {
    persona *le_next;
    persona **le_prev;
  } pna_list;
  struct
  {
    proc *lh_first;
  } pna_members;
  lck_mtx_t pna_lock;
};

/* 1070 */
struct ubc_info
{
  memory_object_t ui_pager;
  memory_object_control_t ui_control;
  _BYTE gap10[8];
  kauth_cred_t ui_ucred;
  off_t ui_size;
  uint32_t ui_flags;
  uint32_t cs_add_gen;
  cl_readahead *cl_rahead;
  cl_writebehind *cl_wbehind;
  timespec cs_mtime;
  _BYTE gap50[8];
  cs_blob *cs_blob_supplement;
};

/* 3288 */
struct __attribute__((aligned(8))) cl_readahead
{
  lck_mtx_t cl_lockr;
  daddr64_t cl_lastr;
  daddr64_t cl_maxra;
  int cl_ralen;
};

/* 3286 */
struct __attribute__((aligned(8))) cl_wextent
{
  daddr64_t b_addr;
  daddr64_t e_addr;
  int io_flags;
};

/* 3287 */
struct cl_writebehind
{
  lck_mtx_t cl_lockw;
  void *cl_scmap;
  off_t cl_last_write;
  off_t cl_seq_written;
  int cl_sparse_pushes;
  int cl_sparse_wait;
  int cl_number;
  cl_wextent cl_clusters[8];
};

/* 1071 */
struct __attribute__((aligned(8))) fifoinfo
{
  unsigned int fi_flags;
  socket *fi_readsock;
  socket *fi_writesock;
  long fi_readers;
  long fi_writers;
  unsigned int fi_count;
};

/* 5449 */
typedef int32_t daddr_t;

/* 1072 */
struct specinfo
{
  vnode **si_hashchain;
  vnode *si_specnext;
  long si_flags;
  dev_t si_rdev;
  int32_t si_opencount;
  daddr_t si_size;
  daddr64_t si_lastr;
  u_int64_t si_devsize;
  u_int8_t si_initted;
  u_int8_t si_throttleable;
  u_int16_t si_isssd;
  u_int32_t si_devbsdunit;
  u_int64_t si_throttle_mask;
};

/* 1133 */
struct OpaqueDTEntry
{
  uint32_t nProperties;
  uint32_t nChildren;
};

/* 1134 */
union ubrdiv_t
{
  uint32_t raw;
  struct
  {
    _BYTE gap0[4];
  };
};

/* 1135 */
union urxh_t
{
  uint32_t raw;
  struct
  {
    _BYTE gap0[4];
  };
};

/* 1136 */
union utxh_t
{
  uint32_t raw;
  struct
  {
    _BYTE gap0[4];
  };
};

/* 1137 */
union ufstat_t
{
  uint32_t raw;
  struct
  {
    _BYTE gap0[4];
  };
};

/* 1138 */
union utrstat_t
{
  uint32_t raw;
  struct
  {
    _BYTE gap0[4];
  };
};

/* 1139 */
union ufcon_t
{
  uint32_t raw;
  struct
  {
    _BYTE gap0[4];
  };
};

/* 1140 */
union ucon_t
{
  uint32_t raw;
  struct
  {
    _BYTE gap0[4];
  };
};

/* 1141 */
union ulcon_t
{
  uint32_t raw;
  struct
  {
    _BYTE gap0[4];
  };
};

/* 1142 */
struct apple_uart_registers_t
{
  ulcon_t ulcon;
  ucon_t ucon;
  ufcon_t ufcon;
  uint32_t umcon;
  utrstat_t utrstat;
  uint32_t uerstat;
  ufstat_t ufstat;
  uint32_t umstat;
  utxh_t utxh;
  urxh_t urxh;
  ubrdiv_t ubrdiv;
  uint32_t uabrcnt;
  uint8_t rsvd0[4];
  uint32_t utxoffset;
  uint32_t urxoffset;
  uint32_t uver;
};

/* 1143 */
enum serial_device : __int32
{
  serial_device::SERIAL_UNKNOWN = 0x0,
  serial_device::SERIAL_APPLE_UART = 0x1,
  serial_device::SERIAL_DOCKCHANNEL = 0x2,
  serial_device::SERIAL_PI3_UART = 0x4,
  serial_device::SERIAL_VMAPPLE_UART = 0x8,
  serial_device::SERIAL_DCC_UART = 0x10,
};

/* 1144 */
typedef serial_device serial_device_t;

/* 1145 */
struct slock
{
  uint64_t lock_data[9];
};

/* 1146 */
typedef slock *usimple_lock_t;

/* 1147 */
struct Boot_Video
{
  unsigned __int64 v_baseAddr;
  unsigned __int64 v_display;
  unsigned __int64 v_rowBytes;
  unsigned __int64 v_width;
  unsigned __int64 v_height;
  unsigned __int64 v_depth;
};

/* 1148 */
struct boot_args
{
  uint16_t Revision;
  uint16_t Version;
  uint64_t virtBase;
  uint64_t physBase;
  uint64_t memSize;
  uint64_t topOfKernelData;
  Boot_Video Video;
  uint32_t machineType;
  void *deviceTreeP;
  uint32_t deviceTreeLength;
  char CommandLine[608];
  uint64_t bootFlags;
  uint64_t memSizeActual;
};

/* 1149 */
struct boot_progress_element
{
  unsigned int width;
  unsigned int height;
  int yOffset;
  unsigned int res[5];
  unsigned __int8 data[];
};

/* 1150 */
struct vc_progress_element
{
  unsigned int version;
  unsigned int flags;
  unsigned int time;
  unsigned __int8 count;
  unsigned __int8 res[3];
  int width;
  int height;
  int dx;
  int dy;
  int transparent;
  unsigned int res2[3];
};

/* 1151 */
struct timebase_freq_t
{
  unsigned __int64 timebase_num;
  unsigned __int64 timebase_den;
};

/* 1152 */
struct clock_frequency_info_t_0
{
  unsigned __int64 bus_clock_rate_hz;
  unsigned __int64 cpu_clock_rate_hz;
  unsigned __int64 dec_clock_rate_hz;
  unsigned __int64 bus_clock_rate_num;
  unsigned __int64 bus_clock_rate_den;
  unsigned __int64 bus_to_cpu_rate_num;
  unsigned __int64 bus_to_cpu_rate_den;
  unsigned __int64 bus_to_dec_rate_num;
  unsigned __int64 bus_to_dec_rate_den;
  unsigned __int64 timebase_frequency_hz;
  unsigned __int64 timebase_frequency_num;
  unsigned __int64 timebase_frequency_den;
  unsigned __int64 bus_frequency_hz;
  unsigned __int64 bus_frequency_min_hz;
  unsigned __int64 bus_frequency_max_hz;
  unsigned __int64 cpu_frequency_hz;
  unsigned __int64 cpu_frequency_min_hz;
  unsigned __int64 cpu_frequency_max_hz;
  unsigned __int64 prf_frequency_hz;
  unsigned __int64 prf_frequency_min_hz;
  unsigned __int64 prf_frequency_max_hz;
  unsigned __int64 mem_frequency_hz;
  unsigned __int64 mem_frequency_min_hz;
  unsigned __int64 mem_frequency_max_hz;
  unsigned __int64 fix_frequency_hz;
};

/* 1153 */
struct PE_Video_0
{
  unsigned __int64 v_baseAddr;
  unsigned __int64 v_rowBytes;
  unsigned __int64 v_width;
  unsigned __int64 v_height;
  unsigned __int64 v_depth;
  unsigned __int64 v_display;
  char v_pixelFormat[64];
  unsigned __int64 v_offset;
  unsigned __int64 v_length;
  unsigned __int8 v_rotate;
  unsigned __int8 v_scale;
  char reserved1[2];
  long reserved2;
};

/* 7996 */
typedef char __darwin_uuid_string_t[37];

/* 4357 */
typedef __darwin_uuid_string_t uuid_string_t;

/* 1154 */
struct __attribute__((packed)) __attribute__((aligned(1))) embedded_panic_header
{
  uint32_t eph_magic;
  uint32_t eph_crc;
  uint32_t eph_version;
  _BYTE gapC[8];
  uint32_t eph_panic_log_offset;
  uint32_t eph_panic_log_len;
  uint32_t eph_stackshot_offset;
  uint32_t eph_stackshot_len;
  uint32_t eph_other_log_offset;
  uint32_t eph_other_log_len;
  union
  {
    struct
    {
      _BYTE gap0[8];
    };
    uint64_t eph_x86_do_not_use;
  };
  char eph_os_version[32];
  char eph_macos_version[32];
  uuid_string_t eph_bootsessionuuid_string;
  uint64_t eph_roots_installed;
};

/* 1156 */
typedef OpaqueDTEntry DeviceTreeNode;

/* 1158 */
typedef const DeviceTreeNode *RealDTEntry;

/* 1155 */
struct DTSavedScope
{
  DTSavedScope *nextScope;
  RealDTEntry scope;
  RealDTEntry entry;
  unsigned __int64 index;
};

/* 1157 */
typedef DTSavedScope *DTSavedScopePtr;

/* 1159 */
struct OpaqueDTEntryIterator
{
  RealDTEntry outerScope;
  RealDTEntry currentScope;
  RealDTEntry currentEntry;
  DTSavedScopePtr savedScope;
  unsigned __int64 currentIndex;
};

/* 1160 */
typedef void (*set_decrementer_t)(uint32_t);

/* 1161 */
typedef uint32_t (*get_decrementer_t)(void);

/* 1162 */
typedef void (*fiq_handler_t)(void);

/* 1163 */
struct dbg_cpr_state_entry_t
{
  uint64_t timestamp;
  uint32_t cp_state;
  uint32_t cp_state_arg;
};

/* 1164 */
struct dbg_record_header_t
{
  uint64_t record_id;
  uint64_t length;
  uint64_t physaddr;
};

/* 1165 */
struct dbg_cpr_t
{
  uint32_t rdptr;
  uint32_t wrptr;
  uint32_t num_cp_state_entries;
  uint32_t checksum;
  dbg_cpr_state_entry_t cp_state_entries[16];
};

/* 1166 */
struct dbg_top_level_header_t
{
  uint64_t record_id;
  uint32_t num_records;
  uint32_t record_size_bytes;
};

/* 1167 */
struct dbg_registry_t
{
  dbg_top_level_header_t top_level_header;
  dbg_record_header_t records[512];
  dbg_cpr_t ap_cpr_region;
};

/* 7276 */
enum kc_format : __int32
{
  kc_format::KCFormatUnknown = 0x0,
  kc_format::KCFormatStatic = 0x1,
  kc_format::KCFormatDynamic = 0x2,
  kc_format::KCFormatFileset = 0x3,
  kc_format::KCFormatKCGEN = 0x4,
};

/* 1168 */
typedef kc_format kc_format_t;

/* 7236 */
enum kc_kind_0 : __int32
{
  kc_kind::KCKindNone_0 = 0xFFFFFFFF,
  kc_kind::KCKindUnknown_0 = 0x0,
  kc_kind::KCKindPrimary_0 = 0x1,
  kc_kind::KCKindPageable_0 = 0x2,
  kc_kind::KCKindAuxiliary_0 = 0x3,
  kc_kind::KCNumKinds_0 = 0x4,
};

/* 1169 */
typedef kc_kind_0 kc_kind_t_0;

/* 1170 */
struct segment_command_64_0
{
  uint32_t cmd;
  uint32_t cmdsize;
  char segname[16];
  uint64_t vmaddr;
  uint64_t vmsize;
  uint64_t fileoff;
  uint64_t filesize;
  vm_prot_t maxprot;
  vm_prot_t initprot;
  uint32_t nsects;
  uint32_t flags;
};

/* 1171 */
struct load_command
{
  uint32_t cmd;
  uint32_t cmdsize;
};

/* 1172 */
typedef mach_header_64_0 kernel_mach_header_t_0;

/* 2182 */
struct mach_header_64_0
{
  uint32_t magic;
  cpu_type_t cputype;
  cpu_subtype_t_0 cpusubtype;
  uint32_t filetype;
  uint32_t ncmds;
  uint32_t sizeofcmds;
  uint32_t flags;
  uint32_t reserved;
};

/* 1173 */
typedef boolean_t (*argsep_func_t)(char);

/* 1174 */
struct OpaqueDTPropertyIterator
{
  RealDTEntry entry;
  const DeviceTreeNodeProperty *currentProperty;
  unsigned __int64 currentIndex;
};

/* 1177 */
struct DeviceTreeNodeProperty
{
  char name[32];
  uint32_t length;
};

/* 1175 */
typedef OpaqueDTPropertyIterator *DTPropertyIterator;

/* 1176 */
typedef OpaqueDTEntryIterator *DTEntryIterator;

/* 1178 */
typedef const OpaqueDTEntry *DTEntry;

/* 1423 */
typedef void *cpu_id_t_0;

/* 1179 */
typedef void (*perfmon_interrupt_handler_func)(cpu_id_t_0);

/* 1180 */
typedef ml_topology_cluster_0 ml_topology_cluster_t;

/* 8210 */
struct ml_topology_cluster_0
{
  unsigned int cluster_id;
  cluster_type_t_0 cluster_type;
  unsigned int num_cpus;
  unsigned int first_cpu_id;
  uint64_t cpu_mask;
  vm_offset_t acc_IMPL_regs;
  uint64_t acc_IMPL_pa;
  uint64_t acc_IMPL_len;
  vm_offset_t cpm_IMPL_regs;
  uint64_t cpm_IMPL_pa;
  uint64_t cpm_IMPL_len;
};

/* 1181 */
typedef ml_topology_cpu_0 ml_topology_cpu_t;

/* 8211 */
struct ml_topology_cpu_0
{
  unsigned int cpu_id;
  uint32_t phys_id;
  unsigned int cluster_id;
  unsigned int die_id;
  cluster_type_t_0 cluster_type;
  uint32_t l2_access_penalty;
  uint32_t l2_cache_size;
  uint32_t l2_cache_id;
  uint32_t l3_cache_size;
  uint32_t l3_cache_id;
  vm_offset_t cpu_IMPL_regs;
  uint64_t cpu_IMPL_pa;
  uint64_t cpu_IMPL_len;
  vm_offset_t cpu_UTTDBG_regs;
  uint64_t cpu_UTTDBG_pa;
  uint64_t cpu_UTTDBG_len;
  vm_offset_t coresight_regs;
  uint64_t coresight_pa;
  uint64_t coresight_len;
  unsigned int die_cluster_id;
  unsigned int cluster_core_id;
};

/* 1182 */
struct ml_topology_info
{
  unsigned int version;
  unsigned int num_cpus;
  unsigned int max_cpu_id;
  unsigned int num_clusters;
  unsigned int max_cluster_id;
  unsigned int max_die_id;
  ml_topology_cpu_t *cpus;
  ml_topology_cluster_t *clusters;
  ml_topology_cpu_t *boot_cpu;
  ml_topology_cluster_t *boot_cluster;
  unsigned int chip_revision;
  unsigned int cluster_types;
  unsigned int cluster_type_num_cpus[3];
  unsigned int cluster_type_num_clusters[3];
};

/* 1183 */
typedef __int64_t user64_time_t;

/* 1193 */
typedef unsigned int libkern::sa_detail::remove_const<unsigned int>::type;

/* 7308 */
typedef libkern::sa_detail::remove_const<unsigned int>::type libkern::sa_detail::remove_const_t<unsigned int>;

/* 1184 */
typedef libkern::sa_detail::remove_const_t<unsigned int> RawT;

/* 1185 */
struct PMSettingCallEntry
{
  queue_chain_t_0 link;
  thread_t_0 thread;
};

/* 1186 */
struct IOHistogramReportValues
{
  uint64_t bucket_hits;
  int64_t bucket_min;
  int64_t bucket_max;
  int64_t bucket_sum;
};

/* 2529 */
struct IOReportChannelType
{
  uint8_t report_format;
  uint8_t reserved;
  uint16_t categories;
  uint16_t nelements;
  int16_t element_idx;
};

/* 2526 */
struct IOReportElementValues
{
  uint64_t v[4];
};

/* 2527 */
struct IOReportElement
{
  uint64_t provider_id;
  uint64_t channel_id;
  IOReportChannelType channel_type;
  uint64_t timestamp;
  IOReportElementValues values;
};

/* 1187 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOHistReportInfo
{
  int bucketWidth;
  IOReportElement elem[];
};

/* 2550 */
typedef IOService_0 *libkern::intrusive_shared_ptr<IOService,intrusive_osobject_retainer>::pointer;

/* 7566 */
struct libkern::intrusive_shared_ptr<IOService,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOService,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7312 */
struct __cppobj OSSharedPtr<IOService> : libkern::intrusive_shared_ptr<IOService,intrusive_osobject_retainer>
{
};

/* 2370 */
struct AggressivesRecord
{
  uint32_t flags;
  uint32_t type;
  uint32_t value;
};

/* 1188 */
struct AggressivesRequest
{
  queue_chain_t_0 chain;
  uint32_t options;
  uint32_t dataType;
  union __attribute__((aligned(8)))
  {
    OSSharedPtr<IOService> service;
    AggressivesRecord record;
  } data;
};

/* 9467 */
struct __cppobj IORegistryEntry_1 : OSObject_1
{
  IORegistryEntry::ExpansionData *reserved;
  OSDictionary_0 *fRegistryTable;
  OSDictionary_0 *fPropertyTable;
};

/* 2592 */
struct __cppobj IOService_0 : IORegistryEntry_1
{
  IOService::ExpansionData_0 *reserved;
  IOService_0 *__provider;
  SInt32 __providerGeneration;
  IOService_0 *__owner;
  IOOptionBits __state[2];
  uint64_t __timeBusy;
  uint64_t __accumBusy;
  IOServicePM *pwrMgt;
  bool initialized;
  void *pm_vars;
  int _numInterruptSources;
  IOInterruptSource_0 *_interruptSources;
};

/* 2579 */
struct __cppobj OSDictionary_0 : OSCollection_0
{
  unsigned int count;
  unsigned int capacity;
  unsigned int capacityIncrement;
};

/* 7773 */
struct IOService::ExpansionData_0
{
  uint64_t authorizationID;
  IOLock_0 interruptStatisticsLock;
  IOInterruptAccountingReporter_0 *interruptStatisticsArray;
  int interruptStatisticsArrayCount;
  OSObjectUserVars *uvars;
  IOServiceStateChangeVars *svars;
  IOInterruptSourcePrivate *interruptSourcesPrivate;
};

/* 2451 */
struct IOInterruptSource_0
{
  IOInterruptController_0 *interruptController;
  OSData_0 *vectorData;
};

/* 2536 */
struct IOInterruptAccountingReporter_0
{
  IOSimpleReporter *reporter;
  IOInterruptAccountingData *statistics;
};

/* 2468 */
struct IOServiceStateChangeVars
{
  IOLock_0 *fLock;
  OSDictionary_0 *fItems;
};

/* 7187 */
struct IOInterruptSourcePrivate
{
  void *vectorBlock;
};

/* 2446 */
typedef lck_spin_t IOSimpleLock_0;

/* 2450 */
struct __cppobj IOInterruptController_0 : IOService_0
{
  IOInterruptVector_0 *vectors;
  IOSimpleLock_0 *controllerLock;
  IOInterruptController::ExpansionData_0 *ioic_reserved;
};

/* 2574 */
struct __cppobj OSData_0 : OSObject_0
{
  unsigned int length;
  unsigned int capacity;
  unsigned int capacityIncrement;
  OSData::ExpansionData_0 *reserved;
};

/* 2532 */
typedef OSArray_0 *OSPtr<OSArray>;

/* 2528 */
typedef uint64_t IOReportUnit;

/* 2531 */
typedef boolean_t IOInterruptState;

/* 2534 */
struct __cppobj IOReporter : OSObject_1
{
  IOReportChannelType _channelType;
  uint64_t _driver_id;
  IOReportElement *_elements;
  int *_enableCounts;
  uint16_t _channelDimension;
  int _nElements;
  int _nChannels;
  OSPtr<OSArray> _channelNames;
  bool _reporterIsLocked;
  bool _reporterConfigIsLocked;
  IOReportElement *_swapElements;
  int *_swapEnableCounts;
  IOReportUnit _unit;
  int _enabled;
  IOLock_0 *_configLock;
  IOInterruptState _interruptState;
  IOSimpleLock_0 *_reporterLock;
};

/* 2535 */
struct __cppobj IOSimpleReporter : IOReporter
{
};

/* 6837 */
typedef void (*IOInterruptHandler_0)(void *, void *, void *, int);

/* 2448 */
struct IOInterruptVector_0
{
  volatile char interruptActive;
  volatile char interruptDisabledSoft;
  volatile char interruptDisabledHard;
  volatile char interruptRegistered;
  IOLock_0 *interruptLock;
  IOService_0 *nub;
  int source;
  void *target;
  IOInterruptHandler_0 handler;
  void *refCon;
  IOSharedInterruptController_0 *sharedController;
};

/* 7764 */
struct IOInterruptController::ExpansionData_0
{
  _BYTE gap0;
};

/* 2573 */
typedef void (*OSData::DeallocFunction_0)(void *, unsigned int);

/* 9142 */
struct __attribute__((aligned(8))) OSData::ExpansionData_0
{
  OSData::DeallocFunction_0 deallocFunction;
  bool disableSerialization;
};

/* 2447 */
struct __cppobj IOSharedInterruptController_0 : IOInterruptController_0
{
  IOService_0 *provider;
  int numVectors;
  int vectorsRegistered;
  int vectorsEnabled;
  volatile int controllerDisabled;
  bool sourceIsLevel;
  IOSharedInterruptController::ExpansionData_0 *iosic_reserved;
};

/* 7765 */
struct IOSharedInterruptController::ExpansionData_0
{
  _BYTE gap0;
};

/* 1189 */
struct PMStatsBounds
{
  uint64_t start;
  uint64_t stop;
};

/* 1190 */
enum shutdownPhase_t : __int32
{
  kNotifyDone = 0x0,
  kNotifyPriorityClients = 0x10,
  kNotifyPowerPlaneDrivers = 0x20,
  kNotifyHaltRestartAction = 0x30,
  kQuiescePM = 0x40,
};

/* 1191 */
typedef IORegistryIterator_0 *libkern::intrusive_shared_ptr<IORegistryIterator,intrusive_osobject_retainer>::pointer;

/* 9868 */
struct __cppobj __attribute__((aligned(8))) OSIterator_1 : OSObject_1
{
};

/* 1453 */
struct IORegistryIterator::IORegCursor_0
{
  IORegistryIterator::IORegCursor_0 *next;
  IORegistryEntry_0 *current;
  OSIterator_0 *iter;
};

/* 7305 */
struct __cppobj __attribute__((aligned(8))) IORegistryIterator_0 : OSIterator_1
{
  IORegistryIterator::IORegCursor_0 start;
  IORegistryIterator::IORegCursor_0 *where;
  IORegistryEntry_0 *root;
  OSOrderedSet_0 *done;
  const IORegistryPlane *plane;
  IOOptionBits_0 options;
};

/* 2585 */
struct __cppobj IORegistryEntry_0 : OSObject_0
{
  IORegistryEntry::ExpansionData *reserved;
  OSDictionary_0 *fRegistryTable;
  OSDictionary_0 *fPropertyTable;
};

/* 7233 */
struct __cppobj __attribute__((aligned(8))) OSIterator_0 : OSObject_0
{
};

/* 9397 */
typedef SInt32 (*OSOrderedSet::OSOrderFunction_1)(const OSMetaClassBase_0 *, const OSMetaClassBase_0 *, void *);

/* 2332 */
struct __cppobj OSOrderedSet_0 : OSCollection_0
{
  _Element *array;
  OSOrderedSet::OSOrderFunction_1 ordering;
  void *orderingRef;
  unsigned int count;
  unsigned int capacity;
  unsigned int capacityIncrement;
  OSOrderedSet::ExpansionData_0 *reserved;
};

/* 7748 */
struct OSOrderedSet::ExpansionData_0
{
  _BYTE gap0;
};

/* 1192 */
typedef IOTimerEventSource_0 *libkern::intrusive_shared_ptr<IOTimerEventSource,intrusive_osobject_retainer>::pointer;

/* 2418 */
typedef void (*IOEventSource::Action_0)(OSObject_0 *, ...);

/* 2417 */
typedef struct *IOEventSource::ActionBlock;

/* 2419 */
struct __cppobj IOEventSource_0 : OSObject_1
{
  IOEventSource_0 *eventChainNext;
  OSObject_0 *owner;
  union
  {
    IOEventSource::Action_0 action;
    IOEventSource::ActionBlock actionBlock;
  };
  bool enabled;
  uint8_t eventSourceReserved1[1];
  uint16_t flags;
  uint8_t eventSourceReserved2[4];
  IOWorkLoop_0 *workLoop;
  void *refcon;
  IOEventSource::ExpansionData_0 *reserved;
};

/* 2583 */
typedef UInt64 AbsoluteTime_0;

/* 2374 */
struct __cppobj IOTimerEventSource_0 : IOEventSource_0
{
  void *calloutEntry;
  AbsoluteTime_0 abstime;
  IOTimerEventSource::ExpansionData_0 *reserved;
};

/* 2259 */
typedef _IORecursiveLock_0 IORecursiveLock_0;

/* 2422 */
typedef thread_t_0 IOThread_0;

/* 2423 */
struct __cppobj IOWorkLoop_0 : OSObject_1
{
  IORecursiveLock_0 *gateLock;
  IOEventSource_0 *eventChain;
  IOCommandGate_0 *controlG;
  IOSimpleLock_0 *workToDoLock;
  IOThread_0 workThread;
  volatile bool workToDo;
  bool loopRestart;
  IOWorkLoop::ExpansionData_0 *reserved;
};

/* 7762 */
struct IOEventSource::ExpansionData_0
{
  IOEventSourceCounter *counter;
};

/* 7758 */
struct IOTimerEventSource::ExpansionData_0
{
  SInt32 calloutGeneration;
  SInt32 calloutGenerationSignaled;
  IOWorkLoop_0 *workLoop;
};

/* 9200 */
struct __attribute__((aligned(8))) _IORecursiveLock_0
{
  lck_mtx_t mutex;
  lck_grp_t *group;
  thread_t_0 thread;
  UInt32 count;
};

/* 2402 */
struct __cppobj IOCommandGate_0 : IOEventSource_0
{
  IOCommandGate::ExpansionData_0 *reserved;
};

/* 7760 */
struct IOWorkLoop::ExpansionData_0
{
  IOOptionBits_0 options;
  IOEventSource_0 *passiveEventChain;
  IOWorkLoopCounter *counter;
  uint64_t lockInterval;
  uint64_t lockTime;
};

/* 1296 */
typedef uint32_t IOStatisticsCounterType;

/* 2406 */
struct IOInterruptEventSourceCounter
{
  uint32_t produced;
  uint32_t checksForWork;
};

/* 2405 */
struct IOTimerEventSourceCounter
{
  uint32_t timeouts;
  uint32_t checksForWork;
};

/* 2404 */
struct IOCommandGateCounter
{
  uint32_t actionCalls;
};

/* 2403 */
struct IOCommandQueueCounter
{
  uint32_t actionCalls;
};

/* 2416 */
struct IOEventSourceCounter
{
  struct
  {
    IOEventSourceCounter *sle_next;
  } link;
  ClassNode *parentClass;
  IOStatisticsCounterType type;
  uint64_t startTimeStamp;
  uint64_t timeOnGate;
  uint32_t closeGateCalls;
  uint32_t openGateCalls;
  union
  {
    IOInterruptEventSourceCounter interrupt;
    IOInterruptEventSourceCounter filter;
    IOTimerEventSourceCounter timer;
    IOCommandGateCounter commandGate;
    IOCommandQueueCounter commandQueue;
  } u;
};

/* 7761 */
struct IOCommandGate::ExpansionData_0
{
  _BYTE gap0;
};

/* 2410 */
struct IOWorkLoopCounter::DependencyTree
{
  IOWorkLoopDependency *rbh_root;
};

/* 2411 */
typedef IOWorkLoopCounter::DependencyTree IOWorkLoopCounter::DependencyTreeHead;

/* 2412 */
struct IOWorkLoopCounter
{
  struct
  {
    IOWorkLoopCounter *sle_next;
  } link;
  KextNode *parentKext;
  int attachedEventSources;
  IOWorkLoop_0 *workLoop;
  uint64_t startTimeStamp;
  uint64_t timeOnGate;
  uint32_t closeGateCalls;
  uint32_t openGateCalls;
  IOWorkLoopCounter::DependencyTreeHead dependencyHead;
};

/* 2415 */
struct ClassNode
{
  struct
  {
    ClassNode *rbe_left;
    ClassNode *rbe_right;
    ClassNode *rbe_parent;
  } tLink;
  struct
  {
    ClassNode *sle_next;
  } lLink;
  KextNode *parentKext;
  uint32_t classID;
  uint32_t superClassID;
  const OSMetaClass_0 *metaClass;
  struct
  {
    IOEventSourceCounter *slh_first;
  } counterList;
  struct
  {
    IOUserClientCounter *slh_first;
  } userClientList;
};

/* 2435 */
typedef uint32_t OSKextLoadTag_0;

/* 2413 */
struct ProcessEntryList
{
  IOUserClientProcessEntry *tqh_first;
  IOUserClientProcessEntry **tqh_last;
};

/* 2414 */
struct KextNode
{
  struct
  {
    KextNode *rbe_left;
    KextNode *rbe_right;
    KextNode *rbe_parent;
  } link;
  struct
  {
    KextNode *rbe_left;
    KextNode *rbe_right;
    KextNode *rbe_parent;
  } addressLink;
  OSKext_0 *kext;
  OSKextLoadTag_0 loadTag;
  vm_offset_t address;
  vm_offset_t address_end;
  uint32_t memoryCounters[8];
  uint32_t classes;
  struct
  {
    ClassNode *slh_first;
  } classList;
  struct
  {
    IOWorkLoopCounter *slh_first;
  } workLoopList;
  ProcessEntryList userClientCallList;
};

/* 2409 */
struct __attribute__((aligned(8))) IOWorkLoopDependency
{
  struct
  {
    IOWorkLoopDependency *rbe_left;
    IOWorkLoopDependency *rbe_right;
    IOWorkLoopDependency *rbe_parent;
  } link;
  OSKextLoadTag_0 loadTag;
};

/* 2620 */
struct __cppobj OSMetaClass_0 : OSMetaClassBase_1
{
  ExpansionData *reserved;
  const OSMetaClass_0 *superClassLink;
  const OSSymbol_0 *className;
  unsigned int classSize;
  unsigned int instanceCount;
};

/* 2407 */
struct __attribute__((aligned(8))) IOUserClientCounter
{
  struct
  {
    IOUserClientCounter *sle_next;
  } link;
  ClassNode *parentClass;
  uint32_t clientCalls;
};

/* 7473 */
typedef OSDictionary_0 *OSPtr<OSDictionary>;

/* 9195 */
typedef const OSSymbol_0 *OSPtr<const OSSymbol>_1;

/* 2397 */
typedef OSString_0 *OSPtr<OSString>;

/* 2432 */
typedef int64_t OSKextVersion_0;

/* 2396 */
typedef OSData_0 *OSPtr<OSData>;

/* 2393 */
typedef OSSet_0 *OSPtr<OSSet>;

/* 2440 */
struct list_head_0
{
  list_head_0 *prev;
  list_head_0 *next;
};

/* 2439 */
typedef OSDextStatistics *OSPtr<OSDextStatistics>;

/* 2441 */
struct __cppobj __attribute__((aligned(8))) OSKext_0 : OSObject_1
{
  OSPtr<OSDictionary> infoDict;
  OSPtr<const OSSymbol>_1 bundleID;
  OSPtr<OSString> path;
  OSPtr<OSString> executableRelPath;
  OSPtr<OSString> userExecutableRelPath;
  OSKextVersion_0 version;
  OSKextVersion_0 compatibleVersion;
  OSKextLoadTag_0 loadTag;
  kmod_info_t_0 *kmod_info;
  OSPtr<OSArray> dependencies;
  OSPtr<OSData> linkedExecutable;
  OSPtr<OSSet> metaClasses;
  OSPtr<OSData> interfaceUUID;
  OSPtr<OSData> driverKitUUID;
  struct
  {
    _BYTE gap0[4];
  } flags;
  uint32_t matchingRefCount;
  kc_kind_t_0 kc_type;
  list_head_0 pendingPgoHead;
  uuid_t_0 instance_uuid;
  OSKextAccount *account;
  uint32_t builtinKmodIdx;
  OSPtr<OSArray> savedMutableSegments;
  OSPtr<OSDextStatistics> dextStatistics;
  OSPtr<OSData> dextUniqueID;
  uint32_t dextLaunchedCount;
};

/* 2408 */
struct __attribute__((aligned(8))) IOUserClientProcessEntry
{
  struct
  {
    IOUserClientProcessEntry *tqe_next;
    IOUserClientProcessEntry **tqe_prev;
  } link;
  char processName[20];
  int32_t pid;
  uint32_t calls;
};

/* 2575 */
struct __cppobj __attribute__((aligned(8))) OSString_0 : OSObject_0
{
  _BYTE gapC[8];
  _BYTE gap14[4];
};

/* 2576 */
struct __cppobj OSSymbol_0 : OSString_0
{
  smrq_slink hashlink;
};

/* 2431 */
struct __cppobj OSDextStatistics : OSObject_1
{
  OSPtr<OSArray> crashes;
  IOLock_0 *lock;
};

/* 1194 */
typedef OSValueObject<PMAssertStruct> *libkern::intrusive_shared_ptr<OSValueObject<PMAssertStruct>,intrusive_osobject_retainer>::pointer;

/* 1196 */
struct __cppobj __attribute__((aligned(8))) OSValueObject<PMAssertStruct> : OSObject_1
{
  _BYTE gapC[8];
  _BYTE gap14[4];
};

/* 1195 */
struct libkern::intrusive_shared_ptr<OSValueObject<PMAssertStruct>,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSValueObject<PMAssertStruct>,intrusive_osobject_retainer>::pointer ptr_;
};

/* 1197 */
typedef uint8_t IOUATHardwareInitState;

/* 1199 */
typedef bool atomic_bool;

/* 1214 */
typedef workload_config workload_config_t;

/* 7334 */
struct __attribute__((aligned(4))) workload_config
{
  uint32_t wc_thread_group_flags;
  uint32_t wc_flags;
  uint32_t wc_create_flags;
  uint8_t wc_class_offset;
};

/* 1215 */
typedef workload_config_ctx workload_config_ctx_t;

/* 6531 */
enum workload_config_flags_t : __int32
{
  WLC_F_NONE = 0x0,
  WLC_F_THREAD_POLICY = 0x1,
};

/* 9162 */
struct workload_config_ctx
{
  workload_config_flags_t wlcc_flags;
  int32_t wlcc_count;
  u_long wlcc_hash_mask;
  lck_mtx_t_0 wlcc_mtx;
  workload_config_hashhead *wlcc_hashtbl;
};

/* 6530 */
struct workload_config_hashhead
{
  workload_config_entry *lh_first;
};

/* 6528 */
typedef workload_phase_entry workload_phase_entry_t;

/* 6529 */
struct workload_config_entry
{
  struct
  {
    workload_config_entry *le_next;
    workload_config_entry **le_prev;
  } wce_link;
  char wce_id[64];
  const workload_phase_entry_t *wce_default;
  struct
  {
    workload_phase_entry *lh_first;
  } wce_phases;
};

/* 8999 */
struct workload_phase_entry
{
  struct
  {
    workload_phase_entry *le_next;
    workload_phase_entry **le_prev;
  } wpe_link;
  char wpe_phase[32];
  workload_config_t wpe_config;
};

/* 1216 */
struct WorkloadClassData
{
  const char *name;
  UInt32 workIntervalFlags;
  UInt32 threadGroupFlags;
};

/* 1217 */
struct __attribute__((aligned(8))) FlagMap
{
  const char *str;
  UInt32 flags;
};

/* 7341 */
struct IOPerfControlClient::PerfControllerInterface::DriverState
{
  _BYTE gap0[8];
  uint64_t target_thread_group_id;
  void *target_thread_group_data;
  uint32_t device_type;
  uint32_t instance_id;
};

/* 1218 */
struct IOPerfControlClient::IOPerfControlClientData
{
  thread_group *target_thread_group;
  IOPerfControlClient::PerfControllerInterface::DriverState driverState;
  IOService_0 *device;
};

/* 7335 */
typedef kern_return_t IOReturn_0;

/* 1219 */
typedef IOReturn_0 (*IOPerfControlClient::PerfControllerInterface::RegisterDriverDeviceFunction)(IOService_0 *, IOService_0 *, IOPerfControlClient::PerfControllerInterface::DriverState *);

/* 1220 */
typedef void (*IOPerfControlClient::PerfControllerInterface::WorkUpdateFunction)(IOService_0 *, uint64_t, IOPerfControlClient::PerfControllerInterface::WorkState *, IOPerfControlClient::WorkUpdateArgs *);

/* 7346 */
struct IOPerfControlClient::PerfControllerInterface::WorkState
{
  uint64_t thread_group_id;
  void *thread_group_data;
  void *work_data;
  uint32_t work_data_size;
  const IOPerfControlClient::PerfControllerInterface::DriverState *driver_state;
};

/* 7342 */
struct IOPerfControlClient::WorkUpdateArgs
{
  uint32_t version;
  uint32_t size;
  uint64_t update_time;
  uint64_t reserved[4];
  void *driver_data;
};

/* 1221 */
typedef void (*IOPerfControlClient::PerfControllerInterface::WorkEndFunction)(IOService_0 *, uint64_t, IOPerfControlClient::PerfControllerInterface::WorkState *, IOPerfControlClient::WorkEndArgs *, bool);

/* 7343 */
struct IOPerfControlClient::WorkEndArgs
{
  uint32_t version;
  uint32_t size;
  uint64_t end_time;
  uint64_t reserved[4];
  void *driver_data;
};

/* 1222 */
typedef void (*IOPerfControlClient::PerfControllerInterface::WorkBeginFunction)(IOService_0 *, uint64_t, IOPerfControlClient::PerfControllerInterface::WorkState *, IOPerfControlClient::WorkBeginArgs *);

/* 7344 */
struct IOPerfControlClient::WorkBeginArgs
{
  uint32_t version;
  uint32_t size;
  uint64_t begin_time;
  uint64_t reserved[4];
  void *driver_data;
};

/* 1223 */
typedef void (*IOPerfControlClient::PerfControllerInterface::WorkSubmitFunction)(IOService_0 *, uint64_t, IOPerfControlClient::PerfControllerInterface::WorkState *, IOPerfControlClient::WorkSubmitArgs *);

/* 7345 */
struct IOPerfControlClient::WorkSubmitArgs
{
  uint32_t version;
  uint32_t size;
  uint64_t submit_time;
  uint64_t reserved[4];
  void *driver_data;
};

/* 1224 */
typedef bool (*IOPerfControlClient::PerfControllerInterface::WorkCanSubmitFunction)(IOService_0 *, IOPerfControlClient::PerfControllerInterface::WorkState *, IOPerfControlClient::WorkSubmitArgs *);

/* 1225 */
typedef IOReturn_0 (*IOPerfControlClient::PerfControllerInterface::RegisterDeviceFunction)(IOService_0 *);

/* 1226 */
struct IOPerfControlClient::PerfControllerInterface
{
  uint64_t version;
  IOPerfControlClient::PerfControllerInterface::RegisterDeviceFunction registerDevice;
  IOPerfControlClient::PerfControllerInterface::RegisterDeviceFunction unregisterDevice;
  IOPerfControlClient::PerfControllerInterface::WorkCanSubmitFunction workCanSubmit;
  IOPerfControlClient::PerfControllerInterface::WorkSubmitFunction workSubmit;
  IOPerfControlClient::PerfControllerInterface::WorkBeginFunction workBegin;
  IOPerfControlClient::PerfControllerInterface::WorkEndFunction workEnd;
  IOPerfControlClient::PerfControllerInterface::WorkUpdateFunction workUpdate;
  IOPerfControlClient::PerfControllerInterface::RegisterDriverDeviceFunction registerDriverDevice;
  IOPerfControlClient::PerfControllerInterface::RegisterDriverDeviceFunction unregisterDriverDevice;
};

/* 7347 */
typedef uint8_t uint_fast8_t;

/* 1227 */
typedef uint_fast8_t atomic_uint_fast8_t;

/* 1228 */
struct IOPowerStateChangeNotification
{
  void *powerRef;
  unsigned __int64 returnValue;
  unsigned __int64 stateNumber;
  IOPMPowerFlags stateFlags;
};

/* 1229 */
typedef IOPowerStateChangeNotification sleepWakeNote;

/* 1230 */
typedef kern_return_t (*IOCoreFileAccessCallback)(void *, boolean_t, uint64_t, int, void *);

/* 1231 */
typedef kern_return_t (*IOCoreFileAccessRecipient)(IOCoreFileAccessCallback, void *, void *);

/* 1232 */
struct __block_literal_30
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor *__descriptor;
};

/* 1233 */
struct __block_literal_31
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct *kr;
  IOService_0 *this;
  IOServiceStateChangeVars *ivars;
  IOStateNotificationListener *listener;
};

/* 2247 */
struct __block_descriptor_withcopydispose
{
  unsigned __int64 reserved;
  unsigned __int64 Size;
  void **CopyFuncPtr;
  void **DestroyFuncPtr;
};

/* 1264 */
typedef struct *IOStateNotificationHandler;

/* 7374 */
struct __cppobj IOStateNotificationListener : OSObject_1
{
  IOStateNotificationHandler fHandler;
};

/* 1234 */
struct __block_literal_26
{
  void *__isa;
  int __flags;
  int __reserved;
  kern_return_t (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  IOServiceStateNotificationDispatchSource *source;
};

/* 1685 */
struct IODispatchSource_LocalIVars;

/* 7622 */
struct __cppobj IODispatchSource : OSObject_1
{
  union
  {
    IODispatchSource_IVars *ivars;
    IODispatchSource_LocalIVars *lvars;
  };
};

/* 1555 */
struct IOServiceStateNotificationDispatchSource_LocalIVars;

/* 7621 */
struct __cppobj IOServiceStateNotificationDispatchSource : IODispatchSource
{
  union
  {
    IOServiceStateNotificationDispatchSource_IVars *ivars;
    IOServiceStateNotificationDispatchSource_LocalIVars *lvars;
  };
};

/* 1686 */
struct __attribute__((aligned(8))) IODispatchSource_IVars
{
  queue_chain_t_0 link;
  IODispatchSource *source;
  IOUserServer *server;
  IODispatchQueue_IVars *queue;
  bool enabled;
};

/* 1556 */
typedef void *IOStateNotificationListenerRef;

/* 1557 */
struct __attribute__((aligned(8))) IOServiceStateNotificationDispatchSource_IVars
{
  IOLock_0 *fLock;
  IOService_0 *fStateNotification;
  IOStateNotificationListenerRef fListener;
  OSAction_0 *fAction;
  bool fEnable;
  bool fArmed;
};

/* 1425 */
typedef lck_rw_t IORWLock_0;

/* 2593 */
struct __cppobj IOUserClient_0 : IOService_0
{
  IOUserClient::ExpansionData_0 *reserved;
  OSSet_0 *mappings;
  UInt8 sharedInstance;
  UInt8 closed;
  UInt8 __ipcFinal;
  volatile SInt32 __ipc;
  queue_head_t_0 owners;
  IORWLock_0 lock;
  IOLock_0 filterLock;
  void *__reserved[1];
  UInt8 __opaque_end[];
};

/* 2597 */
struct __cppobj IOUserClient2022 : IOUserClient_0
{
};

/* 2598 */
struct __cppobj IOUserServer : IOUserClient2022
{
  IOLock_0 *fLock;
  IOSimpleLock_0 *fInterruptLock;
  OSDictionary_0 *fEntitlements;
  OSDictionary_0 *fClasses;
  IODispatchQueue *fRootQueue;
  OSArray_0 *fServices;
  uint8_t fRootNotifier;
  uint8_t fSystemPowerAck;
  uint8_t fSystemOff;
  uint8_t fPowerManagementFailed;
  IOUserServerCheckInToken *fCheckInToken;
  OSDextStatistics *fStatistics;
  bool fPlatformDriver;
  OSString_0 *fTeamIdentifier;
  unsigned int fCSValidationCategory;
  kern_allocation_name_t fAllocationName;
  task_t_0 fOwningTask;
  os_reason_t fTaskCrashReason;
};

/* 2599 */
struct IODispatchQueue_IVars
{
  IOUserServer *userServer;
  IODispatchQueue *queue;
  queue_chain_t_0 link;
  uint64_t tid;
  mach_port_t_0 serverPort;
};

/* 2315 */
struct __cppobj OSAction_0 : OSObject_1
{
  union
  {
    OSAction_IVars *ivars;
    OSAction_LocalIVars *lvars;
  };
};

/* 7747 */
struct IOUserClient::ExpansionData_0
{
  IOUserClientCounter *counter;
  IOUCFilterPolicy *filterPolicies;
};

/* 2283 */
struct IODispatchQueue_LocalIVars;

/* 2609 */
struct __cppobj IODispatchQueue : OSObject_1
{
  union
  {
    IODispatchQueue_IVars *ivars;
    IODispatchQueue_LocalIVars *lvars;
  };
};

/* 2444 */
enum IOUserServerCheckInToken::State : __int32
{
  IOUserServerCheckInToken::State::kIOUserServerCheckInPending = 0x0,
  IOUserServerCheckInToken::State::kIOUserServerCheckInCanceled = 0x1,
  IOUserServerCheckInToken::State::kIOUserServerCheckInComplete = 0x2,
};

/* 2445 */
struct __cppobj IOUserServerCheckInToken : OSObject_1
{
  IOUserServerCheckInToken::State fState;
  size_t fPendingCount;
  const OSSymbol_0 *fServerName;
  const OSSymbol_0 *fExecutableName;
  OSNumber_0 *fServerTag;
  OSSet_0 *fHandlers;
  OSString_0 *fKextBundleID;
  bool fNeedDextDec;
};

/* 2316 */
typedef uintptr_t io_filter_policy_t;

/* 2317 */
struct IOUCFilterPolicy
{
  task_t_0 task;
  io_filter_policy_t filterPolicy;
  IOUCFilterPolicy *next;
};

/* 2443 */
struct __cppobj OSNumber_0 : OSObject_0
{
  unsigned int size;
  union
  {
    unsigned __int64 value;
    double fpValue;
  };
};

/* 1235 */
struct __block_literal_25
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor *__descriptor;
};

/* 1236 */
struct __block_literal_24
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct *result;
  const OSSymbol_0 *serverName;
};

/* 1237 */
struct __block_literal_23
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor *__descriptor;
  IOUserServerCheckInToken *this;
};

/* 1238 */
struct __block_literal_19
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor *__descriptor;
};

/* 1239 */
struct __block_literal_17
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor *__descriptor;
};

/* 1240 */
struct __block_literal_18
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor *__descriptor;
};

/* 1241 */
struct __block_literal_16
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(1))) {void *__isa;void *__forwarding;int __flags;int __size;bool allPowerStates;}; *allPowerStates;
};

/* 1242 */
struct __block_literal_15
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(1))) {void *__isa;void *__forwarding;int __flags;int __size;bool addClass;}; *addClass;
  OSDictionary_0 *retProps;
  OSDictionary_0 *props;
};

/* 1243 */
struct __block_literal_14
{
  void *__isa;
  int __flags;
  int __reserved;
  IOReturn_0 (*__FuncPtr)(void);
  __block_descriptor_withcopydispose *__descriptor;
  struct *object;
  IOService_0 *provider;
  const char *name;
};

/* 1244 */
struct __block_literal_12
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(1))) {void *__isa;void *__forwarding;int __flags;int __size;bool found;}; *found;
  OSObject_0 *bundleID;
};

/* 1245 */
struct __block_literal_9
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(const OSSymbol_0 *, OSObject_0 *);
  __block_descriptor *__descriptor;
};

/* 1246 */
struct __block_literal_29
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(const OSSymbol_0 *, OSObject_0 *);
  __block_descriptor *__descriptor;
  OSDictionary_0 *result;
};

/* 1247 */
struct __block_literal_32
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(const OSSymbol_0 *, OSObject_0 *);
  __block_descriptor *__descriptor;
  IOStateNotificationListener *listener;
};

/* 1248 */
struct __block_literal_22
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  OSAction_0 *action;
};

/* 1249 */
struct __block_literal_21
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor *__descriptor;
  IOService_0 *client;
};

/* 1250 */
struct __block_literal_20
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(1))) {void *__isa;void *__forwarding;int __flags;int __size;bool allPowerStates;}; *allPowerStates;
};

/* 1251 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_10
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor *__descriptor;
  IOUserServer *this;
  IOOptionBits_0 terminateFlags;
};

/* 1252 */
struct __block_literal_13
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(1))) {void *__isa;void *__forwarding;int __flags;int __size;bool allPowerStates;}; *allPowerStates;
};

/* 1253 */
struct __block_literal_11
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(1))) {void *__isa;void *__forwarding;int __flags;int __size;bool unexpectedExit;}; *unexpectedExit;
  IOUserServer *this;
};

/* 1254 */
typedef void (*IOUserServerCheckInCancellationHandler)(IOUserServerCheckInToken *, void *);

/* 1255 */
typedef uint64_t IOTrapMessageBuffer[256];

/* 1256 */
typedef ipc_kmsg *ipc_kmsg_t;

/* 7089 */
typedef uint8_t mach_msg_qos_t;

/* 2284 */
struct ipc_kmsg
{
  queue_chain_t_0 ikm_link;
  _BYTE gap10[16];
  ipc_importance_elem *ikm_importance;
  queue_chain_t_0 ikm_inheritance;
  mach_msg_size_t ikm_aux_size;
  uint32_t ikm_ppriority;
  union
  {
    struct
    {
      uint32_t ikm_sig_partial;
      uint32_t ikm_sig_full;
    };
    uint64_t ikm_signature;
  };
  _BYTE gap48[2];
  mach_msg_qos_t ikm_qos_override;
  mach_msg_size_t ikm_udata_size;
};

/* 7009 */
typedef uint32_t mach_voucher_attr_value_reference_t;

/* 6610 */
struct ipc_importance_elem
{
  uint32_t iie_bits;
  mach_voucher_attr_value_reference_t iie_made;
  queue_head_t_0 iie_kmsgs;
  uint32_t iie_externcnt;
  uint32_t iie_externdrop;
};

/* 1257 */
struct IOUserServerRecordExitReasonContext
{
  task_t_0 task;
  os_reason_t reason;
};

/* 2306 */
typedef uint64_t io_user_reference_t_0;

/* 1321 */
typedef io_user_reference_t_0 OSAsyncReference64[8];

/* 1258 */
struct IOUserUserClientActionRef
{
  OSAsyncReference64 asyncRef;
};

/* 1259 */
struct mach_msg_ool_descriptor_t
{
  void *address;
  _BYTE gap8[4];
  mach_msg_size_t size;
};

/* 2285 */
typedef uint64_t OSObjectRef;

/* 2286 */
struct IORPCMessage
{
  uint64_t msgid;
  uint64_t flags;
  uint64_t objectRefs;
  OSObjectRef objects[];
};

/* 1260 */
struct UEXTTrapReply
{
  uint64_t replySize;
  IORPCMessage replyMessage;
};

/* 1261 */
struct IORPCMessageErrorReturnContent
{
  IORPCMessage hdr;
  kern_return_t result;
  uint32_t pad;
};

/* 1262 */
struct OSObject_Instantiate_Rpl_Content
{
  IORPCMessage __hdr;
  kern_return_t __result;
  uint32_t __pad;
  uint64_t flags;
  char classname[128];
  uint64_t methods[];
};

/* 1263 */
typedef _IODataQueueEntry_0 IODataQueueEntry_0;

/* 7628 */
struct _IODataQueueEntry_0
{
  UInt32 size;
  UInt8 data[4];
};

/* 1265 */
typedef struct *IOServiceStateNotificationEventSource::ActionBlock;

/* 1266 */
typedef libkern::bounded_array<IOExternalTrap,2UL,os_detail::panic_trapping_policy> OSBoundedArray<IOExternalTrap,2>;

/* 2292 */
typedef IOReturn_0 (*IOTrap_0)(IOService_0 *, void *, void *, void *, void *, void *, void *);

/* 2293 */
struct __attribute__((aligned(8))) IOExternalTrap_0
{
  IOService_0 *object;
  IOTrap_0 func;
  _BYTE gap10[8];
};

/* 7378 */
struct libkern::bounded_array<IOExternalTrap,2UL,os_detail::panic_trapping_policy>
{
  IOExternalTrap_0 data_[2];
};

/* 1267 */
typedef unsigned __int8 libkern::sa_detail::remove_const<unsigned char>::type;

/* 1268 */
typedef libkern::bounded_array<IOExternalTrap,1UL,os_detail::panic_trapping_policy> OSBoundedArray<IOExternalTrap,1>;

/* 7379 */
struct libkern::bounded_array<IOExternalTrap,1UL,os_detail::panic_trapping_policy>
{
  IOExternalTrap_0 data_[1];
};

/* 1269 */
typedef IOReportLegend *libkern::intrusive_shared_ptr<IOReportLegend,intrusive_osobject_retainer>::pointer;

/* 7388 */
struct __cppobj IOReportLegend : OSObject_1
{
  OSPtr<OSArray> _reportLegend;
};

/* 1270 */
typedef OSDictionary_1 IOReportLegendEntry;

/* 9466 */
struct __cppobj OSCollection_1 : OSObject_1
{
  unsigned int updateStamp;
  unsigned int fOptions;
};

/* 9867 */
struct __cppobj OSDictionary_1 : OSCollection_1
{
  unsigned int count;
  unsigned int capacity;
  unsigned int capacityIncrement;
};

/* 1271 */
typedef IOHistogramReporter *libkern::intrusive_shared_ptr<IOHistogramReporter,intrusive_osobject_retainer>::pointer;

/* 7392 */
struct __cppobj IOHistogramReporter : IOReporter
{
  int _segmentCount;
  int64_t *_bucketBounds;
  int _bucketCount;
  IOHistogramSegmentConfig *_histogramSegmentsConfig;
};

/* 1273 */
struct IOHistogramSegmentConfig
{
  uint32_t base_bucket_width;
  uint32_t scale_flag;
  uint32_t segment_idx;
  uint32_t segment_bucket_count;
};

/* 1272 */
struct libkern::intrusive_shared_ptr<IOHistogramReporter,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOHistogramReporter,intrusive_osobject_retainer>::pointer ptr_;
};

/* 1274 */
typedef IOStateReporter *libkern::intrusive_shared_ptr<IOStateReporter,intrusive_osobject_retainer>::pointer;

/* 7395 */
struct __cppobj IOStateReporter : IOReporter
{
  int *_currentStates;
  uint64_t *_lastUpdateTimes;
  int *_swapCurrentStates;
  uint64_t *_swapLastUpdateTimes;
};

/* 1275 */
struct libkern::intrusive_shared_ptr<IOStateReporter,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOStateReporter,intrusive_osobject_retainer>::pointer ptr_;
};

/* 1276 */
enum IOStateReporter::valueSelector : __int32
{
  IOStateReporter::valueSelector::kInTransitions = 0x0,
  IOStateReporter::valueSelector::kResidencyTime = 0x1,
  IOStateReporter::valueSelector::kLastTransitionTime = 0x2,
};

/* 1277 */
typedef IOSimpleReporter *libkern::intrusive_shared_ptr<IOSimpleReporter,intrusive_osobject_retainer>::pointer;

/* 1282 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOStatisticsWorkLoop
{
  uint32_t attachedEventSources;
  uint64_t timeOnGate;
  uint32_t kextLoadTag;
  uint32_t dependentKexts;
  uint32_t dependentKextLoadTags[];
};

/* 1278 */
struct IOStatisticsWorkLoopHeader
{
  uint32_t sig;
  uint32_t ver;
  uint32_t seq;
  uint32_t workloopCount;
  IOStatisticsWorkLoop workLoopStats;
};

/* 1279 */
struct IOStatisticsHeader
{
  uint32_t sig;
  uint32_t ver;
  uint32_t seq;
  uint32_t globalStatsOffset;
  uint32_t kextStatsOffset;
  uint32_t memoryStatsOffset;
  uint32_t classStatsOffset;
  uint32_t counterStatsOffset;
  uint32_t kextIdentifiersOffset;
  uint32_t classNamesOffset;
};

/* 1280 */
struct IOStatisticsUserClientCall
{
  char processName[20];
  int32_t pid;
  uint32_t calls;
};

/* 1281 */
struct IOStatisticsUserClientHeader
{
  uint32_t sig;
  uint32_t ver;
  uint32_t seq;
  uint32_t processes;
  IOStatisticsUserClientCall userClientCalls[];
};

/* 1283 */
struct IOStatisticsClassName
{
  char name[64];
};

/* 1284 */
struct IOStatisticsKextIdentifier
{
  char identifier[64];
};

/* 1285 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOStatisticsDerivedEventSources
{
  uint32_t created;
  uint32_t openGateCalls;
  uint32_t closeGateCalls;
  uint64_t timeOnGate;
};

/* 1286 */
struct IOStatisticsCommandQueues
{
  uint32_t created;
  uint32_t actionCalls;
};

/* 1287 */
struct IOStatisticsCommandGates
{
  uint32_t created;
  uint32_t openGateCalls;
  uint32_t closeGateCalls;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t timeOnGate;
  uint32_t actionCalls;
};

/* 1288 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOStatisticsTimerEventSources
{
  uint32_t created;
  uint32_t openGateCalls;
  uint32_t closeGateCalls;
  uint64_t timeOnGate;
  uint32_t timeouts;
  uint32_t checksForWork;
};

/* 1289 */
struct IOStatisticsInterruptEventSources
{
  uint32_t created;
  uint32_t produced;
  uint32_t checksForWork;
};

/* 1290 */
struct IOStatisticsUserClients
{
  uint32_t created;
  uint32_t clientCalls;
};

/* 1291 */
struct IOStatisticsCounter
{
  uint32_t classID;
  uint32_t classInstanceCount;
  IOStatisticsUserClients userClientStatistics;
  IOStatisticsInterruptEventSources interruptEventSourceStatistics;
  IOStatisticsInterruptEventSources filterInterruptEventSourceStatistics;
  IOStatisticsTimerEventSources timerEventSourceStatistics;
  IOStatisticsCommandGates commandGateStatistics;
  IOStatisticsCommandQueues commandQueueStatistics;
  IOStatisticsDerivedEventSources derivedEventSourceStatistics;
};

/* 1292 */
struct IOStatisticsClass
{
  uint32_t classID;
  uint32_t superClassID;
  uint32_t classSize;
};

/* 1293 */
struct IOStatisticsMemory
{
  uint32_t allocatedSize;
  uint32_t freedSize;
  uint32_t allocatedAlignedSize;
  uint32_t freedAlignedSize;
  uint32_t allocatedContiguousSize;
  uint32_t freedContiguousSize;
  uint32_t allocatedPageableSize;
  uint32_t freedPageableSize;
};

/* 1294 */
struct IOStatisticsKext
{
  uint32_t loadTag;
  uint32_t loadSize;
  uint32_t wiredSize;
  uint32_t classes;
  uint32_t classIndexes[];
};

/* 1295 */
struct IOStatisticsGlobal
{
  uint32_t kextCount;
  uint32_t classCount;
  uint32_t workloops;
};

/* 1297 */
typedef _IODataQueueAppendix IODataQueueAppendix;

/* 7232 */
typedef integer_t mach_msg_id_t_0;

/* 9143 */
struct mach_msg_header_t_1
{
  mach_msg_bits_t msgh_bits;
  mach_msg_size_t msgh_size;
  mach_port_t_0 msgh_remote_port;
  mach_port_t_0 msgh_local_port;
  mach_port_name_t_0 msgh_voucher_port;
  mach_msg_id_t_0 msgh_id;
};

/* 9410 */
struct __attribute__((packed)) __attribute__((aligned(4))) _IODataQueueAppendix
{
  UInt32 version;
  mach_msg_header_t_1 msgh;
};

/* 1298 */
typedef IOSharedDataQueue_0 *libkern::intrusive_shared_ptr<IOSharedDataQueue,intrusive_osobject_retainer>::pointer;

/* 1302 */
typedef _IODataQueueMemory_0 IODataQueueMemory_0;

/* 7407 */
struct __cppobj IODataQueue_0 : OSObject_1
{
  IODataQueueMemory_0 *dataQueue;
  void *notifyMsg;
};

/* 7405 */
struct __cppobj IOSharedDataQueue_0 : IODataQueue_0
{
  IOSharedDataQueue::ExpansionData_0 *_reserved;
};

/* 7629 */
struct _IODataQueueMemory_0
{
  UInt32 queueSize;
  volatile UInt32 head;
  volatile UInt32 tail;
  IODataQueueEntry_0 queue[1];
};

/* 7406 */
struct IOSharedDataQueue::ExpansionData_0
{
  UInt32 queueSize;
};

/* 1299 */
struct libkern::intrusive_shared_ptr<IOSharedDataQueue,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOSharedDataQueue,intrusive_osobject_retainer>::pointer ptr_;
};

/* 1300 */
typedef IODataQueue_0 *libkern::intrusive_shared_ptr<IODataQueue,intrusive_osobject_retainer>::pointer;

/* 1301 */
struct libkern::intrusive_shared_ptr<IODataQueue,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IODataQueue,intrusive_osobject_retainer>::pointer ptr_;
};

/* 1303 */
struct __attribute__((aligned(8))) IOKitDiagnosticsParameters
{
  size_t size;
  uint64_t value;
  uint32_t options;
  uint32_t tag;
  uint32_t zsize;
  uint32_t reserved[8];
};

/* 1304 */
struct iokit_user_client_trap_args
{
  void *userClientRef;
  uint32_t index;
  char index_r_[4];
  void *p1;
  void *p2;
  void *p3;
  void *p4;
  void *p5;
  void *p6;
  char p6_r_[];
};

/* 9165 */
typedef OSObject_0 *io_object_t_2;

/* 1305 */
typedef io_object_t_2 io_iterator_t;

/* 1306 */
typedef natural_t OSAsyncReference_0[8];

/* 1307 */
struct __attribute__((aligned(4))) mach_msg_guarded_port_descriptor32_t
{
  uint32_t context;
  mach_port_name_t_0 name;
  _BYTE gap8[4];
};

/* 1308 */
struct __attribute__((aligned(4))) mach_msg_type_descriptor_t_0
{
  natural_t pad1;
  mach_msg_size_t pad2;
  _BYTE gap8[4];
};

/* 1309 */
struct __attribute__((aligned(4))) mach_msg_ool_ports_descriptor32_t
{
  uint32_t address;
  mach_msg_size_t count;
  _BYTE gap8[4];
};

/* 1310 */
struct __attribute__((aligned(4))) mach_msg_ool_descriptor32_t
{
  uint32_t address;
  mach_msg_size_t size;
  _BYTE gap8[4];
};

/* 2610 */
struct mach_msg_port_descriptor_t
{
  mach_port_t_0 name;
  _BYTE gap8[4];
  uint32_t pad_end;
};

/* 1311 */
union mach_msg_descriptor_t
{
  mach_msg_port_descriptor_t port;
  mach_msg_ool_descriptor32_t out_of_line;
  mach_msg_ool_ports_descriptor32_t ool_ports;
  mach_msg_type_descriptor_t_0 type;
  mach_msg_guarded_port_descriptor32_t guarded_port;
};

/* 1312 */
typedef io_object_t_2 io_connect_t;

/* 1313 */
struct NDR_record_t_0
{
  unsigned __int8 mig_vers;
  unsigned __int8 if_vers;
  unsigned __int8 reserved1;
  unsigned __int8 mig_encoding;
  unsigned __int8 int_rep;
  unsigned __int8 char_rep;
  unsigned __int8 float_rep;
  unsigned __int8 reserved2;
};

/* 1314 */
typedef io_object_t_2 io_service_t;

/* 1315 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOAsyncCompletionContent
{
  IOReturn_0 result;
  void *args[];
};

/* 1316 */
struct OSNotificationHeader
{
  mach_msg_size_t size;
  natural_t type;
  OSAsyncReference_0 reference;
  unsigned __int8 content[];
};

/* 1317 */
typedef char *io_buf_ptr_t;

/* 1318 */
struct GetPropertiesEditorRef
{
  kauth_cred_t cred;
  IORegistryEntry_0 *entry;
  OSCollection_0 *root;
};

/* 1319 */
struct IOUserClientOwner
{
  task_t_0 task;
  queue_chain_t_0 taskLink;
  IOUserClient_0 *uc;
  queue_chain_t_0 ucLink;
};

/* 1320 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceInterestContent64
{
  natural_t messageType;
  io_user_reference_t_0 messageArgument[1];
};

/* 1322 */
typedef char libkern::detail::copy_cv<unsigned long long,char>::type;

/* 1323 */
struct OSNotificationHeader64
{
  mach_msg_size_t size;
  natural_t type;
  OSAsyncReference64 reference;
  unsigned __int8 content[];
};

/* 1324 */
typedef natural_t mach_port_mscount_t;

/* 1325 */
struct IOMachPortHashList
{
  IOMachPort *slh_first;
};

/* 7431 */
struct __cppobj __attribute__((aligned(4))) IOMachPort : OSObject_1
{
  struct
  {
    IOMachPort *sle_next;
  } link;
  ipc_port_t_0 port;
  OSObject_0 *object;
  UInt32 mscount;
  UInt8 holdDestroy;
  UInt8 type;
};

/* 1326 */
typedef natural_t ipc_kobject_type_t;

/* 1342 */
enum NVRAMPartitionType : __int32
{
  NVRAMPartitionType::kIONVRAMPartitionTypeUnknown = 0x0,
  NVRAMPartitionType::kIONVRAMPartitionSystem = 0x1,
  NVRAMPartitionType::kIONVRAMPartitionCommon = 0x2,
};

/* 1327 */
struct NVRAMRegionInfo
{
  NVRAMPartitionType type;
  uint32_t offset;
  uint32_t size;
};

/* 7445 */
struct chrp_nvram_header
{
  uint8_t sig;
  uint8_t cksum;
  uint16_t len;
  char name[12];
  uint8_t data[];
};

/* 1328 */
struct apple_nvram_header
{
  chrp_nvram_header chrp;
  uint32_t adler;
  uint32_t generation;
  uint8_t padding[8];
};

/* 1329 */
struct v3_store_header
{
  uint32_t name;
  uint32_t size;
  uint32_t generation;
  uint8_t state;
  uint8_t flags;
  uint8_t version;
  uint8_t reserved1;
  uint32_t system_size;
  uint32_t common_size;
};

/* 1330 */
struct v3_var_header
{
  uint16_t startId;
  uint8_t state;
  uint8_t reserved;
  uint32_t attributes;
  uint32_t nameSize;
  uint32_t dataSize;
  uuid_t_0 guid;
  uint32_t crc;
  uint8_t name_data_buf[];
};

/* 1331 */
struct __attribute__((aligned(8))) nvram_v3_var_entry
{
  uint8_t new_state;
  size_t existing_offset;
  v3_var_header header;
};

/* 1332 */
enum IONVRAMVariableType : __int32
{
  IONVRAMVariableType::kOFVariableTypeBoolean = 0x1,
  IONVRAMVariableType::kOFVariableTypeNumber = 0x2,
  IONVRAMVariableType::kOFVariableTypeString = 0x3,
  IONVRAMVariableType::kOFVariableTypeData = 0x4,
};

/* 1333 */
struct __attribute__((aligned(8))) VariableTypeEntry
{
  const char *name;
  IONVRAMVariableType type;
};

/* 1334 */
union VariablePermission
{
  struct
  {
    _BYTE gap0[8];
  } Bits;
  uint64_t Uint64;
};

/* 1335 */
struct VariablePermissionEntry
{
  const char *name;
  VariablePermission p;
};

/* 1336 */
struct VariableEntitlementEntry
{
  const uint8_t checkOp;
  const uuid_t_0 *varGuid;
  const char *varName;
  const char *varEntitlement;
};

/* 1337 */
typedef const OSString_0 *libkern::intrusive_shared_ptr<const OSString,intrusive_osobject_retainer>::pointer;

/* 1338 */
typedef OSBoolean_0 *libkern::intrusive_shared_ptr<OSBoolean,intrusive_osobject_retainer>::pointer;

/* 2426 */
struct __cppobj OSBoolean_0 : OSObject_0
{
  bool value;
};

/* 1339 */
enum NVRAMVersion : __int32
{
  NVRAMVersion::kNVRAMVersionUnknown = 0x0,
  NVRAMVersion::kNVRAMVersion1 = 0x1,
  NVRAMVersion::kNVRAMVersion2 = 0x2,
  NVRAMVersion::kNVRAMVersion3 = 0x3,
  NVRAMVersion::kNVRAMVersionMax = 0x4,
};

/* 1340 */
struct IOTypedOperatorsMixin<IONVRAMCHRPHandler>
{
  _BYTE gap0;
};

/* 1341 */
struct __cppobj __attribute__((aligned(8))) IODTNVRAMFormatHandler
{
  int (**_vptr$IODTNVRAMFormatHandler)(void);
  uint32_t _bankSize;
  uint32_t _bankCount;
  uint32_t _currentBank;
};

/* 1343 */
typedef kern_return_t (*iocpu_platform_action_t)(void *, void *, uint32_t, void *, void *, void *, const char *, uint64_t);

/* 1344 */
typedef iocpu_platform_action_entry iocpu_platform_action_entry_t;

/* 7455 */
struct iocpu_platform_action_entry
{
  queue_chain_t_0 link;
  iocpu_platform_action_t action;
  int32_t priority;
  const char *name;
  void *refcon0;
  void *refcon1;
  boolean_t callout_in_progress;
  iocpu_platform_action_entry *alloc_list;
};

/* 7101 */
enum processor_state_t : __int32
{
  PROCESSOR_OFF_LINE = 0x0,
  PROCESSOR_SHUTDOWN = 0x1,
  PROCESSOR_START = 0x2,
  PROCESSOR_PENDING_OFFLINE = 0x3,
  PROCESSOR_IDLE = 0x4,
  PROCESSOR_DISPATCHING = 0x5,
  PROCESSOR_RUNNING = 0x6,
  PROCESSOR_STATE_LEN = 0x7,
};

/* 7100 */
typedef uint32_t sfi_class_id_t;

/* 7093 */
enum perfcontrol_class : __int32
{
  perfcontrol_class::PERFCONTROL_CLASS_IDLE = 0x1,
  perfcontrol_class::PERFCONTROL_CLASS_KERNEL = 0x2,
  perfcontrol_class::PERFCONTROL_CLASS_REALTIME = 0x3,
  perfcontrol_class::PERFCONTROL_CLASS_BACKGROUND = 0x4,
  perfcontrol_class::PERFCONTROL_CLASS_UTILITY = 0x5,
  perfcontrol_class::PERFCONTROL_CLASS_NONUI = 0x6,
  perfcontrol_class::PERFCONTROL_CLASS_UI = 0x7,
  perfcontrol_class::PERFCONTROL_CLASS_ABOVEUI = 0x8,
  perfcontrol_class::PERFCONTROL_CLASS_MAX = 0x9,
};

/* 7099 */
typedef perfcontrol_class perfcontrol_class_t;

/* 7092 */
enum thread_urgency : __int32
{
  thread_urgency::THREAD_URGENCY_NONE = 0x0,
  thread_urgency::THREAD_URGENCY_BACKGROUND = 0x1,
  thread_urgency::THREAD_URGENCY_NORMAL = 0x2,
  thread_urgency::THREAD_URGENCY_REAL_TIME = 0x3,
  thread_urgency::THREAD_URGENCY_LOWPRI = 0x4,
  thread_urgency::THREAD_URGENCY_MAX = 0x5,
};

/* 7098 */
typedef thread_urgency thread_urgency_t;

/* 5660 */
struct hslock
{
  uintptr_t lock_data;
};

/* 8196 */
struct lck_spin_t_0
{
  hslock hwlock;
  unsigned __int64 type;
};

/* 8197 */
typedef lck_spin_t_0 usimple_lock_data_t_0;

/* 8198 */
typedef usimple_lock_data_t_0 simple_lock_data_t_0;

/* 5458 */
typedef void *timer_call_param_t;

/* 5459 */
typedef void (*timer_call_func_t)(timer_call_param_t, timer_call_param_t);

/* 9345 */
struct __attribute__((aligned(4))) timer_call_0
{
  uint64_t tc_soft_deadline;
  simple_lock_data_t_0 tc_lock;
  priority_queue_entry_deadline tc_pqlink;
  queue_head_t_0 *tc_queue;
  queue_chain_t_0 tc_qlink;
  timer_call_func_t tc_func;
  timer_call_param_t tc_param0;
  timer_call_param_t tc_param1;
  uint64_t tc_ttd;
  uint64_t tc_entry_time;
  uint32_t tc_flags;
  bool tc_async_dequeue;
};

/* 5658 */
struct recount_snap
{
  uint64_t rsn_time_mach;
};

/* 5666 */
struct recount_usage
{
  uint64_t ru_user_time_mach;
  uint64_t ru_system_time_mach;
  uint64_t ru_energy_nj;
};

/* 5667 */
struct recount_track
{
  uint32_t rt_sync;
  uint32_t rt_pad;
  recount_usage rt_usage;
};

/* 5695 */
struct recount_processor
{
  recount_snap rpr_snap;
  recount_track rpr_active;
  uint64_t rpr_idle_time_mach;
  uint64_t rpr_state_last_abs_time;
};

/* 1347 */
typedef processor *processor_t;

/* 7097 */
enum processor_reason_t : __int32
{
  REASON_NONE = 0x0,
  REASON_SYSTEM = 0x1,
  REASON_USER = 0x2,
  REASON_CLPC_SYSTEM = 0x3,
  REASON_CLPC_USER = 0x4,
};

/* 1345 */
struct __attribute__((aligned(8))) processor
{
  processor_state_t state;
  bool is_SMT;
  bool is_recommended;
  bool current_is_NO_SMT;
  bool current_is_bound;
  bool current_is_eagerpreempt;
  thread *active_thread;
  thread *idle_thread;
  thread *startup_thread;
  processor_set_t processor_set;
  int current_pri;
  sfi_class_id_t current_sfi_class;
  perfcontrol_class_t current_perfctl_class;
  pset_cluster_type_t current_recommended_pset_type;
  thread_urgency_t current_urgency;
  int runq_bound_count;
  thread_group *current_thread_group;
  int starting_pri;
  int cpu_id;
  uint64_t quantum_end;
  uint64_t last_dispatch;
  uint64_t kperf_last_sample_time;
  uint64_t deadline;
  bool first_timeslice;
  bool processor_offlined;
  bool must_idle;
  bool running_timers_active;
  timer_call_0 running_timers[2];
  run_queue runq;
  recount_processor pr_recount;
  processor_t processor_primary;
  processor_t processor_secondary;
  ipc_port *processor_self;
  processor_t processor_list;
  uint64_t timer_call_ttd;
  simple_lock_data_t_0 start_state_lock;
  processor_reason_t last_startup_reason;
  processor_reason_t last_shutdown_reason;
  processor_reason_t last_recommend_reason;
  processor_reason_t last_derecommend_reason;
  bool shutdown_temporary;
  bool shutdown_locked;
};

/* 1346 */
typedef void (*ipi_handler_t)(void);

/* 1348 */
typedef unsigned int clock_usec_t;

/* 2563 */
typedef OSDictionary_0 *libkern::intrusive_shared_ptr<OSDictionary,intrusive_osobject_retainer>::pointer;

/* 7726 */
struct libkern::intrusive_shared_ptr<OSDictionary,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSDictionary,intrusive_osobject_retainer>::pointer ptr_;
};

/* 2582 */
struct __cppobj OSSharedPtr<OSDictionary> : libkern::intrusive_shared_ptr<OSDictionary,intrusive_osobject_retainer>
{
};

/* 1349 */
struct __cppobj IODTNVRAMDiags : IOService_0
{
  IODTNVRAM_0 *_provider;
  IORWLock_0 *_variableLock;
  OSSharedPtr<OSDictionary> _stats;
};

/* 1352 */
struct __cppobj __attribute__((aligned(4))) IODTNVRAM_0 : IOService_0
{
  IODTNVRAMPlatformNotifier *_notifier;
  IODTNVRAMDiags *_diags;
  IODTNVRAMFormatHandler *_format;
  IORWLock_0 *_variableLock;
  IOLock_0 *_controllerLock;
  IODTNVRAMVariables *_commonService;
  IODTNVRAMVariables *_systemService;
  OSPtr<OSDictionary> _varDict;
  SInt32 _lastDeviceSync;
  bool _freshInterval;
};

/* 1350 */
struct __cppobj IODTNVRAMPlatformNotifier : IOService_0
{
  IODTNVRAM_0 *_provider;
};

/* 1351 */
enum IONVRAMOperation : __int32
{
  IONVRAMOperation::kIONVRAMOperationInit = 0x0,
  IONVRAMOperation::kIONVRAMOperationRead = 0x1,
  IONVRAMOperation::kIONVRAMOperationWrite = 0x2,
  IONVRAMOperation::kIONVRAMOperationDelete = 0x3,
  IONVRAMOperation::kIONVRAMOperationObliterate = 0x4,
  IONVRAMOperation::kIONVRAMOperationReset = 0x5,
};

/* 1353 */
typedef IOGuardPageMemoryDescriptor *libkern::intrusive_shared_ptr<IOGuardPageMemoryDescriptor,intrusive_osobject_retainer>::pointer;

/* 7475 */
struct __cppobj IOGuardPageMemoryDescriptor : IOGeneralMemoryDescriptor_0
{
  vm_offset_t _buffer;
  vm_size_t_0 _size;
};

/* 1354 */
struct libkern::intrusive_shared_ptr<IOGuardPageMemoryDescriptor,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOGuardPageMemoryDescriptor,intrusive_osobject_retainer>::pointer ptr_;
};

/* 1356 */
struct __cppobj __attribute__((aligned(4))) IOMultiMemoryDescriptor_0 : IOMemoryDescriptor_0
{
  IOMemoryDescriptor_0 **_descriptors;
  UInt32 _descriptorsCount;
  bool _descriptorsIsAllocated;
};

/* 1357 */
struct __cppobj IOSubMemoryDescriptor_0 : IOMemoryDescriptor_0
{
  IOMemoryDescriptor_0 *_parent;
  IOByteCount_0 _start;
};

/* 1387 */
struct IOMDDMAWalkSegmentArgs
{
  UInt64 fOffset;
  UInt64 fIOVMAddr;
  UInt64 fLength;
  UInt8 fMapped;
  UInt64 fMappedBase;
};

/* 1358 */
struct __attribute__((aligned(8))) IOGeneralMemoryDescriptor::dmaCommandOperation::InternalState
{
  IOMDDMAWalkSegmentArgs fIO;
  mach_vm_size_t_0 fOffset2Index;
  mach_vm_size_t_0 fNextOffset;
  UInt fIndex;
};

/* 7179 */
struct IODMAMapSpecification_0
{
  uint64_t alignment;
  IOService_0 *device;
  uint32_t options;
  uint8_t numAddressBits;
  uint8_t resvA[3];
  uint32_t resvB[4];
};

/* 1359 */
struct IOMDDMAMapArgs
{
  IOMapper_0 *fMapper;
  IODMACommand_0 *fCommand;
  IODMAMapSpecification_0 fMapSpec;
  uint64_t fOffset;
  uint64_t fLength;
  uint64_t fAlloc;
  uint64_t fAllocLength;
};

/* 2504 */
struct __cppobj __attribute__((aligned(8))) IOMapper_0 : IOService_0
{
  uint64_t __reservedA[6];
  kern_allocation_name_t fAllocName;
  uint32_t __reservedB;
  uint32_t fPageSize;
  bool fIsSystem;
};

/* 2502 */
struct __cppobj IOCommand_0 : OSObject_1
{
  queue_chain_t_0 fCommandChain;
};

/* 7771 */
typedef IOMapper_0 *OSPtr<IOMapper>;

/* 9196 */
typedef IOMemoryDescriptor_0 *OSPtr<IOMemoryDescriptor>_0;

/* 7518 */
struct IODMACommand::Segment64_0
{
  UInt64 fIOVMAddr;
  UInt64 fLength;
};

/* 2500 */
typedef bool (*IODMACommand::SegmentFunction_0)(IODMACommand_0 *, IODMACommand::Segment64_0, void *, UInt32);

/* 2503 */
struct __cppobj IODMACommand_0 : IOCommand_0
{
  void *fRefCon;
  UInt64 fMaxSegmentSize;
  UInt64 fMaxTransferSize;
  UInt32 fAlignMaskLength;
  UInt32 fAlignMaskInternalSegments;
  OSPtr<IOMapper> fMapper;
  OSPtr<IOMemoryDescriptor>_0 fMemory;
  IODMACommand::SegmentFunction_0 fOutSeg;
  UInt32 fAlignMask;
  UInt32 fNumAddressBits;
  UInt32 fNumSegments;
  uint32_t fMappingOptions;
  UInt32 fActive;
  IODMACommandInternal *reserved;
};

/* 1360 */
struct IOMDPersistentInitData
{
  const IOGeneralMemoryDescriptor_0 *fMD;
  IOMemoryReference *fMemRef;
};

/* 1361 */
struct __attribute__((aligned(8))) ioPLBlock
{
  upl_t fIOPL;
  vm_address_t fPageInfo;
  uint64_t fIOMDOffset;
  ppnum_t_0 fMappedPage;
  unsigned int fPageOffset;
  unsigned int fFlags;
};

/* 1362 */
struct ioGMDData
{
  IOMapper_0 *fMapper;
  uint64_t fDMAMapAlignment;
  uint64_t fMappedBase;
  uint64_t fMappedLength;
  uint64_t fPreparationID;
  unsigned int fPageCnt;
  uint8_t fDMAMapNumAddressBits;
  upl_page_info_t_0 fPageList[1];
};

/* 1363 */
struct __attribute__((aligned(8))) IOMemoryDescriptorMapAllocRef
{
  vm_map_t_0 map;
  mach_vm_address_t_0 mapped;
  mach_vm_size_t_0 size;
  vm_prot_t prot;
  vm_tag_t tag;
  IOOptionBits_0 options;
};

/* 1374 */
struct iokit_memtype_entry
{
  unsigned int wimg;
  unsigned int object_type;
};

/* 1375 */
typedef IOGeneralMemoryDescriptor_0 *libkern::intrusive_shared_ptr<IOGeneralMemoryDescriptor,intrusive_osobject_retainer>::pointer;

/* 1376 */
typedef char libkern::detail::copy_cv<SerData,char>::type;

/* 1377 */
typedef _IOMemoryDescriptorMixedData *libkern::intrusive_shared_ptr<_IOMemoryDescriptorMixedData,intrusive_osobject_retainer>::pointer;

/* 1378 */
struct libkern::intrusive_shared_ptr<_IOMemoryDescriptorMixedData,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<_IOMemoryDescriptorMixedData,intrusive_osobject_retainer>::pointer ptr_;
};

/* 1379 */
typedef IOLittleMemoryCursor_0 *libkern::intrusive_shared_ptr<IOLittleMemoryCursor,intrusive_osobject_retainer>::pointer;

/* 1384 */
typedef IOPhysicalLength64 IOPhysicalLength_0;

/* 7506 */
struct IOMemoryCursor::PhysicalSegment_0
{
  IOPhysicalAddress_0 location;
  IOPhysicalLength_0 length;
};

/* 1385 */
typedef void (*IOMemoryCursor::SegmentFunction_0)(IOMemoryCursor::PhysicalSegment_0, void *, UInt32);

/* 7511 */
struct __cppobj IOMemoryCursor_0 : OSObject_1
{
  IOMemoryCursor::SegmentFunction_0 outSeg;
  IOPhysicalLength_0 maxSegmentSize;
  IOPhysicalLength_0 maxTransferSize;
  IOPhysicalLength_0 alignMask;
};

/* 7510 */
struct __cppobj IOLittleMemoryCursor_0 : IOMemoryCursor_0
{
};

/* 1380 */
typedef IOBigMemoryCursor_0 *libkern::intrusive_shared_ptr<IOBigMemoryCursor,intrusive_osobject_retainer>::pointer;

/* 7512 */
struct __cppobj IOBigMemoryCursor_0 : IOMemoryCursor_0
{
};

/* 1381 */
typedef IONaturalMemoryCursor_0 *libkern::intrusive_shared_ptr<IONaturalMemoryCursor,intrusive_osobject_retainer>::pointer;

/* 7513 */
struct __cppobj IONaturalMemoryCursor_0 : IOMemoryCursor_0
{
};

/* 1382 */
typedef IOMemoryCursor_0 *libkern::intrusive_shared_ptr<IOMemoryCursor,intrusive_osobject_retainer>::pointer;

/* 1383 */
struct libkern::intrusive_shared_ptr<IOMemoryCursor,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOMemoryCursor,intrusive_osobject_retainer>::pointer ptr_;
};

/* 1386 */
struct __attribute__((aligned(8))) IODMACommandTransferContext
{
  void *buffer;
  UInt64 bufferOffset;
  UInt64 remaining;
  UInt32 op;
};

/* 1388 */
typedef IODMACommand_0 *libkern::intrusive_shared_ptr<IODMACommand,intrusive_osobject_retainer>::pointer;

/* 1389 */
typedef IOMapper_0 *libkern::intrusive_shared_ptr<IOMapper,intrusive_osobject_retainer>::pointer;

/* 1390 */
typedef IOBufferMemoryDescriptor_0 *libkern::intrusive_shared_ptr<IOBufferMemoryDescriptor,intrusive_osobject_retainer>::pointer;

/* 1391 */
typedef IOFilterInterruptEventSource_0 *libkern::intrusive_shared_ptr<IOFilterInterruptEventSource,intrusive_osobject_retainer>::pointer;

/* 1408 */
struct __cppobj IOInterruptEventSource_0 : IOEventSource_0
{
  IOService_0 *provider;
  int intIndex;
  volatile unsigned int producerCount;
  unsigned int consumerCount;
  bool autoDisable;
  bool explicitDisable;
  IOInterruptEventSource::ExpansionData_0 *reserved;
};

/* 1395 */
typedef bool (*IOFilterInterruptEventSource::Filter_0)(OSObject_0 *, IOFilterInterruptEventSource_0 *);

/* 1394 */
typedef struct *IOFilterInterruptEventSource::FilterBlock;

/* 7533 */
struct __cppobj IOFilterInterruptEventSource_0 : IOInterruptEventSource_0
{
  union
  {
    IOFilterInterruptEventSource::Filter_0 filterAction;
    IOFilterInterruptEventSource::FilterBlock filterActionBlock;
  };
  IOFilterInterruptEventSource::ExpansionData_0 *reserved;
};

/* 7551 */
struct IOInterruptEventSource::ExpansionData_0
{
  IOInterruptAccountingData *statistics;
};

/* 7534 */
struct IOFilterInterruptEventSource::ExpansionData_0
{
  _BYTE gap0;
};

/* 1392 */
typedef IOInterruptEventSource_0 *libkern::intrusive_shared_ptr<IOInterruptEventSource,intrusive_osobject_retainer>::pointer;

/* 1393 */
struct libkern::intrusive_shared_ptr<IOInterruptEventSource,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOInterruptEventSource,intrusive_osobject_retainer>::pointer ptr_;
};

/* 1396 */
typedef IODMAEventSource_0 *libkern::intrusive_shared_ptr<IODMAEventSource,intrusive_osobject_retainer>::pointer;

/* 1397 */
typedef IODMAController_0 *libkern::intrusive_shared_ptr<IODMAController,intrusive_osobject_retainer>::pointer;

/* 1398 */
struct libkern::intrusive_shared_ptr<IODMAController,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IODMAController,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7538 */
struct __cppobj OSSharedPtr<IODMAController> : libkern::intrusive_shared_ptr<IODMAController,intrusive_osobject_retainer>
{
};

/* 1400 */
typedef OSSharedPtr<IODMAController> OSPtr<IODMAController>;

/* 1399 */
typedef void (*IODMAEventSource::Action_0)(OSObject_0 *, IODMAEventSource_0 *, IODMACommand_0 *, IOReturn_0, IOByteCount_0, AbsoluteTime_0);

/* 7539 */
struct __cppobj __attribute__((aligned(8))) IODMAEventSource_0 : IOEventSource_0
{
  IOService_0 *dmaProvider;
  OSPtr<IODMAController> dmaController;
  UInt32 dmaIndex;
  queue_head_t_0 dmaCommandsCompleted;
  IOSimpleLock_0 *dmaCommandsCompletedLock;
  IODMAEventSource::Action_0 dmaCompletionAction;
  IODMAEventSource::Action_0 dmaNotificationAction;
  bool dmaSynchBusy;
};

/* 2570 */
typedef const OSSymbol_0 *libkern::intrusive_shared_ptr<const OSSymbol,intrusive_osobject_retainer>::pointer;

/* 2571 */
struct libkern::intrusive_shared_ptr<const OSSymbol,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<const OSSymbol,intrusive_osobject_retainer>::pointer ptr_;
};

/* 2572 */
struct __cppobj OSSharedPtr<const OSSymbol> : libkern::intrusive_shared_ptr<const OSSymbol,intrusive_osobject_retainer>
{
};

/* 9171 */
typedef OSSharedPtr<const OSSymbol> OSPtr<const OSSymbol>_0;

/* 7540 */
struct __cppobj IODMAController_0 : IOService_0
{
  IOService_0 *_provider;
  OSPtr<const OSSymbol>_0 _dmaControllerName;
};

/* 1401 */
typedef IOCommand_0 *libkern::intrusive_shared_ptr<IOCommand,intrusive_osobject_retainer>::pointer;

/* 1402 */
typedef IOCommandPool_0 *libkern::intrusive_shared_ptr<IOCommandPool,intrusive_osobject_retainer>::pointer;

/* 7553 */
typedef IOCommandGate_0 *OSPtr<IOCommandGate>;

/* 1409 */
struct __cppobj IOCommandPool_0 : OSObject_1
{
  queue_head_t_0 fQueueHead;
  UInt32 fSleepers;
  OSPtr<IOCommandGate> fSerializer;
  IOCommandPool::ExpansionData_0 *reserved;
};

/* 7552 */
struct IOCommandPool::ExpansionData_0
{
  _BYTE gap0;
};

/* 1403 */
typedef IOCommandGate_0 *libkern::intrusive_shared_ptr<IOCommandGate,intrusive_osobject_retainer>::pointer;

/* 1404 */
struct libkern::intrusive_shared_ptr<IOCommandGate,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOCommandGate,intrusive_osobject_retainer>::pointer ptr_;
};

/* 1405 */
struct __cppobj OSSharedPtr<IOInterruptEventSource> : libkern::intrusive_shared_ptr<IOInterruptEventSource,intrusive_osobject_retainer>
{
};

/* 1406 */
typedef struct *IOInterruptEventSource::ActionBlock;

/* 1407 */
typedef void (*IOInterruptEventSource::Action_0)(OSObject_0 *, IOInterruptEventSource_0 *, int);

/* 1410 */
struct aes_ctx
{
  aes_decrypt_ctx decrypt;
  aes_encrypt_ctx encrypt;
};

/* 1411 */
struct IOPolledFileCryptVars
{
  uint8_t aes_iv[16];
  aes_ctx ctx;
};

/* 1412 */
struct _OpenFileContext
{
  OSData_0 *extents;
  uint64_t size;
};

/* 1413 */
struct IOPolledFileExtent
{
  uint64_t start;
  uint64_t length;
};

/* 1414 */
struct __attribute__((aligned(8))) kern_direct_file_io_ref_t
{
  vfs_context_t ctx;
  vnode *vp;
  char *name;
  size_t namesize;
  dev_t device;
  uint32_t blksize;
  off_t filelength;
  char cf;
  char pinned;
  char frozen;
  char wbcranged;
};

/* 1415 */
struct __attribute__((aligned(8))) IOPolledFileIOVars
{
  IOPolledFilePollers *pollers;
  kern_direct_file_io_ref_t *fileRef;
  OSData_0 *fileExtents;
  uint64_t block0;
  uint32_t blockSize;
  uint64_t maxiobytes;
  uint32_t bufferLimit;
  uint8_t *buffer;
  uint32_t bufferSize;
  uint32_t bufferOffset;
  uint32_t bufferHalf;
  uint64_t extentRemaining;
  uint32_t lastRead;
  uint64_t readEnd;
  uint32_t flags;
  uint64_t fileSize;
  uint64_t position;
  uint64_t extentPosition;
  uint64_t encryptStart;
  uint64_t encryptEnd;
  uint64_t cryptBytes;
  AbsoluteTime_0 cryptTime;
  IOPolledFileExtent *extentMap;
  IOPolledFileExtent *currentExtent;
  bool allocated;
};

/* 7557 */
struct __cppobj __attribute__((aligned(8))) IOPolledFilePollers : OSObject_1
{
  IOService_0 *media;
  OSArray_0 *pollers;
  IOBufferMemoryDescriptor_0 *ioBuffer;
  bool abortable;
  bool io;
  IOReturn_0 ioStatus;
  uint32_t openCount;
};

/* 1416 */
typedef void (*IOPolledCompletionAction)(void *, void *, IOReturn_0, uint64_t);

/* 1417 */
struct IOPolledCompletion
{
  void *target;
  IOPolledCompletionAction action;
  void *parameter;
};

/* 1418 */
typedef void (*idle_tickle_t_0)(void);

/* 1419 */
typedef void (*platform_error_handler_t_0)(void *, vm_offset_t);

/* 1420 */
typedef void (*idle_timer_t_0)(void *, uint64_t *);

/* 1421 */
typedef void (*processor_idle_t_0)(cpu_id_t_0, boolean_t, uint64_t *);

/* 1422 */
typedef void (*time_base_enable_t_0)(cpu_id_t_0, boolean_t);

/* 1424 */
typedef ml_processor_info_0 ml_processor_info_t_0;

/* 9413 */
struct __attribute__((aligned(8))) ml_processor_info_0
{
  cpu_id_t_0 cpu_id;
  vm_offset_t start_paddr;
  boolean_t supports_nap;
  void *platform_cache_dispatch;
  time_base_enable_t_0 time_base_enable;
  processor_idle_t_0 processor_idle;
  idle_tickle_t_0 *idle_tickle;
  idle_timer_t_0 idle_timer;
  void *idle_timer_refcon;
  vm_offset_t powergate_stub_addr;
  uint32_t powergate_stub_length;
  uint32_t powergate_latency;
  platform_error_handler_t_0 platform_error_handler;
  uint64_t regmap_paddr;
  uint32_t phys_id;
  uint32_t log_id;
  uint32_t l2_access_penalty;
  uint32_t cluster_id;
  _BYTE gap78[4];
  uint32_t l2_cache_id;
  uint32_t l2_cache_size;
  uint32_t l3_cache_id;
  uint32_t l3_cache_size;
};

/* 1426 */
typedef IOCatalogue_0 *libkern::intrusive_shared_ptr<IOCatalogue,intrusive_osobject_retainer>::pointer;

/* 9396 */
typedef OSSharedPtr<OSDictionary> OSPtr<OSDictionary>_0;

/* 7569 */
struct __cppobj IOCatalogue_0 : OSObject_0
{
  IORWLock_0 *lock;
  SInt32 generation;
  OSPtr<OSDictionary>_0 personalities;
};

/* 1427 */
typedef OSOrderedSet_0 *libkern::intrusive_shared_ptr<OSOrderedSet,intrusive_osobject_retainer>::pointer;

/* 1428 */
struct libkern::intrusive_shared_ptr<OSOrderedSet,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSOrderedSet,intrusive_osobject_retainer>::pointer ptr_;
};

/* 1429 */
struct libkern::intrusive_shared_ptr<IOCatalogue,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOCatalogue,intrusive_osobject_retainer>::pointer ptr_;
};

/* 1430 */
struct IOPMRequestDomainPowerContext
{
  IOService_0 *child;
  IOPMPowerFlags requestPowerFlags;
};

/* 1431 */
struct IOSimpleReportValues
{
  int64_t simple_value;
  uint64_t reserved1;
  uint64_t reserved2;
  uint64_t reserved3;
};

/* 2465 */
typedef unsigned __int64 IOPMPowerStateIndex;

/* 2467 */
typedef uint32_t IOPMPowerChangeFlags;

/* 7579 */
typedef bool (*IOPMMessageFilter)(void *, void *, void *, void *, void *);

/* 1432 */
struct IOPMInterestContext
{
  OSArray_0 *responseArray;
  OSArray_0 *notifyClients;
  uint16_t serialNumber;
  uint8_t isPreChange;
  uint8_t enableTracing;
  uint32_t maxTimeRequested;
  uint32_t messageType;
  uint32_t notifyType;
  uint32_t skippedInDark;
  uint32_t notSkippedInDark;
  IOService_0 *us;
  IOPMPowerStateIndex stateNumber;
  IOPMPowerFlags stateFlags;
  IOPMPowerChangeFlags changeFlags;
  IOPMMessageFilter messageFilter;
};

/* 1433 */
struct IOStateReportValues
{
  uint64_t state_id;
  uint64_t intransitions;
  uint64_t upticks;
  uint64_t last_intransition;
};

/* 1434 */
struct IOStateReportInfo
{
  uint16_t curr_state;
  uint64_t update_ts;
  IOReportElement elem[];
};

/* 1435 */
struct __attribute__((aligned(8))) DriverCallParam
{
  OSObject_0 *Target;
  IOReturn_0 Result;
};

/* 1436 */
typedef void (*IOInterruptAction_0)(OSObject_0 *, void *, IOService_0 *, int);

/* 1437 */
typedef queue_entry_0 *queue_t;

/* 1438 */
typedef void (*OSObjectApplierFunction_0)(OSObject_0 *, void *);

/* 1439 */
typedef void *IONotificationRef_0;

/* 1440 */
struct CpuDelayEntry
{
  IOService_0 *fService;
  UInt32 fMaxDelay;
  UInt32 fDelayType;
};

/* 1441 */
struct __attribute__((aligned(8))) ServiceOpenMessageContext
{
  IOService_0 *service;
  UInt32 type;
  IOService_0 *excludeClient;
  IOOptionBits_0 options;
};

/* 1442 */
struct __attribute__((aligned(8))) MessageClientsContext
{
  IOService_0 *service;
  UInt32 type;
  void *argument;
  vm_size_t_0 argSize;
  IOReturn_0 ret;
};

/* 1443 */
struct __attribute__((aligned(8))) IOUserServerCancellationHandlerArgs
{
  IOService_0 **ref;
  bool canceled;
};

/* 1444 */
struct IOServiceMatchContext
{
  OSDictionary_0 *table;
  OSObject_0 *result;
  uint32_t options;
  uint32_t state;
  uint32_t count;
  uint32_t done;
};

/* 1445 */
struct FindRootMediaContext
{
  OSArray_0 *services;
  IOService_0 *parent;
};

/* 1446 */
struct IOPMSystemCapabilityChangeParameters
{
  uint32_t notifyRef;
  uint32_t maxWaitForReply;
  uint32_t changeFlags;
  uint32_t __reserved1;
  uint32_t fromCapabilities;
  uint32_t toCapabilities;
  uint32_t __reserved2[4];
};

/* 1447 */
struct _IOServiceNotifierInvocation
{
  IOThread_0 thread;
  queue_chain_t_0 link;
};

/* 1448 */
struct __attribute__((aligned(4))) ArbitrationLockQueueElement
{
  queue_chain_t_0 link;
  IOThread_0 thread;
  IOService_0 *service;
  unsigned int count;
  bool required;
  bool aborted;
};

/* 1449 */
typedef char libkern::sa_detail::remove_const<char>::type;

/* 1450 */
struct IONamedValue
{
  int value;
  const char *name;
};

/* 1451 */
typedef void (*IORegistryEntryApplierFunction_0)(IORegistryEntry_0 *, void *);

/* 1452 */
typedef char libkern::detail::copy_cv<char,char>::type;

/* 1454 */
typedef UInt64 dtptr_t;

/* 2621 */
typedef __int64 SInt64;

/* 1455 */
typedef SInt64 (*IODTCompareAddressCellFunc)(UInt32, UInt32 *, UInt32 *);

/* 1456 */
struct IODTPersistent
{
  IODTCompareAddressCellFunc compareFunc;
};

/* 1457 */
struct IODTResolvers
{
  unsigned int alloc;
  unsigned int count;
  IOLock_0 *lock;
  IODTPersistent *resolvers;
};

/* 1458 */
typedef void (*IODTNVLocationFunc)(IORegistryEntry_0 *, UInt8 *, UInt8 *, UInt8 *);

/* 1459 */
struct __cppobj IOPlatformExpertDevice_0 : IOService_0
{
  IOWorkLoop_0 *workLoop;
  IOPlatformExpertDevice::ExpansionData_0 *ioped_reserved;
};

/* 7612 */
struct IOPlatformExpertDevice::ExpansionData_0
{
  _BYTE gap0;
};

/* 1460 */
enum IOLockState : __int32
{
  kIOLockStateUnlocked = 0x0,
  kIOLockStateLocked = 0x1,
};

/* 1461 */
typedef kern_return_t (*IOIteratePageableMapsCallback)(vm_map_t_0, void *);

/* 1462 */
typedef void (*IOThreadFunc)(void *);

/* 1463 */
struct __attribute__((aligned(8))) IOMallocPageableRef
{
  vm_offset_t address;
  vm_size_t_0 size;
  vm_tag_t tag;
};

/* 1464 */
struct _IOMallocContiguousEntry
{
  mach_vm_address_t_0 virtualAddr;
  IOBufferMemoryDescriptor_0 *md;
  queue_chain_t_0 link;
};

/* 1465 */
struct IOLibPageMallocHeader
{
  mach_vm_size_t_0 alignMask;
  mach_vm_offset_t allocationOffset;
};

/* 1466 */
struct _lck_grp_attr_
{
  _BYTE gap0[4];
};

/* 1467 */
typedef _lck_grp_attr_ lck_grp_attr_t;

/* 1468 */
struct IOMapData
{
  vm_map_t_0 map;
  vm_offset_t address;
  vm_offset_t end;
};

/* 1471 */
struct mach_vm_range
{
  mach_vm_offset_t min_address;
  mach_vm_offset_t max_address;
};

/* 1472 */
struct IODMACommand_Create_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef command;
};

/* 5987 */
struct mach_msg_body_t_0
{
  mach_msg_size_t msgh_descriptor_count;
};

/* 2612 */
struct __attribute__((packed)) __attribute__((aligned(4))) IORPCMessageMach_0
{
  mach_msg_header_t_1 msgh;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t objects[];
};

/* 1473 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODMACommand_Create_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t command__descriptor;
  IODMACommand_Create_Rpl_Content content;
};

/* 2482 */
struct IODMACommandSpecification
{
  uint64_t options;
  uint64_t maxAddressBits;
  uint64_t _resv[16];
};

/* 1474 */
struct IODMACommand_Create_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef device;
  uint64_t options;
  IODMACommandSpecification specification;
};

/* 1475 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODMACommand_Create_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t device__descriptor;
  IODMACommand_Create_Msg_Content content;
};

/* 1476 */
struct IODMACommand_GetPreparation_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef memory;
  unsigned __int64 offset;
  unsigned __int64 length;
};

/* 1477 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODMACommand_GetPreparation_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t memory__descriptor;
  IODMACommand_GetPreparation_Rpl_Content content;
};

/* 1478 */
struct IODMACommand_GetPreparation_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1479 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODMACommand_GetPreparation_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IODMACommand_GetPreparation_Msg_Content content;
};

/* 1480 */
struct IODMACommand_CompleteDMA_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1481 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODMACommand_CompleteDMA_Rpl
{
  IORPCMessageMach_0 mach;
  IODMACommand_CompleteDMA_Rpl_Content content;
};

/* 1482 */
struct IODMACommand_CompleteDMA_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  uint64_t options;
};

/* 1483 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODMACommand_CompleteDMA_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IODMACommand_CompleteDMA_Msg_Content content;
};

/* 2481 */
struct IOAddressSegment
{
  uint64_t address;
  uint64_t length;
};

/* 1484 */
struct IODMACommand_PrepareForDMA_Rpl_Content
{
  IORPCMessage __hdr;
  unsigned __int64 flags;
  unsigned int segmentsCount;
  IOAddressSegment *segments;
  IOAddressSegment __segments[32];
};

/* 1485 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODMACommand_PrepareForDMA_Rpl
{
  IORPCMessageMach_0 mach;
  IODMACommand_PrepareForDMA_Rpl_Content content;
};

/* 1486 */
struct __attribute__((aligned(8))) IODMACommand_PrepareForDMA_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef memory;
  uint64_t options;
  uint64_t offset;
  uint64_t length;
  unsigned int segmentsCount;
};

/* 1487 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODMACommand_PrepareForDMA_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t memory__descriptor;
  IODMACommand_PrepareForDMA_Msg_Content content;
};

/* 1488 */
struct IODMACommand_PerformOperation_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1489 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODMACommand_PerformOperation_Rpl
{
  IORPCMessageMach_0 mach;
  IODMACommand_PerformOperation_Rpl_Content content;
};

/* 1490 */
struct IODMACommand_PerformOperation_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef data;
  uint64_t options;
  uint64_t dmaOffset;
  uint64_t length;
  uint64_t dataOffset;
};

/* 1491 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODMACommand_PerformOperation_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t data__descriptor;
  IODMACommand_PerformOperation_Msg_Content content;
};

/* 1492 */
struct IOUserServer_Create_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef server;
};

/* 1493 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserServer_Create_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t server__descriptor;
  IOUserServer_Create_Rpl_Content content;
};

/* 1494 */
struct IOUserServer_Create_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSString_0 *bundleID;
  const char *name;
  char __name[64];
  uint64_t tag;
  uint64_t options;
};

/* 1495 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserServer_Create_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t bundleID__descriptor;
  IOUserServer_Create_Msg_Content content;
};

/* 1496 */
struct IOUserServer_LoadModule_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1497 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserServer_LoadModule_Rpl
{
  IORPCMessageMach_0 mach;
  IOUserServer_LoadModule_Rpl_Content content;
};

/* 1498 */
struct IOUserServer_LoadModule_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  const char *path;
  char __path[1024];
};

/* 1499 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserServer_LoadModule_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOUserServer_LoadModule_Msg_Content content;
};

/* 1500 */
struct IOUserServer_Exit_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1501 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserServer_Exit_Rpl
{
  IORPCMessageMach_0 mach;
  IOUserServer_Exit_Rpl_Content content;
};

/* 1502 */
struct IOUserServer_Exit_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  const char *reason;
  char __reason[1024];
};

/* 1503 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserServer_Exit_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOUserServer_Exit_Msg_Content content;
};

/* 1504 */
struct IOWorkGroup_Create_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef workgroup;
};

/* 1505 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOWorkGroup_Create_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t workgroup__descriptor;
  IOWorkGroup_Create_Rpl_Content content;
};

/* 1506 */
struct IOWorkGroup_Create_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSString_0 *name;
  OSObjectRef userClient;
};

/* 1507 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOWorkGroup_Create_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t name__descriptor;
  mach_msg_port_descriptor_t userClient__descriptor;
  IOWorkGroup_Create_Msg_Content content;
};

/* 1508 */
struct IOWorkGroup_InvalidateKernel_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1509 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOWorkGroup_InvalidateKernel_Rpl
{
  IORPCMessageMach_0 mach;
  IOWorkGroup_InvalidateKernel_Rpl_Content content;
};

/* 1510 */
struct IOWorkGroup_InvalidateKernel_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef client;
};

/* 1511 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOWorkGroup_InvalidateKernel_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t client__descriptor;
  IOWorkGroup_InvalidateKernel_Msg_Content content;
};

/* 1512 */
struct IOWorkGroup_SetWorkGroupPort_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1513 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOWorkGroup_SetWorkGroupPort_Rpl
{
  IORPCMessageMach_0 mach;
  IOWorkGroup_SetWorkGroupPort_Rpl_Content content;
};

/* 1514 */
struct IOWorkGroup_SetWorkGroupPort_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1515 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOWorkGroup_SetWorkGroupPort_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t port__descriptor;
  IOWorkGroup_SetWorkGroupPort_Msg_Content content;
};

/* 1516 */
struct IOWorkGroup_LocalIVars;

/* 1517 */
struct IOWorkGroup_IVars
{
  IOUserServer *userServer;
  OSString_0 *name;
  IOUserUserClient *userClient;
};

/* 1535 */
struct __cppobj IOUserUserClient : IOUserClient_0
{
  task_t_0 fTask;
  OSDictionary_0 *fWorkGroups;
  OSDictionary_0 *fEventLinks;
  IOLock_0 *fLock;
};

/* 1518 */
typedef kern_return_t (*IOWorkGroup::InvalidateKernel_Handler)(OSMetaClassBase_0 *, IOUserClient_0 *);

/* 1519 */
typedef kern_return_t (*IOWorkGroup::SetWorkGroupPort_Handler)(OSMetaClassBase_0 *, mach_port_t_0);

/* 1520 */
typedef kern_return_t (*IOWorkGroup::Create_Handler)(OSString_0 *, IOUserClient_0 *, IOWorkGroup **);

/* 7617 */
struct __cppobj IOWorkGroup : OSObject_1
{
  union
  {
    IOWorkGroup_IVars *ivars;
    IOWorkGroup_LocalIVars *lvars;
  };
};

/* 1521 */
struct IOWorkGroupInterface
{
  _BYTE gap0;
};

/* 1522 */
struct IOEventLink_Create_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef eventLink;
};

/* 1523 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOEventLink_Create_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t eventLink__descriptor;
  IOEventLink_Create_Rpl_Content content;
};

/* 1524 */
struct IOEventLink_Create_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSString_0 *name;
  OSObjectRef userClient;
};

/* 1525 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOEventLink_Create_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t name__descriptor;
  mach_msg_port_descriptor_t userClient__descriptor;
  IOEventLink_Create_Msg_Content content;
};

/* 1526 */
struct IOEventLink_InvalidateKernel_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1527 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOEventLink_InvalidateKernel_Rpl
{
  IORPCMessageMach_0 mach;
  IOEventLink_InvalidateKernel_Rpl_Content content;
};

/* 1528 */
struct IOEventLink_InvalidateKernel_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef client;
};

/* 1529 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOEventLink_InvalidateKernel_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t client__descriptor;
  IOEventLink_InvalidateKernel_Msg_Content content;
};

/* 1530 */
struct IOEventLink_SetEventlinkPort_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1531 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOEventLink_SetEventlinkPort_Rpl
{
  IORPCMessageMach_0 mach;
  IOEventLink_SetEventlinkPort_Rpl_Content content;
};

/* 1532 */
struct IOEventLink_SetEventlinkPort_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1533 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOEventLink_SetEventlinkPort_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t port__descriptor;
  IOEventLink_SetEventlinkPort_Msg_Content content;
};

/* 1534 */
struct IOEventLink_LocalIVars;

/* 1536 */
struct IOEventLink_IVars
{
  IOUserServer *userServer;
  OSString_0 *name;
  IOUserUserClient *userClient;
};

/* 1537 */
typedef kern_return_t (*IOEventLink::InvalidateKernel_Handler)(OSMetaClassBase_0 *, IOUserClient_0 *);

/* 1538 */
typedef kern_return_t (*IOEventLink::SetEventlinkPort_Handler)(OSMetaClassBase_0 *, mach_port_t_0);

/* 1539 */
typedef kern_return_t (*IOEventLink::Create_Handler)(OSString_0 *, IOUserClient_0 *, IOEventLink **);

/* 7619 */
struct __cppobj IOEventLink : OSObject_1
{
  union
  {
    IOEventLink_IVars *ivars;
    IOEventLink_LocalIVars *lvars;
  };
};

/* 1540 */
struct IOEventLinkInterface
{
  _BYTE gap0;
};

/* 1541 */
struct IOServiceStateNotificationDispatchSource_Create_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef source;
};

/* 1542 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceStateNotificationDispatchSource_Create_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t source__descriptor;
  IOServiceStateNotificationDispatchSource_Create_Rpl_Content content;
};

/* 1543 */
struct IOServiceStateNotificationDispatchSource_Create_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef service;
  OSArray_0 *items;
  OSObjectRef queue;
};

/* 1544 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceStateNotificationDispatchSource_Create_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t service__descriptor;
  mach_msg_ool_descriptor_t items__descriptor;
  mach_msg_port_descriptor_t queue__descriptor;
  IOServiceStateNotificationDispatchSource_Create_Msg_Content content;
};

/* 1545 */
struct IOServiceStateNotificationDispatchSource_StateNotificationReady_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef action;
};

/* 1546 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceStateNotificationDispatchSource_StateNotificationReady_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t action__descriptor;
  IOServiceStateNotificationDispatchSource_StateNotificationReady_Msg_Content content;
};

/* 1547 */
struct IOServiceStateNotificationDispatchSource_SetHandler_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1548 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceStateNotificationDispatchSource_SetHandler_Rpl
{
  IORPCMessageMach_0 mach;
  IOServiceStateNotificationDispatchSource_SetHandler_Rpl_Content content;
};

/* 1549 */
struct IOServiceStateNotificationDispatchSource_SetHandler_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef action;
};

/* 1550 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceStateNotificationDispatchSource_SetHandler_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t action__descriptor;
  IOServiceStateNotificationDispatchSource_SetHandler_Msg_Content content;
};

/* 1551 */
struct IOServiceStateNotificationDispatchSource_StateNotificationBegin_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1552 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceStateNotificationDispatchSource_StateNotificationBegin_Rpl
{
  IORPCMessageMach_0 mach;
  IOServiceStateNotificationDispatchSource_StateNotificationBegin_Rpl_Content content;
};

/* 1553 */
struct IOServiceStateNotificationDispatchSource_StateNotificationBegin_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1554 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceStateNotificationDispatchSource_StateNotificationBegin_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOServiceStateNotificationDispatchSource_StateNotificationBegin_Msg_Content content;
};

/* 1558 */
typedef void (*IOServiceStateNotificationDispatchSource::StateNotificationReady_Handler)(OSMetaClassBase_0 *, OSAction_0 *);

/* 1559 */
typedef kern_return_t (*IOServiceStateNotificationDispatchSource::StateNotificationBegin_Handler)(OSMetaClassBase_0 *);

/* 1560 */
typedef kern_return_t (*IOServiceStateNotificationDispatchSource::SetHandler_Handler)(OSMetaClassBase_0 *, OSAction_0 *);

/* 1561 */
typedef kern_return_t (*IOServiceStateNotificationDispatchSource::Create_Handler)(IOService_0 *, OSArray_0 *, IODispatchQueue *, IOServiceStateNotificationDispatchSource **);

/* 1562 */
struct IOServiceStateNotificationDispatchSourceInterface
{
  _BYTE gap0;
};

/* 1563 */
struct IOServiceNotificationDispatchSource_Create_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef notification;
};

/* 1564 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceNotificationDispatchSource_Create_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t notification__descriptor;
  IOServiceNotificationDispatchSource_Create_Rpl_Content content;
};

/* 1565 */
struct IOServiceNotificationDispatchSource_Create_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSDictionary_0 *matching;
  OSObjectRef queue;
  uint64_t options;
};

/* 1566 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceNotificationDispatchSource_Create_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t matching__descriptor;
  mach_msg_port_descriptor_t queue__descriptor;
  IOServiceNotificationDispatchSource_Create_Msg_Content content;
};

/* 1567 */
struct IOServiceNotificationDispatchSource_ServiceNotificationReady_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef action;
};

/* 1568 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceNotificationDispatchSource_ServiceNotificationReady_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t action__descriptor;
  IOServiceNotificationDispatchSource_ServiceNotificationReady_Msg_Content content;
};

/* 1569 */
struct IOServiceNotificationDispatchSource_SetHandler_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1570 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceNotificationDispatchSource_SetHandler_Rpl
{
  IORPCMessageMach_0 mach;
  IOServiceNotificationDispatchSource_SetHandler_Rpl_Content content;
};

/* 1571 */
struct IOServiceNotificationDispatchSource_SetHandler_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef action;
};

/* 1572 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceNotificationDispatchSource_SetHandler_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t action__descriptor;
  IOServiceNotificationDispatchSource_SetHandler_Msg_Content content;
};

/* 1573 */
struct IOServiceNotificationDispatchSource_CopyNextNotification_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef service;
  unsigned __int64 type;
  unsigned __int64 options;
};

/* 1574 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceNotificationDispatchSource_CopyNextNotification_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t service__descriptor;
  IOServiceNotificationDispatchSource_CopyNextNotification_Rpl_Content content;
};

/* 1575 */
struct IOServiceNotificationDispatchSource_CopyNextNotification_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1576 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOServiceNotificationDispatchSource_CopyNextNotification_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOServiceNotificationDispatchSource_CopyNextNotification_Msg_Content content;
};

/* 1577 */
struct IOServiceNotificationDispatchSource_LocalIVars;

/* 1578 */
typedef char libkern::detail::copy_cv<OSArray *,char>::type;

/* 1579 */
typedef libkern::detail::copy_cv<OSArray *,char>::type libkern::detail::copy_cv_t<OSArray *,char>;

/* 1580 */
typedef libkern::bounded_array<OSArray *,2UL,os_detail::panic_trapping_policy> OSBoundedArray<OSArray *,kIOServiceNotificationTypeCount>;

/* 7358 */
struct libkern::bounded_array<OSArray *,2UL,os_detail::panic_trapping_policy>
{
  OSArray_0 *data_[2];
};

/* 1581 */
struct __attribute__((aligned(8))) IOServiceNotificationDispatchSource_IVars
{
  OSObject_0 *serverName;
  OSAction_0 *action;
  IOLock_0 *lock;
  IONotifier_0 *notifier;
  OSDictionary_0 *interestNotifiers;
  OSBoundedArray<OSArray *,kIOServiceNotificationTypeCount> pending;
  bool enable;
};

/* 7177 */
struct __cppobj __attribute__((aligned(8))) IONotifier_0 : OSObject_0
{
};

/* 1582 */
typedef kern_return_t (*IOServiceNotificationDispatchSource::CopyNextNotification_Handler)(OSMetaClassBase_1 *, uint64_t *, IOService_0 **, uint64_t *);

/* 1583 */
typedef void (*IOServiceNotificationDispatchSource::ServiceNotificationReady_Handler)(OSMetaClassBase_0 *, OSAction_0 *);

/* 1584 */
typedef kern_return_t (*IOServiceNotificationDispatchSource::SetHandler_Handler)(OSMetaClassBase_0 *, OSAction_0 *);

/* 1585 */
typedef kern_return_t (*IOServiceNotificationDispatchSource::Create_Handler)(OSDictionary_0 *, uint64_t, IODispatchQueue *, IOServiceNotificationDispatchSource **);

/* 7624 */
struct __cppobj IOServiceNotificationDispatchSource : IODispatchSource
{
  union
  {
    IOServiceNotificationDispatchSource_IVars *ivars;
    IOServiceNotificationDispatchSource_LocalIVars *lvars;
  };
};

/* 1586 */
typedef struct *IOServiceNotificationBlock;

/* 1587 */
struct IOServiceNotificationDispatchSourceInterface
{
  _BYTE gap0;
};

/* 1588 */
struct IODataQueueDispatchSource_DataServiced_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1589 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_DataServiced_Rpl
{
  IORPCMessageMach_0 mach;
  IODataQueueDispatchSource_DataServiced_Rpl_Content content;
};

/* 1590 */
struct IODataQueueDispatchSource_DataServiced_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef action;
};

/* 1591 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_DataServiced_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t action__descriptor;
  IODataQueueDispatchSource_DataServiced_Msg_Content content;
};

/* 1592 */
struct IODataQueueDispatchSource_DataAvailable_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1593 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_DataAvailable_Rpl
{
  IORPCMessageMach_0 mach;
  IODataQueueDispatchSource_DataAvailable_Rpl_Content content;
};

/* 1594 */
struct IODataQueueDispatchSource_DataAvailable_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef action;
};

/* 1595 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_DataAvailable_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t action__descriptor;
  IODataQueueDispatchSource_DataAvailable_Msg_Content content;
};

/* 1596 */
struct IODataQueueDispatchSource_Create_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef source;
};

/* 1597 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_Create_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t source__descriptor;
  IODataQueueDispatchSource_Create_Rpl_Content content;
};

/* 1598 */
struct IODataQueueDispatchSource_Create_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef queue;
  uint64_t queueByteCount;
};

/* 1599 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_Create_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t queue__descriptor;
  IODataQueueDispatchSource_Create_Msg_Content content;
};

/* 1600 */
struct IODataQueueDispatchSource_CopyDataAvailableHandler_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef action;
};

/* 1601 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_CopyDataAvailableHandler_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t action__descriptor;
  IODataQueueDispatchSource_CopyDataAvailableHandler_Rpl_Content content;
};

/* 1602 */
struct IODataQueueDispatchSource_CopyDataAvailableHandler_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1603 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_CopyDataAvailableHandler_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IODataQueueDispatchSource_CopyDataAvailableHandler_Msg_Content content;
};

/* 1604 */
struct IODataQueueDispatchSource_SetDataAvailableHandler_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1605 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_SetDataAvailableHandler_Rpl
{
  IORPCMessageMach_0 mach;
  IODataQueueDispatchSource_SetDataAvailableHandler_Rpl_Content content;
};

/* 1606 */
struct IODataQueueDispatchSource_SetDataAvailableHandler_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef action;
};

/* 1607 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_SetDataAvailableHandler_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t action__descriptor;
  IODataQueueDispatchSource_SetDataAvailableHandler_Msg_Content content;
};

/* 1608 */
struct IODataQueueDispatchSource_CopyMemory_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef memory;
};

/* 1609 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_CopyMemory_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t memory__descriptor;
  IODataQueueDispatchSource_CopyMemory_Rpl_Content content;
};

/* 1610 */
struct IODataQueueDispatchSource_CopyMemory_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1611 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_CopyMemory_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IODataQueueDispatchSource_CopyMemory_Msg_Content content;
};

/* 1612 */
struct IODataQueueDispatchSource_SetDataServicedHandler_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1613 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_SetDataServicedHandler_Rpl
{
  IORPCMessageMach_0 mach;
  IODataQueueDispatchSource_SetDataServicedHandler_Rpl_Content content;
};

/* 1614 */
struct IODataQueueDispatchSource_SetDataServicedHandler_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef action;
};

/* 1615 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_SetDataServicedHandler_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t action__descriptor;
  IODataQueueDispatchSource_SetDataServicedHandler_Msg_Content content;
};

/* 1616 */
struct IODataQueueDispatchSource_CopyDataServicedHandler_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef action;
};

/* 1617 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_CopyDataServicedHandler_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t action__descriptor;
  IODataQueueDispatchSource_CopyDataServicedHandler_Rpl_Content content;
};

/* 1618 */
struct IODataQueueDispatchSource_CopyDataServicedHandler_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1619 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODataQueueDispatchSource_CopyDataServicedHandler_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IODataQueueDispatchSource_CopyDataServicedHandler_Msg_Content content;
};

/* 1620 */
struct IODataQueueDispatchSource_LocalIVars;

/* 1621 */
struct __attribute__((aligned(8))) IODataQueueDispatchSource_IVars
{
  IODataQueueMemory_0 *dataQueue;
  IODataQueueDispatchSource *source;
  IOMemoryDescriptor_0 *memory;
  OSAction_0 *dataAvailableAction;
  OSAction_0 *dataServicedAction;
  uint64_t options;
  uint32_t queueByteCount;
};

/* 7627 */
struct __cppobj IODataQueueDispatchSource : IODispatchSource
{
  union
  {
    IODataQueueDispatchSource_IVars *ivars;
    IODataQueueDispatchSource_LocalIVars *lvars;
  };
};

/* 1622 */
typedef void (*IODataQueueDispatchSource::DataServiced_Handler)(OSMetaClassBase_0 *, OSAction_0 *);

/* 1623 */
typedef void (*IODataQueueDispatchSource::DataAvailable_Handler)(OSMetaClassBase_0 *, OSAction_0 *);

/* 1624 */
typedef kern_return_t (*IODataQueueDispatchSource::CopyDataServicedHandler_Handler)(OSMetaClassBase_0 *, OSAction_0 **);

/* 1625 */
typedef kern_return_t (*IODataQueueDispatchSource::CopyDataAvailableHandler_Handler)(OSMetaClassBase_0 *, OSAction_0 **);

/* 1626 */
typedef kern_return_t (*IODataQueueDispatchSource::CopyMemory_Handler)(OSMetaClassBase_1 *, IOMemoryDescriptor_0 **);

/* 1627 */
typedef kern_return_t (*IODataQueueDispatchSource::SetDataServicedHandler_Handler)(OSMetaClassBase_0 *, OSAction_0 *);

/* 1628 */
typedef kern_return_t (*IODataQueueDispatchSource::SetDataAvailableHandler_Handler)(OSMetaClassBase_0 *, OSAction_0 *);

/* 1629 */
typedef kern_return_t (*IODataQueueDispatchSource::Create_Handler)(uint64_t, IODispatchQueue *, IODataQueueDispatchSource **);

/* 1630 */
typedef struct *IODataQueueClientEnqueueEntryBlock;

/* 1631 */
typedef struct *IODataQueueClientDequeueEntryBlock;

/* 1632 */
struct IODataQueueDispatchSourceInterface
{
  _BYTE gap0;
};

/* 1633 */
struct IOInterruptDispatchSource_Create_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef source;
};

/* 1634 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOInterruptDispatchSource_Create_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t source__descriptor;
  IOInterruptDispatchSource_Create_Rpl_Content content;
};

/* 1635 */
struct __attribute__((aligned(8))) IOInterruptDispatchSource_Create_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef provider;
  OSObjectRef queue;
  uint32_t index;
};

/* 1636 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOInterruptDispatchSource_Create_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t provider__descriptor;
  mach_msg_port_descriptor_t queue__descriptor;
  IOInterruptDispatchSource_Create_Msg_Content content;
};

/* 1637 */
struct IOInterruptDispatchSource_GetInterruptType_Rpl_Content
{
  IORPCMessage __hdr;
  unsigned __int64 interruptType;
};

/* 1638 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOInterruptDispatchSource_GetInterruptType_Rpl
{
  IORPCMessageMach_0 mach;
  IOInterruptDispatchSource_GetInterruptType_Rpl_Content content;
};

/* 1639 */
struct __attribute__((aligned(8))) IOInterruptDispatchSource_GetInterruptType_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef provider;
  uint32_t index;
};

/* 1640 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOInterruptDispatchSource_GetInterruptType_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t provider__descriptor;
  IOInterruptDispatchSource_GetInterruptType_Msg_Content content;
};

/* 1641 */
struct IOInterruptDispatchSource_GetLastInterrupt_Rpl_Content
{
  IORPCMessage __hdr;
  unsigned __int64 count;
  unsigned __int64 time;
};

/* 1642 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOInterruptDispatchSource_GetLastInterrupt_Rpl
{
  IORPCMessageMach_0 mach;
  IOInterruptDispatchSource_GetLastInterrupt_Rpl_Content content;
};

/* 1643 */
struct IOInterruptDispatchSource_GetLastInterrupt_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1644 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOInterruptDispatchSource_GetLastInterrupt_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOInterruptDispatchSource_GetLastInterrupt_Msg_Content content;
};

/* 1645 */
struct IOInterruptDispatchSource_SetHandler_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1646 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOInterruptDispatchSource_SetHandler_Rpl
{
  IORPCMessageMach_0 mach;
  IOInterruptDispatchSource_SetHandler_Rpl_Content content;
};

/* 1647 */
struct IOInterruptDispatchSource_SetHandler_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef action;
};

/* 1648 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOInterruptDispatchSource_SetHandler_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t action__descriptor;
  IOInterruptDispatchSource_SetHandler_Msg_Content content;
};

/* 1649 */
struct IOInterruptDispatchSource_InterruptOccurred_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1650 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOInterruptDispatchSource_InterruptOccurred_Rpl
{
  IORPCMessageMach_0 mach;
  IOInterruptDispatchSource_InterruptOccurred_Rpl_Content content;
};

/* 1651 */
struct IOInterruptDispatchSource_InterruptOccurred_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef action;
  uint64_t count;
  uint64_t time;
};

/* 1652 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOInterruptDispatchSource_InterruptOccurred_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t action__descriptor;
  IOInterruptDispatchSource_InterruptOccurred_Msg_Content content;
};

/* 1653 */
struct IOInterruptDispatchSource_LocalIVars;

/* 1654 */
struct __attribute__((aligned(8))) IOInterruptDispatchSource_IVars
{
  IOService_0 *provider;
  uint32_t intIndex;
  uint32_t flags;
  int interruptType;
  IOSimpleLock_0 *lock;
  thread_t_0 waiter;
  uint64_t count;
  uint64_t time;
  OSAction_0 *action;
  bool enable;
  bool canceled;
};

/* 1655 */
typedef void (*IOInterruptDispatchSource::InterruptOccurred_Handler)(OSMetaClassBase_0 *, OSAction_0 *, uint64_t, uint64_t);

/* 1656 */
typedef kern_return_t (*IOInterruptDispatchSource::GetLastInterrupt_Handler)(OSMetaClassBase_0 *, uint64_t *, uint64_t *);

/* 1657 */
typedef kern_return_t (*IOInterruptDispatchSource::SetHandler_Handler)(OSMetaClassBase_0 *, OSAction_0 *);

/* 1658 */
typedef kern_return_t (*IOInterruptDispatchSource::GetInterruptType_Handler)(IOService_0 *, uint32_t, uint64_t *);

/* 1659 */
typedef kern_return_t (*IOInterruptDispatchSource::Create_Handler)(IOService_0 *, uint32_t, IODispatchQueue *, IOInterruptDispatchSource **);

/* 7631 */
struct __cppobj IOInterruptDispatchSource : IODispatchSource
{
  union
  {
    IOInterruptDispatchSource_IVars *ivars;
    IOInterruptDispatchSource_LocalIVars *lvars;
  };
};

/* 1660 */
struct IOInterruptDispatchSourceInterface
{
  _BYTE gap0;
};

/* 1661 */
struct IODispatchQueue_Create_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef queue;
};

/* 1662 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODispatchQueue_Create_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t queue__descriptor;
  IODispatchQueue_Create_Rpl_Content content;
};

/* 1663 */
struct IODispatchQueue_Create_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  const char *name;
  char __name[256];
  uint64_t options;
  uint64_t priority;
};

/* 1664 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODispatchQueue_Create_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IODispatchQueue_Create_Msg_Content content;
};

/* 1665 */
struct IODispatchQueue_SetPort_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1666 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODispatchQueue_SetPort_Rpl
{
  IORPCMessageMach_0 mach;
  IODispatchQueue_SetPort_Rpl_Content content;
};

/* 1667 */
struct IODispatchQueue_SetPort_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1668 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODispatchQueue_SetPort_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t port__descriptor;
  IODispatchQueue_SetPort_Msg_Content content;
};

/* 1669 */
struct IODispatchSource_CheckForWork_Rpl_Content
{
  IORPCMessage __hdr;
  uint64_t __replyBuffer[8];
};

/* 1670 */
struct __attribute__((aligned(8))) IODispatchSource_CheckForWork_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  bool synchronous;
};

/* 1671 */
struct IODispatchSource_Cancel_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1672 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODispatchSource_Cancel_Rpl
{
  IORPCMessageMach_0 mach;
  IODispatchSource_Cancel_Rpl_Content content;
};

/* 1691 */
typedef struct *IODispatchSourceCancelHandler;

/* 1673 */
struct IODispatchSource_Cancel_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  IODispatchSourceCancelHandler handler;
};

/* 1674 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODispatchSource_Cancel_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IODispatchSource_Cancel_Msg_Content content;
};

/* 1675 */
struct IODispatchSource_SetEnableWithCompletion_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1676 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODispatchSource_SetEnableWithCompletion_Rpl
{
  IORPCMessageMach_0 mach;
  IODispatchSource_SetEnableWithCompletion_Rpl_Content content;
};

/* 1677 */
struct IODispatchSource_SetEnableWithCompletion_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  bool enable;
  IODispatchSourceCancelHandler handler;
};

/* 1678 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODispatchSource_SetEnableWithCompletion_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IODispatchSource_SetEnableWithCompletion_Msg_Content content;
};

/* 1679 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODispatchSource_CheckForWork_Rpl
{
  IORPCMessageMach_0 mach;
  IODispatchSource_CheckForWork_Rpl_Content content;
};

/* 1680 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODispatchSource_CheckForWork_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IODispatchSource_CheckForWork_Msg_Content content;
};

/* 1681 */
struct IODispatchSource_SetEnable_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1682 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODispatchSource_SetEnable_Rpl
{
  IORPCMessageMach_0 mach;
  IODispatchSource_SetEnable_Rpl_Content content;
};

/* 1683 */
struct __attribute__((aligned(8))) IODispatchSource_SetEnable_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  bool enable;
};

/* 1684 */
struct __attribute__((packed)) __attribute__((aligned(4))) IODispatchSource_SetEnable_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IODispatchSource_SetEnable_Msg_Content content;
};

/* 1687 */
typedef kern_return_t (*IODispatchSource::SetEnable_Handler)(OSMetaClassBase_0 *, bool);

/* 2613 */
struct IORPC_0
{
  IORPCMessageMach_0 *message;
  IORPCMessageMach_0 *reply;
  uint32_t sendSize;
  uint32_t replySize;
};

/* 1688 */
typedef kern_return_t (*IODispatchSource::CheckForWork_Handler)(OSMetaClassBase_0 *, const IORPC_0, bool);

/* 1689 */
typedef kern_return_t (*IODispatchSource::SetEnableWithCompletion_Handler)(OSMetaClassBase_0 *, bool, IODispatchSourceCancelHandler);

/* 1690 */
typedef kern_return_t (*IODispatchSource::Cancel_Handler)(OSMetaClassBase_0 *, IODispatchSourceCancelHandler);

/* 1692 */
struct IODispatchSourceInterface
{
  _BYTE gap0;
};

/* 7180 */
struct _IOMemoryMapPrivateState
{
  uint64_t length;
  uint64_t offset;
  uint64_t options;
  uint64_t address;
};

/* 1693 */
struct IOMemoryMap__CopyState_Rpl_Content
{
  IORPCMessage __hdr;
  _IOMemoryMapPrivateState state;
};

/* 1694 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOMemoryMap__CopyState_Rpl
{
  IORPCMessageMach_0 mach;
  IOMemoryMap__CopyState_Rpl_Content content;
};

/* 1695 */
struct IOMemoryMap__CopyState_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1696 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOMemoryMap__CopyState_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOMemoryMap__CopyState_Msg_Content content;
};

/* 1697 */
struct IOBufferMemoryDescriptor_Create_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef memory;
};

/* 1698 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOBufferMemoryDescriptor_Create_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t memory__descriptor;
  IOBufferMemoryDescriptor_Create_Rpl_Content content;
};

/* 1699 */
struct IOBufferMemoryDescriptor_Create_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  uint64_t options;
  uint64_t capacity;
  uint64_t alignment;
};

/* 1700 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOBufferMemoryDescriptor_Create_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOBufferMemoryDescriptor_Create_Msg_Content content;
};

/* 1701 */
struct IOBufferMemoryDescriptor_SetLength_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1702 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOBufferMemoryDescriptor_SetLength_Rpl
{
  IORPCMessageMach_0 mach;
  IOBufferMemoryDescriptor_SetLength_Rpl_Content content;
};

/* 1703 */
struct IOBufferMemoryDescriptor_SetLength_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  uint64_t length;
};

/* 1704 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOBufferMemoryDescriptor_SetLength_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOBufferMemoryDescriptor_SetLength_Msg_Content content;
};

/* 1705 */
struct IOMemoryDescriptor_CreateWithMemoryDescriptors_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef memory;
};

/* 1706 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOMemoryDescriptor_CreateWithMemoryDescriptors_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t memory__descriptor;
  IOMemoryDescriptor_CreateWithMemoryDescriptors_Rpl_Content content;
};

/* 1707 */
struct __attribute__((aligned(8))) IOMemoryDescriptor_CreateWithMemoryDescriptors_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef __withDescriptors[32];
  uint64_t memoryDescriptorCreateOptions;
  uint32_t withDescriptorsCount;
};

/* 1708 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOMemoryDescriptor_CreateWithMemoryDescriptors_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t withDescriptors__descriptor[32];
  IOMemoryDescriptor_CreateWithMemoryDescriptors_Msg_Content content;
};

/* 1709 */
struct IOMemoryDescriptor_CreateSubMemoryDescriptor_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef memory;
};

/* 1710 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOMemoryDescriptor_CreateSubMemoryDescriptor_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t memory__descriptor;
  IOMemoryDescriptor_CreateSubMemoryDescriptor_Rpl_Content content;
};

/* 1711 */
struct IOMemoryDescriptor_CreateSubMemoryDescriptor_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef ofDescriptor;
  uint64_t memoryDescriptorCreateOptions;
  uint64_t offset;
  uint64_t length;
};

/* 1712 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOMemoryDescriptor_CreateSubMemoryDescriptor_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t ofDescriptor__descriptor;
  IOMemoryDescriptor_CreateSubMemoryDescriptor_Msg_Content content;
};

/* 1713 */
struct IOMemoryDescriptor_CreateMapping_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef map;
};

/* 1714 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOMemoryDescriptor_CreateMapping_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t map__descriptor;
  IOMemoryDescriptor_CreateMapping_Rpl_Content content;
};

/* 1715 */
struct IOMemoryDescriptor_CreateMapping_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  uint64_t options;
  uint64_t address;
  uint64_t offset;
  uint64_t length;
  uint64_t alignment;
};

/* 1716 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOMemoryDescriptor_CreateMapping_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOMemoryDescriptor_CreateMapping_Msg_Content content;
};

/* 7182 */
struct _IOMDPrivateState
{
  uint64_t length;
  uint64_t options;
};

/* 1717 */
struct IOMemoryDescriptor__CopyState_Rpl_Content
{
  IORPCMessage __hdr;
  _IOMDPrivateState state;
};

/* 1718 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOMemoryDescriptor__CopyState_Rpl
{
  IORPCMessageMach_0 mach;
  IOMemoryDescriptor__CopyState_Rpl_Content content;
};

/* 1719 */
struct IOMemoryDescriptor__CopyState_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1720 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOMemoryDescriptor__CopyState_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOMemoryDescriptor__CopyState_Msg_Content content;
};

/* 1721 */
struct IOUserClient_CopyClientMemoryForType_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef memory;
  unsigned __int64 options;
};

/* 1722 */
struct IOUserClient_CopyClientMemoryForType_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  uint64_t type;
};

/* 1723 */
struct __attribute__((aligned(8))) IOUserClient__ExternalMethod_Rpl_Content
{
  IORPCMessage __hdr;
  OSData_0 *structureOutput;
  unsigned __int64 *scalarOutput;
  unsigned __int64 __scalarOutput[16];
  unsigned int scalarOutputCount;
};

/* 1724 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserClient__ExternalMethod_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_ool_descriptor_t structureOutput__descriptor;
  IOUserClient__ExternalMethod_Rpl_Content content;
};

/* 1725 */
struct IOUserClient__ExternalMethod_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSData_0 *structureInput;
  OSObjectRef structureInputDescriptor;
  OSObjectRef structureOutputDescriptor;
  OSObjectRef completion;
  uint64_t selector;
  const unsigned __int64 *scalarInput;
  unsigned __int64 __scalarInput[16];
  uint32_t scalarInputCount;
  unsigned int scalarOutputCount;
  uint64_t structureOutputMaximumSize;
};

/* 1726 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserClient__ExternalMethod_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t structureInput__descriptor;
  mach_msg_port_descriptor_t structureInputDescriptor__descriptor;
  mach_msg_port_descriptor_t structureOutputDescriptor__descriptor;
  mach_msg_port_descriptor_t completion__descriptor;
  IOUserClient__ExternalMethod_Msg_Content content;
};

/* 1727 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserClient_CopyClientMemoryForType_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t memory__descriptor;
  IOUserClient_CopyClientMemoryForType_Rpl_Content content;
};

/* 1728 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserClient_CopyClientMemoryForType_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOUserClient_CopyClientMemoryForType_Msg_Content content;
};

/* 1729 */
struct IOUserClient_AsyncCompletion_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1730 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserClient_AsyncCompletion_Rpl
{
  IORPCMessageMach_0 mach;
  IOUserClient_AsyncCompletion_Rpl_Content content;
};

/* 1731 */
struct __attribute__((aligned(8))) IOUserClient_AsyncCompletion_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef action;
  IOReturn_0 status;
  const unsigned __int64 *asyncData;
  unsigned __int64 __asyncData[16];
  uint32_t asyncDataCount;
};

/* 1732 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserClient_AsyncCompletion_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t action__descriptor;
  IOUserClient_AsyncCompletion_Msg_Content content;
};

/* 1733 */
struct IOUserClient_CopyClientEntitlements_Rpl_Content
{
  IORPCMessage __hdr;
  OSDictionary_0 *entitlements;
};

/* 1734 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserClient_CopyClientEntitlements_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_ool_descriptor_t entitlements__descriptor;
  IOUserClient_CopyClientEntitlements_Rpl_Content content;
};

/* 1735 */
struct IOUserClient_CopyClientEntitlements_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1736 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserClient_CopyClientEntitlements_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOUserClient_CopyClientEntitlements_Msg_Content content;
};

/* 1737 */
struct IOUserClient_CreateMemoryDescriptorFromClient_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef memory;
};

/* 1738 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserClient_CreateMemoryDescriptorFromClient_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t memory__descriptor;
  IOUserClient_CreateMemoryDescriptorFromClient_Rpl_Content content;
};

/* 1739 */
struct IOUserClient_CreateMemoryDescriptorFromClient_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  uint64_t memoryDescriptorCreateOptions;
  uint32_t segmentsCount;
  const IOAddressSegment *segments;
  IOAddressSegment __segments[32];
};

/* 1740 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOUserClient_CreateMemoryDescriptorFromClient_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOUserClient_CreateMemoryDescriptorFromClient_Msg_Content content;
};

/* 1741 */
struct OSAction_IOUserClient_KernelCompletion_LocalIVars;

/* 1742 */
struct OSAction_IOUserClient_KernelCompletion_IVars;

/* 1743 */
struct OSAction_IOUserClient_KernelCompletionInterface
{
  _BYTE gap0;
};

/* 1744 */
struct IOService_StateNotificationItemSet_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1745 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_StateNotificationItemSet_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_StateNotificationItemSet_Rpl_Content content;
};

/* 1746 */
struct IOService_StateNotificationItemSet_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSString_0 *itemName;
  OSDictionary_0 *value;
};

/* 1747 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_StateNotificationItemSet_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t itemName__descriptor;
  mach_msg_ool_descriptor_t value__descriptor;
  IOService_StateNotificationItemSet_Msg_Content content;
};

/* 1748 */
struct IOService_StateNotificationItemCreate_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1749 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_StateNotificationItemCreate_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_StateNotificationItemCreate_Rpl_Content content;
};

/* 1750 */
struct IOService_StateNotificationItemCreate_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSString_0 *itemName;
  OSDictionary_0 *schema;
};

/* 1751 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_StateNotificationItemCreate_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t itemName__descriptor;
  mach_msg_ool_descriptor_t schema__descriptor;
  IOService_StateNotificationItemCreate_Msg_Content content;
};

/* 1752 */
struct IOService__ClaimSystemWakeEvent_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1753 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService__ClaimSystemWakeEvent_Rpl
{
  IORPCMessageMach_0 mach;
  IOService__ClaimSystemWakeEvent_Rpl_Content content;
};

/* 2276 */
typedef OSObject_1 OSContainer;

/* 1754 */
struct IOService__ClaimSystemWakeEvent_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef device;
  OSContainer *details;
  uint64_t flags;
  const char *reason;
  char __reason[128];
};

/* 1755 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService__ClaimSystemWakeEvent_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t device__descriptor;
  mach_msg_ool_descriptor_t details__descriptor;
  IOService__ClaimSystemWakeEvent_Msg_Content content;
};

/* 1756 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_UpdateReport_Rpl_Content
{
  IORPCMessage __hdr;
  unsigned int outElementCount;
};

/* 1757 */
struct IOService_UpdateReport_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_UpdateReport_Rpl_Content content;
};

/* 1758 */
struct IOService_UpdateReport_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSData_0 *channels;
  OSObjectRef buffer;
  uint32_t action;
  uint64_t offset;
  uint64_t capacity;
};

/* 1759 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_UpdateReport_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t channels__descriptor;
  mach_msg_port_descriptor_t buffer__descriptor;
  IOService_UpdateReport_Msg_Content content;
};

/* 1760 */
struct IOService_CoreAnalyticsSendEvent_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1761 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_CoreAnalyticsSendEvent_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_CoreAnalyticsSendEvent_Rpl_Content content;
};

/* 1762 */
struct IOService_CoreAnalyticsSendEvent_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSString_0 *eventName;
  OSDictionary_0 *eventPayload;
  uint64_t options;
};

/* 1763 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_CoreAnalyticsSendEvent_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t eventName__descriptor;
  mach_msg_ool_descriptor_t eventPayload__descriptor;
  IOService_CoreAnalyticsSendEvent_Msg_Content content;
};

/* 1764 */
struct IOService_SetProperties_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1765 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_SetProperties_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_SetProperties_Rpl_Content content;
};

/* 1766 */
struct IOService_SetProperties_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSDictionary_0 *properties;
};

/* 1767 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_SetProperties_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t properties__descriptor;
  IOService_SetProperties_Msg_Content content;
};

/* 1768 */
struct IOService_CopyProperties_Rpl_Content
{
  IORPCMessage __hdr;
  OSDictionary_0 *properties;
};

/* 1769 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_CopyProperties_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_ool_descriptor_t properties__descriptor;
  IOService_CopyProperties_Rpl_Content content;
};

/* 1770 */
struct IOService_CopyProperties_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1771 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_CopyProperties_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_CopyProperties_Msg_Content content;
};

/* 1772 */
struct IOService_StringFromReturn_Rpl_Content
{
  IORPCMessage __hdr;
  OSString_0 *str;
};

/* 1773 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_StringFromReturn_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_ool_descriptor_t str__descriptor;
  IOService_StringFromReturn_Rpl_Content content;
};

/* 1774 */
struct __attribute__((aligned(8))) IOService_StringFromReturn_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  IOReturn_0 retval;
};

/* 1775 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_StringFromReturn_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_StringFromReturn_Msg_Content content;
};

/* 1776 */
struct IOService_SearchProperty_Rpl_Content
{
  IORPCMessage __hdr;
  OSContainer *property;
};

/* 1777 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_SearchProperty_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_ool_descriptor_t property__descriptor;
  IOService_SearchProperty_Rpl_Content content;
};

/* 1778 */
struct IOService_SearchProperty_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  const char *name;
  char __name[128];
  const char *plane;
  char __plane[128];
  uint64_t options;
};

/* 1779 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_SearchProperty_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_SearchProperty_Msg_Content content;
};

/* 1780 */
struct IOService_ChangePowerState_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1781 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_ChangePowerState_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_ChangePowerState_Rpl_Content content;
};

/* 1782 */
struct __attribute__((aligned(8))) IOService_ChangePowerState_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  uint32_t powerFlags;
};

/* 1783 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_ChangePowerState_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_ChangePowerState_Msg_Content content;
};

/* 1784 */
struct IOService_Stop_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1785 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_Stop_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_Stop_Rpl_Content content;
};

/* 1786 */
struct IOService_Stop_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef provider;
};

/* 1787 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_Stop_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t provider__descriptor;
  IOService_Stop_Msg_Content content;
};

/* 1788 */
struct IOService_CopyProviderProperties_Rpl_Content
{
  IORPCMessage __hdr;
  OSArray_0 *properties;
};

/* 1789 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_CopyProviderProperties_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_ool_descriptor_t properties__descriptor;
  IOService_CopyProviderProperties_Rpl_Content content;
};

/* 1790 */
struct IOService_CopyProviderProperties_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSArray_0 *propertyKeys;
};

/* 1791 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_CopyProviderProperties_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t propertyKeys__descriptor;
  IOService_CopyProviderProperties_Msg_Content content;
};

/* 1792 */
struct IOService_CreateDefaultDispatchQueue_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef queue;
};

/* 1793 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_CreateDefaultDispatchQueue_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t queue__descriptor;
  IOService_CreateDefaultDispatchQueue_Rpl_Content content;
};

/* 1794 */
struct IOService_CreateDefaultDispatchQueue_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1795 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_CreateDefaultDispatchQueue_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_CreateDefaultDispatchQueue_Msg_Content content;
};

/* 1796 */
struct IOService_CopyName_Rpl_Content
{
  IORPCMessage __hdr;
  OSString_0 *name;
};

/* 1797 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_CopyName_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_ool_descriptor_t name__descriptor;
  IOService_CopyName_Rpl_Content content;
};

/* 1798 */
struct IOService_CopyName_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1799 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_CopyName_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_CopyName_Msg_Content content;
};

/* 1800 */
struct IOService_Terminate_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1801 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_Terminate_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_Terminate_Rpl_Content content;
};

/* 1802 */
struct IOService_Terminate_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  uint64_t options;
};

/* 1803 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_Terminate_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_Terminate_Msg_Content content;
};

/* 1804 */
struct IOService_Create_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef result;
};

/* 1805 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_Create_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t result__descriptor;
  IOService_Create_Rpl_Content content;
};

/* 1806 */
struct IOService_Create_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef provider;
  const char *propertiesKey;
  char __propertiesKey[128];
};

/* 1807 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_Create_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t provider__descriptor;
  IOService_Create_Msg_Content content;
};

/* 1808 */
struct IOService_CopySystemStateNotificationService_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef service;
};

/* 1809 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_CopySystemStateNotificationService_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t service__descriptor;
  IOService_CopySystemStateNotificationService_Rpl_Content content;
};

/* 1810 */
struct IOService_CopySystemStateNotificationService_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1811 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_CopySystemStateNotificationService_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_CopySystemStateNotificationService_Msg_Content content;
};

/* 1812 */
struct IOService_GetRegistryEntryID_Rpl_Content
{
  IORPCMessage __hdr;
  unsigned __int64 registryEntryID;
};

/* 1813 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_GetRegistryEntryID_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_GetRegistryEntryID_Rpl_Content content;
};

/* 1814 */
struct IOService_GetRegistryEntryID_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1815 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_GetRegistryEntryID_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_GetRegistryEntryID_Msg_Content content;
};

/* 1816 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_GetBusyState_Rpl_Content
{
  IORPCMessage __hdr;
  unsigned int busyState;
};

/* 1817 */
struct IOService_GetBusyState_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_GetBusyState_Rpl_Content content;
};

/* 1818 */
struct IOService_GetBusyState_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1819 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_GetBusyState_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_GetBusyState_Msg_Content content;
};

/* 1820 */
struct IOService_SendIOMessageServicePropertyChange_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1821 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_SendIOMessageServicePropertyChange_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_SendIOMessageServicePropertyChange_Rpl_Content content;
};

/* 1822 */
struct IOService_SendIOMessageServicePropertyChange_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1823 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_SendIOMessageServicePropertyChange_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_SendIOMessageServicePropertyChange_Msg_Content content;
};

/* 1824 */
struct IOService_Start_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1825 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_Start_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_Start_Rpl_Content content;
};

/* 1826 */
struct IOService_Start_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef provider;
};

/* 1827 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_Start_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t provider__descriptor;
  IOService_Start_Msg_Content content;
};

/* 1828 */
struct IOService_Stop_async_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1829 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_Stop_async_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_Stop_async_Rpl_Content content;
};

/* 1830 */
struct IOService_Stop_async_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef provider;
};

/* 1831 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_Stop_async_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t provider__descriptor;
  IOService_Stop_async_Msg_Content content;
};

/* 1832 */
struct IOService_RemoveProperty_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1833 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_RemoveProperty_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_RemoveProperty_Rpl_Content content;
};

/* 1834 */
struct IOService_RemoveProperty_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSString_0 *propertyName;
};

/* 1835 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_RemoveProperty_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t propertyName__descriptor;
  IOService_RemoveProperty_Msg_Content content;
};

/* 1836 */
struct IOService_NewUserClient_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef userClient;
};

/* 1837 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_NewUserClient_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t userClient__descriptor;
  IOService_NewUserClient_Rpl_Content content;
};

/* 1838 */
struct __attribute__((aligned(8))) IOService_NewUserClient_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  uint32_t type;
};

/* 1839 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_NewUserClient_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_NewUserClient_Msg_Content content;
};

/* 1840 */
struct IOService_UserSetProperties_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1841 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_UserSetProperties_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_UserSetProperties_Rpl_Content content;
};

/* 1842 */
struct IOService_UserSetProperties_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSContainer *properties;
};

/* 1843 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_UserSetProperties_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t properties__descriptor;
  IOService_UserSetProperties_Msg_Content content;
};

/* 1844 */
struct IOService_AdjustBusy_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1845 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_AdjustBusy_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_AdjustBusy_Rpl_Content content;
};

/* 1846 */
struct __attribute__((aligned(8))) IOService_AdjustBusy_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  int32_t delta;
};

/* 1847 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_AdjustBusy_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_AdjustBusy_Msg_Content content;
};

/* 1848 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_ConfigureReport_Rpl_Content
{
  IORPCMessage __hdr;
  unsigned int outCount;
};

/* 1849 */
struct IOService_ConfigureReport_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_ConfigureReport_Rpl_Content content;
};

/* 1850 */
struct __attribute__((aligned(8))) IOService_ConfigureReport_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSData_0 *channels;
  uint32_t action;
};

/* 1851 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_ConfigureReport_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t channels__descriptor;
  IOService_ConfigureReport_Msg_Content content;
};

/* 1852 */
struct IOService_JoinPMTree_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1853 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_JoinPMTree_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_JoinPMTree_Rpl_Content content;
};

/* 1854 */
struct IOService_JoinPMTree_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1855 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_JoinPMTree_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_JoinPMTree_Msg_Content content;
};

/* 1856 */
struct IOService_SetLegend_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1857 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_SetLegend_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_SetLegend_Rpl_Content content;
};

/* 1858 */
struct __attribute__((aligned(8))) IOService_SetLegend_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSArray_0 *legend;
  bool is_public;
};

/* 1859 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_SetLegend_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t legend__descriptor;
  IOService_SetLegend_Msg_Content content;
};

/* 1860 */
struct IOService_SetPowerState_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1861 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_SetPowerState_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_SetPowerState_Rpl_Content content;
};

/* 1862 */
struct __attribute__((aligned(8))) IOService_SetPowerState_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  uint32_t powerFlags;
};

/* 1863 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_SetPowerState_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_SetPowerState_Msg_Content content;
};

/* 1864 */
struct IOService__NewUserClient_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef userClient;
};

/* 1865 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService__NewUserClient_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t userClient__descriptor;
  IOService__NewUserClient_Rpl_Content content;
};

/* 1866 */
struct __attribute__((aligned(8))) IOService__NewUserClient_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSDictionary_0 *entitlements;
  uint32_t type;
};

/* 1867 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService__NewUserClient_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t entitlements__descriptor;
  IOService__NewUserClient_Msg_Content content;
};

/* 1868 */
struct IOService_SetName_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1869 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_SetName_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_SetName_Rpl_Content content;
};

/* 1870 */
struct IOService_SetName_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  const char *name;
  char __name[128];
};

/* 1871 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_SetName_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_SetName_Msg_Content content;
};

/* 1872 */
struct IOService_RequireMaxBusStall_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1873 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_RequireMaxBusStall_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_RequireMaxBusStall_Rpl_Content content;
};

/* 1874 */
struct IOService_RequireMaxBusStall_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  uint64_t maxBusStall;
};

/* 1875 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_RequireMaxBusStall_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_RequireMaxBusStall_Msg_Content content;
};

/* 1876 */
struct IOService_RegisterService_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1877 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_RegisterService_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_RegisterService_Rpl_Content content;
};

/* 1878 */
struct IOService_RegisterService_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1879 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_RegisterService_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  IOService_RegisterService_Msg_Content content;
};

/* 1880 */
struct IOService_ClientCrashed_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1881 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_ClientCrashed_Rpl
{
  IORPCMessageMach_0 mach;
  IOService_ClientCrashed_Rpl_Content content;
};

/* 1882 */
struct IOService_ClientCrashed_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef client;
  uint64_t options;
};

/* 1883 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_ClientCrashed_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t client__descriptor;
  IOService_ClientCrashed_Msg_Content content;
};

/* 1884 */
struct IOService_StateNotificationItemCopy_Rpl_Content
{
  IORPCMessage __hdr;
  OSDictionary_0 *value;
};

/* 1885 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_StateNotificationItemCopy_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_ool_descriptor_t value__descriptor;
  IOService_StateNotificationItemCopy_Rpl_Content content;
};

/* 1886 */
struct IOService_StateNotificationItemCopy_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSString_0 *itemName;
};

/* 1887 */
struct __attribute__((packed)) __attribute__((aligned(4))) IOService_StateNotificationItemCopy_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_ool_descriptor_t itemName__descriptor;
  IOService_StateNotificationItemCopy_Msg_Content content;
};

/* 1888 */
struct OSAction_CreateWithTypeName_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef action;
};

/* 1889 */
struct __attribute__((packed)) __attribute__((aligned(4))) OSAction_CreateWithTypeName_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t action__descriptor;
  OSAction_CreateWithTypeName_Rpl_Content content;
};

/* 1890 */
struct OSAction_CreateWithTypeName_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef target;
  OSString_0 *typeName;
  uint64_t targetmsgid;
  uint64_t msgid;
  size_t referenceSize;
};

/* 1891 */
struct __attribute__((packed)) __attribute__((aligned(4))) OSAction_CreateWithTypeName_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t target__descriptor;
  mach_msg_ool_descriptor_t typeName__descriptor;
  OSAction_CreateWithTypeName_Msg_Content content;
};

/* 1892 */
struct OSAction_Create_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef action;
};

/* 1893 */
struct __attribute__((packed)) __attribute__((aligned(4))) OSAction_Create_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t action__descriptor;
  OSAction_Create_Rpl_Content content;
};

/* 1894 */
struct OSAction_Create_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef target;
  uint64_t targetmsgid;
  uint64_t msgid;
  size_t referenceSize;
};

/* 1895 */
struct __attribute__((packed)) __attribute__((aligned(4))) OSAction_Create_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t target__descriptor;
  OSAction_Create_Msg_Content content;
};

/* 1896 */
struct OSAction_Aborted_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1897 */
struct __attribute__((packed)) __attribute__((aligned(4))) OSAction_Aborted_Rpl
{
  IORPCMessageMach_0 mach;
  OSAction_Aborted_Rpl_Content content;
};

/* 1898 */
struct OSAction_Aborted_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
};

/* 1899 */
struct __attribute__((packed)) __attribute__((aligned(4))) OSAction_Aborted_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  OSAction_Aborted_Msg_Content content;
};

/* 1900 */
struct OSObject_CopyDispatchQueue_Rpl_Content
{
  IORPCMessage __hdr;
  OSObjectRef queue;
};

/* 1901 */
struct OSObject_CopyDispatchQueue_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  const char *name;
  char __name[256];
};

/* 1902 */
struct msg_labels_t
{
  mach_port_name_t_0 sender;
};

/* 1903 */
typedef int mach_msg_filter_id;

/* 1904 */
typedef vm_offset_t mach_port_context_t;

/* 1905 */
typedef natural_t mach_port_seqno_t;

/* 1906 */
typedef unsigned int mach_msg_trailer_size_t;

/* 1907 */
typedef unsigned int mach_msg_trailer_type_t;

/* 1908 */
struct OSObject_SetDispatchQueue_Rpl_Content
{
  IORPCMessage __hdr;
};

/* 1909 */
struct OSObject_SetDispatchQueue_Msg_Content
{
  IORPCMessage __hdr;
  OSObjectRef __object;
  OSObjectRef queue;
  const char *name;
  char __name[256];
};

/* 1910 */
typedef mach_msg_mac_trailer_t mach_msg_max_trailer_t;

/* 9172 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_msg_mac_trailer_t
{
  mach_msg_trailer_type_t msgh_trailer_type;
  mach_msg_trailer_size_t msgh_trailer_size;
  mach_port_seqno_t msgh_seqno;
  security_token_t msgh_sender;
  audit_token_t msgh_audit;
  mach_port_context_t msgh_context;
  mach_msg_filter_id msgh_ad;
  msg_labels_t msgh_labels;
};

/* 1911 */
struct __attribute__((packed)) __attribute__((aligned(4))) OSObject_CopyDispatchQueue_Rpl
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t queue__descriptor;
  OSObject_CopyDispatchQueue_Rpl_Content content;
};

/* 1912 */
struct __attribute__((packed)) __attribute__((aligned(4))) OSObject_CopyDispatchQueue_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  OSObject_CopyDispatchQueue_Msg_Content content;
};

/* 1913 */
struct __attribute__((packed)) __attribute__((aligned(4))) OSObject_SetDispatchQueue_Rpl
{
  IORPCMessageMach_0 mach;
  OSObject_SetDispatchQueue_Rpl_Content content;
};

/* 1914 */
struct __attribute__((packed)) __attribute__((aligned(4))) OSObject_SetDispatchQueue_Msg
{
  IORPCMessageMach_0 mach;
  mach_msg_port_descriptor_t __object__descriptor;
  mach_msg_port_descriptor_t queue__descriptor;
  OSObject_SetDispatchQueue_Msg_Content content;
};

/* 1915 */
struct compression_stream_t
{
  uint8_t *dst_ptr;
  size_t dst_size;
  const uint8_t *src_ptr;
  size_t src_size;
  void *state;
};

/* 1916 */
enum compression_algorithm_t : __int32
{
  COMPRESSION_LZ4 = 0x100,
};

/* 1917 */
enum compression_stream_operation_t : __int32
{
  COMPRESSION_STREAM_ENCODE = 0x0,
  COMPRESSION_STREAM_DECODE = 0x1,
};

/* 1918 */
enum compression_status_t : __int32
{
  COMPRESSION_STATUS_OK = 0x0,
  COMPRESSION_STATUS_ERROR = 0xFFFFFFFF,
  COMPRESSION_STATUS_END = 0x1,
};

/* 1919 */
typedef int (*compression_stream_identify_algorithm_proc)(const uint8_t *);

/* 1920 */
typedef compression_status_t (*compression_stream_process_proc)(compression_stream_t *, int);

/* 1921 */
typedef compression_status_t (*compression_stream_destroy_proc)(compression_stream_t *);

/* 1922 */
typedef compression_status_t (*compression_stream_reinit_proc)(compression_stream_t *, compression_stream_operation_t, compression_algorithm_t);

/* 1923 */
typedef compression_status_t (*compression_stream_init_proc)(compression_stream_t *, compression_stream_operation_t, compression_algorithm_t);

/* 1924 */
struct compression_ki_t
{
  compression_stream_init_proc compression_stream_init;
  compression_stream_reinit_proc compression_stream_reinit;
  compression_stream_destroy_proc compression_stream_destroy;
  compression_stream_process_proc compression_stream_process;
  compression_stream_identify_algorithm_proc compression_stream_identify_algorithm;
};

/* 1925 */
struct Block_byref_3
{
  const char *layout;
};

/* 1926 */
typedef StorageSignedFunctionPointer<void (*)(Block_byref *),(ptrauth_key)0> BlockByrefDestroyFunction;

/* 7638 */
struct __cppobj StorageSignedFunctionPointer<void (*)(Block_byref *),(ptrauth_key)0>
{
  uintptr_t bits;
};

/* 1927 */
typedef StorageSignedFunctionPointer<void (*)(Block_byref *,Block_byref *),(ptrauth_key)0> BlockByrefKeepFunction;

/* 7639 */
struct __cppobj StorageSignedFunctionPointer<void (*)(Block_byref *,Block_byref *),(ptrauth_key)0>
{
  uintptr_t bits;
};

/* 1928 */
struct Block_byref_2
{
  BlockByrefKeepFunction byref_keep;
  BlockByrefDestroyFunction byref_destroy;
};

/* 1929 */
struct Block_byref
{
  void *isa;
  Block_byref *forwarding;
  volatile int32_t flags;
  uint32_t size;
};

/* 1930 */
struct Block_descriptor_3
{
  const char *signature;
  const char *layout;
};

/* 1931 */
typedef StorageSignedFunctionPointer<void (*)(const void *),(ptrauth_key)0> BlockDisposeFunction;

/* 7641 */
struct __cppobj StorageSignedFunctionPointer<void (*)(const void *),(ptrauth_key)0>
{
  uintptr_t bits;
};

/* 1932 */
typedef StorageSignedFunctionPointer<void (*)(void *,const void *),(ptrauth_key)0> BlockCopyFunction;

/* 7642 */
struct __cppobj StorageSignedFunctionPointer<void (*)(void *,const void *),(ptrauth_key)0>
{
  uintptr_t bits;
};

/* 1933 */
struct Block_descriptor_2
{
  BlockCopyFunction copy;
  BlockDisposeFunction dispose;
};

/* 1934 */
struct Block_descriptor_1
{
  uintptr_t reserved;
  uintptr_t size;
};

/* 1935 */
typedef StorageSignedFunctionPointer<void (*)(void *,___),(ptrauth_key)0> BlockInvokeFunction;

/* 7640 */
struct __cppobj StorageSignedFunctionPointer<void (*)(void *,___),(ptrauth_key)0>
{
  uintptr_t bits;
};

/* 1936 */
struct Block_layout
{
  void *isa;
  volatile int32_t flags;
  int32_t reserved;
  BlockInvokeFunction invoke;
  Block_descriptor_1 *descriptor;
};

/* 1937 */
typedef kern_return_t (*OSEntitlements_copyEntitlementAsOSObjectWithProc)(const proc_t, const char *, void **);

/* 1938 */
typedef kern_return_t (*OSEntitlements_copyEntitlementAsOSObject)(const void *, const char *, void **);

/* 1939 */
typedef kern_return_t (*OSEntitlements_queryEntitlementStringWithProc)(const proc_t, const char *, const char *);

/* 1940 */
typedef kern_return_t (*OSEntitlements_queryEntitlementString)(const void *, const char *, const char *);

/* 1941 */
typedef kern_return_t (*OSEntitlements_queryEntitlementBooleanWithProc)(const proc_t, const char *);

/* 1942 */
typedef kern_return_t (*OSEntitlements_queryEntitlementBoolean)(const void *, const char *);

/* 1943 */
typedef kern_return_t (*OSEntitlements_adjustContextWithoutMonitor)(void *, cs_blob *);

/* 1992 */
typedef CEQueryContext *CEQueryContext_t;

/* 1944 */
typedef kern_return_t (*OSEntitlements_adjustContextWithMonitor)(void *, const CEQueryContext_t, const void *, const char *, const uint32_t);

/* 2007 */
typedef const CERuntime *CERuntime_t;

/* 1994 */
typedef CEAccelerationElement CEAccelerationElement_t;

/* 1996 */
struct CEAccelerationContext
{
  CEAccelerationElement_t *index;
  size_t index_count;
};

/* 1995 */
typedef unsigned __int64 ccder_tag;

/* 1993 */
struct ccder_read_blob
{
  const uint8_t *der;
  const uint8_t *der_end;
};

/* 9178 */
struct der_vm_context
{
  CERuntime_t runtime;
  CEAccelerationContext lookup;
  ccder_tag dictionary_tag;
  bool sorted;
  bool valid;
  union
  {
    ccder_read_blob ccstate;
    struct
    {
      const uint8_t *der_start;
      const uint8_t *der_end;
    } state;
  };
};

/* 1997 */
typedef der_vm_context der_vm_context_t;

/* 1998 */
struct __attribute__((aligned(8))) CEQueryContext
{
  der_vm_context_t der_context;
  bool managed;
};

/* 2005 */
typedef void *(*CERuntimeMalloc)(const CERuntime_t, size_t);

/* 2004 */
typedef void (*CERuntimeFree)(const CERuntime_t, void *);

/* 2003 */
typedef void (*CERuntimeLog)(const CERuntime_t, const char *, ...);

/* 2002 */
typedef void (*CERuntimeAbort)(const CERuntime_t, const char *, ...);

/* 2001 */
typedef bool (*CERuntimeInternalStatus)(const CERuntime_t);

/* 2000 */
typedef void *(*CERuntimeAllocIndex)(const CERuntime_t, size_t);

/* 1999 */
typedef void (*CERuntimeFreeIndex)(const CERuntime_t, void *, size_t);

/* 2006 */
struct CERuntime
{
  const uint64_t version;
  const CERuntimeMalloc alloc;
  const CERuntimeFree free;
  const CERuntimeLog log;
  const CERuntimeAbort abort;
  const CERuntimeInternalStatus internalStatus;
  const CERuntimeAllocIndex allocIndex;
  const CERuntimeFreeIndex freeIndex;
};

/* 7652 */
struct CEAccelerationElement
{
  uint32_t key_offset;
  uint32_t key_length;
};

/* 1945 */
typedef uint64_t TCCapabilities_t;

/* 1946 */
typedef _TrustCacheQueryToken TrustCacheQueryToken_t;

/* 1951 */
typedef _TrustCache_0 TrustCache_t;

/* 7645 */
struct _TrustCacheQueryToken
{
  const TrustCache_t *trustCache;
  const void *trustCacheEntry;
};

/* 1950 */
typedef uint8_t TCType_t;

/* 1949 */
typedef _TrustCacheModuleBase TrustCacheModuleBase_t;

/* 8242 */
struct _TrustCache_0
{
  _TrustCache *next;
  _TrustCache *prev;
  TCType_t type;
  size_t moduleSize;
  const TrustCacheModuleBase_t *module;
};

/* 7648 */
struct _TrustCache
{
  _TrustCache *next;
  _TrustCache *prev;
  TCType_t type;
  size_t moduleSize;
  const TrustCacheModuleBase_t *module;
};

/* 7647 */
struct _TrustCacheModuleBase
{
  uint32_t version;
};

/* 1947 */
typedef uint8_t TCQueryType_t;

/* 1948 */
typedef _TrustCacheMutableRuntime TrustCacheMutableRuntime_t;

/* 7646 */
struct _TrustCacheMutableRuntime
{
  TrustCache_t *loadableTCHead;
};

/* 1952 */
typedef _img4_nonce img4_nonce_t;

/* 2035 */
typedef uint16_t img4_struct_version_t;

/* 7655 */
struct _img4_nonce
{
  img4_struct_version_t i4n_version;
  uint8_t i4n_nonce[48];
  uint32_t i4n_length;
};

/* 1953 */
typedef _img4_buff img4_buff_t;

/* 1973 */
typedef _img4_runtime img4_runtime_t;

/* 1970 */
typedef void (*img4_runtime_dealloc_t)(const img4_runtime_t *, void *, size_t);

/* 9175 */
struct _img4_buff
{
  img4_struct_version_t i4b_version;
  uint8_t *i4b_bytes;
  size_t i4b_len;
  img4_runtime_dealloc_t i4b_dealloc;
};

/* 1972 */
typedef void (*img4_runtime_init_t)(const img4_runtime_t *);

/* 1971 */
typedef void *(*img4_runtime_alloc_t)(const img4_runtime_t *, size_t);

/* 1968 */
typedef void *(*img4_runtime_log_handle_t)(const img4_runtime_t *);

/* 3749 */
typedef void img4_runtime_object_spec_t;

/* 1962 */
typedef errno_t (*img4_runtime_execute_object_t)(const img4_runtime_t *, const img4_runtime_object_spec_t *, const img4_buff_t *, const img4_buff_t *);

/* 1961 */
typedef errno_t (*img4_runtime_copy_object_t)(const img4_runtime_t *, const img4_runtime_object_spec_t *, img4_buff_t *, size_t *);

/* 1960 */
typedef void *(*img4_runtime_alloc_type_t)(const img4_runtime_t *, void *);

/* 1959 */
typedef void (*img4_runtime_dealloc_type_t)(const img4_runtime_t *, void *, void *);

/* 9177 */
struct __attribute__((aligned(32))) _img4_runtime
{
  img4_struct_version_t i4rt_version;
  const char *i4rt_name;
  img4_runtime_init_t i4rt_init;
  img4_runtime_alloc_t i4rt_alloc;
  img4_runtime_dealloc_t i4rt_dealloc;
  __attribute__((aligned(16))) img4_runtime_log_handle_t i4rt_log_handle;
  _BYTE gap38[32];
  void *i4rt_context;
  _BYTE gap60[8];
  img4_runtime_execute_object_t i4rt_execute_object;
  img4_runtime_copy_object_t i4rt_copy_object;
  img4_runtime_alloc_type_t i4rt_alloc_type;
  img4_runtime_dealloc_type_t i4rt_dealloc_type;
};

/* 1954 */
typedef _img4_cstr img4_cstr_t;

/* 7649 */
struct _img4_cstr
{
  size_t i4cs_len;
  char i4cs_cstr[64];
};

/* 1955 */
typedef _img4_dgst img4_dgst_t;

/* 9176 */
struct _img4_dgst
{
  img4_struct_version_t i4d_version;
  size_t i4d_len;
  uint8_t i4d_bytes[48];
};

/* 1956 */
typedef void img4_runtime_copy_nonce_t;

/* 1957 */
typedef void img4_runtime_roll_nonce_t;

/* 1958 */
typedef void img4_runtime_set_nonce_t;

/* 1963 */
typedef void img4_runtime_get_identifier_cstr_t;

/* 1964 */
typedef void img4_runtime_get_identifier_digest_t;

/* 1965 */
typedef void img4_runtime_get_identifier_uint64_t;

/* 1966 */
typedef void img4_runtime_get_identifier_uint32_t;

/* 1967 */
typedef void img4_runtime_get_identifier_bool_t;

/* 1969 */
typedef void img4_runtime_log_t;

/* 1974 */
struct _TrustCacheRuntime
{
  const img4_runtime_t *image4RT;
  bool allowSecondStaticTC;
  bool allowEngineeringTC;
  bool allowLegacyTC;
  TrustCache_t *staticTCHead;
  TrustCache_t *engineeringTCHead;
  TrustCacheMutableRuntime_t *mutableRT;
};

/* 1975 */
typedef _TrustCacheRuntime TrustCacheRuntime_t;

/* 7650 */
struct _TCReturn
{
  union
  {
    uint32_t rawValue;
    struct
    {
      uint8_t component;
      uint8_t error;
      uint16_t uniqueError;
    };
  };
};

/* 7644 */
typedef _TCReturn TCReturn_t;

/* 1976 */
typedef TCReturn_t (*getUUID_t)(const TrustCache_t *, uint8_t *);

/* 9174 */
typedef _TrustCache TrustCache_t_0;

/* 1977 */
typedef TCReturn_t (*getModule_t)(const TrustCache_t_0 *, const uint8_t **, size_t *);

/* 1978 */
typedef TCReturn_t (*extractModule_t)(TrustCache_t *, const uint8_t *, size_t);

/* 1979 */
typedef TCReturn_t (*checkRuntimeForUUID_t)(const TrustCacheRuntime_t *, const uint8_t *, const TrustCache_t **);

/* 1980 */
typedef TCReturn_t (*constructInvalid_t)(TrustCache_t *, const uint8_t *, size_t);

/* 1981 */
typedef TCReturn_t (*queryGetConstraintCategory_t)(const TrustCacheQueryToken_t *, uint8_t *);

/* 1982 */
typedef TCReturn_t (*queryGetFlags_t)(const TrustCacheQueryToken_t *, uint64_t *);

/* 1983 */
typedef TCReturn_t (*queryGetHashType_t)(const TrustCacheQueryToken_t *, uint8_t *);

/* 1984 */
typedef TCReturn_t (*queryGetCapabilities_t)(const TrustCacheQueryToken_t *, TCCapabilities_t *);

/* 1985 */
typedef TCReturn_t (*queryGetTCType_t)(const TrustCacheQueryToken_t *, TCType_t *);

/* 1986 */
typedef TCReturn_t (*getCapabilities_t)(const TrustCache_t *, TCCapabilities_t *);

/* 1987 */
typedef TCReturn_t (*query_t)(const TrustCacheRuntime_t *, TCQueryType_t, const uint8_t *, TrustCacheQueryToken_t *);

/* 1988 */
typedef TCReturn_t (*load_t)(TrustCacheRuntime_t *, TCType_t, TrustCache_t *, const uintptr_t, const size_t, const uintptr_t, const size_t);

/* 1989 */
typedef TCReturn_t (*loadModule_t)(TrustCacheRuntime_t *, const TCType_t, TrustCache_t_0 *, const uintptr_t, const size_t);

/* 1990 */
struct der_vm_iteration_context
{
  der_vm_context_t original;
  der_vm_context_t active;
  _BYTE gap70[8];
  void *user_data;
};

/* 1991 */
typedef bool (*der_vm_iteration_callback)(der_vm_iteration_context);

/* 2008 */
struct CEValidationResult
{
  _BYTE gap0[8];
  const uint8_t *blob;
  const uint8_t *blob_end;
};

/* 2010 */
struct CEStaticBuffer
{
  uint8_t data[240];
  size_t length;
};

/* 2011 */
struct CEBuffer
{
  const uint8_t *data;
  size_t length;
};

/* 2012 */
typedef CEQueryOperation CEQueryOperation_t;

/* 9179 */
struct CEQueryOperation
{
  _BYTE gap0[8];
  union
  {
    CEBuffer dynamicParameter;
    CEStaticBuffer stringParameter;
    int64_t numericParameter;
  } parameters;
};

/* 2013 */
struct CEError;

/* 2014 */
typedef _OSEntitlementsInterface OSEntitlementsInterface_t;

/* 9173 */
struct _OSEntitlementsInterface
{
  uint32_t version;
  OSEntitlements_adjustContextWithMonitor adjustContextWithMonitor;
  OSEntitlements_adjustContextWithoutMonitor adjustContextWithoutMonitor;
  OSEntitlements_queryEntitlementBoolean queryEntitlementBoolean;
  OSEntitlements_queryEntitlementBooleanWithProc queryEntitlementBooleanWithProc;
  OSEntitlements_queryEntitlementString queryEntitlementString;
  OSEntitlements_queryEntitlementStringWithProc queryEntitlementStringWithProc;
  OSEntitlements_copyEntitlementAsOSObject copyEntitlementAsOSObject;
  OSEntitlements_copyEntitlementAsOSObjectWithProc copyEntitlementAsOSObjectWithProc;
};

/* 2015 */
typedef _TrustCacheInterface TrustCacheInterface_t;

/* 9451 */
struct _TrustCacheInterface
{
  uint32_t version;
  loadModule_t loadModule;
  load_t load;
  query_t query;
  getCapabilities_t getCapabilities;
  queryGetTCType_t queryGetTCType;
  queryGetCapabilities_t queryGetCapabilities;
  queryGetHashType_t queryGetHashType;
  queryGetFlags_t queryGetFlags;
  queryGetConstraintCategory_t queryGetConstraintCategory;
  constructInvalid_t constructInvalid;
  checkRuntimeForUUID_t checkRuntimeForUUID;
  extractModule_t extractModule;
  getModule_t getModule;
  getUUID_t getUUID;
};

/* 2016 */
typedef void *(*amfi_query_context_to_object)(CEQueryContext_t);

/* 2017 */
typedef bool (*amfi_get_udid)(const uint8_t **, size_t *);

/* 2018 */
typedef bool (*amfi_get_legacy_profile_exemptions)(const uint8_t **, size_t *);

/* 7651 */
typedef const CEError *CEError_t;

/* 2019 */
struct coreentitlements_t
{
  uint64_t version;
  CEError_t (*AcquireUnmanagedContext)(const CERuntime_t, CEValidationResult, CEQueryContext *);
  CEError_t (*Validate)(const CERuntime_t, CEValidationResult *, const uint8_t *, const uint8_t *);
  CEError_t (*ContextQuery)(CEQueryContext_t, const CEQueryOperation_t *, size_t);
  CEQueryContext (*ConjureContextFromDER)(der_vm_context_t);
  der_vm_context_t (*der_vm_context_create)(const CERuntime_t, ccder_tag, bool, const uint8_t *, const uint8_t *);
  der_vm_context_t (*der_vm_execute)(const der_vm_context_t, CEQueryOperation_t);
  CEError_t (*der_vm_iterate)(const der_vm_context_t, void *, der_vm_iteration_callback);
  bool (*der_vm_context_is_valid)(const der_vm_context_t);
  _BYTE gap48[8];
  int64_t (*der_vm_integer_from_context)(const der_vm_context_t);
  CEBuffer (*der_vm_string_from_context)(const der_vm_context_t);
  bool (*der_vm_bool_from_context)(const der_vm_context_t);
  CEError_t kNoError;
  CEError_t kAPIMisuse;
  CEError_t kInvalidArgument;
  CEError_t kAllocationFailed;
  CEError_t kMalformedEntitlements;
  CEError_t kQueryCannotBeSatisfied;
  CEError_t kNotEligibleForAcceleration;
  const char *(*GetErrorString)(CEError_t);
  CEBuffer (*der_vm_buffer_from_context)(const der_vm_context_t);
  CEError_t (*CEContextIsSubset)(CEQueryContext_t, CEQueryContext_t);
  CEError_t (*IndexSizeForContext)(CEQueryContext_t, size_t *);
  CEError_t (*BuildIndexForContext)(CEQueryContext_t);
  CEError_t (*FreeIndexForContext)(CEQueryContext_t);
  bool (*ContextIsAccelerated)(CEQueryContext_t);
};

/* 2020 */
typedef bool (*amfi_OSEntitlements_get_xml_blob)(void *, CS_GenericBlob **);

/* 2021 */
typedef bool (*amfi_OSEntitlements_get_transmuted_blob)(void *, const CS_GenericBlob **);

/* 2022 */
typedef CEError_t (*amfi_OSEntitlements_query)(void *, uint8_t *, CEQueryOperation_t *, size_t);

/* 2023 */
typedef void *(*amfi_OSEntitlements_asDict)(void *);

/* 2024 */
typedef void (*amfi_OSEntitlements_invalidate)(void *);

/* 2025 */
typedef _amfi amfi_t;

/* 9874 */
struct _amfi
{
  amfi_OSEntitlements_invalidate OSEntitlements_invalidate;
  amfi_OSEntitlements_asDict OSEntitlements_asdict;
  amfi_OSEntitlements_query OSEntitlements_query;
  amfi_OSEntitlements_get_transmuted_blob OSEntitlements_get_transmuted;
  amfi_OSEntitlements_get_xml_blob OSEntitlements_get_xml;
  coreentitlements_t CoreEntitlements;
  amfi_get_legacy_profile_exemptions get_legacy_profile_exemptions;
  amfi_get_udid get_udid;
  amfi_query_context_to_object query_context_to_object;
  TrustCacheInterface_t TrustCache;
  OSEntitlementsInterface_t OSEntitlements;
};

/* 3750 */
typedef void img4_chip_t;

/* 2026 */
typedef const img4_chip_t *const *img4_chip_select_array_t;

/* 2027 */
typedef void img4_object_spec_t;

/* 2028 */
struct _img4_image;

/* 2029 */
typedef _img4_image *img4_image_t;

/* 2032 */
struct _img4_firmware;

/* 7654 */
typedef _img4_firmware *img4_firmware_t;

/* 2030 */
typedef void (*img4_firmware_authenticated_execute_t)(const img4_firmware_t, img4_image_t, errno_t, void *);

/* 2031 */
typedef _img4_firmware_execution_context img4_firmware_execution_context_t;

/* 9180 */
struct _img4_firmware_execution_context
{
  img4_struct_version_t i4fex_version;
  img4_firmware_authenticated_execute_t i4fex_execute;
  void *i4fex_context;
};

/* 2033 */
typedef uint32_t img4_4cc_t;

/* 2034 */
typedef _img4_chip_instance img4_chip_instance_t;

/* 9181 */
struct _img4_chip_instance
{
  img4_struct_version_t chid_version;
  const img4_chip_t *chid_chip_family;
  _BYTE gap10[8];
  uint32_t chid_cepo;
  uint32_t chid_bord;
  uint32_t chid_chip;
  uint32_t chid_sdom;
  uint64_t chid_ecid;
  bool chid_cpro;
  bool chid_csec;
  bool chid_epro;
  bool chid_esec;
  bool chid_iuou;
  bool chid_rsch;
  bool chid_euou;
  uint32_t chid_esdm;
  bool chid_fpgt;
  img4_dgst_t chid_udid;
  uint32_t chid_fchp;
  uint32_t chid_type;
  uint32_t chid_styp;
  uint32_t chid_clas;
};

/* 2036 */
typedef const img4_buff_t *(*img4_image_get_property_data_t)(img4_image_t, img4_4cc_t, img4_buff_t *);

/* 2037 */
typedef const uint64_t *(*img4_image_get_property_uint64_t)(img4_image_t, img4_4cc_t, uint64_t *);

/* 2038 */
typedef const uint32_t *(*img4_image_get_property_uint32_t)(img4_image_t, img4_4cc_t, uint32_t *);

/* 2039 */
typedef const bool *(*img4_image_get_property_bool_t)(img4_image_t, img4_4cc_t, bool *);

/* 2040 */
typedef const img4_chip_t *(*img4_chip_get_cryptex1_boot_t)(const img4_chip_t *);

/* 2041 */
typedef const img4_chip_t *(*img4_chip_select_personalized_ap_t)(void);

/* 2042 */
typedef const img4_buff_t *(*img4_get_payload_t)(const void *, size_t, img4_buff_t *);

/* 2043 */
typedef const img4_buff_t *(*img4_get_manifest_t)(const void *, size_t, img4_buff_t *);

/* 3747 */
typedef void img4_nonce_domain_t;

/* 2044 */
typedef errno_t (*img4_nonce_domain_preroll_nonce_t)(const img4_nonce_domain_t *, img4_nonce_t *);

/* 2045 */
typedef const img4_runtime_object_spec_t *(*img4_runtime_find_object_spec_t)(img4_4cc_t);

/* 2046 */
typedef const img4_chip_t *(*img4_firmware_select_chip_t)(const img4_firmware_t, const img4_chip_select_array_t, size_t);

/* 2047 */
typedef errno_t (*img4_firmware_evaluate_t)(img4_firmware_t, const img4_chip_t *, const img4_nonce_t *);

/* 2048 */
typedef void (*img4_buff_dealloc_t)(img4_buff_t *);

/* 2049 */
typedef const img4_buff_t *(*img4_image_get_bytes_t)(img4_image_t);

/* 2050 */
typedef void (*img4_firmware_destroy_t)(img4_firmware_t *);

/* 2051 */
typedef void (*img4_firmware_execute_t)(img4_firmware_t, const img4_chip_t *, const img4_nonce_t *);

/* 2052 */
typedef void (*img4_firmware_attach_manifest_t)(img4_firmware_t, img4_buff_t *);

/* 2053 */
typedef void img4_firmware_init_t;

/* 2054 */
typedef img4_firmware_t (*img4_firmware_init_from_buff_t)(void *, size_t);

/* 2055 */
typedef void img4_firmware_new_from_vnode_4xnu_t;

/* 2056 */
typedef void img4_firmware_new_t;

/* 2057 */
typedef const img4_chip_t *(*img4_chip_custom_t)(const img4_chip_instance_t *, img4_chip_t *);

/* 2058 */
typedef errno_t (*img4_chip_instantiate_t)(const img4_chip_t *, img4_chip_instance_t *);

/* 2059 */
typedef const img4_chip_t *(*img4_chip_select_effective_ap_t)(void);

/* 2060 */
typedef img4_chip_t *(*img4_chip_init_from_buff_t)(void *, size_t);

/* 2061 */
typedef const void *img4_retired_t;

/* 2062 */
typedef errno_t (*const img4_nonce_domain_roll_nonce_t)(const img4_nonce_domain_t *);

/* 2063 */
typedef errno_t (*const img4_nonce_domain_copy_nonce_t)(const img4_nonce_domain_t *, img4_nonce_t *);

/* 2064 */
typedef _img4_interface img4_interface_t;

/* 9452 */
struct _img4_interface
{
  const uint32_t i4if_version;
  img4_retired_t i4if_init;
  img4_retired_t i4if_set_nonce;
  img4_retired_t i4if_get_trusted_payload;
  img4_retired_t i4if_get_trusted_external_payload;
  img4_retired_t i4if_destroy;
  img4_retired_t i4if_payload_init;
  img4_retired_t i4if_payload_destroy;
  img4_retired_t i4if_environment_platform;
  img4_retired_t i4if_environment_ppl;
  img4_retired_t i4if_environment_trust_cache;
  struct
  {
    img4_retired_t set_nonce_domain;
    img4_nonce_domain_copy_nonce_t nonce_domain_copy_nonce;
    img4_nonce_domain_roll_nonce_t nonce_domain_roll_nonce;
    const img4_nonce_domain_t *nonce_domain_trust_cache;
  } i4if_v1;
  struct
  {
    img4_retired_t payload_init_with_vnode_4xnu;
  } i4if_v2;
  struct
  {
    const img4_nonce_domain_t *nonce_domain_pdi;
    const img4_nonce_domain_t *nonce_domain_cryptex;
  } i4if_v3;
  struct
  {
    img4_retired_t environment_init_identity;
  } i4if_v4;
  struct
  {
    img4_retired_t environment_t2;
    img4_retired_t environment_init_from_identity;
    img4_retired_t identity_init_from_environment;
  } i4if_v5;
  struct
  {
    img4_retired_t environment_x86;
  } i4if_v6;
  struct
  {
    const img4_chip_t *chip_ap_sha1;
    const img4_chip_t *chip_ap_sha2_384;
    const img4_chip_t *chip_ap_hybrid;
    const img4_chip_t *chip_ap_reduced;
    const img4_chip_t *chip_ap_software_ff00;
    const img4_chip_t *chip_ap_software_ff01;
    const img4_chip_t *chip_x86;
    const img4_chip_t *chip_x86_software_8012;
    img4_chip_init_from_buff_t chip_init_from_buff;
    img4_chip_select_personalized_ap_t chip_select_personalized_ap;
    img4_chip_select_effective_ap_t chip_select_effective_ap;
    img4_chip_instantiate_t chip_instantiate;
    img4_chip_custom_t chip_custom;
    _BYTE gap68[16];
    img4_firmware_init_from_buff_t firmware_init_from_buff;
    _BYTE gap80[8];
    img4_firmware_attach_manifest_t firmware_attach_manifest;
    img4_firmware_execute_t firmware_execute;
    img4_firmware_destroy_t firmware_destroy;
    img4_image_get_bytes_t image_get_bytes;
    img4_image_get_property_bool_t image_get_property_bool;
    img4_image_get_property_uint32_t image_get_property_uint32;
    img4_image_get_property_uint64_t image_get_property_uint64;
    img4_image_get_property_data_t image_get_property_data;
    const img4_object_spec_t *firmware_spec;
    const img4_object_spec_t *chip_spec;
    const img4_runtime_t *runtime_default;
    const img4_runtime_t *runtime_pmap_cs;
    img4_buff_dealloc_t buff_dealloc;
  } i4if_v7;
  struct
  {
    const img4_chip_t *chip_ap_permissive;
    const img4_chip_t *chip_ap_hybrid_medium;
    const img4_chip_t *chip_ap_hybrid_relaxed;
  } i4if_v8;
  struct
  {
    img4_firmware_evaluate_t firmware_evaluate;
  } i4if_v9;
  struct
  {
    img4_firmware_select_chip_t firmware_select_chip;
  } i4if_v10;
  struct
  {
    const img4_chip_t *chip_ap_datacenter_development;
    const img4_chip_t *chip_ap_intransigent;
    const img4_chip_t *chip_ap_category;
    const img4_chip_t *chip_ap_ddi;
    const img4_chip_t *chip_ap_developer_disk_image;
    const img4_chip_t *chip_ap_software_ff06;
    const img4_chip_t *chip_ap_supplemental;
    const img4_runtime_object_spec_t *runtime_object_spec_supplemental_root;
    img4_runtime_find_object_spec_t runtime_find_object_spec;
    img4_runtime_execute_object_t runtime_execute_object;
    img4_runtime_copy_object_t runtime_copy_object;
  } i4if_v11;
  struct
  {
    const img4_nonce_domain_t *nonce_domain_ddi;
    const img4_nonce_domain_t *nonce_domain_ephemeral_cryptex;
    const img4_chip_t *chip_ap_category_ff02;
    const img4_chip_t *chip_ap_category_ff03;
    const img4_chip_t *chip_ap_category_ff04_f0;
    const img4_chip_t *chip_ap_category_ff04_f1;
    const img4_chip_t *chip_ap_category_ff04_f2;
    const img4_chip_t *chip_ap_category_ff04_f3;
    img4_chip_select_personalized_ap_t chip_select_categorized_ap;
  } i4if_v12;
  struct
  {
    const img4_chip_t *chip_ap_vma2;
    const img4_chip_t *chip_ap_vma2_clone;
    const img4_object_spec_t *pmap_data_spec;
  } i4if_v13;
  struct
  {
    img4_nonce_domain_preroll_nonce_t nonce_domain_preroll_nonce;
  } i4if_v14;
  struct
  {
    img4_get_manifest_t get_manifest;
    img4_get_payload_t get_payload;
  } i4if_v15;
  struct
  {
    img4_chip_select_personalized_ap_t chip_select_personalized_sep;
    const img4_nonce_domain_t *nonce_domain_cryptex1_boot;
    const img4_nonce_domain_t *nonce_domain_cryptex1_asset;
  } i4if_v16;
  struct
  {
    img4_chip_select_personalized_ap_t chip_select_cryptex1_boot;
    img4_chip_select_personalized_ap_t chip_select_cryptex1_preboot;
    const img4_chip_t *chip_cryptex1_boot;
    const img4_chip_t *chip_cryptex1_boot_reduced;
    const img4_chip_t *chip_cryptex1_boot_x86;
    const img4_chip_t *chip_cryptex1_boot_vma2;
    const img4_chip_t *chip_cryptex1_preboot;
    const img4_chip_t *chip_cryptex1_preboot_reduced;
    const img4_chip_t *chip_cryptex1_preboot_x86;
    const img4_chip_t *chip_cryptex1_preboot_vma2;
    const img4_chip_t *chip_cryptex1_asset;
  } i4if_v17;
  struct
  {
    const img4_nonce_domain_t *nonce_domain_cryptex1_snuf_stub;
    const img4_chip_t *chip_cryptex1_asset_x86;
    const img4_chip_t *chip_cryptex1_boot_proposal;
    const img4_chip_t *chip_cryptex1_boot_reduced_proposal;
    const img4_chip_t *chip_cryptex1_boot_vma2_proposal;
    const img4_chip_t *chip_cryptex1_boot_vma2_clone_proposal;
    img4_chip_get_cryptex1_boot_t chip_get_cryptex1_boot;
    img4_chip_get_cryptex1_boot_t chip_get_cryptex1_boot_proposal;
    img4_image_get_property_bool_t image_get_entitlement_bool;
    img4_image_get_property_uint32_t image_get_entitlement_uint32;
    img4_image_get_property_uint64_t image_get_entitlement_uint64;
    img4_image_get_property_data_t image_get_entitlement_data;
    const img4_runtime_object_spec_t *runtime_object_spec_local_policy;
    const img4_chip_t *chip_ap_local_blessed;
  } i4if_v18;
};

/* 2203 */
typedef long __darwin_ssize_t;

/* 5407 */
typedef __darwin_ssize_t ssize_t;

/* 2065 */
typedef ssize_t (*apple_encrypted_archive_pread_proc)(void *, void *, size_t, off_t);

/* 2066 */
typedef ssize_t (*apple_encrypted_archive_pwrite_proc)(void *, const void *, size_t, off_t);

/* 2067 */
typedef int (*apple_encrypted_archive_close)(void *, size_t);

/* 2068 */
typedef ssize_t (*apple_encrypted_archive_write)(void *, size_t, const void *, size_t);

/* 2069 */
typedef int (*apple_encrypted_archive_open)(void *, size_t, void *, apple_encrypted_archive_pwrite_proc, apple_encrypted_archive_pread_proc);

/* 2070 */
typedef int (*apple_encrypted_archive_initialize_state)(void *, size_t, const uint8_t *, size_t);

/* 2071 */
typedef size_t (*apple_encrypted_archive_get_state_size)(void);

/* 2072 */
typedef _apple_encrypted_archive apple_encrypted_archive_t;

/* 9182 */
struct _apple_encrypted_archive
{
  apple_encrypted_archive_get_state_size aea_get_state_size;
  apple_encrypted_archive_initialize_state aea_initialize_state;
  apple_encrypted_archive_open aea_open;
  apple_encrypted_archive_write aea_write;
  apple_encrypted_archive_close aea_close;
};

/* 7656 */
typedef uint32_t CT_uint32_t;

/* 2073 */
typedef CT_uint32_t CoreTrustDigestType;

/* 7657 */
typedef uint64_t CT_uint64_t;

/* 2074 */
typedef CT_uint64_t CoreTrustPolicyFlags;

/* 2075 */
typedef int (*coretrust_CTVerifyAmfiCertificateChain_t)(const uint8_t *, size_t, bool, CoreTrustDigestType, CoreTrustPolicyFlags *);

/* 2076 */
typedef int (*coretrust_CTVerifyAmfiCMS_t)(const uint8_t *, size_t, const uint8_t *, size_t, CoreTrustDigestType, CoreTrustDigestType *, const uint8_t **, size_t *);

/* 2077 */
typedef int (*coretrust_CTParseAmfiCMS_t)(const uint8_t *, size_t, CoreTrustDigestType, const uint8_t **, size_t *, const uint8_t **, size_t *, CoreTrustDigestType *, CoreTrustPolicyFlags *);

/* 2078 */
typedef int (*coretrust_CTParseKey_t)(const uint8_t *, size_t, const uint8_t **, size_t *);

/* 2079 */
typedef int (*coretrust_CTEvaluateProvisioningProfile_t)(const uint8_t *, size_t, bool, const uint8_t **, size_t *);

/* 2080 */
typedef int (*coretrust_CTEvaluateAMFICodeSignatureCMSPubKey_t)(const uint8_t *, size_t, const uint8_t *, size_t, const uint8_t *, size_t, CoreTrustDigestType *, CoreTrustDigestType *, const uint8_t **, size_t *);

/* 2081 */
typedef int (*coretrust_CTEvaluateAMFICodeSignatureCMS_t)(const uint8_t *, size_t, const uint8_t *, size_t, bool, const uint8_t **, size_t *, CoreTrustPolicyFlags *, CoreTrustDigestType *, CoreTrustDigestType *, const uint8_t **, size_t *);

/* 2082 */
typedef _coretrust coretrust_t;

/* 9453 */
struct _coretrust
{
  coretrust_CTEvaluateAMFICodeSignatureCMS_t CTEvaluateAMFICodeSignatureCMS;
  coretrust_CTEvaluateAMFICodeSignatureCMSPubKey_t CTEvaluateAMFICodeSignatureCMSPubKey;
  coretrust_CTEvaluateProvisioningProfile_t CTEvaluateProvisioningProfile;
  coretrust_CTParseKey_t CTParseKey;
  coretrust_CTParseAmfiCMS_t CTParseAmfiCMS;
  coretrust_CTVerifyAmfiCMS_t CTVerifyAmfiCMS;
  coretrust_CTVerifyAmfiCertificateChain_t CTVerifyAmfiCertificateChain;
};

/* 2083 */
struct ccrng_state
{
  _BYTE gap0[8];
};

/* 2084 */
struct ccxts_tweak
{
  uint8_t b[16];
};

/* 2085 */
struct __attribute__((aligned(8))) ccmode_xts
{
  size_t size;
  size_t tweak_size;
  size_t block_size;
  _BYTE gap18[32];
  const void *custom;
  const void *custom1;
  cc_impl_t impl;
};

/* 2086 */
struct ccxts_ctx
{
  uint8_t b[16];
};

/* 2087 */
struct symmetric_xts
{
  ccxts_ctx enc[67];
  ccxts_ctx dec[67];
};

/* 2090 */
struct ccecb_ctx
{
  uint8_t b[16];
};

/* 2088 */
struct des_ecb_key_schedule
{
  ccecb_ctx enc[16];
  ccecb_ctx dec[16];
};

/* 2089 */
struct __attribute__((aligned(8))) ccmode_ecb
{
  size_t size;
  size_t block_size;
  _BYTE gap10[24];
  cc_impl_t impl;
};

/* 2091 */
struct des3_ecb_key_schedule
{
  ccecb_ctx enc[48];
  ccecb_ctx dec[48];
};

/* 2092 */
typedef unsigned __int8 des_cblock[8];

/* 2093 */
struct MD5_CTX
{
  u_int32_t state[4];
  u_int32_t count[2];
  unsigned __int8 buffer[64];
};

/* 2095 */
struct __attribute__((aligned(8))) ccdigest_state_0
{
  uint8_t state[1];
};

/* 2096 */
struct __attribute__((aligned(8))) ccdigest_ctx_0
{
  uint8_t state[1];
};

/* 2097 */
typedef sha1_ctxt SHA1_CTX;

/* 7659 */
struct __attribute__((aligned(8))) sha1_ctxt
{
  union
  {
    u_int8_t b8[20];
    u_int32_t b32[5];
  } h;
  union
  {
    u_int8_t b8[8];
    u_int32_t b32[2];
    u_int64_t b64[1];
  } c;
  union
  {
    u_int8_t b8[64];
    u_int32_t b32[16];
  } m;
  u_int8_t count;
};

/* 2098 */
typedef SHA512_CTX SHA384_CTX;

/* 9140 */
struct __attribute__((aligned(8))) ccdigest_ctx_1
{
  uint8_t state[1];
};

/* 2099 */
struct SHA512_CTX
{
  ccdigest_ctx_1 ctx[26];
};

/* 2100 */
typedef ccdigest_ctx_0 *ccdigest_ctx_t_0;

/* 2101 */
typedef ccdigest_state_0 *ccdigest_state_t_0;

/* 2102 */
struct SHA256_CTX
{
  ccdigest_ctx_1 ctx[14];
};

/* 2103 */
enum crypto_digest_alg_t : __int32
{
  CRYPTO_DIGEST_ALG_NONE = 0x0,
  CRYPTO_DIGEST_ALG_MD5 = 0x1,
  CRYPTO_DIGEST_ALG_SHA1 = 0x2,
  CRYPTO_DIGEST_ALG_SHA256 = 0x3,
  CRYPTO_DIGEST_ALG_SHA384 = 0x4,
  CRYPTO_DIGEST_ALG_SHA512 = 0x5,
};

/* 2104 */
typedef void *crypto_random_ctx_t;

/* 2105 */
struct cczp_funcs;

/* 2106 */
typedef const cczp_funcs *cczp_funcs_t;

/* 2107 */
typedef uint64_t cc_unit_0;

/* 2108 */
typedef size_t cc_size;

/* 2109 */
struct ccrsa_pub_ctx
{
  cc_size pb_n;
  cc_unit_0 pb_bitlen;
  cczp_funcs_t pb_funcs;
  cc_unit_0 pb_ccn[];
};

/* 2110 */
typedef ccrsa_pub_ctx *ccrsa_pub_ctx_t;

/* 2111 */
struct ccctr_ctx
{
  uint8_t b[16];
};

/* 2112 */
struct ccmode_ctr
{
  size_t size;
  size_t block_size;
  size_t ecb_block_size;
  _BYTE gap18[24];
  const void *custom;
};

/* 2113 */
struct __attribute__((aligned(8))) cchmac_ctx
{
  uint8_t b[1];
};

/* 2114 */
typedef cchmac_ctx *cchmac_ctx_t;

/* 2115 */
typedef bool (*crypto_hmac_verify_fn_t)(crypto_digest_alg_t, const void *, size_t, const void *, size_t, const void *, size_t);

/* 2116 */
typedef void (*crypto_hmac_generate_fn_t)(crypto_digest_alg_t, const void *, size_t, const void *, size_t, void *, size_t);

/* 2117 */
typedef bool (*crypto_hmac_final_verify_fn_t)(crypto_digest_alg_t, void *, size_t, const void *, size_t);

/* 2118 */
typedef void (*crypto_hmac_final_generate_fn_t)(crypto_digest_alg_t, void *, size_t, void *, size_t);

/* 2119 */
typedef void (*crypto_hmac_update_fn_t)(crypto_digest_alg_t, void *, size_t, const void *, size_t);

/* 2120 */
typedef void (*crypto_hmac_init_fn_t)(crypto_digest_alg_t, void *, size_t, const void *, size_t);

/* 2121 */
typedef size_t (*crypto_hmac_ctx_size_fn_t)(crypto_digest_alg_t);

/* 2122 */
typedef void (*crypto_digest_fn_t)(crypto_digest_alg_t, const void *, size_t, void *, size_t);

/* 2123 */
typedef void (*crypto_digest_final_fn_t)(crypto_digest_alg_t, void *, size_t, void *, size_t);

/* 2124 */
typedef void (*crypto_digest_update_fn_t)(crypto_digest_alg_t, void *, size_t, const void *, size_t);

/* 2125 */
typedef void (*crypto_digest_init_fn_t)(crypto_digest_alg_t, void *, size_t);

/* 2126 */
typedef size_t (*crypto_digest_ctx_size_fn_t)(crypto_digest_alg_t);

/* 2127 */
typedef void (*crypto_random_kmem_init_fn_t)(crypto_random_ctx_t);

/* 2128 */
typedef size_t (*crypto_random_kmem_ctx_size_fn_t)(void);

/* 2129 */
typedef void (*crypto_random_uniform_fn_t)(crypto_random_ctx_t, uint64_t, uint64_t *);

/* 2130 */
typedef void (*crypto_random_generate_fn_t)(crypto_random_ctx_t, void *, size_t);

/* 2131 */
typedef int (*ccrsa_verify_pkcs1v15_fn_t)(ccrsa_pub_ctx_t, const uint8_t *, size_t, const uint8_t *, size_t, const uint8_t *, bool *);

/* 2132 */
typedef int (*ccrsa_make_pub_fn_t)(ccrsa_pub_ctx_t, size_t, const uint8_t *, size_t, const uint8_t *);

/* 2133 */
typedef ccrng_state *(*ccrng_fn_t)(int *);

/* 2134 */
typedef size_t (*ccpad_cts3_crypt_fn_t)(const ccmode_cbc *, cccbc_ctx *, cccbc_iv *, size_t, const void *, void *);

/* 2135 */
typedef void (*ccdes_key_set_odd_parity_fn_t)(void *, unsigned __int64);

/* 2136 */
typedef int (*ccdes_key_is_weak_fn_t)(void *, unsigned __int64);

/* 2137 */
typedef const ccchacha20poly1305_fns *ccchacha20poly1305_fns_t;

/* 2138 */
typedef int (*ccgcm_inc_iv_fn_t)(const ccmode_gcm *, ccgcm_ctx *, void *);

/* 2139 */
typedef int (*ccgcm_init_with_iv_fn_t)(const ccmode_gcm *, ccgcm_ctx *, size_t, const void *, const void *);

/* 2140 */
typedef void (*cchmac_fn_t)(const ccdigest_info_0 *, unsigned __int64, const void *, unsigned __int64, const void *, unsigned __int8 *);

/* 2141 */
typedef void (*cchmac_final_fn_t)(const ccdigest_info_0 *, cchmac_ctx_t, unsigned __int8 *);

/* 2142 */
typedef void (*cchmac_update_fn_t)(const ccdigest_info_0 *, cchmac_ctx_t, unsigned __int64, const void *);

/* 2143 */
typedef void (*cchmac_init_fn_t)(const ccdigest_info_0 *, cchmac_ctx_t, unsigned __int64, const void *);

/* 2144 */
typedef void (*ccdigest_fn_t)(const ccdigest_info_0 *, unsigned __int64, const void *, void *);

/* 2145 */
typedef void (*ccdigest_final_fn_t)(const ccdigest_info_0 *, ccdigest_ctx_t_0, void *);

/* 2146 */
typedef void (*ccdigest_update_fn_t)(const ccdigest_info_0 *, ccdigest_ctx_t_0, unsigned __int64, const void *);

/* 2147 */
typedef void (*ccdigest_init_fn_t)(const ccdigest_info_0 *, ccdigest_ctx_t_0);

/* 2148 */
struct crypto_functions
{
  ccdigest_init_fn_t ccdigest_init_fn;
  ccdigest_update_fn_t ccdigest_update_fn;
  ccdigest_final_fn_t ccdigest_final_fn;
  ccdigest_fn_t ccdigest_fn;
  const ccdigest_info_0 *ccmd5_di;
  const ccdigest_info_0 *ccsha1_di;
  const ccdigest_info_0 *ccsha256_di;
  const ccdigest_info_0 *ccsha384_di;
  const ccdigest_info_0 *ccsha512_di;
  cchmac_init_fn_t cchmac_init_fn;
  cchmac_update_fn_t cchmac_update_fn;
  cchmac_final_fn_t cchmac_final_fn;
  cchmac_fn_t cchmac_fn;
  const ccmode_ecb *ccaes_ecb_encrypt;
  const ccmode_ecb *ccaes_ecb_decrypt;
  const ccmode_cbc *ccaes_cbc_encrypt;
  const ccmode_cbc *ccaes_cbc_decrypt;
  const ccmode_ctr *ccaes_ctr_crypt;
  const ccmode_xts_0 *ccaes_xts_encrypt;
  const ccmode_xts_0 *ccaes_xts_decrypt;
  const ccmode_gcm *ccaes_gcm_encrypt;
  const ccmode_gcm *ccaes_gcm_decrypt;
  ccgcm_init_with_iv_fn_t ccgcm_init_with_iv_fn;
  ccgcm_inc_iv_fn_t ccgcm_inc_iv_fn;
  ccchacha20poly1305_fns_t ccchacha20poly1305_fns;
  const ccmode_ecb *ccdes_ecb_encrypt;
  const ccmode_ecb *ccdes_ecb_decrypt;
  const ccmode_cbc *ccdes_cbc_encrypt;
  const ccmode_cbc *ccdes_cbc_decrypt;
  const ccmode_ecb *cctdes_ecb_encrypt;
  const ccmode_ecb *cctdes_ecb_decrypt;
  const ccmode_cbc *cctdes_cbc_encrypt;
  const ccmode_cbc *cctdes_cbc_decrypt;
  ccdes_key_is_weak_fn_t ccdes_key_is_weak_fn;
  ccdes_key_set_odd_parity_fn_t ccdes_key_set_odd_parity_fn;
  ccpad_cts3_crypt_fn_t ccpad_cts3_encrypt_fn;
  ccpad_cts3_crypt_fn_t ccpad_cts3_decrypt_fn;
  ccrng_fn_t ccrng_fn;
  ccrsa_make_pub_fn_t ccrsa_make_pub_fn;
  ccrsa_verify_pkcs1v15_fn_t ccrsa_verify_pkcs1v15_fn;
  crypto_random_generate_fn_t random_generate_fn;
  crypto_random_uniform_fn_t random_uniform_fn;
  crypto_random_kmem_ctx_size_fn_t random_kmem_ctx_size_fn;
  crypto_random_kmem_init_fn_t random_kmem_init_fn;
  crypto_digest_ctx_size_fn_t digest_ctx_size_fn;
  crypto_digest_init_fn_t digest_init_fn;
  crypto_digest_update_fn_t digest_update_fn;
  crypto_digest_final_fn_t digest_final_fn;
  crypto_digest_fn_t digest_fn;
  crypto_hmac_ctx_size_fn_t hmac_ctx_size_fn;
  crypto_hmac_init_fn_t hmac_init_fn;
  crypto_hmac_update_fn_t hmac_update_fn;
  crypto_hmac_final_generate_fn_t hmac_final_generate_fn;
  crypto_hmac_final_verify_fn_t hmac_final_verify_fn;
  crypto_hmac_generate_fn_t hmac_generate_fn;
  crypto_hmac_verify_fn_t hmac_verify_fn;
};

/* 9186 */
struct __attribute__((aligned(8))) ccmode_xts_0
{
  size_t size;
  size_t tweak_size;
  size_t block_size;
  _BYTE gap18[32];
  const void *custom;
  const void *custom1;
  cc_impl_t impl;
};

/* 2149 */
typedef gz_header_s gz_header;

/* 7662 */
struct __attribute__((aligned(8))) gz_header_s
{
  int text;
  uLong time;
  int xflags;
  int os;
  Bytef *extra;
  uInt extra_len;
  uInt extra_max;
  Bytef *name;
  uInt name_max;
  Bytef *comment;
  uInt comm_max;
  int hcrc;
  int done;
};

/* 2150 */
typedef gz_header *gz_headerp;

/* 2153 */
typedef z_stream *z_streamp;

/* 2151 */
typedef int (*z_output_func)(z_streamp, Bytef *, unsigned int);

/* 2152 */
typedef int (*z_input_func)(z_streamp, Bytef *, unsigned int);

/* 2154 */
typedef internal_state_0 deflate_state;

/* 2170 */
typedef unsigned __int64 ulg;

/* 2175 */
typedef unsigned __int16 ush;

/* 7666 */
typedef ush Pos;

/* 2169 */
typedef Pos Posf;

/* 2172 */
typedef unsigned int IPos;

/* 2168 */
struct ct_data_s
{
  union
  {
    ush freq;
    ush code;
  } fc;
  union
  {
    ush dad;
    ush len;
  } dl;
};

/* 2157 */
typedef ct_data_s ct_data;

/* 7663 */
typedef static_tree_desc_s static_tree_desc_0;

/* 7664 */
struct tree_desc_s_0
{
  ct_data *dyn_tree;
  int max_code;
  static_tree_desc_0 *stat_desc;
};

/* 2165 */
typedef unsigned __int8 uch;

/* 2164 */
typedef uch uchf;

/* 2163 */
typedef ush ushf;

/* 9188 */
struct internal_state_0
{
  z_streamp strm;
  z_input_func zinput;
  z_output_func zoutput;
  int status;
  Bytef *pending_buf;
  ulg pending_buf_size;
  Bytef *pending_out;
  uInt pending;
  int wrap;
  gz_headerp gzhead;
  uInt gzindex;
  Byte method;
  int last_flush;
  uInt w_size;
  uInt w_bits;
  uInt w_mask;
  Bytef *window;
  ulg window_size;
  Posf *prev;
  Posf *head;
  uInt ins_h;
  uInt hash_size;
  uInt hash_bits;
  uInt hash_mask;
  uInt hash_shift;
  long block_start;
  uInt match_length;
  IPos prev_match;
  int match_available;
  uInt strstart;
  uInt match_start;
  uInt lookahead;
  uInt prev_length;
  uInt max_chain_length;
  uInt max_lazy_match;
  int level;
  int strategy;
  uInt good_match;
  int nice_match;
  ct_data_s dyn_ltree[573];
  ct_data_s dyn_dtree[61];
  ct_data_s bl_tree[39];
  tree_desc_s_0 l_desc;
  tree_desc_s_0 d_desc;
  tree_desc_s_0 bl_desc;
  ush bl_count[16];
  int heap[573];
  int heap_len;
  int heap_max;
  uch depth[573];
  uchf *l_buf;
  uInt lit_bufsize;
  uInt last_lit;
  ushf *d_buf;
  ulg opt_len;
  ulg static_len;
  uInt matches;
  int last_eob_len;
  ush bi_buf;
  int bi_valid;
};

/* 2156 */
typedef int intf;

/* 2158 */
struct __attribute__((aligned(8))) static_tree_desc_s
{
  const ct_data *static_tree;
  const intf *extra_bits;
  int extra_base;
  int elems;
  int max_length;
};

/* 2155 */
typedef tree_desc_s_0 tree_desc;

/* 2159 */
struct code
{
  unsigned __int8 op;
  unsigned __int8 bits;
  unsigned __int16 val;
};

/* 2160 */
enum codetype : __int32
{
  CODES = 0x0,
  LENS = 0x1,
  DISTS = 0x2,
};

/* 7665 */
enum inflate_mode : __int32
{
  HEAD = 0x0,
  FLAGS = 0x1,
  TIME = 0x2,
  OS = 0x3,
  EXLEN = 0x4,
  EXTRA = 0x5,
  NAME = 0x6,
  COMMENT = 0x7,
  HCRC = 0x8,
  DICTID = 0x9,
  DICT = 0xA,
  TYPE = 0xB,
  TYPEDO = 0xC,
  STORED = 0xD,
  COPY = 0xE,
  TABLE = 0xF,
  LENLENS = 0x10,
  CODELENS = 0x11,
  LEN = 0x12,
  LENEXT = 0x13,
  DIST = 0x14,
  DISTEXT = 0x15,
  MATCH = 0x16,
  LIT = 0x17,
  CHECK = 0x18,
  LENGTH = 0x19,
  DONE = 0x1A,
  BAD = 0x1B,
  MEM = 0x1C,
  SYNC = 0x1D,
};

/* 2161 */
struct inflate_state
{
  inflate_mode mode;
  int last;
  int wrap;
  int havedict;
  int flags;
  unsigned int dmax;
  unsigned __int64 check;
  unsigned __int64 total;
  gz_headerp head;
  unsigned int wbits;
  unsigned int wsize;
  unsigned int whave;
  unsigned int write;
  unsigned __int8 *window;
  unsigned __int64 hold;
  unsigned int bits;
  unsigned int length;
  unsigned int offset;
  unsigned int extra;
  const code *lencode;
  const code *distcode;
  unsigned int lenbits;
  unsigned int distbits;
  unsigned int ncode;
  unsigned int nlen;
  unsigned int ndist;
  unsigned int have;
  code *next;
  unsigned __int16 lens[320];
  unsigned __int16 work[288];
  code codes[2048];
};

/* 2162 */
typedef char charf;

/* 2166 */
struct static_tree_desc_s_0
{
  int dummy;
};

/* 2167 */
typedef static_tree_desc_s_0 static_tree_desc;

/* 2171 */
struct tree_desc_s
{
  ct_data *dyn_tree;
  int max_code;
  static_tree_desc *stat_desc;
};

/* 2173 */
enum block_state : __int32
{
  need_more = 0x0,
  block_done = 0x1,
  finish_started = 0x2,
  finish_done = 0x3,
};

/* 2174 */
typedef block_state (*compress_func)(deflate_state *, int);

/* 2176 */
struct config_s
{
  ush good_length;
  ush max_lazy;
  ush nice_length;
  ush max_chain;
  compress_func func;
};

/* 2177 */
typedef config_s config;

/* 2178 */
typedef section_64_0 kernel_section_t;

/* 3482 */
struct section_64_0
{
  char sectname[16];
  char segname[16];
  uint64_t addr;
  uint64_t size;
  uint32_t offset;
  uint32_t align;
  uint32_t reloff;
  uint32_t nreloc;
  uint32_t flags;
  uint32_t reserved1;
  uint32_t reserved2;
  uint32_t reserved3;
};

/* 2179 */
struct uuid_command_0
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint8_t uuid[16];
};

/* 2180 */
typedef segment_command_64_0 kernel_segment_command_t_0;

/* 2181 */
struct os_refgrp;

/* 2183 */
struct segment_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  char segname[16];
  uint32_t vmaddr;
  uint32_t vmsize;
  uint32_t fileoff;
  uint32_t filesize;
  vm_prot_t maxprot;
  vm_prot_t initprot;
  uint32_t nsects;
  uint32_t flags;
};

/* 2184 */
struct mach_header
{
  uint32_t magic;
  cpu_type_t cputype;
  cpu_subtype_t_0 cpusubtype;
  uint32_t filetype;
  uint32_t ncmds;
  uint32_t sizeofcmds;
  uint32_t flags;
};

/* 2185 */
typedef struct *log_payload_t;

/* 2186 */
typedef log_queue_entry *log_queue_entry_t;

/* 2188 */
struct __attribute__((aligned(8))) log_payload_s
{
  firehose_tracepoint_id_u lp_ftid;
  uint64_t lp_timestamp;
  uint16_t lp_data_size;
};

/* 2189 */
struct log_queue_entry
{
  struct
  {
    log_queue_entry *stqe_next;
  } lqe_link;
  uint16_t lqe_size;
  uint16_t lqe_lm_id;
  log_payload_s lqe_payload;
};

/* 2187 */
typedef logmem_s logmem_t;

/* 9191 */
struct __attribute__((aligned(8))) logmem_s
{
  lck_spin_t lm_lock;
  uint8_t *lm_mem;
  uint8_t *lm_mem_map;
  size_t lm_mem_size;
  size_t lm_cap_order;
  size_t lm_min_order;
  size_t lm_max_order;
  uint32_t lm_cnt_allocations;
  uint32_t lm_cnt_failed_size;
  uint32_t lm_cnt_failed_full;
  uint32_t lm_cnt_failed_lmoff;
  uint32_t lm_cnt_free;
};

/* 2190 */
struct log_queue_list_s
{
  log_queue_entry *stqh_first;
  log_queue_entry **stqh_last;
};

/* 2191 */
typedef long intmax_t;

/* 2197 */
typedef os_log_fmt_hdr_s *os_log_fmt_hdr_t;

/* 2192 */
struct __attribute__((aligned(16))) os_log_context_s
{
  logmem_t *ctx_logmem;
  uint8_t *ctx_buffer;
  size_t ctx_buffer_sz;
  os_log_fmt_hdr_t ctx_hdr;
  char *ctx_pubdata[32];
  uint16_t ctx_content_off;
  uint16_t ctx_content_sz;
  uint16_t ctx_pubdata_sz;
  uint16_t ctx_pubdata_cnt;
};

/* 2196 */
struct os_log_fmt_hdr_s
{
  _BYTE gap0;
  uint8_t hdr_cmd_cnt;
  uint8_t hdr_data[];
};

/* 2193 */
typedef os_log_context_s *os_log_context_t;

/* 2194 */
struct __attribute__((aligned(4))) os_log_fmt_range_s
{
  uint16_t offset;
};

/* 2195 */
struct os_log_fmt_cmd_s
{
  _BYTE gap0;
  uint8_t cmd_size;
  uint8_t cmd_data[];
};

/* 2198 */
typedef firehose_buffer_u *firehose_buffer_t;

/* 2199 */
struct firehose_trace_uuid_info_s
{
  uuid_t_0 ftui_uuid;
  uint64_t ftui_address;
  uint64_t ftui_size;
  char ftui_path[];
};

/* 2200 */
enum os_log_coproc_reg_t : __int32
{
  os_log_coproc_register_memory = 0x0,
  os_log_coproc_register_harvest_fs_ftab = 0x1,
};

/* 2201 */
typedef os_log_s *os_log_t;

/* 7011 */
struct os_log_s
{
  int a;
};

/* 2202 */
enum firehose_activity_flags_t : __int64
{
  firehose_activity_flags_default = 0x0,
  firehose_activity_flags_info_mode = 0x1,
  firehose_activity_flags_debug_mode = 0x2,
  firehose_activity_flags_stream_live_mode = 0x4,
  firehose_activity_flags_precise_timestamp = 0x80,
};

/* 2205 */
struct mkext2_header
{
  uint32_t magic;
  uint32_t signature;
  uint32_t length;
  uint32_t adler32;
  uint32_t version;
  uint32_t numkexts;
  cpu_type_t cputype;
  cpu_subtype_t_0 cpusubtype;
  uint32_t plist_offset;
  uint32_t plist_compressed_size;
  uint32_t plist_full_size;
};

/* 2206 */
struct __attribute__((aligned(8))) vm_map_copy
{
  uint16_t type;
  bool is_kernel_range;
  bool is_user_range;
  vm_object_offset_t offset;
  vm_map_size_t size;
  _BYTE gap18[48];
};

/* 2207 */
typedef IOService_0 core_analytics_family_service_t;

/* 2208 */
typedef core_analytics_serialized_event_s core_analytics_serialized_event_t;

/* 2560 */
typedef OSString_0 *libkern::intrusive_shared_ptr<OSString,intrusive_osobject_retainer>::pointer;

/* 7684 */
struct libkern::intrusive_shared_ptr<OSString,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSString,intrusive_osobject_retainer>::pointer ptr_;
};

/* 2537 */
struct __cppobj OSSharedPtr<OSString> : libkern::intrusive_shared_ptr<OSString,intrusive_osobject_retainer>
{
};

/* 7676 */
struct core_analytics_serialized_event_s
{
  OSSharedPtr<OSString> case_event_name;
  OSSharedPtr<OSDictionary> case_event;
};

/* 2209 */
struct _ca_event
{
  mpsc_queue_chain link;
  const char *format_str;
  void *data;
};

/* 2210 */
typedef _ca_event *ca_event_t;

/* 2211 */
struct core_analytics_hub_functions_s
{
  int version;
  bool (*analytics_send_event_lazy)(IOService_0 *, OSString_0 *, OSObject_0 *);
};

/* 2212 */
typedef const core_analytics_hub_functions_s core_analytics_hub_functions_t;

/* 2213 */
typedef priority_queue_entry_deadline *priority_queue_entry_deadline_t;

/* 2215 */
typedef priority_queue_entry_sched *priority_queue_entry_sched_t;

/* 2216 */
typedef priority_queue_entry_stable *priority_queue_entry_stable_t;

/* 2220 */
typedef short yytype_int16;

/* 2221 */
typedef object object_t;

/* 7677 */
struct object
{
  object *next;
  object *prev;
  void *object;
  int size;
  union
  {
    void *key;
    __int64 offset;
  } u;
};

/* 2222 */
typedef parser_state parser_state_t;

/* 9454 */
struct parser_state
{
  const char *parseBuffer;
  int parseBufferIndex;
  int lineNumber;
  object_t *objects;
  object_t *freeObjects;
  OSDictionary_0 *tags;
  OSString_0 **errorString;
  OSObject_0 *parsedObject;
  int parsedObjectCount;
  int retrievedObjectCount;
};

/* 2223 */
typedef unsigned __int8 yytype_uint8;

/* 2224 */
typedef char yytype_int8;

/* 2225 */
typedef const smrh_traits *smrh_traits_t;

/* 2229 */
struct smrh_key_t
{
  union
  {
    const char *smrk_string;
    const void *smrk_opaque;
    uint64_t smrk_u64;
  };
  size_t smrk_len;
};

/* 2233 */
struct smrh_traits
{
  unsigned __int64 link_offset;
  smr_t domain;
  uint32_t (*key_hash)(smrh_key_t, uint32_t);
  bool (*key_equ)(smrh_key_t, smrh_key_t);
  uint32_t (*obj_hash)(const smrq_slink *, uint32_t);
  bool (*obj_equ)(const smrq_slink *, smrh_key_t);
  bool (*obj_try_get)(void *);
};

/* 2226 */
typedef OSSymbol_0 *libkern::intrusive_shared_ptr<OSSymbol,intrusive_osobject_retainer>::pointer;

/* 2227 */
struct libkern::intrusive_shared_ptr<OSSymbol,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSSymbol,intrusive_osobject_retainer>::pointer ptr_;
};

/* 2228 */
struct __cppobj OSSharedPtr<OSSymbol> : libkern::intrusive_shared_ptr<OSSymbol,intrusive_osobject_retainer>
{
};

/* 2231 */
struct smrq_slist_head
{
  __smrq_slink_t first;
};

/* 2232 */
struct smr_hash
{
  uintptr_t smrh_array;
  uint32_t smrh_count;
  bool smrh_resizing;
  uint8_t smrh_unused1;
  uint16_t smrh_unused2;
};

/* 2236 */
typedef OSSerialize_0 *libkern::intrusive_shared_ptr<OSSerialize,intrusive_osobject_retainer>::pointer;

/* 2616 */
typedef const OSMetaClassBase_0 *(*OSSerialize::Editor_0)(void *, OSSerialize_0 *, OSCollection_0 *, const OSSymbol_0 *, const OSMetaClassBase_0 *);

/* 2617 */
struct __cppobj OSSerialize_0 : OSObject_1
{
  char *data;
  unsigned int length;
  unsigned int capacity;
  unsigned int capacityIncrement;
  OSPtr<OSArray> tags;
  bool binary;
  bool endCollection;
  OSSerialize::Editor_0 editor;
  void *editRef;
  OSPtr<OSData> indexData;
};

/* 2237 */
typedef OSSerializer_0 *libkern::intrusive_shared_ptr<OSSerializer,intrusive_osobject_retainer>::pointer;

/* 2240 */
typedef bool (*OSSerializerCallback_0)(void *, void *, OSSerialize_0 *);

/* 7691 */
struct __cppobj OSSerializer_0 : OSObject_1
{
  void *target;
  void *ref;
  OSSerializerCallback_0 callback;
};

/* 2238 */
struct libkern::intrusive_shared_ptr<OSSerializer,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSSerializer,intrusive_osobject_retainer>::pointer ptr_;
};

/* 2239 */
typedef struct *OSSerializerBlock;

/* 2241 */
typedef void (*structor_t)(void);

/* 2242 */
union lc_str
{
  uint32_t offset;
};

/* 2243 */
struct fileset_entry_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint64_t vmaddr;
  uint64_t fileoff;
  lc_str entry_id;
  uint32_t reserved;
};

/* 2244 */
struct __cppobj OSSharedPtr<OSOrderedSet> : libkern::intrusive_shared_ptr<OSOrderedSet,intrusive_osobject_retainer>
{
};

/* 2245 */
typedef OSNumber_0 *libkern::intrusive_shared_ptr<OSNumber,intrusive_osobject_retainer>::pointer;

/* 2246 */
struct libkern::intrusive_shared_ptr<OSNumber,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSNumber,intrusive_osobject_retainer>::pointer ptr_;
};

/* 2248 */
typedef uint32_t vm32_object_id_t;

/* 2249 */
struct pgo_metadata_footer
{
  uint32_t number_of_pairs;
  uint32_t offset_to_pairs;
  uint32_t magic;
};

/* 2250 */
typedef osLogDataHeader osLogDataHeaderRef;

/* 2274 */
struct osLogDataHeader
{
  uint32_t version;
  uint32_t sect_count;
  struct {uint32_t sect_offset;uint32_t sect_size;}; sections[];
};

/* 2251 */
struct OSKextGrabPgoStruct
{
  bool metadata;
  uint64_t *pSize;
  char *pBuffer;
  uint64_t bufferSize;
  int err;
  list_head_0 list_head;
};

/* 2252 */
struct __attribute__((aligned(8))) relocation_info
{
  int32_t r_address;
};

/* 2253 */
typedef nlist_64 kernel_nlist_t;

/* 5801 */
struct nlist_64
{
  union
  {
    uint32_t n_strx;
  } n_un;
  uint8_t n_type;
  uint8_t n_sect;
  uint16_t n_desc;
  uint64_t n_value;
};

/* 2254 */
struct symtab_command_0
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint32_t symoff;
  uint32_t nsyms;
  uint32_t stroff;
  uint32_t strsize;
};

/* 2255 */
struct dysymtab_command_0
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint32_t ilocalsym;
  uint32_t nlocalsym;
  uint32_t iextdefsym;
  uint32_t nextdefsym;
  uint32_t iundefsym;
  uint32_t nundefsym;
  uint32_t tocoff;
  uint32_t ntoc;
  uint32_t modtaboff;
  uint32_t nmodtab;
  uint32_t extrefsymoff;
  uint32_t nextrefsyms;
  uint32_t indirectsymoff;
  uint32_t nindirectsyms;
  uint32_t extreloff;
  uint32_t nextrel;
  uint32_t locreloff;
  uint32_t nlocrel;
};

/* 2256 */
struct linkedit_data_command_0
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint32_t dataoff;
  uint32_t datasize;
};

/* 2257 */
struct _DeviceTreeBuffer
{
  uint32_t paddr;
  uint32_t length;
};

/* 2258 */
struct _BooterKextFileInfo
{
  uint32_t infoDictPhysAddr;
  uint32_t infoDictLength;
  uint32_t executablePhysAddr;
  uint32_t executableLength;
  uint32_t bundlePathPhysAddr;
  uint32_t bundlePathLength;
};

/* 2260 */
typedef OSDextStatistics *libkern::intrusive_shared_ptr<OSDextStatistics,intrusive_osobject_retainer>::pointer;

/* 2261 */
typedef OSValueObject<void *> *libkern::intrusive_shared_ptr<OSValueObject<void *>,intrusive_osobject_retainer>::pointer;

/* 7716 */
struct __cppobj __attribute__((aligned(8))) OSValueObject<void *> : OSObject_1
{
  _BYTE gapC[8];
  _BYTE gap14[4];
};

/* 2262 */
typedef OSValueObject<void (*)(unsigned int,int,const void *,unsigned int,void *)> *libkern::intrusive_shared_ptr<OSValueObject<void (*)(unsigned int,int,const void *,unsigned int,void *)>,intrusive_osobject_retainer>::pointer;

/* 7717 */
struct __cppobj __attribute__((aligned(8))) OSValueObject<void (*)(unsigned int,int,const void *,unsigned int,void *)> : OSObject_1
{
  _BYTE gapC[8];
  _BYTE gap14[4];
};

/* 2263 */
typedef OSDextCrash *libkern::intrusive_shared_ptr<OSDextCrash,intrusive_osobject_retainer>::pointer;

/* 7718 */
struct __cppobj OSDextCrash : OSObject_1
{
  uint64_t fTimestamp;
};

/* 2264 */
typedef OSKextSavedMutableSegment *libkern::intrusive_shared_ptr<OSKextSavedMutableSegment,intrusive_osobject_retainer>::pointer;

/* 7719 */
struct __cppobj OSKextSavedMutableSegment : OSObject_1
{
  kernel_segment_command_t_0 *savedSegment;
  vm_offset_t vmaddr;
  vm_size_t_0 vmsize;
  void *data;
};

/* 2265 */
struct libkern::intrusive_shared_ptr<OSKextSavedMutableSegment,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSKextSavedMutableSegment,intrusive_osobject_retainer>::pointer ptr_;
};

/* 2266 */
typedef _loaded_kext_summary_header OSKextLoadedKextSummaryHeader;

/* 7763 */
struct _loaded_kext_summary
{
  char name[64];
  uuid_t_0 uuid;
  uint64_t address;
  uint64_t size;
  uint64_t version;
  uint32_t loadTag;
  uint32_t flags;
  uint64_t reference_list;
  uint64_t text_exec_address;
  size_t text_exec_size;
};

/* 2428 */
typedef _loaded_kext_summary OSKextLoadedKextSummary;

/* 9192 */
struct _loaded_kext_summary_header
{
  uint32_t version;
  uint32_t entry_size;
  uint32_t numSummaries;
  uint32_t reserved;
  OSKextLoadedKextSummary summaries[];
};

/* 2267 */
typedef OSCollection_0 *libkern::intrusive_shared_ptr<OSCollection,intrusive_tagged_osobject_retainer<OSCollection> >::pointer;

/* 2268 */
typedef const OSSymbol_0 *libkern::intrusive_shared_ptr<const OSSymbol,intrusive_tagged_osobject_retainer<OSCollection> >::pointer;

/* 2269 */
typedef const OSCollection_0 *libkern::intrusive_shared_ptr<const OSCollection,intrusive_osobject_retainer>::pointer;

/* 2270 */
typedef OSCollectionIterator_0 *libkern::intrusive_shared_ptr<OSCollectionIterator,intrusive_osobject_retainer>::pointer;

/* 7733 */
struct libkern::intrusive_shared_ptr<const OSCollection,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<const OSCollection,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7732 */
struct __cppobj OSSharedPtr<const OSCollection> : libkern::intrusive_shared_ptr<const OSCollection,intrusive_osobject_retainer>
{
};

/* 9855 */
typedef OSSharedPtr<const OSCollection> OSPtr<const OSCollection>_0;

/* 2425 */
struct __cppobj __attribute__((aligned(4))) OSCollectionIterator_0 : OSIterator_0
{
  OSPtr<const OSCollection>_0 collection;
  union
  {
    struct
    {
      uint8_t inlineStorage[4];
      uint8_t __padding[4];
    };
    void *collIterator;
  };
  unsigned int initialUpdateStamp;
  bool valid;
};

/* 2271 */
struct libkern::intrusive_shared_ptr<OSCollectionIterator,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSCollectionIterator,intrusive_osobject_retainer>::pointer ptr_;
};

/* 2272 */
typedef OSCollection_0 *libkern::intrusive_shared_ptr<OSCollection,intrusive_osobject_retainer>::pointer;

/* 2273 */
struct libkern::intrusive_shared_ptr<OSCollection,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSCollection,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7743 */
typedef void (*OSMetaClassBase::_ptf_t)(void);

/* 7287 */
typedef long ptrdiff_t;

/* 2275 */
struct OSMetaClassBase::_ptmf2ptf::ptmf_t
{
  OSMetaClassBase::_ptf_t fPFN;
  ptrdiff_t delta;
};

/* 2437 */
typedef kern_return_t OSReturn_0;

/* 2277 */
struct StalledData
{
  const char *kextIdentifier;
  OSReturn_0 result;
  unsigned int capacity;
  unsigned int count;
  OSMetaClass_0 **classes;
};

/* 2540 */
typedef OSUserMetaClass *libkern::intrusive_shared_ptr<OSUserMetaClass,intrusive_osobject_retainer>::pointer;

/* 7745 */
struct libkern::intrusive_shared_ptr<OSUserMetaClass,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSUserMetaClass,intrusive_osobject_retainer>::pointer ptr_;
};

/* 2287 */
struct __cppobj OSSharedPtr<OSUserMetaClass> : libkern::intrusive_shared_ptr<OSUserMetaClass,intrusive_osobject_retainer>
{
};

/* 2469 */
struct __cppobj OSUserMetaClass : OSObject_1
{
  const OSSymbol_0 *name;
  const OSMetaClass_0 *meta;
  OSUserMetaClass *superMeta;
  queue_chain_t_0 link;
  OSClassDescription *description;
  IOPStrings *queueNames;
  uint32_t methodCount;
  uint64_t *methods;
};

/* 2288 */
struct OSClassDescription
{
  uint32_t descriptionSize;
  char name[96];
  char superName[96];
  uint32_t methodOptionsSize;
  uint32_t methodOptionsOffset;
  uint32_t metaMethodOptionsSize;
  uint32_t metaMethodOptionsOffset;
  uint32_t queueNamesSize;
  uint32_t queueNamesOffset;
  uint32_t methodNamesSize;
  uint32_t methodNamesOffset;
  uint32_t metaMethodNamesSize;
  uint32_t metaMethodNamesOffset;
  uint64_t flags;
  uint64_t resv1[8];
  uint64_t methodOptions[];
  uint64_t metaMethodOptions[];
  char dispatchNames[];
  char methodNames[];
  char metaMethodNames[];
};

/* 2289 */
struct IOPStrings
{
  uint32_t dataSize;
  uint32_t count;
  const char strings[];
};

/* 2304 */
typedef IOReturn_0 (*IOExternalMethodAction_0)(OSObject_0 *, void *, IOExternalMethodArguments_0 *);

/* 2290 */
struct IOExternalMethodDispatch2022
{
  IOExternalMethodAction_0 function;
  uint32_t checkScalarInputCount;
  uint32_t checkStructureInputSize;
  uint32_t checkScalarOutputCount;
  uint32_t checkStructureOutputSize;
  uint8_t allowAsync;
  const char *checkEntitlement;
};

/* 2307 */
struct IOExternalMethodArguments_0
{
  uint32_t version;
  uint32_t selector;
  mach_port_t_0 asyncWakePort;
  io_user_reference_t_0 *asyncReference;
  uint32_t asyncReferenceCount;
  const uint64_t *scalarInput;
  uint32_t scalarInputCount;
  const void *structureInput;
  uint32_t structureInputSize;
  IOMemoryDescriptor_0 *structureInputDescriptor;
  uint64_t *scalarOutput;
  uint32_t scalarOutputCount;
  void *structureOutput;
  uint32_t structureOutputSize;
  IOMemoryDescriptor_0 *structureOutputDescriptor;
  uint32_t structureOutputDescriptorSize;
  uint32_t __reservedA;
  OSObject_0 **structureVariableOutputData;
  uint32_t __reserved[30];
};

/* 2291 */
struct IOExternalMethodArgumentsOpaque;

/* 2294 */
typedef IOReturn_0 (*IOAsyncMethod_0)(IOService_0 *, natural_t *, void *, void *, void *, void *, void *, void *);

/* 2295 */
struct IOExternalAsyncMethod_0
{
  IOService_0 *object;
  IOAsyncMethod_0 func;
  _BYTE gap10[8];
  IOOptionBits flags;
  IOByteCount count0;
  IOByteCount count1;
};

/* 2296 */
typedef IOReturn_0 (*IOMethod_0)(IOService_0 *, void *, void *, void *, void *, void *, void *);

/* 2297 */
struct IOExternalMethod_0
{
  IOService_0 *object;
  IOMethod_0 func;
  _BYTE gap10[8];
  IOOptionBits flags;
  IOByteCount count0;
  IOByteCount count1;
};

/* 2298 */
typedef struct semaphore *semaphore_t_0;

/* 2299 */
typedef void (*io_filter_release_t)(io_filter_policy_t);

/* 2300 */
enum io_filter_type_t : __int32
{
  io_filter_type_t::io_filter_type_external_method = 0x1,
  io_filter_type_t::io_filter_type_external_async_method = 0x2,
  io_filter_type_t::io_filter_type_trap = 0x3,
};

/* 2301 */
typedef IOReturn_0 (*io_filter_applier_t)(IOUserClient_0 *, io_filter_policy_t, io_filter_type_t, uint32_t);

/* 2302 */
typedef IOReturn_0 (*io_filter_resolver_t)(task_t_0, IOUserClient_0 *, uint32_t, io_filter_policy_t *);

/* 2303 */
struct io_filter_callbacks
{
  const io_filter_resolver_t io_filter_resolver;
  const io_filter_applier_t io_filter_applier;
  const io_filter_release_t io_filter_release;
};

/* 2305 */
struct IOExternalMethodDispatch_0
{
  IOExternalMethodAction_0 function;
  uint32_t checkScalarInputCount;
  uint32_t checkStructureInputSize;
  uint32_t checkScalarOutputCount;
  uint32_t checkStructureOutputSize;
};

/* 2308 */
struct OSActionWaitToken;

/* 2309 */
typedef struct *OSActionAbortedHandler;

/* 2310 */
typedef void (*OSAction::Aborted_Handler)(OSMetaClassBase_0 *);

/* 2311 */
typedef kern_return_t (*OSAction::CreateWithTypeName_Handler)(OSObject_0 *, uint64_t, uint64_t, size_t, OSString_0 *, OSAction_0 **);

/* 2312 */
typedef kern_return_t (*OSAction::Create_Handler)(OSObject_0 *, uint64_t, uint64_t, size_t, OSAction_0 **);

/* 2313 */
typedef struct *OSActionCancelHandler;

/* 2314 */
struct OSActionInterface_0
{
  _BYTE gap0;
};

/* 2318 */
typedef bool (*IOPMCompletionQueue::Action)(IOService_0 *, IOPMRequest *, IOPMCompletionQueue *);

/* 2452 */
typedef void (*IOPMCompletionAction)(void *, void *);

/* 2453 */
struct __cppobj IOPMRequest : IOCommand_0
{
  IOService_0 *fTarget;
  IOPMRequest *fRequestNext;
  IOPMRequest *fRequestRoot;
  uint32_t fWorkWaitCount;
  uint32_t fFreeWaitCount;
  uint64_t fTimestamp;
  uint32_t fRequestType;
  bool fIsQuiesceBlocker;
  IOPMCompletionAction fCompletionAction;
  void *fCompletionTarget;
  void *fCompletionParam;
  uint32_t fTag;
  void *fArg0;
  void *fArg1;
  void *fArg2;
};

/* 2319 */
struct __cppobj IOPMCompletionQueue : IOEventSource_0
{
  queue_head_t_0 fQueue;
};

/* 2320 */
typedef bool (*IOPMRequestQueue::Action)(IOService_0 *, IOPMRequest *, IOPMRequestQueue *);

/* 2321 */
struct __cppobj IOPMRequestQueue : IOEventSource_0
{
  queue_head_t_0 fQueue;
  IOLock_0 *fLock;
};

/* 2322 */
typedef bool (*IOPMWorkQueue::Action)(IOService_0 *, IOPMRequest *, IOPMWorkQueue *);

/* 2323 */
struct __cppobj IOPMWorkQueue : IOEventSource_0
{
  uint64_t fStatCheckForWork;
  uint64_t fStatScanEntries;
  uint64_t fStatQueueEmpty;
  uint64_t fStatNoWorkDone;
  queue_head_t_0 fWorkQueue;
  IOPMWorkQueue::Action fInvokeAction;
  IOPMWorkQueue::Action fRetireAction;
  uint32_t fQueueLength;
  uint32_t fConsumerCount;
  volatile uint32_t fProducerCount;
  IOPMRequest *fQuiesceRequest;
  AbsoluteTime_0 fQuiesceStartTime;
  AbsoluteTime_0 fQuiesceFinishTime;
};

/* 2324 */
struct IOPMDriverCallEntry
{
  queue_chain_t_0 link;
  thread_t_0 thread;
  IOService_0 *target;
  const void *callMethod;
};

/* 2325 */
typedef bool (*IOServiceNotificationHandler)(void *, void *, IOService_0 *);

/* 2326 */
typedef bool (*IOServiceMatchingNotificationHandler)(void *, void *, IOService_0 *, IONotifier_0 *);

/* 2327 */
struct __cppobj __attribute__((aligned(8))) _IOServiceNotifier : IONotifier_0
{
  OSOrderedSet_0 *whence;
  OSDictionary_0 *matching;
  const OSSymbol_0 *type;
  IOServiceMatchingNotificationHandler handler;
  IOServiceNotificationHandler compatHandler;
  void *target;
  void *ref;
  SInt32 priority;
  queue_head_t_0 handlerInvocations;
  IOOptionBits_0 state;
};

/* 2328 */
struct __cppobj IOStateNotificationItem : OSObject_1
{
  OSDictionary_0 *fSchema;
  OSDictionary_0 *fValue;
  OSSet_0 *fListeners;
};

/* 2329 */
typedef const OSMetaClassBase_0 *OSTaggedPtr<const OSMetaClassBase>;

/* 2330 */
typedef struct *OSOrderedSet::OSOrderBlock;

/* 2331 */
typedef SInt32 (*OSOrderedSet::OSOrderFunction_0)(const OSMetaClassBase_0 *, const OSMetaClassBase_0 *, void *);

/* 2542 */
typedef IOUserClient_0 *libkern::intrusive_shared_ptr<IOUserClient,intrusive_osobject_retainer>::pointer;

/* 7580 */
struct libkern::intrusive_shared_ptr<IOUserClient,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOUserClient,intrusive_osobject_retainer>::pointer ptr_;
};

/* 2333 */
struct __cppobj OSSharedPtr<IOUserClient> : libkern::intrusive_shared_ptr<IOUserClient,intrusive_osobject_retainer>
{
};

/* 2334 */
typedef IOByteCount_0 IORangeScalar_0;

/* 2335 */
struct __cppobj IORangeAllocator_0 : OSObject_1
{
  UInt32 numElements;
  UInt32 capacity;
  UInt32 capacityIncrement;
  IORangeScalar_0 defaultAlignmentMask;
  IOOptionBits_0 options;
  IORangeAllocatorElement *elements;
};

/* 2336 */
struct __cppobj IONVRAMController_0 : IOService_0
{
};

/* 2356 */
struct ucred::posix_cred
{
  uid_t cr_uid;
  uid_t cr_ruid;
  uid_t cr_svuid;
  u_short cr_ngroups;
  u_short __cr_padding;
  gid_t cr_groups[16];
  gid_t cr_rgid;
  gid_t cr_svgid;
  uid_t cr_gmuid;
  int cr_flags;
};

/* 2358 */
struct proc_ro::task_ro_data
{
  task_token_ro_data task_tokens;
  task_filter_ro_data task_filters;
  uint32_t t_flags_ro;
  uint32_t task_control_port_options;
};

/* 2359 */
struct __attribute__((aligned(8))) proc_ro::proc_ro_data
{
  uint64_t p_uniqueid;
  int p_idversion;
  uint32_t p_csflags;
  ucred *p_ucred;
  uint8_t *syscall_filter_mask;
  proc_platform_ro_data p_platform_data;
};

/* 2363 */
struct __attribute__((aligned(8))) proc::proc_forkcopy_data
{
  u_int p_argslen;
  int p_argc;
  user_addr_t_0 user_stack;
  _BYTE gap10[8];
  off_t p_textoff;
  sigset_t p_sigmask;
  sigset_t p_sigignore;
  sigset_t p_sigcatch;
  u_char p_priority;
  u_char p_resv0;
  char p_nice;
  u_char p_resv1;
  command_t p_comm;
  proc_name_t p_name;
  uint8_t p_xhighbits;
  pid_t p_contproc;
  uint32_t p_pcaction;
  uint8_t p_uuid[16];
  cpu_type_t p_cputype;
  cpu_subtype_t_0 p_cpusubtype;
};

/* 2364 */
struct knote::kevent_internal_s
{
  uint64_t kei_ident;
  int8_t kei_filter;
  uint8_t kei_filtid;
  uint16_t kei_flags;
  int32_t kei_qos;
  uint64_t kei_udata;
  uint32_t kei_fflags;
  uint32_t kei_sfflags;
  int64_t kei_sdata;
  uint64_t kei_ext[4];
};

/* 2365 */
struct vnode::fl_head
{
  file_lease *lh_first;
};

/* 2367 */
struct __cppobj PMSettingHandle : OSObject_1
{
  PMSettingObject *pmso;
};

/* 2388 */
typedef IOReturn_0 (*IOPMSettingControllerCallback)(OSObject_0 *, const OSSymbol_0 *, OSObject_0 *, uintptr_t);

/* 7292 */
struct __attribute__((aligned(8))) libkern::safe_allocation<unsigned int,os_detail::IOKit_typed_allocator<unsigned int,true>,os_detail::panic_trapping_policy>
{
  unsigned int *data_;
  uint32_t size_;
};

/* 9193 */
typedef libkern::safe_allocation<unsigned int,os_detail::IOKit_typed_allocator<unsigned int,true>,os_detail::panic_trapping_policy> OSAllocation<unsigned int>;

/* 2368 */
typedef OSAllocation<unsigned int> OSDataAllocation<unsigned int>;

/* 2369 */
struct __cppobj __attribute__((aligned(4))) PMSettingObject : OSObject_1
{
  queue_head_t_0 calloutQueue;
  thread_t_0 waitThread;
  IOPMrootDomain_0 *parent;
  PMSettingHandle *pmsh;
  IOPMSettingControllerCallback func;
  OSObject_0 *target;
  uintptr_t refcon;
  OSDataAllocation<unsigned int> publishedFeatureID;
  uint32_t settingCount;
  bool disabled;
};

/* 2395 */
typedef IOService_0 *OSPtr<IOService>;

/* 2398 */
typedef PMTraceWorker *OSPtr<PMTraceWorker>;

/* 2389 */
typedef const OSSymbol_0 *OSPtr<const OSSymbol>;

/* 2394 */
typedef IONotifier_0 *OSPtr<IONotifier>;

/* 2392 */
typedef OSObject_0 *OSPtr<OSObject>;

/* 2487 */
typedef IOBufferMemoryDescriptor_0 *OSPtr<IOBufferMemoryDescriptor>;

/* 2375 */
struct __attribute__((aligned(4))) IOPMCalendarStruct
{
  UInt32 year;
  UInt8 month;
  UInt8 day;
  UInt8 hour;
  UInt8 minute;
  UInt8 second;
  UInt8 selector;
};

/* 2391 */
typedef IOTimerEventSource_0 *OSPtr<IOTimerEventSource>;

/* 2390 */
typedef OSNumber_0 *OSPtr<OSNumber>;

/* 2399 */
struct __cppobj IOPMrootDomain_0 : IOService_0
{
  OSPtr<IOService> wrangler;
  OSPtr<OSDictionary> wranglerIdleSettings;
  IOLock_0 *featuresDictLock;
  IOLock_0 *wakeEventLock;
  IOPMPowerStateQueue *pmPowerStateQueue;
  OSPtr<OSArray> allowedPMSettings;
  OSPtr<OSArray> noPublishPMSettings;
  OSPtr<PMTraceWorker> pmTracer;
  PMAssertionsTracker *pmAssertions;
  IOLock_0 *settingsCtrlLock;
  OSPtr<OSDictionary> settingsCallbacks;
  OSPtr<OSDictionary> fPMSettingsDict;
  OSPtr<const OSSymbol> _statsNameKey;
  OSPtr<const OSSymbol> _statsPIDKey;
  OSPtr<const OSSymbol> _statsTimeMSKey;
  OSPtr<const OSSymbol> _statsResponseTypeKey;
  OSPtr<const OSSymbol> _statsMessageTypeKey;
  OSPtr<const OSSymbol> _statsPowerCapsKey;
  uint32_t sleepCnt;
  uint32_t darkWakeCnt;
  uint32_t displayWakeCnt;
  OSPtr<OSString> queuedSleepWakeUUIDString;
  OSPtr<OSArray> pmStatsAppResponses;
  IOLock_0 *pmStatsLock;
  void *sleepDelaysReport;
  uint32_t sleepDelaysClientCnt;
  uint64_t ts_sleepStart;
  uint64_t wake2DarkwakeDelay;
  void *assertOnWakeReport;
  uint32_t assertOnWakeClientCnt;
  clock_sec_t assertOnWakeSecs;
  bool uuidPublished;
  bool idleSleepEnabled;
  uint32_t sleepSlider;
  uint32_t idleMilliSeconds;
  uint32_t extraSleepDelay;
  thread_call_t extraSleepTimer;
  thread_call_t powerButtonDown;
  thread_call_t powerButtonUp;
  thread_call_t diskSyncCalloutEntry;
  thread_call_t fullWakeThreadCall;
  thread_call_t updateConsoleUsersEntry;
  uint32_t _desiredCapability;
  uint32_t _currentCapability;
  uint32_t _pendingCapability;
  uint32_t _highestCapability;
  OSPtr<OSSet> _joinedCapabilityClients;
  uint32_t _systemStateGeneration;
  uint32_t _systemMessageClientMask;
  enum : __int32
  {
    kSystemTransitionNone = 0x0,
    kSystemTransitionSleep = 0x1,
    kSystemTransitionWake = 0x2,
    kSystemTransitionCapability = 0x3,
    kSystemTransitionNewCapClient = 0x4,
  } _systemTransitionType;
  _BYTE gap1DC[5];
  uint8_t tasksSuspended;
  uint8_t tasksSuspendState;
  uint32_t hibernateMode;
  AbsoluteTime_0 userActivityTime;
  AbsoluteTime_0 userActivityTime_prev;
  uint32_t userActivityCount;
  uint32_t userActivityAtSleep;
  uint32_t lastSleepReason;
  uint32_t fullToDarkReason;
  uint32_t hibernateAborted;
  uint8_t standbyNixed;
  uint8_t resetTimers;
  uint32_t fullWakeReason;
  uint32_t clamshellSleepDisableMask;
  int32_t idxPMCPUClamshell;
  int32_t idxPMCPULimitedPower;
  IOOptionBits_0 platformSleepSupport;
  uint32_t _debugWakeSeconds;
  queue_head_t_0 aggressivesQueue;
  thread_call_t aggressivesThreadCall;
  OSPtr<OSData> aggressivesData;
  AbsoluteTime_0 userBecameInactiveTime;
  OSPtr<IOService> pciHostBridgeDevice;
  OSPtr<IOService> pciHostBridgeDriver;
  OSPtr<IONotifier> systemCapabilityNotifier;
  uint32_t pmSuspendedCapacity;
  uint32_t pmSuspendedSize;
  IOPMrootDomain::PMNotifySuspendedStruct *pmSuspendedPIDS;
  OSPtr<OSSet> preventIdleSleepList;
  OSPtr<OSSet> preventSystemSleepList;
  OSPtr<const OSSymbol> _nextScheduledAlarmType;
  clock_sec_t _nextScheduledAlarmUTC;
  clock_sec_t _calendarWakeAlarmUTC;
  UInt32 _scheduledAlarmMask;
  UInt32 _userScheduledAlarmMask;
  volatile uint32_t swd_lock;
  void *swd_buffer;
  uint32_t swd_flags;
  void *swd_compressed_buffer;
  void *swd_spindump_buffer;
  thread_t_0 notifierThread;
  OSPtr<OSObject> notifierObject;
  OSPtr<IOBufferMemoryDescriptor> swd_spindump_memDesc;
  OSPtr<IOBufferMemoryDescriptor> swd_memDesc;
  OSPtr<OSArray> _systemWakeEventsArray;
  bool _acceptSystemWakeEvents;
  IOPMCalendarStruct _aotWakeTimeCalendar;
  OSPtr<IOTimerEventSource> _aotTimerES;
  clock_sec_t _aotWakeTimeUTC;
  uint64_t _aotTestTime;
  uint64_t _aotTestInterval;
  uint32_t _aotPendingFlags;
  IOPMAOTMetrics *_aotMetrics;
  uint8_t _aotMode;
  uint8_t _aotNow;
  uint8_t _aotTasksSuspended;
  uint8_t _aotTimerScheduled;
  uint8_t _aotReadyToFullWake;
  uint64_t _aotLastWakeTime;
  uint64_t _aotWakeTimeContinuous;
  uint64_t _aotWakePreWindow;
  uint64_t _aotWakePostWindow;
  uint64_t _aotLingerTime;
  OSPtr<OSDictionary> lowLatencyAudioNotifierDict;
  OSPtr<OSNumber> lowLatencyAudioNotifyStateVal;
  OSPtr<OSNumber> lowLatencyAudioNotifyTimestampVal;
  OSPtr<const OSSymbol> lowLatencyAudioNotifyStateSym;
  OSPtr<const OSSymbol> lowLatencyAudioNotifyTimestampSym;
};

/* 2380 */
struct __cppobj IOPMPowerStateQueue : IOEventSource_0
{
  queue_head_t_0 queueHead;
  IOLock_0 *queueLock;
};

/* 2378 */
typedef void (*IOPMTracePointHandler)(void *, uint32_t, uint32_t);

/* 2379 */
struct __cppobj __attribute__((aligned(8))) PMTraceWorker : OSObject_1
{
  IOPMTracePointHandler tracePointHandler;
  void *tracePointTarget;
  IOPMrootDomain_0 *owner;
  IOLock_0 *pmTraceWorkerLock;
  OSSharedPtr<OSArray> pciDeviceBitMappings;
  uint8_t addedToRegistry;
  uint8_t tracePhase;
  uint32_t traceData32;
  uint8_t loginWindowData;
  uint8_t coreDisplayData;
  uint8_t coreGraphicsData;
};

/* 2385 */
typedef uint64_t IOPMDriverAssertionID;

/* 2382 */
typedef uint64_t IOPMDriverAssertionType;

/* 2376 */
struct __cppobj PMAssertionsTracker : OSObject_1
{
  uint32_t tabulateProducerCount;
  uint32_t tabulateConsumerCount;
  uint64_t maxAssertCPUDuration;
  uint64_t maxAssertCPUEntryId;
  IOPMrootDomain_0 *owner;
  OSSharedPtr<OSArray> assertionsArray;
  IOLock_0 *assertionsArrayLock;
  IOPMDriverAssertionID issuingUniqueID;
  IOPMDriverAssertionType assertionsKernel;
  IOPMDriverAssertionType assertionsUser;
  IOPMDriverAssertionType assertionsCombined;
};

/* 7759 */
struct IOPMrootDomain::PMNotifySuspendedStruct
{
  uint32_t pid;
  uint32_t refcount;
};

/* 2371 */
struct IOPMAOTMetrics
{
  uint32_t sleepCount;
  uint32_t possibleCount;
  uint32_t confirmedPossibleCount;
  uint32_t rejectedPossibleCount;
  uint32_t expiredPossibleCount;
  uint32_t noTimeSetCount;
  uint32_t rtcAlarmsCount;
  uint32_t softwareRequestCount;
  uint64_t totalTime;
  char kernelWakeReason[24][64];
  uint64_t kernelSleepTime[24];
  uint64_t kernelWakeTime[24];
};

/* 2372 */
typedef struct *IOTimerEventSource::ActionBlock;

/* 2373 */
typedef void (*IOTimerEventSource::Action_0)(OSObject_0 *, IOTimerEventSource_0 *);

/* 2377 */
enum PMTraceWorker::change_t : __int32
{
  kPowerChangeStart = 0x0,
  kPowerChangeCompleted = 0x1,
};

/* 2381 */
typedef uint32_t IOPMRequestTag;

/* 2383 */
enum IOPMrootDomain::FullWakeReason : __int32
{
  IOPMrootDomain::FullWakeReason::kFullWakeReasonNone = 0x0,
  IOPMrootDomain::FullWakeReason::kFullWakeReasonLocalUser = 0x1,
  IOPMrootDomain::FullWakeReason::kFullWakeReasonDisplayOn = 0x2,
  IOPMrootDomain::FullWakeReason::fFullWakeReasonDisplayOnAndLocalUser = 0x3,
};

/* 2384 */
typedef uint32_t IOReportUpdateAction_0;

/* 2386 */
typedef uint32_t IOPMDriverAssertionLevel;

/* 2387 */
typedef IOReturn_0 (*IOServiceInterestHandler_0)(void *, void *, UInt32, IOService_0 *, void *, vm_size_t_0);

/* 2400 */
struct __cppobj IOPlatformExpert_0 : IOService_0
{
  long _peBootROMType;
  long _peChipSetType;
  long _peMachineType;
  IOPMrootDomain_0 *root;
  int _pePMFeatures;
  int _pePrivPMFeatures;
  int _peNumBatteriesSupported;
  OSArray_0 *thePowerTree;
  bool searchingForAdditionalParents;
  OSNumber_0 *multipleParentKeyValue;
  int numInstancesRegistered;
  IOPlatformExpert::ExpansionData_0 *iope_reserved;
};

/* 7751 */
struct IOPlatformExpert::ExpansionData_0
{
  _BYTE gap0;
};

/* 2401 */
typedef IOReturn_0 (*IOCommandGate::Action_0)(OSObject_0 *, void *, void *, void *, void *);

/* 2420 */
typedef struct *IOWorkLoop::ActionBlock;

/* 2421 */
typedef IOReturn_0 (*IOWorkLoop::Action_0)(OSObject_0 *, void *, void *, void *, void *);

/* 2424 */
typedef const OSCollection_0 *OSPtr<const OSCollection>;

/* 2427 */
struct OSKextActiveAccount
{
  uintptr_t address;
  uintptr_t address_end;
  OSKextAccount *account;
};

/* 2548 */
typedef OSData_0 *libkern::intrusive_shared_ptr<OSData,intrusive_osobject_retainer>::pointer;

/* 7728 */
struct libkern::intrusive_shared_ptr<OSData,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSData,intrusive_osobject_retainer>::pointer ptr_;
};

/* 2429 */
struct __cppobj OSSharedPtr<OSData> : libkern::intrusive_shared_ptr<OSData,intrusive_osobject_retainer>
{
};

/* 2430 */
struct host
{
  lck_mtx_t_0 lock;
  _BYTE gap10[272];
  exception_action exc_actions[14];
};

/* 2433 */
typedef uint32_t OSKextRequestTag;

/* 2434 */
typedef void (*OSKextRequestResourceCallback)(OSKextRequestTag, OSReturn_0, const void *, uint32_t, void *);

/* 2436 */
typedef uint8_t OSKextExcludeLevel_0;

/* 2438 */
typedef host *host_priv_t;

/* 2442 */
struct __cppobj _IOUserServerCheckInCancellationHandler : OSObject_1
{
  IOUserServerCheckInCancellationHandler fHandler;
  void *fHandlerArgs;
};

/* 2449 */
typedef int32_t IOInterruptVectorNumber_0;

/* 2454 */
typedef void (*IOPMActionUpdatePowerClient)(void *, IOService_0 *, IOPMActions *, const OSSymbol_0 *, IOPMPowerStateIndex, IOPMPowerStateIndex);

/* 2458 */
typedef void (*IOPMActionPowerChangeStart)(void *, IOService_0 *, IOPMActions *, const IOPMRequest *, IOPMPowerStateIndex, IOPMPowerChangeFlags *);

/* 2457 */
typedef void (*IOPMActionPowerChangeDone)(void *, IOService_0 *, IOPMActions *, const IOPMRequest *, IOPMPowerStateIndex, IOPMPowerChangeFlags);

/* 2456 */
typedef void (*IOPMActionPowerChangeOverride)(void *, IOService_0 *, IOPMActions *, const IOPMRequest *, IOPMPowerStateIndex *, IOPMPowerChangeFlags *);

/* 2455 */
typedef void (*IOPMActionActivityTickle)(void *, IOService_0 *, IOPMActions *);

/* 2463 */
struct IOPMActions
{
  void *target;
  IOPMActionPowerChangeStart actionPowerChangeStart;
  IOPMActionPowerChangeDone actionPowerChangeDone;
  IOPMActionPowerChangeOverride actionPowerChangeOverride;
  IOPMActionActivityTickle actionActivityTickle;
  IOPMActionUpdatePowerClient actionUpdatePowerClient;
  uint32_t darkWakePowerState;
  uint16_t flags;
  uint16_t state;
};

/* 2459 */
struct __cppobj __attribute__((aligned(8))) IOPowerConnection_0 : IOService_0
{
  bool stateKnown;
  IOPMPowerFlags currentPowerFlags;
  unsigned __int64 desiredDomainState;
  bool requestFlag;
  unsigned __int64 preventIdleSleepFlag;
  unsigned __int64 preventSystemSleepFlag;
  bool awaitingAck;
  bool readyFlag;
  bool delayChildNotification;
};

/* 2460 */
struct IOPMPSEntry
{
  IOPMPowerFlags capabilityFlags;
  IOPMPowerFlags outputPowerFlags;
  IOPMPowerFlags inputPowerFlags;
  unsigned __int64 staticPower;
  IOPMPowerStateIndex stateOrder;
  IOPMPowerStateIndex stateOrderToIndex;
};

/* 2461 */
struct __cppobj __attribute__((aligned(8))) IOPMinformee : OSObject_1
{
  IOService_0 *whatObject;
  int32_t timer;
  IOPMinformee *nextInList;
  AbsoluteTime_0 startTime;
  bool active;
};

/* 2462 */
struct __cppobj IOPMinformeeList : OSObject_1
{
  IOPMinformee *firstItem;
  unsigned __int64 length;
};

/* 2466 */
typedef UInt32 IOItemCount_0;

/* 2470 */
struct os_detail::IOKit_data_allocator
{
  _BYTE gap0;
};

/* 2471 */
typedef libkern::bounded_array_ref<IODispatchQueue *,os_detail::panic_trapping_policy> OSBoundedArrayRef<IODispatchQueue *>;

/* 7766 */
struct __attribute__((aligned(8))) libkern::bounded_array_ref<IODispatchQueue *,os_detail::panic_trapping_policy>
{
  IODispatchQueue **data_;
  uint32_t size_;
};

/* 2480 */
struct IODMAMapPageList_0
{
  uint32_t pageOffset;
  uint32_t pageListCount;
  const upl_page_info_t_0 *pageList;
};

/* 2483 */
struct IODMACommandMapSegment
{
  uint64_t fDMAOffset;
  uint64_t fMapOffset;
  uint64_t fPageOffset;
};

/* 2485 */
typedef IOOptionBits_0 IODirection_0;

/* 2488 */
typedef vm_page *vm_page_t;

/* 2489 */
struct __attribute__((aligned(4))) IOMDDMACharacteristics
{
  UInt64 fLength;
  UInt32 fSGCount;
  UInt32 fPages;
  UInt32 fPageAlign;
  ppnum_t_0 fHighestPage;
  IODirection_0 fDirection;
  UInt8 fIsPrepared;
};

/* 2490 */
typedef UInt8 IOMDDMAWalkSegmentState[128];

/* 2491 */
typedef IOReturn_0 (*IODMACommand::InternalSegmentFunction)(void *, IODMACommand_0 *, IODMACommand::Segment64_0, void *, UInt32);

/* 2493 */
enum IODMACommand::MappingOptions_0 : __int32
{
  IODMACommand::MappingOptions::kMapped_0 = 0x0,
  IODMACommand::MappingOptions::kBypassed_0 = 0x1,
  IODMACommand::MappingOptions::kNonCoherent_0 = 0x2,
  IODMACommand::MappingOptions::kUnmapped_0 = 0x3,
  IODMACommand::MappingOptions::kTypeMask_0 = 0xF,
  IODMACommand::MappingOptions::kNoCacheStore_0 = 0x10,
  IODMACommand::MappingOptions::kOnChip_0 = 0x20,
  IODMACommand::MappingOptions::kIterateOnly_0 = 0x40,
};

/* 2494 */
typedef kern_return_t (*IODMACommand::PerformOperation_Handler)(OSMetaClassBase_0 *, uint64_t, uint64_t, uint64_t, uint64_t, IOMemoryDescriptor_0 *);

/* 2495 */
typedef kern_return_t (*IODMACommand::GetPreparation_Handler)(OSMetaClassBase_1 *, uint64_t *, uint64_t *, IOMemoryDescriptor_0 **);

/* 2496 */
typedef kern_return_t (*IODMACommand::CompleteDMA_Handler)(OSMetaClassBase_0 *, uint64_t);

/* 2497 */
typedef kern_return_t (*IODMACommand::PrepareForDMA_Handler)(OSMetaClassBase_0 *, uint64_t, IOMemoryDescriptor_0 *, uint64_t, uint64_t, uint64_t *, uint32_t *, IOAddressSegment *);

/* 2498 */
typedef kern_return_t (*IODMACommand::Create_Handler)(IOService_0 *, uint64_t, const IODMACommandSpecification *, IODMACommand_0 **);

/* 2499 */
typedef kern_return_t (*OSDispatchMethod)(OSMetaClassBase_0 *, const IORPC_0);

/* 2514 */
struct IOMemoryDescriptorDevicePager
{
  void *devicePager;
  _BYTE gap8[8];
  IOMemoryDescriptor_0 *memory;
};

/* 2515 */
typedef IOOptionBits_0 IOMemoryDescriptor::DMACommandOps_0;

/* 2519 */
typedef kern_return_t (*IOBufferMemoryDescriptor::SetLength_Handler)(OSMetaClassBase_0 *, uint64_t);

/* 2520 */
typedef kern_return_t (*IOBufferMemoryDescriptor::Create_Handler)(uint64_t, uint64_t, uint64_t, IOBufferMemoryDescriptor_0 **);

/* 7178 */
struct IOReportChannel
{
  uint64_t channel_id;
  IOReportChannelType channel_type;
};

/* 2524 */
struct IOReportChannelList_0
{
  uint32_t nchannels;
  IOReportChannel channels[];
};

/* 2530 */
typedef uint32_t IOReportConfigureAction_0;

/* 2533 */
typedef uint16_t IOReportCategories;

/* 2566 */
typedef const OSMetaClassBase_0 *libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_osobject_retainer>::pointer;

/* 7712 */
struct libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_osobject_retainer>::pointer ptr_;
};

/* 2539 */
struct __cppobj OSSharedPtr<const OSMetaClassBase> : libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_osobject_retainer>
{
};

/* 2541 */
typedef const OSMetaClassBase_0 *libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_tagged_osobject_retainer<OSCollection> >::pointer;

/* 2543 */
typedef void *libkern::sa_detail::nullptr_t;

/* 2544 */
struct __cppobj libkern::allocate_memory_zero_t
{
  _BYTE gap0;
};

/* 2545 */
struct __cppobj libkern::allocate_memory_t
{
  _BYTE gap0;
};

/* 2546 */
struct __cppobj libkern::adopt_memory_t
{
  _BYTE gap0;
};

/* 2547 */
typedef PMTraceWorker *libkern::intrusive_shared_ptr<PMTraceWorker,intrusive_osobject_retainer>::pointer;

/* 2549 */
typedef OSKext_0 *libkern::intrusive_shared_ptr<OSKext,intrusive_osobject_retainer>::pointer;

/* 2551 */
typedef IONotifier_0 *libkern::intrusive_shared_ptr<IONotifier,intrusive_osobject_retainer>::pointer;

/* 2552 */
typedef char libkern::detail::copy_cv<unsigned int,char>::type;

/* 2553 */
typedef char libkern::detail::copy_cv<IODispatchQueue *,char>::type;

/* 2554 */
typedef void *libkern::detail::nullptr_t;

/* 2555 */
typedef libkern::detail::copy_cv<IODispatchQueue *,char>::type libkern::detail::copy_cv_t<IODispatchQueue *,char>;

/* 7767 */
typedef libkern::detail::copy_cv_t<IODispatchQueue *,char> libkern::bounded_ptr<IODispatchQueue *,os_detail::panic_trapping_policy>::CharType;

/* 2556 */
struct libkern::bounded_ptr<IODispatchQueue *,os_detail::panic_trapping_policy>
{
  libkern::bounded_ptr<IODispatchQueue *,os_detail::panic_trapping_policy>::CharType *base_;
  uint32_t count_;
  int32_t offset_;
};

/* 2562 */
typedef OSIterator_0 *libkern::intrusive_shared_ptr<OSIterator,intrusive_osobject_retainer>::pointer;

/* 2564 */
typedef IORegistryEntry_0 *libkern::intrusive_shared_ptr<IORegistryEntry,intrusive_osobject_retainer>::pointer;

/* 2565 */
typedef OSObject_0 *libkern::intrusive_shared_ptr<OSObject,intrusive_osobject_retainer>::pointer;

/* 2567 */
struct __cppobj libkern::retain_t
{
  _BYTE gap0;
};

/* 2568 */
struct __cppobj libkern::no_retain_t
{
  _BYTE gap0;
};

/* 2569 */
typedef void *libkern::isp_detail::nullptr_t;

/* 2577 */
typedef const OSSymbol_0 *OSTaggedPtr<const OSSymbol>;

/* 2584 */
typedef OSObject_0 *OSObjectPtr;

/* 2586 */
typedef integer_t mach_port_delta_t;

/* 2587 */
typedef kern_return_t (*IOUserClient::_ExternalMethod_Handler)(OSMetaClassBase_1 *, uint64_t, const unsigned __int64 *, uint32_t, OSData_0 *, IOMemoryDescriptor_0 *, unsigned __int64 *, uint32_t *, uint64_t, OSData_0 **, IOMemoryDescriptor_0 *, OSAction_0 *);

/* 2588 */
typedef kern_return_t (*IOUserClient::CopyClientEntitlements_Handler)(OSMetaClassBase_0 *, OSDictionary_0 **);

/* 2589 */
typedef kern_return_t (*IOUserClient::CreateMemoryDescriptorFromClient_Handler)(OSMetaClassBase_1 *, uint64_t, uint32_t, const IOAddressSegment *, IOMemoryDescriptor_0 **);

/* 2590 */
typedef kern_return_t (*IOUserClient::CopyClientMemoryForType_Handler)(OSMetaClassBase_1 *, uint64_t, uint64_t *, IOMemoryDescriptor_0 **);

/* 2591 */
typedef void (*IOUserClient::AsyncCompletion_Handler)(OSMetaClassBase_0 *, OSAction_0 *, IOReturn_0, const unsigned __int64 *, uint32_t);

/* 2594 */
typedef kern_return_t (*IOUserServer::LoadModule_Handler)(OSMetaClassBase_0 *, const char *);

/* 2595 */
typedef kern_return_t (*IOUserServer::Exit_Handler)(OSMetaClassBase_0 *, const char *);

/* 2596 */
typedef kern_return_t (*IOUserServer::Create_Handler)(const char *, uint64_t, uint64_t, OSString_0 *, IOUserServer **);

/* 2600 */
struct OSInterface_0
{
  _BYTE gap0;
};

/* 2601 */
typedef kern_return_t (*IODispatchQueue::Create_Handler)(const char *, uint64_t, uint64_t, IODispatchQueue **);

/* 2602 */
typedef kern_return_t (*IODispatchQueue::SetPort_Handler)(OSMetaClassBase_0 *, mach_port_t_0);

/* 2603 */
typedef struct *IODispatchAction;

/* 2604 */
typedef int (*IODispatchLogFunction)(const char *, ...);

/* 2605 */
typedef void (*IODispatchFunction)(void *);

/* 2606 */
typedef struct *IODispatchBlock;

/* 2607 */
typedef struct *IODispatchQueueCancelHandler;

/* 2608 */
struct IODispatchQueueInterface
{
  _BYTE gap0;
};

/* 2611 */
struct mach_msg_header_t_0
{
  mach_msg_bits_t msgh_bits;
  mach_msg_size_t msgh_size;
  mach_port_t_0 msgh_remote_port;
  mach_port_t_0 msgh_local_port;
  mach_port_name_t_0 msgh_voucher_port;
  mach_msg_id_t msgh_id;
};

/* 2614 */
typedef kern_return_t (*OSObject::CopyDispatchQueue_Handler)(OSMetaClassBase_0 *, const char *, IODispatchQueue **);

/* 2615 */
typedef kern_return_t (*OSObject::SetDispatchQueue_Handler)(OSMetaClassBase_0 *, const char *, IODispatchQueue *);

/* 2618 */
typedef bool (*OSMetaClassInstanceApplierFunction)(const OSObject_0 *, void *);

/* 2622 */
struct __attribute__((aligned(8))) devsw_lock
{
  struct
  {
    devsw_lock *tqe_next;
    devsw_lock **tqe_prev;
  } dl_list;
  thread_t_0 dl_thread;
  dev_t dl_dev;
  int dl_mode;
  int dl_waiters;
};

/* 2623 */
typedef int select_fcn_t(dev_t, int, void *, struct proc *);

/* 2624 */
typedef int stop_fcn_t(tty *, int);

/* 2627 */
typedef int open_close_fcn_t(dev_t, int, int, struct proc *);

/* 3665 */
typedef int read_write_fcn_t(dev_t, uio *, int);

/* 2626 */
typedef int ioctl_fcn_t(dev_t, u_long, caddr_t, int, struct proc *);

/* 5505 */
typedef int reset_fcn_t(int);

/* 5504 */
typedef int mmap_fcn_t(void);

/* 5503 */
typedef void strategy_fcn_t(buf *);

/* 5502 */
typedef int rsvd_fcn_t(void);

/* 2625 */
struct __attribute__((aligned(8))) cdevsw
{
  open_close_fcn_t *d_open;
  open_close_fcn_t *d_close;
  read_write_fcn_t *d_read;
  read_write_fcn_t *d_write;
  ioctl_fcn_t *d_ioctl;
  stop_fcn_t *d_stop;
  reset_fcn_t *d_reset;
  tty **d_ttys;
  select_fcn_t *d_select;
  mmap_fcn_t *d_mmap;
  strategy_fcn_t *d_strategy;
  rsvd_fcn_t *d_reserved_1;
  rsvd_fcn_t *d_reserved_2;
  int d_type;
};

/* 5411 */
typedef int dump_fcn_t(void);

/* 5410 */
typedef int psize_fcn_t(dev_t);

/* 2628 */
struct __attribute__((aligned(8))) bdevsw
{
  open_close_fcn_t *d_open;
  open_close_fcn_t *d_close;
  strategy_fcn_t *d_strategy;
  ioctl_fcn_t *d_ioctl;
  dump_fcn_t *d_dump;
  psize_fcn_t *d_psize;
  int d_type;
};

/* 2634 */
typedef sdt_provider sdt_provider_t;

/* 7237 */
typedef uintptr_t dtrace_provider_id_t;

/* 9203 */
struct sdt_provider
{
  const char *sdtp_name;
  const char *sdtp_prefix;
  dtrace_pattr_t *sdtp_attr;
  dtrace_provider_id_t sdtp_id;
};

/* 2635 */
typedef sdt_probe sdt_probe_t;

/* 5442 */
typedef uint32_t sdt_instr_t;

/* 7781 */
struct sdt_probe
{
  sdt_provider_t *sdp_provider;
  char *sdp_name;
  int sdp_namelen;
  dtrace_id_t sdp_id;
  modctl *sdp_ctl;
  int sdp_loadcnt;
  int sdp_primary;
  sdt_instr_t *sdp_patchpoint;
  sdt_instr_t sdp_patchval;
  sdt_instr_t sdp_savedval;
  sdt_probe *sdp_next;
  sdt_probe *sdp_hashnext;
};

/* 2636 */
typedef arm_saved_state64 arm_saved_state64_t;

/* 2639 */
struct arm_saved_state64
{
  uint64_t x[29];
  uint64_t fp;
  uint64_t lr;
  uint64_t sp;
  uint64_t pc;
  uint32_t cpsr;
  uint32_t aspsr;
  uint64_t far;
  uint32_t esr;
  uint32_t exception;
  uint64_t jophash;
};

/* 2637 */
typedef arm_saved_state arm_saved_state_t;

/* 7238 */
struct arm_state_hdr
{
  uint32_t flavor;
  uint32_t count;
};

/* 2641 */
typedef arm_state_hdr arm_state_hdr_t;

/* 2640 */
struct arm_saved_state32
{
  uint32_t r[13];
  uint32_t sp;
  uint32_t lr;
  uint32_t pc;
  uint32_t cpsr;
  uint32_t far;
  uint32_t esr;
  uint32_t exception;
};

/* 2642 */
struct arm_saved_state
{
  arm_state_hdr_t ash;
  union
  {
    arm_saved_state32 ss_32;
    arm_saved_state64 ss_64;
  } uss;
};

/* 2638 */
struct frame
{
  frame *backchain;
  uintptr_t retaddr;
};

/* 2643 */
struct __attribute__((aligned(4))) arm64_decode_entry
{
  uint32_t mask;
  uint32_t value;
  uint8_t type;
};

/* 2644 */
typedef fasttrap_bucket fasttrap_bucket_t;

/* 9204 */
struct fasttrap_bucket
{
  lck_mtx_t ftb_mtx;
  void *ftb_data;
  uint8_t ftb_pad[40];
};

/* 2645 */
typedef arm_saved_state32 arm_saved_state32_t;

/* 2646 */
struct uint32x4_t_0
{
  uint32_t body[4];
};

/* 2647 */
struct uint64x2_t_0
{
  uint64_t body[2];
};

/* 2648 */
typedef unsigned __int128 __uint128_t_0;

/* 2649 */
typedef __uint128_t_0 uint128_t;

/* 2650 */
typedef arm_neon_saved_state64 arm_neon_saved_state64_t;

/* 5652 */
struct arm_neon_saved_state64
{
  union
  {
    uint128_t q[32];
    uint64x2_t_0 d[32];
    uint32x4_t_0 s[32];
  } v;
  uint32_t fpsr;
  uint32_t fpcr;
  uint32_t afpcr;
  uint32_t reserved;
};

/* 2682 */
typedef uthread *uthread_t;

/* 2683 */
union fasttrap_instr_t
{
  uint32_t instr32;
  struct
  {
    uint16_t instr1;
    uint16_t instr2;
  } instr16;
};

/* 2684 */
typedef fasttrap_machtp fasttrap_machtp_t;

/* 7801 */
struct __attribute__((aligned(2))) fasttrap_machtp
{
  fasttrap_instr_t ftmt_instr;
  uint8_t ftmt_fntype;
  uint8_t ftmt_thumb;
  uint8_t ftmt_type;
};

/* 2685 */
typedef fasttrap_tracepoint fasttrap_tracepoint_t;

/* 2688 */
typedef fasttrap_proc fasttrap_proc_t;

/* 2686 */
typedef fasttrap_id fasttrap_id_t;

/* 9212 */
struct fasttrap_tracepoint
{
  fasttrap_proc_t *ftt_proc;
  user_addr_t_0 ftt_pc;
  pid_t ftt_pid;
  fasttrap_machtp_t ftt_mtp;
  fasttrap_id_t *ftt_ids;
  fasttrap_id_t *ftt_retids;
  fasttrap_tracepoint_t *ftt_next;
};

/* 7803 */
struct fasttrap_proc
{
  pid_t ftpc_pid;
  uint64_t ftpc_acount;
  uint64_t ftpc_rcount;
  lck_mtx_t ftpc_mtx;
  fasttrap_proc *ftpc_next;
};

/* 2690 */
typedef fasttrap_probe fasttrap_probe_t;

/* 8124 */
enum fasttrap_probe_type : __int32
{
  fasttrap_probe_type::DTFTP_NONE = 0x0,
  fasttrap_probe_type::DTFTP_ENTRY = 0x1,
  fasttrap_probe_type::DTFTP_RETURN = 0x2,
  fasttrap_probe_type::DTFTP_OFFSETS = 0x3,
  fasttrap_probe_type::DTFTP_POST_OFFSETS = 0x4,
  fasttrap_probe_type::DTFTP_IS_ENABLED = 0x5,
};

/* 5422 */
typedef fasttrap_probe_type fasttrap_probe_type_t;

/* 8126 */
struct __attribute__((aligned(8))) fasttrap_id
{
  fasttrap_probe_t *fti_probe;
  fasttrap_id_t *fti_next;
  fasttrap_probe_type_t fti_ptype;
};

/* 2689 */
typedef fasttrap_provider fasttrap_provider_t;

/* 8127 */
struct fasttrap_id_tp
{
  fasttrap_id_t fit_id;
  fasttrap_tracepoint_t *fit_tp;
};

/* 2687 */
typedef fasttrap_id_tp fasttrap_id_tp_t;

/* 9213 */
struct fasttrap_probe
{
  dtrace_id_t ftp_id;
  pid_t ftp_pid;
  fasttrap_provider_t *ftp_prov;
  user_addr_t_0 ftp_faddr;
  size_t ftp_fsize;
  uint64_t ftp_gen;
  uint64_t ftp_ntps;
  uint8_t *ftp_argmap;
  uint8_t ftp_nargs;
  uint8_t ftp_enabled;
  uint8_t ftp_triggered;
  char *ftp_xtypes;
  char *ftp_ntypes;
  fasttrap_id_tp_t ftp_tps[1];
};

/* 8125 */
enum fasttrap_provider_type : __int32
{
  fasttrap_provider_type::DTFTP_PROVIDER_NONE = 0x0,
  fasttrap_provider_type::DTFTP_PROVIDER_USDT = 0x1,
  fasttrap_provider_type::DTFTP_PROVIDER_PID = 0x2,
  fasttrap_provider_type::DTFTP_PROVIDER_OBJC = 0x3,
  fasttrap_provider_type::DTFTP_PROVIDER_ONESHOT = 0x4,
};

/* 5421 */
typedef fasttrap_provider_type fasttrap_provider_type_t;

/* 7802 */
struct fasttrap_provider
{
  pid_t ftp_pid;
  fasttrap_provider_type_t ftp_provider_type;
  char ftp_name[64];
  dtrace_provider_id_t ftp_provid;
  uint_t_0 ftp_marked;
  uint_t_0 ftp_retired;
  lck_mtx_t ftp_mtx;
  lck_mtx_t ftp_cmtx;
  uint64_t ftp_pcount;
  uint64_t ftp_rcount;
  uint64_t ftp_ccount;
  uint64_t ftp_mcount;
  fasttrap_proc_t *ftp_proc;
  fasttrap_provider *ftp_next;
};

/* 2691 */
typedef dtrace_mstate dtrace_mstate_t;

/* 9215 */
struct dtrace_mstate
{
  uintptr_t dtms_scratch_base;
  uintptr_t dtms_scratch_ptr;
  size_t dtms_scratch_size;
  uint32_t dtms_present;
  uint64_t dtms_arg[5];
  dtrace_epid_t dtms_epid;
  uint64_t dtms_timestamp;
  hrtime_t dtms_walltimestamp;
  uint64_t dtms_machtimestamp;
  uint64_t dtms_machctimestamp;
  int dtms_stackdepth;
  int dtms_ustackdepth;
  dtrace_probe *dtms_probe;
  uintptr_t dtms_caller;
  uint64_t dtms_ucaller;
  int dtms_ipl;
  int dtms_fltoffs;
  uintptr_t dtms_strtok;
  uintptr_t dtms_strtok_limit;
  uint32_t dtms_access;
  dtrace_difo_t *dtms_difo;
};

/* 2692 */
typedef xcArg xcArg_t;

/* 5515 */
typedef int processorid_t;

/* 7805 */
typedef void (*dtrace_xcall_t)(void *);

/* 9216 */
struct xcArg
{
  processorid_t cpu;
  dtrace_xcall_t f;
  void *arg;
};

/* 2693 */
typedef arm_saved_state_t savearea_t;

/* 2694 */
struct sigreturn_args
{
  user_addr_t_0 uctx;
  int infostyle;
  char infostyle_r_[4];
  user_addr_t_0 token;
  char token_r_[];
};

/* 2713 */
struct arm_thread_state64
{
  __uint64_t x[29];
  __uint64_t fp;
  __uint64_t lr;
  __uint64_t sp;
  __uint64_t pc;
  __uint32_t cpsr;
  __uint32_t flags;
};

/* 2701 */
typedef arm_thread_state64 arm_thread_state64_t;

/* 2695 */
struct sendsig::ts64
{
  arm_thread_state64_t ss;
};

/* 2704 */
struct arm_thread_state
{
  __uint32_t r[13];
  __uint32_t sp;
  __uint32_t lr;
  __uint32_t pc;
  __uint32_t cpsr;
};

/* 2702 */
typedef arm_thread_state arm_thread_state_t;

/* 2696 */
struct sendsig::ts32
{
  arm_thread_state_t ss;
};

/* 2698 */
typedef user_siginfo user_siginfo_t;

/* 9260 */
struct user_siginfo
{
  int si_signo;
  int si_errno;
  int si_code;
  pid_t si_pid;
  uid_t si_uid;
  int si_status;
  user_addr_t_0 si_addr;
  user_sigval si_value;
  user_long_t si_band;
  user_ulong_t pad[7];
};

/* 2699 */
typedef user_ucontext64 user_ucontext64_t;

/* 6994 */
typedef __uint64_t user64_addr_t;

/* 4069 */
typedef __uint64_t user64_size_t;

/* 2715 */
struct __attribute__((aligned(8))) user64_sigaltstack
{
  user64_addr_t ss_sp;
  user64_size_t ss_size;
  int ss_flags;
};

/* 2719 */
struct user_ucontext64
{
  int uc_onstack;
  sigset_t uc_sigmask;
  user64_sigaltstack uc_stack;
  user_addr_t_0 uc_link;
  user_size_t uc_mcsize;
  user_addr_t_0 uc_mcontext64;
};

/* 2700 */
typedef user_ucontext32 user_ucontext32_t;

/* 5361 */
typedef __uint32_t user32_addr_t;

/* 4020 */
typedef __uint32_t user32_size_t;

/* 2706 */
struct user32_sigaltstack
{
  user32_addr_t ss_sp;
  user32_size_t ss_size;
  int ss_flags;
};

/* 2710 */
struct user_ucontext32
{
  int uc_onstack;
  sigset_t uc_sigmask;
  user32_sigaltstack uc_stack;
  user32_addr_t uc_link;
  user32_size_t uc_mcsize;
  user32_addr_t uc_mcontext;
};

/* 2703 */
struct arm_vfp_state
{
  __uint32_t r[64];
  __uint32_t fpscr;
};

/* 2705 */
struct arm_exception_state
{
  __uint32_t exception;
  __uint32_t fsr;
  __uint32_t far;
};

/* 2707 */
typedef __uint32_t user32_ulong_t;

/* 2708 */
union user32_sigval
{
  int32_t sival_int;
  user32_addr_t sival_ptr;
};

/* 2709 */
typedef mcontext32 mcontext32_t;

/* 7808 */
struct mcontext32
{
  arm_exception_state es;
  arm_thread_state ss;
  arm_vfp_state fs;
};

/* 2711 */
typedef user32_siginfo user32_siginfo_t;

/* 7809 */
typedef __int32_t user32_long_t;

/* 9217 */
struct user32_siginfo
{
  int si_signo;
  int si_errno;
  int si_code;
  pid_t si_pid;
  uid_t si_uid;
  int si_status;
  user32_addr_t si_addr;
  user32_sigval si_value;
  user32_long_t si_band;
  user32_ulong_t __pad[7];
};

/* 2712 */
struct __attribute__((aligned(16))) arm_neon_state64
{
  __uint128_t_0 q[32];
  uint32_t fpsr;
  uint32_t fpcr;
};

/* 2714 */
struct arm_exception_state64
{
  __uint64_t far;
  __uint32_t esr;
  __uint32_t exception;
};

/* 2716 */
typedef __uint64_t user64_ulong_t;

/* 2717 */
union user64_sigval
{
  struct
  {
    uint32_t pad;
    int32_t sival_int;
  } size_equivalent;
  user64_addr_t sival_ptr;
};

/* 2718 */
typedef mcontext64 mcontext64_t;

/* 7810 */
struct mcontext64
{
  arm_exception_state64 es;
  arm_thread_state64 ss;
  arm_neon_state64 ns;
};

/* 2720 */
typedef user64_siginfo user64_siginfo_t;

/* 5370 */
typedef __int64_t user64_long_t;

/* 9218 */
struct user64_siginfo
{
  int si_signo;
  int si_errno;
  int si_code;
  pid_t si_pid;
  uid_t si_uid;
  int si_status;
  user64_addr_t si_addr;
  user64_sigval si_value;
  user64_long_t si_band;
  user64_ulong_t __pad[7];
};

/* 2721 */
typedef int32_t sy_call_t(struct proc *, void *, int *);

/* 4110 */
typedef void sy_munge_t(void *);

/* 2722 */
struct sysent
{
  sy_call_t *sy_call;
  sy_munge_t *sy_arg_munge32;
  int32_t sy_return_type;
  int16_t sy_narg;
  uint16_t sy_arg_bytes;
};

/* 2723 */
struct register_uexc_handler_args
{
  user_addr_t_0 start;
  user_size_t size;
  user_addr_t_0 handler;
  user_addr_t_0 refcon;
  char refcon_r_[];
};

/* 7812 */
typedef __uint64_t user_tcflag_t;

/* 7811 */
typedef __uint64_t user_speed_t;

/* 2724 */
struct user_termios
{
  user_tcflag_t c_iflag;
  user_tcflag_t c_oflag;
  user_tcflag_t c_cflag;
  user_tcflag_t c_lflag;
  cc_t c_cc[20];
  user_speed_t c_ispeed;
  user_speed_t c_ospeed;
};

/* 2725 */
struct termios32
{
  __uint32_t c_iflag;
  __uint32_t c_oflag;
  __uint32_t c_cflag;
  __uint32_t c_lflag;
  cc_t c_cc[20];
  __uint32_t c_ispeed;
  __uint32_t c_ospeed;
};

/* 2726 */
struct kern_pbufpool_init
{
  uint32_t kbi_version;
  pbufpool_name_t kbi_name;
  uint32_t kbi_flags;
  uint32_t kbi_packets;
  uint32_t kbi_max_frags;
  uint32_t kbi_buflets;
  uint32_t kbi_bufsize;
  uint32_t kbi_buf_seg_size;
  pbuf_seg_ctor_fn_t_0 kbi_buf_seg_ctor;
  pbuf_seg_dtor_fn_t_0 kbi_buf_seg_dtor;
  void *kbi_ctx;
  pbuf_ctx_retain_fn_t kbi_ctx_retain;
  pbuf_ctx_release_fn_t kbi_ctx_release;
};

/* 2727 */
struct __attribute__((aligned(64))) kern_pbufpool_memory_info
{
  uint32_t kpm_flags;
  uint32_t kpm_packets;
  uint32_t kpm_max_frags;
  uint32_t kpm_buflets;
  uint32_t kpm_bufsize;
  uint32_t kpm_bufsegs;
  uint32_t kpm_buf_seg_size;
  uint32_t kpm_buf_obj_size;
};

/* 2728 */
typedef void (*alloc_cb_func_t)(kern_packet_t, uint32_t, const void *);

/* 2729 */
typedef __kern_buflet *kern_buflet_t;

/* 2817 */
struct __attribute__((aligned(8))) route
{
  rtentry *ro_rt;
  llentry *ro_lle;
  ifaddr *ro_srcia;
  uint32_t ro_flags;
  sockaddr ro_dst;
};

/* 2831 */
typedef errno_t (*ifnet_framer_func)(ifnet_t, mbuf_t *, const sockaddr *, const char *, const char *);

/* 2888 */
struct __attribute__((aligned(8))) __user_packet
{
  __user_quantum pkt_qum;
  __packet pkt_com;
  __packet_opt pkt_com_opt;
  const uint16_t pkt_bufs_max;
  const uint16_t pkt_bufs_cnt;
};

/* 2889 */
struct skmem_obj
{
  skmem_obj *mo_next;
  skmem_obj_info mo_info;
  skmem_obj_info mo_minfo;
};

/* 2890 */
struct __metadata_preamble
{
  union
  {
    uint64_t _mdp_next;
    uint64_t mdp_redzone;
  };
  const obj_idx_t mdp_idx;
  uint16_t mdp_type;
  uint16_t mdp_subtype;
};

/* 2891 */
typedef uint32_t kern_obj_idx_seg_t;

/* 2892 */
enum packet_expiry_action_t : __int32
{
  PACKET_EXPIRY_ACTION_NONE = 0x0,
  PACKET_EXPIRY_ACTION_DROP = 0x1,
  PACKET_EXPIRY_ACTION_NOTIFY = 0x2,
};

/* 2893 */
enum kern_packet_traffic_class_t : __int32
{
  KPKT_TC_UNSPEC = 0xFFFFFFFF,
  KPKT_TC_BE = 0x0,
  KPKT_TC_BK = 0x1,
  KPKT_TC_VI = 0x2,
  KPKT_TC_VO = 0x3,
  KPKT_TC_MAX = 0x4,
};

/* 2894 */
enum kern_packet_copy_mode_t : __int32
{
  KPKT_COPY_HEAVY = 0x0,
  KPKT_COPY_LIGHT = 0x1,
};

/* 2895 */
typedef packet_id packet_id_t;

/* 7817 */
struct packet_id
{
  uint8_t pktid_version;
  uint8_t pktid_payload_type;
  uint16_t pktid_sequence_number;
  uint32_t pktid_timestamp;
  uint32_t pktid_stream_identifier;
  uint32_t _reserved;
};

/* 2911 */
struct nxprov_adjusted_params
{
  nexus_meta_subtype_t *adj_md_subtype;
  uint32_t *adj_stats_size;
  uint32_t *adj_flowadv_max;
  uint32_t *adj_nexusadv_size;
  uint32_t *adj_caps;
  uint32_t *adj_tx_rings;
  uint32_t *adj_rx_rings;
  uint32_t *adj_tx_slots;
  uint32_t *adj_rx_slots;
  uint32_t *adj_alloc_rings;
  uint32_t *adj_free_rings;
  uint32_t *adj_alloc_slots;
  uint32_t *adj_free_slots;
  uint32_t *adj_buf_size;
  uint32_t *adj_buf_region_segment_size;
  uint32_t *adj_pp_region_config_flags;
  uint32_t *adj_max_frags;
  uint32_t *adj_event_rings;
  uint32_t *adj_event_slots;
  uint32_t *adj_max_buffers;
  uint32_t *adj_large_buf_size;
};

/* 2912 */
struct nexus_kpipe_adapter
{
  nexus_adapter_0 kna_up;
};

/* 2913 */
struct __flowadv_entry
{
  union
  {
    uint64_t fae_id_64[2];
    uint32_t fae_id_32[4];
    uuid_t_1 fae_id;
  };
  volatile uint32_t fae_flags;
  uint32_t fae_flowid;
};

/* 2914 */
struct skmem_arena_nexus
{
  skmem_arena arn_cmn;
  kern_pbufpool *arn_rx_pp;
  kern_pbufpool *arn_tx_pp;
  uint32_t arn_mode;
  nexus_meta_type_t arn_md_type;
  nexus_meta_subtype_t arn_md_subtype;
  int arn_ksd_nodefunct;
  skmem_cache *arn_schema_cache;
  skmem_cache *arn_ring_cache;
  skmem_cache *arn_txaksd_cache;
  skmem_cache *arn_rxfksd_cache;
  void *arn_stats_obj;
  __flowadv_entry *arn_flowadv_obj;
  void *arn_nexusadv_obj;
};

/* 2989 */
struct nx_upipe
{
  nexus_adapter *nup_pna;
  uint32_t nup_pna_users;
  nxbind *nup_cli_nxb;
  nxbind *nup_srv_nxb;
};

/* 3031 */
struct __attribute__((aligned(8))) netif_gso_ip_tcp_state
{
  void (*update)(netif_gso_ip_tcp_state *, __kern_packet *, uint8_t *);
  void (*internal)(netif_gso_ip_tcp_state *, uint32_t, uint16_t);
  union
  {
    ip *ip;
    ip6_hdr *ip6;
  } hdr;
  int af;
  tcphdr *tcp;
  kern_pbufpool *pp;
  uint32_t psuedo_hdr_csum;
  uint32_t tcp_seq;
  uint16_t hlen;
  uint16_t mss;
  uint16_t ip_id;
  uint8_t mac_hlen;
  uint8_t ip_hlen;
  uint8_t tcp_hlen;
};

/* 3035 */
struct ip
{
  _BYTE gap0;
  u_char ip_tos;
  u_short ip_len;
  u_short ip_id;
  u_short ip_off;
  u_char ip_ttl;
  u_char ip_p;
  u_short ip_sum;
  in_addr ip_src;
  in_addr ip_dst;
};

/* 3033 */
struct ip6_hdrctl
{
  u_int32_t ip6_un1_flow;
  u_int16_t ip6_un1_plen;
  u_int8_t ip6_un1_nxt;
  u_int8_t ip6_un1_hlim;
};

/* 3034 */
struct ip6_hdr
{
  union
  {
    ip6_hdrctl ip6_un1;
    u_int8_t ip6_un2_vfc;
  } ip6_ctlun;
  in6_addr_0 ip6_src;
  in6_addr_0 ip6_dst;
};

/* 5049 */
typedef __uint32_t tcp_seq;

/* 3032 */
struct tcphdr
{
  unsigned __int16 th_sport;
  unsigned __int16 th_dport;
  tcp_seq th_seq;
  tcp_seq th_ack;
  _BYTE gapC;
  unsigned __int8 th_flags;
  unsigned __int16 th_win;
  unsigned __int16 th_sum;
  unsigned __int16 th_urp;
};

/* 3036 */
struct ifnet_poll_params
{
  u_int32_t flags;
  u_int32_t packets_limit;
  u_int32_t packets_lowat;
  u_int32_t packets_hiwat;
  u_int32_t bytes_lowat;
  u_int32_t bytes_hiwat;
  u_int64_t interval_time;
  u_int64_t reserved[4];
};

/* 3037 */
struct ifkpi
{
  unsigned int ifk_module_id;
  unsigned int ifk_type;
  union
  {
    void *ifk_ptr;
    int ifk_value;
    u_int64_t ifk_ptr64;
  } ifk_data;
};

/* 3038 */
struct ifdevmtu
{
  int ifdm_current;
  int ifdm_min;
  int ifdm_max;
};

/* 3039 */
struct ether_vlan_header
{
  u_char evl_dhost[6];
  u_char evl_shost[6];
  u_int16_t evl_encap_proto;
  u_int16_t evl_tag;
  u_int16_t evl_proto;
};

/* 3062 */
enum nx_port_info_type_t : __int32
{
  NX_PORT_INFO_TYPE_NETIF = 0x10000001,
};

/* 3040 */
struct nx_port_info_header
{
  nx_port_info_type_t ih_type;
  size_t ih_size;
};

/* 3041 */
struct __kern_channel_event_metadata
{
  os_channel_event_type_t emd_etype;
  uint32_t emd_nevents;
};

/* 3042 */
enum netif_flowtable_type_t : __int32
{
  FT_TYPE_ETHERTYPE = 0x0,
  FT_TYPE_IPV6_ULA = 0x1,
};

/* 3043 */
struct netif_list_flowtable
{
  netif_flow_head lft_flow_list;
};

/* 3044 */
typedef ether_header ether_header_t;

/* 3045 */
struct filter_pktq
{
  __kern_packet *fp_head;
  __kern_packet **fp_tailp;
};

/* 3046 */
struct necp_demux_pattern
{
  uint16_t offset;
  uint16_t len;
  uint8_t mask[32];
  uint8_t value[32];
};

/* 3047 */
union necp_sockaddr_union
{
  sockaddr sa;
  __sockaddr_header sah;
  sockaddr_in sin;
  sockaddr_in6 sin6;
};

/* 3048 */
struct necp_client_group_members
{
  size_t group_members_length;
  u_int8_t *group_members;
};

/* 3247 */
typedef ns_token *netns_token;

/* 4793 */
typedef u_int32_t necp_policy_id;

/* 3049 */
struct __attribute__((aligned(2))) necp_client_nexus_parameters
{
  pid_t pid;
  pid_t epid;
  uuid_t_1 euuid;
  netns_token port_reservation;
  necp_sockaddr_union local_addr;
  necp_sockaddr_union remote_addr;
  u_int8_t ip_protocol;
  u_int8_t transport_protocol;
  u_int16_t ethertype;
  u_int32_t traffic_class;
  necp_policy_id policy_id;
  _BYTE gap64[2];
  uuid_t_1 parent_flow_uuid;
  necp_demux_pattern demux_patterns[4];
  uint8_t demux_pattern_count;
};

/* 3050 */
struct necp_client_agent_parameters
{
  union
  {
    necp_client_nexus_parameters nexus_request;
    u_int8_t close_token[16];
    necp_client_group_members group_members;
    int32_t error;
  } u;
};

/* 3059 */
typedef ether_addr ether_addr_t;

/* 4720 */
struct ether_addr
{
  u_char octet[6];
};

/* 3060 */
struct nx_flow_req
{
  nexus_port_t nfr_nx_port;
  uint16_t nfr_ethertype;
  ether_addr_t nfr_etheraddr;
  sockaddr_in_4_6 nfr_saddr;
  sockaddr_in_4_6 nfr_daddr;
  uint8_t nfr_ip_protocol;
  uint8_t nfr_transport_protocol;
  uint16_t nfr_flags;
  uuid_t_1 nfr_flow_uuid;
  packet_svc_class_t nfr_svc_class;
  uuid_t_1 nfr_euuid;
  uint32_t nfr_policy_id;
  pid_t nfr_epid;
  flowadv_idx_t nfr_flowadv_idx;
  uuid_t_1 nfr_bind_key;
  uint64_t nfr_qset_id;
  uuid_t_1 nfr_parent_flow_uuid;
  uint8_t nfr_flow_demux_count;
  flow_demux_pattern nfr_flow_demux_patterns[4];
  union
  {
    struct
    {
      void *nfr_context;
      proc *nfr_proc;
      ifnet *nfr_ifp;
      flow_route *nfr_route;
      ns_token *nfr_port_reservation;
      protons_token *nfr_proto_reservation;
      flow_stats *nfr_flow_stats;
      pid_t nfr_pid;
      uint32_t nfr_saddr_gencnt;
      void *nfr_ipsec_reservation;
      uint32_t nfr_inp_flowhash;
      uint8_t _nfr_kernel_pad[4];
      char _nfr_kernel_field_end[];
    };
    struct
    {
      uint8_t _nfr_opaque[80];
      char _nfr_common_field_end[];
    };
  };
};

/* 3061 */
struct netagent_nexus
{
  u_int32_t frame_type;
  u_int32_t endpoint_assignment_type;
  u_int32_t endpoint_request_types[16];
  u_int32_t endpoint_resolution_type_pairs[30];
  u_int32_t nexus_max_buf_size;
  u_int32_t reserved;
  u_int32_t nexus_flags;
};

/* 3063 */
struct __attribute__((aligned(8))) netif_port_info
{
  nx_port_info_header npi_hdr;
  netif_flow_desc npi_fd;
};

/* 3090 */
struct nexus_netif_compat_adapter
{
  nexus_netif_adapter nca_up;
};

/* 3091 */
struct __attribute__((aligned(8))) if_netif_stats
{
  u_int64_t ifn_rx_mit_interval;
  u_int32_t ifn_rx_mit_mode;
  u_int32_t ifn_rx_mit_packets_avg;
  u_int32_t ifn_rx_mit_packets_min;
  u_int32_t ifn_rx_mit_packets_max;
  u_int32_t ifn_rx_mit_bytes_avg;
  u_int32_t ifn_rx_mit_bytes_min;
  u_int32_t ifn_rx_mit_bytes_max;
  u_int32_t ifn_rx_mit_cfg_idx;
  u_int32_t ifn_rx_mit_cfg_packets_lowat;
  u_int32_t ifn_rx_mit_cfg_packets_hiwat;
  u_int32_t ifn_rx_mit_cfg_bytes_lowat;
  u_int32_t ifn_rx_mit_cfg_bytes_hiwat;
  u_int32_t ifn_rx_mit_cfg_interval;
};

/* 3092 */
struct __attribute__((aligned(8))) nx_spec_req
{
  union
  {
    char nsru_name[64];
    uuid_t_1 nsru_uuid;
    ifnet *nsru_ifp;
  } nsr_u;
  uint32_t nsr_flags;
  uuid_t_1 nsr_if_uuid;
};

/* 3093 */
struct sk_stats_net_if
{
  uuid_t_1 sns_nx_uuid;
  char sns_if_name[16];
  netif_stats sns_nifs;
};

/* 3094 */
enum netif_mode_t : __int32
{
  NETIF_MODE_NONE = 0x0,
  NETIF_MODE_FSW = 0x1,
  NETIF_MODE_LLW = 0x2,
};

/* 3095 */
struct netif_qstats_info
{
  uint64_t nqi_qset_id;
  uint16_t nqi_queue_flag;
  uint16_t nqi_queue_idx;
  packet_svc_class_t nqi_svc;
  netif_qstats nqi_stats;
};

/* 3096 */
struct __attribute__((aligned(8))) nx_qset_info
{
  uint64_t nqi_id;
  uint16_t nqi_flags;
  uint8_t nqi_num_rx_queues;
  uint8_t nqi_num_tx_queues;
};

/* 3097 */
struct nx_llink_info
{
  uuid_t_1 nli_netif_uuid;
  uint64_t nli_link_id;
  uint16_t nli_link_id_internal;
  uint8_t nli_state;
  uint8_t nli_flags;
  uint16_t nli_qset_cnt;
  nx_qset_info nli_qset[256];
};

/* 3098 */
struct nx_llink_info_req
{
  uint16_t nlir_version;
  uint16_t nlir_llink_cnt;
  nx_llink_info nlir_llink[];
};

/* 3099 */
struct nexus_monitor_adapter
{
  nexus_adapter_0 mna_up;
  nexus_adapter *mna_pna;
  uint32_t mna_first[2];
  uint32_t mna_last[2];
  uint32_t mna_mode;
  pkt_copy_from_pkt_t *mna_pkt_copy_from_pkt;
};

/* 3100 */
typedef _dbuf_array _dbuf_array_t;

/* 9229 */
struct __attribute__((aligned(8))) _dbuf_array
{
  union
  {
    __kern_buflet *dba_buflet[32];
    mbuf *dba_mbuf[32];
  };
  uint8_t dba_num_dbufs;
  bool dba_is_buflet;
};

/* 3101 */
typedef uint16_t (*flow_agg_fix_pkt_sum_func)(uint16_t, uint16_t, uint16_t);

/* 3102 */
struct flow_agg
{
  union
  {
    struct
    {
      union
      {
        void *_fa_sobj;
        mbuf *_fa_smbuf;
        __kern_packet *_fa_spkt;
      };
      uint8_t *_fa_sptr;
      bool _fa_sobj_is_pkt;
      bool _fa_sobj_is_short;
      uint32_t _fa_tcp_seq;
      uint32_t _fa_ulen;
      uint32_t _fa_total;
      flow_agg_fix_pkt_sum_func _fa_fix_pkt_sum;
    } __flow_agg;
    uint64_t __flow_agg_data[5];
  };
};

/* 3103 */
struct ip6_tcp_mask
{
  ip6_hdr ip6_m;
  tcphdr tcp_m;
  uint32_t tcp_option_m[5];
};

/* 3104 */
struct ip_tcp_mask
{
  ip ip_m;
  tcphdr tcp_m;
  uint32_t tcp_option_m[10];
};

/* 3105 */
struct flowadv
{
  int32_t code;
};

/* 3106 */
struct flow_track_abort_quic::quic_stateless_reset
{
  uint8_t ssr_header[30];
  uint8_t ssr_token[16];
};

/* 3107 */
struct udphdr
{
  u_short uh_sport;
  u_short uh_dport;
  u_short uh_ulen;
  u_short uh_sum;
};

/* 3108 */
typedef int (*flow_route_resolve_fn_t)(void *, flow_route *, __kern_packet *);

/* 3109 */
typedef void (*flow_route_ctor_fn_t)(void *, flow_route *);

/* 3115 */
struct in6_multi_mship
{
  in6_multi *i6mm_maddr;
  struct
  {
    in6_multi_mship *le_next;
    in6_multi_mship **le_prev;
  } i6mm_chain;
};

/* 3116 */
struct nd_defrouter
{
  lck_mtx_t nddr_lock;
  lck_mtx_t nddr_ref_lock;
  struct
  {
    nd_defrouter *tqe_next;
    nd_defrouter **tqe_prev;
  } dr_entry;
  in6_addr_0 rtaddr;
  u_int32_t nddr_refcount;
  u_int32_t nddr_debug;
  u_int64_t expire;
  u_int64_t base_calendartime;
  u_int64_t base_uptime;
  u_char flags;
  u_char stateflags;
  u_int32_t rtlifetime;
  int err;
  ifnet *ifp;
  in6_addr_0 rtaddr_mapped;
  boolean_t is_reachable;
  void (*nddr_trace)(nd_defrouter *, int);
};

/* 3117 */
struct nd_pfxrouter
{
  struct
  {
    nd_pfxrouter *le_next;
    nd_pfxrouter **le_prev;
  } pfr_entry;
  nd_defrouter *router;
};

/* 3118 */
struct prproxy_sols_tree
{
  nd6_prproxy_soltgt *rbh_root;
};

/* 4244 */
struct nd6_prproxy_soltgt
{
  struct
  {
    nd6_prproxy_soltgt *rbe_left;
    nd6_prproxy_soltgt *rbe_right;
    nd6_prproxy_soltgt *rbe_parent;
  } soltgt_link;
  soltgt_key_s soltgt_key;
  u_int64_t soltgt_expire;
  u_int32_t soltgt_cnt;
  struct
  {
    nd6_prproxy_solsrc *tqh_first;
    nd6_prproxy_solsrc **tqh_last;
  } soltgt_q;
};

/* 4243 */
struct soltgt_key_s
{
  in6_addr_0 taddr;
};

/* 4242 */
struct nd6_prproxy_solsrc
{
  struct
  {
    nd6_prproxy_solsrc *tqe_next;
    nd6_prproxy_solsrc **tqe_prev;
  } solsrc_tqe;
  in6_addr_0 solsrc_saddr;
  ifnet *solsrc_ifp;
};

/* 3119 */
struct pr_rtrhead
{
  nd_pfxrouter *lh_first;
};

/* 3120 */
struct prf_ra
{
  _BYTE gap0;
};

/* 3121 */
struct nd_prefix
{
  lck_mtx_t ndpr_lock;
  lck_mtx_t ndpr_ref_lock;
  u_int32_t ndpr_refcount;
  u_int32_t ndpr_debug;
  ifnet *ndpr_ifp;
  rtentry *ndpr_rt;
  struct
  {
    nd_prefix *le_next;
    nd_prefix **le_prev;
  } ndpr_entry;
  sockaddr_in6 ndpr_prefix;
  in6_addr_0 ndpr_mask;
  in6_addr_0 ndpr_addr;
  u_int32_t ndpr_vltime;
  u_int32_t ndpr_pltime;
  u_int64_t ndpr_preferred;
  u_int64_t ndpr_expire;
  u_int64_t ndpr_lastupdate;
  u_int64_t ndpr_base_calendartime;
  u_int64_t ndpr_base_uptime;
  prf_ra ndpr_flags;
  unsigned int ndpr_genid;
  u_int32_t ndpr_stateflags;
  pr_rtrhead ndpr_advrtrs;
  u_char ndpr_plen;
  int ndpr_addrcnt;
  int ndpr_manual_addrcnt;
  u_int32_t ndpr_allmulti_cnt;
  u_int32_t ndpr_prproxy_sols_cnt;
  prproxy_sols_tree ndpr_prproxy_sols;
  void (*ndpr_trace)(nd_prefix *, int);
};

/* 3122 */
struct in6_addrlifetime_i
{
  u_int64_t ia6ti_expire;
  u_int64_t ia6ti_preferred;
  u_int32_t ia6ti_vltime;
  u_int32_t ia6ti_pltime;
  u_int64_t ia6ti_base_calendartime;
  u_int64_t ia6ti_base_uptime;
};

/* 3123 */
struct in6_ifaddr
{
  ifaddr ia_ifa;
  sockaddr_in6 ia_addr;
  sockaddr_in6 ia_net;
  sockaddr_in6 ia_dstaddr;
  sockaddr_in6 ia_prefixmask;
  u_int32_t ia_plen;
  struct
  {
    in6_ifaddr *tqe_next;
    in6_ifaddr **tqe_prev;
  } ia6_link;
  struct
  {
    in6_ifaddr *tqe_next;
    in6_ifaddr **tqe_prev;
  } ia6_hash;
  int ia6_flags;
  uint8_t ia6_cga_collision_count;
  in6_addrlifetime_i ia6_lifetime;
  u_int64_t ia6_createtime;
  u_int64_t ia6_updatetime;
  nd_prefix *ia6_ndpr;
  struct
  {
    in6_multi_mship *lh_first;
  } ia6_memberships;
};

/* 3124 */
struct flow_owner_tree
{
  flow_owner *rbh_root;
};

/* 3127 */
struct flow_owner
{
  struct
  {
    flow_owner *rbe_left;
    flow_owner *rbe_right;
    flow_owner *rbe_parent;
  } fo_link;
  flow_entry_id_tree fo_flow_entry_id_head;
  const flow_owner_bucket *fo_bucket;
  void *fo_context;
  pid_t fo_pid;
  bool fo_nx_port_pid_bound;
  bool fo_nx_port_destroyed;
  bool fo_low_latency;
  nexus_port_t fo_nx_port;
  uuid_t_1 fo_key;
  nexus_adapter *const fo_nx_port_na;
  nx_flowswitch *const fo_fsw;
  bitmap_t *fo_flowadv_bmap;
  uint32_t fo_flowadv_max;
  uint32_t fo_num_flowadv;
  char fo_name[24];
};

/* 3126 */
struct flow_entry_id_tree
{
  flow_entry *rbh_root;
};

/* 3125 */
struct flow_owner_bucket
{
  lck_mtx_t fob_lock;
  flow_owner_tree fob_owner_head;
  uint16_t fob_busy_flags;
  uint16_t fob_open_waiters;
  uint16_t fob_close_waiters;
  uint16_t fob_dtor_waiters;
  const size_t fob_idx;
};

/* 3129 */
typedef void (*cuckoo_obj_release_func)(cuckoo_node *);

/* 3130 */
typedef void (*cuckoo_obj_retain_func)(cuckoo_node *);

/* 3131 */
typedef int (*cuckoo_obj_cmp_func)(cuckoo_node *, void *);

/* 3132 */
struct ifnet_ip_addr
{
  union
  {
    uint8_t addr8[16];
    uint16_t addr16[8];
    uint32_t addr32[4];
  };
};

/* 3133 */
struct ifnet_traffic_descriptor_inet
{
  ifnet_traffic_descriptor_common inet_common;
  uint8_t inet_mask;
  uint8_t inet_ipver;
  uint8_t inet_proto;
  uint8_t _reserved;
  ifnet_ip_addr inet_laddr;
  ifnet_ip_addr inet_raddr;
  uint16_t inet_lport;
  uint16_t inet_rport;
};

/* 3134 */
struct flow_entry_dead
{
  struct
  {
    flow_entry_dead *le_next;
    flow_entry_dead **le_prev;
  } fed_link;
  boolean_t fed_want_nonviable;
  boolean_t fed_want_clonotify;
  union
  {
    uint64_t fed_uuid_64[2];
    uint32_t fed_uuid_32[4];
    uuid_t_1 fed_uuid;
  };
};

/* 3135 */
struct ip6_frag
{
  u_int8_t ip6f_nxt;
  u_int8_t ip6f_reserved;
  u_int16_t ip6f_offlg;
  u_int32_t ip6f_ident;
};

/* 3136 */
struct netagent
{
  uuid_t_1 netagent_uuid;
  char netagent_domain[32];
  char netagent_type[32];
  char netagent_desc[128];
  u_int32_t netagent_flags;
  u_int32_t netagent_data_size;
  u_int8_t netagent_data[];
};

/* 3137 */
struct llinfo_nd6
{
  llinfo_nd6 *ln_next;
  llinfo_nd6 *ln_prev;
  rtentry *ln_rt;
  ifnet *ln_exclifp;
  mbuf *ln_hold;
  uint32_t ln_asked;
  short ln_state;
  short ln_router;
  u_int32_t ln_flags;
  u_int64_t ln_expire;
  u_int64_t ln_lastused;
  if_llreach *ln_llreach;
};

/* 3143 */
struct __attribute__((aligned(8))) nexus_vp_adapter
{
  nexus_adapter_0 vpna_up;
  nx_flowswitch *vpna_fsw;
  nexus_port_t vpna_nx_port;
  uint16_t vpna_gencnt;
  boolean_t vpna_retry;
  boolean_t vpna_pid_bound;
  boolean_t vpna_defunct;
  pid_t vpna_pid;
};

/* 3144 */
typedef struct *channel_ring_error_stats_t;

/* 3145 */
struct __nx_stats_channel_errors
{
  channel_ring_error_stats_t nxs_cres;
};

/* 3146 */
struct protoctl_ev_val
{
  uint32_t val;
  uint32_t tcp_seq_number;
};

/* 3147 */
struct sk_stats_flow_route
{
  uuid_t_1 sfr_nx_uuid;
  uuid_t_1 sfr_uuid;
  char sfr_if_name[16];
  uint32_t sfr_bucket_idx;
  uint32_t sfr_id_bucket_idx;
  uint32_t sfr_flags;
  uint32_t sfr_usecnt;
  int64_t sfr_expire;
  sockaddr_in_4_6 sfr_laddr;
  sockaddr_in_4_6 sfr_faddr;
  sockaddr_in_4_6 sfr_gaddr;
  __attribute__((aligned(64))) uint8_t sfr_ether_dhost[6];
};

/* 3148 */
struct __attribute__((aligned(64))) sk_stats_flow_owner
{
  uuid_t_1 sfo_nx_uuid;
  char sfo_if_name[16];
  uint32_t sfo_bucket_idx;
  char sfo_name[32];
  pid_t sfo_pid;
  nexus_port_t sfo_nx_port;
  boolean_t sfo_nx_port_pid_bound;
  boolean_t sfo_nx_port_destroyed;
};

/* 3149 */
struct __attribute__((aligned(64))) sk_stats_userstack
{
  uuid_t_1 sus_nx_uuid;
  char sus_if_name[16];
  pid_t sus_owner_pid;
  __attribute__((aligned(16))) ip_stats sus_ip;
  ip6_stats sus_ip6;
  tcp_stats sus_tcp;
  udp_stats sus_udp;
  quic_stats sus_quic;
};

/* 3150 */
struct __attribute__((aligned(64))) sk_stats_flow_switch
{
  uuid_t_1 sfs_nx_uuid;
  char sfs_if_name[16];
  fsw_stats sfs_fsws;
};

/* 5031 */
enum if_netem_model_t : __int32
{
  IF_NETEM_MODEL_NULL = 0x0,
  IF_NETEM_MODEL_NLC = 0x1,
  IF_NETEM_MODEL_IOD = 0x2,
  IF_NETEM_MODEL_FPD = 0x3,
};

/* 3151 */
struct if_netem_params
{
  if_netem_model_t ifnetem_model;
  uint64_t ifnetem_bandwidth_bps;
  uint32_t ifnetem_latency_ms;
  uint32_t ifnetem_jitter_ms;
  uint32_t ifnetem_corruption_p;
  uint32_t ifnetem_duplication_p;
  uint32_t ifnetem_loss_p_gr_gl;
  uint32_t ifnetem_loss_p_gr_bl;
  uint32_t ifnetem_loss_p_bl_br;
  uint32_t ifnetem_loss_p_bl_gr;
  uint32_t ifnetem_loss_p_br_bl;
  uint32_t ifnetem_loss_recovery_ms;
  uint32_t ifnetem_reordering_p;
  uint32_t ifnetem_output_ival_ms;
};

/* 3152 */
struct sk_stats_flow_adv_ent
{
  uuid_t_1 sfae_flow_id;
  uint32_t sfae_flags;
};

/* 3153 */
struct sk_stats_flow_adv
{
  uuid_t_1 sfa_nx_uuid;
  char sfa_if_name[16];
  pid_t sfa_owner_pid;
  uint32_t sfa_entries_count;
  sk_stats_flow_adv_ent sfa_entries[];
};

/* 3154 */
struct nxctl_traffic_rule_generic_iocinfo
{
  uuid_t_1 trg_uuid;
  char trg_procname[64];
  char trg_ifname[16];
};

/* 3176 */
struct ifnet_traffic_rule_action
{
  uint8_t ra_type;
  uint8_t _reserved;
  uint16_t ra_len;
};

/* 3165 */
struct __attribute__((packed)) __attribute__((aligned(4))) ifnet_traffic_rule_action_steer
{
  ifnet_traffic_rule_action ras_common;
  uint64_t ras_qset_id;
};

/* 3155 */
struct nxctl_traffic_rule_inet_iocinfo
{
  nxctl_traffic_rule_generic_iocinfo tri_common;
  ifnet_traffic_descriptor_inet tri_td;
  ifnet_traffic_rule_action_steer tri_ra;
};

/* 3156 */
struct nxctl_traffic_rule_inet_head
{
  nxctl_traffic_rule_inet *slh_first;
};

/* 3174 */
struct nxctl_traffic_rule
{
  nxctl_traffic_rule_type *ntr_type;
  uint32_t ntr_flags;
  os_refcnt_t ntr_refcnt;
  uuid_t_1 ntr_uuid;
  char ntr_procname[64];
  char ntr_ifname[16];
  struct
  {
    nxctl_traffic_rule *sle_next;
  } ntr_storage_link;
};

/* 3160 */
struct __attribute__((aligned(8))) nxctl_traffic_rule_inet
{
  nxctl_traffic_rule ntri_common;
  struct
  {
    nxctl_traffic_rule_inet *sle_next;
  } ntri_storage_link;
  ifnet_traffic_descriptor_inet ntri_td;
  ifnet_traffic_rule_action_steer ntri_ra;
};

/* 3177 */
typedef int nxctl_traffic_rule_validate_cb_t(nxctl_traffic_rule_type *, const char *, ifnet_traffic_descriptor_common *, ifnet_traffic_rule_action *);

/* 3175 */
typedef int nxctl_traffic_rule_find_cb_t(nxctl_traffic_rule_type *, const char *, ifnet_traffic_descriptor_common *, uint32_t, nxctl_traffic_rule **);

/* 3173 */
typedef int nxctl_traffic_rule_find_by_uuid_cb_t(nxctl_traffic_rule_type *, unsigned __int8 *, nxctl_traffic_rule **);

/* 3172 */
typedef void nxctl_traffic_rule_link_cb_t(nxctl_traffic_rule *);

/* 3171 */
typedef void nxctl_traffic_rule_unlink_cb_t(nxctl_traffic_rule *);

/* 3170 */
typedef int nxctl_traffic_rule_notify_cb_t(nxctl_traffic_rule *, uint32_t);

/* 3169 */
typedef int nxctl_traffic_rule_create_cb_t(nxctl_traffic_rule_type *, const char *, ifnet_traffic_descriptor_common *, ifnet_traffic_rule_action *, uint32_t, nxctl_traffic_rule **);

/* 3168 */
typedef void nxctl_traffic_rule_destroy_cb_t(nxctl_traffic_rule *);

/* 3167 */
typedef int nxctl_traffic_rule_get_all_cb_t(nxctl_traffic_rule_type *, uint32_t, uint32_t *, user_addr_t_0);

/* 3178 */
struct nxctl_traffic_rule_type
{
  uint8_t ntrt_type;
  nxctl_traffic_rule_validate_cb_t *ntrt_validate;
  nxctl_traffic_rule_find_cb_t *ntrt_find;
  nxctl_traffic_rule_find_by_uuid_cb_t *ntrt_find_by_uuid;
  nxctl_traffic_rule_link_cb_t *ntrt_link;
  nxctl_traffic_rule_unlink_cb_t *ntrt_unlink;
  nxctl_traffic_rule_notify_cb_t *ntrt_notify;
  nxctl_traffic_rule_create_cb_t *ntrt_create;
  nxctl_traffic_rule_destroy_cb_t *ntrt_destroy;
  nxctl_traffic_rule_get_all_cb_t *ntrt_get_all;
  void *ntrt_storage;
};

/* 3157 */
struct nxctl_traffic_rule_inet_if
{
  char rii_ifname[16];
  nxctl_traffic_rule_inet_head rii_lists[2];
  uint32_t rii_count;
  struct
  {
    nxctl_traffic_rule_inet_if *sle_next;
  } rii_link;
};

/* 3158 */
struct nxctl_traffic_rule_inet_if_head
{
  nxctl_traffic_rule_inet_if *slh_first;
};

/* 3159 */
struct __attribute__((aligned(8))) nxctl_traffic_rule_inet_storage
{
  nxctl_traffic_rule_inet_if_head ris_if_list;
  uint32_t ris_count;
};

/* 3161 */
struct nxctl_traffic_rule_head
{
  nxctl_traffic_rule *slh_first;
};

/* 3162 */
struct __attribute__((aligned(8))) nxctl_traffic_rule_storage
{
  nxctl_traffic_rule_head rs_list;
  uint32_t rs_count;
};

/* 3163 */
struct nxctl_get_traffic_rules_iocargs
{
  uint8_t gtr_type;
  uint32_t gtr_size;
  uint32_t gtr_count;
  union
  {
    void *gtr_buf;
    uint64_t gtr_buf64;
  };
};

/* 3164 */
struct nxctl_remove_traffic_rule_iocargs
{
  uuid_t_1 rtr_uuid;
};

/* 3166 */
struct nxctl_add_traffic_rule_inet_iocargs
{
  char atri_ifname[16];
  ifnet_traffic_descriptor_inet atri_td;
  ifnet_traffic_rule_action_steer atri_ra;
  uint32_t atri_flags;
  uuid_t_1 atri_uuid;
};

/* 3179 */
struct __nexus_set_opt_args
{
  int ctl;
  char ctl_r_[4];
  uint32_t opt;
  char opt_r_[4];
  user_addr_t_0 aoptval;
  uint32_t optlen;
  char optlen_r_[4];
};

/* 3180 */
struct __nexus_get_opt_args
{
  int ctl;
  char ctl_r_[4];
  uint32_t opt;
  char opt_r_[4];
  user_addr_t_0 aoptval;
  user_addr_t_0 aoptlen;
  char aoptlen_r_[];
};

/* 3181 */
struct __nexus_destroy_args
{
  int ctl;
  char ctl_r_[4];
  user_addr_t_0 nx_uuid;
  uint32_t nx_uuid_len;
  char nx_uuid_len_r_[4];
};

/* 3182 */
struct __nexus_create_args
{
  int ctl;
  char ctl_r_[4];
  user_addr_t_0 prov_uuid;
  uint32_t prov_uuid_len;
  char prov_uuid_len_r_[4];
  user_addr_t_0 nx_uuid;
  uint32_t nx_uuid_len;
  char nx_uuid_len_r_[4];
};

/* 3183 */
struct __nexus_deregister_args
{
  int ctl;
  char ctl_r_[4];
  user_addr_t_0 prov_uuid;
  uint32_t prov_uuid_len;
  char prov_uuid_len_r_[4];
};

/* 3184 */
struct __nexus_register_args
{
  int ctl;
  char ctl_r_[4];
  user_addr_t_0 reg;
  uint32_t reg_len;
  char reg_len_r_[4];
  user_addr_t_0 prov_uuid;
  uint32_t prov_uuid_len;
  char prov_uuid_len_r_[4];
};

/* 3185 */
struct __nexus_open_args
{
  user_addr_t_0 init;
  uint32_t init_len;
  char init_len_r_[4];
};

/* 3187 */
typedef void (*ifnet_free_func)(ifnet_t);

/* 7824 */
typedef errno_t (*ifnet_demux_func_0)(ifnet_t, mbuf_t, char *, protocol_family_t *);

/* 9226 */
typedef errno_t (*ifnet_framer_func_1)(ifnet_t, mbuf_t *, const sockaddr *, const char *, const char *);

/* 9225 */
typedef errno_t (*ifnet_framer_extended_func_0)(ifnet_t, mbuf_t *, const sockaddr *, const char *, const char *, u_int32_t *, u_int32_t *);

/* 3188 */
struct ifnet_init_eparams
{
  u_int32_t ver;
  u_int32_t len;
  u_int32_t flags;
  const void *uniqueid;
  u_int32_t uniqueid_len;
  const char *name;
  u_int32_t unit;
  ifnet_family_t family;
  u_int32_t type;
  u_int32_t sndq_maxlen;
  ifnet_output_func output;
  ifnet_pre_enqueue_func pre_enqueue;
  ifnet_start_func start;
  ifnet_ctl_func output_ctl;
  u_int32_t output_sched_model;
  u_int32_t output_target_qdelay;
  u_int64_t output_bw;
  u_int64_t output_bw_max;
  u_int64_t output_lt;
  u_int64_t output_lt_max;
  u_int16_t start_delay_qlen;
  u_int16_t start_delay_timeout;
  u_int32_t _reserved[3];
  ifnet_input_poll_func input_poll;
  ifnet_ctl_func input_ctl;
  u_int32_t rcvq_maxlen;
  u_int32_t __reserved;
  u_int64_t input_bw;
  u_int64_t input_bw_max;
  u_int64_t input_lt;
  u_int64_t input_lt_max;
  u_int64_t ___reserved[2];
  ifnet_demux_func_0 demux;
  ifnet_add_proto_func add_proto;
  ifnet_del_proto_func del_proto;
  ifnet_check_multi check_multi;
  ifnet_framer_func_1 framer;
  void *softc;
  ifnet_ioctl_func ioctl;
  ifnet_set_bpf_tap set_bpf_tap;
  ifnet_detached_func detach;
  ifnet_event_func event;
  const void *broadcast_addr;
  u_int32_t broadcast_len;
  ifnet_framer_extended_func_0 framer_extended;
  ifnet_subfamily_t subfamily;
  u_int16_t tx_headroom;
  u_int16_t tx_trailer;
  u_int32_t rx_mit_ival;
  u_int32_t ____reserved;
  ifnet_free_func free;
};

/* 3189 */
typedef errno_t (*nxnet_prepare_fn_t)(kern_nexus_t, ifnet_t);

/* 3190 */
struct kern_nexus_net_init
{
  uint32_t nxneti_version;
  uint32_t nxneti_flags;
  ifnet_init_eparams *nxneti_eparams;
  sockaddr_dl *nxneti_lladdr;
  nxnet_prepare_fn_t nxneti_prepare;
  kern_pbufpool_t nxneti_tx_pbufpool;
  kern_pbufpool_t nxneti_rx_pbufpool;
  kern_nexus_netif_llink_init *nxneti_llink;
};

/* 3191 */
struct kern_nexus_init
{
  uint32_t nxi_version;
  uint32_t nxi_flags;
  kern_pbufpool_t nxi_tx_pbufpool;
  kern_pbufpool_t nxi_rx_pbufpool;
};

/* 3192 */
struct nx_unbind_req
{
  uuid_t_1 nu_nx_uuid;
  nexus_port_t nu_port;
};

/* 3193 */
struct nx_bind_req
{
  uuid_t_1 nb_nx_uuid;
  nexus_port_t nb_port;
  uint32_t nb_flags;
  uuid_t_1 nb_exec_uuid;
  user_addr_t_0 nb_key;
  uint32_t nb_key_len;
  pid_t nb_pid;
};

/* 3194 */
struct nxprov_reg
{
  uint32_t nxpreg_version;
  uint32_t nxpreg_requested;
  nxprov_params nxpreg_params;
};

/* 3195 */
typedef nexus_controller *nexus_controller_t;

/* 3198 */
struct nexus_controller
{
  nxctl *ncd_nxctl;
};

/* 3196 */
enum nexus_attr_type_t : __int32
{
  NEXUS_ATTR_TX_RINGS = 0x0,
  NEXUS_ATTR_RX_RINGS = 0x1,
  NEXUS_ATTR_TX_SLOTS = 0x2,
  NEXUS_ATTR_RX_SLOTS = 0x3,
  NEXUS_ATTR_SLOT_BUF_SIZE = 0x4,
  NEXUS_ATTR_SLOT_META_SIZE = 0x5,
  NEXUS_ATTR_ANONYMOUS = 0x6,
  NEXUS_ATTR_MHINTS = 0x7,
  NEXUS_ATTR_PIPES = 0x8,
  NEXUS_ATTR_EXTENSIONS = 0x9,
  NEXUS_ATTR_IFINDEX = 0xA,
  NEXUS_ATTR_STATS_SIZE = 0xB,
  NEXUS_ATTR_FLOWADV_MAX = 0xC,
  NEXUS_ATTR_QMAP = 0xD,
  NEXUS_ATTR_CHECKSUM_OFFLOAD = 0xE,
  NEXUS_ATTR_USER_PACKET_POOL = 0xF,
  NEXUS_ATTR_ADV_SIZE = 0x10,
  NEXUS_ATTR_USER_CHANNEL = 0x11,
  NEXUS_ATTR_MAX_FRAGS = 0x12,
  NEXUS_ATTR_REJECT_ON_CLOSE = 0x13,
  NEXUS_ATTR_LARGE_BUF_SIZE = 0x14,
};

/* 3197 */
typedef nexus_attr *nexus_attr_t;

/* 3199 */
struct nexus_attr
{
  uint64_t nxa_requested;
  uint64_t nxa_tx_rings;
  uint64_t nxa_rx_rings;
  uint64_t nxa_tx_slots;
  uint64_t nxa_rx_slots;
  uint64_t nxa_buf_size;
  uint64_t nxa_meta_size;
  uint64_t nxa_stats_size;
  uint64_t nxa_anonymous;
  uint64_t nxa_pipes;
  uint64_t nxa_extensions;
  uint64_t nxa_mhints;
  uint64_t nxa_ifindex;
  uint64_t nxa_flowadv_max;
  uint64_t nxa_qmap;
  uint64_t nxa_checksum_offload;
  uint64_t nxa_user_packet_pool;
  uint64_t nxa_nexusadv_size;
  uint64_t nxa_user_channel;
  uint64_t nxa_max_frags;
  uint64_t nxa_reject_on_close;
  uint64_t nxa_large_buf_size;
};

/* 3200 */
typedef void kern_nexus_walktree_f_t(kern_nexus *, void *);

/* 3201 */
struct __kern_nexus_adv_metadata
{
  uint16_t knam_version;
  uint16_t __reserved;
  nexus_advisory_type_t knam_type;
};

/* 3202 */
struct nexus_channel_ring_entry
{
  ring_id_t ncre_ring_id;
  uint32_t __ncre_align_reserved;
  channel_ring_stats ncre_stats;
  channel_ring_user_stats ncre_user_stats;
  channel_ring_error_stats ncre_error_stats;
};

/* 3203 */
struct nexus_channel_entry
{
  uuid_t_1 nce_uuid;
  uint32_t nce_flags;
  pid_t nce_pid;
  int nce_fd;
  nexus_port_t nce_port;
  uint32_t nce_tx_rings;
  uint32_t nce_rx_rings;
  uint32_t __nce_align_reserved;
  nexus_channel_ring_entry nce_ring_entries[];
};

/* 3204 */
typedef struct *nexus_channel_ring_entry_t;

/* 3205 */
typedef struct *nexus_channel_entry_t;

/* 3206 */
typedef struct *nexus_channel_info_t;

/* 3207 */
typedef struct *nexus_provider_info_t;

/* 3208 */
struct nxprov_reg_ent
{
  uuid_t_1 npre_prov_uuid;
  nxprov_params npre_prov_params;
};

/* 7834 */
enum sk_stats_region_id_t : __int32
{
  SREG_GUARD_HEAD = 0x0,
  SREG_SCHEMA = 0x1,
  SREG_RING = 0x2,
  SREG_BUF_DEF = 0x3,
  SREG_BUF_LARGE = 0x4,
  SREG_RXBUF_DEF = 0x5,
  SREG_RXBUF_LARGE = 0x6,
  SREG_TXBUF_DEF = 0x7,
  SREG_TXBUF_LARGE = 0x8,
  SREG_UMD = 0x9,
  SREG_TXAUSD = 0xA,
  SREG_RXFUSD = 0xB,
  SREG_UBFT = 0xC,
  SREG_USTATS = 0xD,
  SREG_FLOWADV = 0xE,
  SREG_NEXUSADV = 0xF,
  SREG_SYSCTLS = 0x10,
  SREG_GUARD_TAIL = 0x11,
  SREG_KMD = 0x12,
  SREG_RXKMD = 0x13,
  SREG_TXKMD = 0x14,
  SREG_KBFT = 0x15,
  SREG_RXKBFT = 0x16,
  SREG_TXKBFT = 0x17,
  SREG_TXAKSD = 0x18,
  SREG_RXFKSD = 0x19,
  SREG_KSTATS = 0x1A,
  SREG_INSTRINSIC = 0x1B,
  SREG_MAX = 0x1C,
};

/* 3209 */
struct sk_stats_region
{
  char sreg_name[64];
  uuid_t_1 sreg_uuid;
  sk_stats_region_id_t sreg_id;
  uint32_t sreg_mode;
  uint64_t sreg_r_seg_size;
  uint64_t sreg_c_seg_size;
  uint64_t sreg_seg_cnt;
  uint64_t sreg_seg_objs;
  uint64_t sreg_r_obj_size;
  uint64_t sreg_r_obj_cnt;
  uint64_t sreg_c_obj_size;
  uint64_t sreg_c_obj_cnt;
  uint64_t sreg_align;
  uint64_t sreg_max_frags;
  uint64_t sreg_meminuse;
  uint64_t sreg_w_meminuse;
  uint64_t sreg_memtotal;
  uint64_t sreg_seginuse;
  uint64_t sreg_rescale;
  uint64_t sreg_hash_size;
  uint64_t sreg_alloc;
  uint64_t sreg_free;
};

/* 3210 */
struct sk_stats_cache
{
  char sca_name[64];
  uuid_t_1 sca_uuid;
  uuid_t_1 sca_ruuid;
  uint32_t sca_mode;
  uint64_t sca_bufsize;
  uint64_t sca_objsize;
  uint64_t sca_chunksize;
  uint64_t sca_slabsize;
  uint64_t sca_bufalign;
  uint64_t sca_objalign;
  uint64_t sca_cpu_mag_size;
  uint64_t sca_cpu_mag_resize;
  uint64_t sca_cpu_mag_purge;
  uint64_t sca_cpu_mag_reap;
  uint64_t sca_depot_full;
  uint64_t sca_depot_empty;
  uint64_t sca_depot_ws_zero;
  uint64_t sca_depot_contention_factor;
  uint64_t sca_sl_create;
  uint64_t sca_sl_destroy;
  uint64_t sca_sl_alloc;
  uint64_t sca_sl_free;
  uint64_t sca_sl_alloc_fail;
  uint64_t sca_sl_partial;
  uint64_t sca_sl_empty;
  uint64_t sca_sl_bufinuse;
  uint64_t sca_sl_rescale;
  uint64_t sca_sl_hash_size;
};

/* 3211 */
struct skmem_bufctl_audit
{
  struct
  {
    skmem_bufctl *sle_next;
  } bc_link;
  void *bc_addr;
  void *bc_addrm;
  skmem_slab *bc_slab;
  uint32_t bc_flags;
  uint32_t bc_idx;
  volatile uint32_t bc_usecnt;
  thread *bc_thread;
  uint32_t bc_timestamp;
  uint32_t bc_depth;
  void *bc_stack[16];
};

/* 7835 */
enum sk_stats_arena_type_t : __int32
{
  SAR_TYPE_NEXUS = 0x0,
  SAR_TYPE_NECP = 0x1,
  SAR_TYPE_SYSTEM = 0x2,
};

/* 3212 */
struct sk_stats_arena
{
  char sar_name[64];
  sk_stats_arena_type_t sar_type;
  uint64_t sar_mapsize;
  uuid_t_1 sar_regions_uuid[28];
  pid_t sar_mapped_pids[8];
};

/* 3213 */
struct skmem_arena_system
{
  skmem_arena ars_cmn;
  void *ars_sysctls_obj;
  size_t ars_sysctls_objsize;
};

/* 3214 */
struct skmem_arena_necp
{
  skmem_arena arc_cmn;
  skmem_cache *arc_kstats_cache;
};

/* 3215 */
struct ml_cpu_info
{
  unsigned __int64 vector_unit;
  unsigned __int64 cache_line_size;
  unsigned __int64 l1_icache_size;
  unsigned __int64 l1_dcache_size;
  unsigned __int64 l2_settings;
  unsigned __int64 l2_cache_size;
  unsigned __int64 l3_settings;
  unsigned __int64 l3_cache_size;
};

/* 3216 */
typedef void net_filter_event_callback_t;

/* 3217 */
struct __attribute__((aligned(16))) eventhandler_entry_net_filter_event
{
  eventhandler_entry ee;
};

/* 3218 */
struct nwk_wq_entry
{
  _BYTE gap0[8];
  struct
  {
    nwk_wq_entry *tqe_next;
    nwk_wq_entry **tqe_prev;
  } nwk_wq_link;
};

/* 3219 */
struct cuckoo_hashtable_params
{
  size_t cht_capacity;
  cuckoo_obj_cmp_func cht_obj_cmp;
  cuckoo_obj_retain_func cht_obj_retain;
  cuckoo_obj_release_func cht_obj_release;
};

/* 3220 */
struct __attribute__((aligned(4))) _bfs_node
{
  uint32_t bkt_idx;
  uint8_t prev_node_idx;
  uint8_t prev_slot_idx;
};

/* 3224 */
enum cuckoo_resize_ops : __int32
{
  cuckoo_resize_ops::_CHT_RESIZE_EXPAND = 0x0,
  cuckoo_resize_ops::_CHT_RESIZE_SHRINK = 0x1,
};

/* 3225 */
struct __channel_set_opt_args
{
  int c;
  char c_r_[4];
  uint32_t opt;
  char opt_r_[4];
  user_addr_t_0 aoptval;
  uint32_t optlen;
  char optlen_r_[4];
};

/* 3226 */
struct __channel_get_opt_args
{
  int c;
  char c_r_[4];
  uint32_t opt;
  char opt_r_[4];
  user_addr_t_0 aoptval;
  user_addr_t_0 aoptlen;
  char aoptlen_r_[];
};

/* 3227 */
struct __channel_sync_args
{
  int c;
  char c_r_[4];
  int mode;
  char mode_r_[4];
  int flags;
  char flags_r_[4];
};

/* 3228 */
struct __channel_get_info_args
{
  int c;
  char c_r_[4];
  user_addr_t_0 cinfo;
  uint32_t cinfolen;
  char cinfolen_r_[4];
};

/* 3229 */
struct __channel_open_args
{
  user_addr_t_0 init;
  uint32_t init_len;
  char init_len_r_[4];
};

/* 3230 */
typedef os_channel_event_packet_transmit_status os_channel_event_packet_transmit_status_t;

/* 7836 */
struct os_channel_event_packet_transmit_status
{
  packet_id_t packet_id;
  int32_t packet_status;
};

/* 4578 */
typedef uint32_t flowadv_token_t;

/* 3231 */
struct flowadv_fcentry
{
  struct
  {
    flowadv_fcentry *stqe_next;
  } fce_link;
  u_int32_t fce_flowsrc_type;
  u_int32_t fce_flowid;
  flowadv_token_t fce_flowsrc_token;
  flowadv_idx_t fce_flowsrc_fidx;
  ifnet *fce_ifp;
};

/* 3232 */
struct kern_channel_ring_stat_increment
{
  uint32_t kcrsi_slots_transferred;
  uint32_t kcrsi_bytes_transferred;
};

/* 3234 */
struct ch_init
{
  uint32_t ci_version;
  uint32_t ci_ch_mode;
  ring_id_t ci_ch_ring_id;
  nexus_port_t ci_nx_port;
  uuid_t_1 ci_nx_uuid;
  user_addr_t_0 ci_key;
  uint32_t ci_key_len;
  uint32_t __ci_align;
  ch_ev_thresh ci_tx_lowat;
  ch_ev_thresh ci_rx_lowat;
  guardid_t ci_guard;
};

/* 3235 */
typedef vm_packing_params vm_packing_params_t;

/* 8249 */
struct __attribute__((aligned(8))) vm_packing_params
{
  vm_offset_t vmpp_base;
  uint8_t vmpp_bits;
  uint8_t vmpp_shift;
  bool vmpp_base_relative;
};

/* 3236 */
struct filterops
{
  bool f_isfd;
  bool f_adjusts_qos;
  bool f_extended_codes;
  int (*f_attach)(knote *, kevent_qos_s *);
  void (*f_detach)(knote *);
  int (*f_event)(knote *, long);
  int (*f_touch)(knote *, kevent_qos_s *);
  int (*f_process)(knote *, kevent_qos_s *);
  bool (*f_allow_drop)(knote *, kevent_qos_s *);
  void (*f_post_register_wait)(uthread *, knote *, _kevent_register *);
  void (*f_sanitized_copyout)(knote *, kevent_qos_s *);
};

/* 3237 */
struct proc_channel_info
{
  uuid_t_1 chi_instance;
  uint32_t chi_port;
  uint32_t chi_type;
  uint32_t chi_flags;
  uint32_t rfu_1;
};

/* 3238 */
enum flowidns_domain_id_t : __int32
{
  FLOWIDNS_DOMAIN_MIN = 0x0,
  FLOWIDNS_DOMAIN_IPSEC = 0x0,
  FLOWIDNS_DOMAIN_FLOWSWITCH = 0x1,
  FLOWIDNS_DOMAIN_INPCB = 0x2,
  FLOWIDNS_DOMAIN_PF = 0x3,
  FLOWIDNS_DOMAIN_MAX = 0x3,
};

/* 3239 */
typedef uint32_t flowidns_flowid_t;

/* 3240 */
struct __attribute__((aligned(4))) flowidns_flow_key
{
  union
  {
    in_addr _v4;
    in6_addr_0 _v6;
  } ffk_laddr;
  union
  {
    in_addr _v4;
    in6_addr_0 _v6;
  } ffk_raddr;
  union
  {
    struct
    {
      uint16_t _lport;
      uint16_t _rport;
    } ffk_ports;
    uint32_t ffk_spi;
    uint32_t ffk_protoid;
  };
  uint8_t ffk_af;
  uint8_t ffk_proto;
};

/* 3241 */
struct __attribute__((aligned(8))) flowidns_flowid_tree_node
{
  struct
  {
    flowidns_flowid_tree_node *rbe_left;
    flowidns_flowid_tree_node *rbe_right;
    flowidns_flowid_tree_node *rbe_parent;
  } fftn_link;
  flowidns_flow_key fftn_flowkey;
  flowidns_flowid_t fftn_flowid;
};

/* 3242 */
struct flowidns_flowid_tree
{
  flowidns_flowid_tree_node *rbh_root;
};

/* 3243 */
struct flowidns_domain
{
  lck_mtx_t fd_mtx;
  flowidns_flowid_tree fd_flowid_tree;
  uint32_t fd_id;
  uint64_t fd_nallocs;
  uint64_t fd_nreleases;
  uint64_t fd_ncollisions;
};

/* 3244 */
struct sk_stats_protons_token
{
  uint8_t spt_protocol;
  uint32_t spt_refcnt;
  pid_t spt_pid;
  pid_t spt_epid;
};

/* 3249 */
struct __attribute__((aligned(8))) ns_reservation
{
  struct
  {
    ns_reservation *rbe_left;
    ns_reservation *rbe_right;
    ns_reservation *rbe_parent;
  } nsr_link;
  uint32_t nsr_refs[4];
  in_port_t nsr_port;
};

/* 3250 */
struct ns_reservation_tree
{
  ns_reservation *rbh_root;
};

/* 3251 */
struct ns
{
  struct
  {
    ns *rbe_left;
    ns *rbe_right;
    ns *rbe_parent;
  } ns_link;
  void *ns_addr_key;
  union
  {
    uint32_t ns_addr[4];
    in_addr ns_inaddr;
    in6_addr_0 ns_in6addr;
  };
  uint8_t ns_addr_len;
  uint8_t ns_proto;
  in_port_t ns_last_ephemeral_port_down;
  in_port_t ns_last_ephemeral_port_up;
  uint8_t ns_is_freeable;
  uint32_t ns_n_reservations;
  ns_reservation_tree ns_reservations;
};

/* 3252 */
struct vnop_generic_args
{
  vnodeop_desc *a_desc;
};

/* 3271 */
struct vnodeop_desc
{
  int vdesc_offset;
  const char *vdesc_name;
  int vdesc_flags;
  int *vdesc_vp_offsets;
  int vdesc_vpp_offset;
  int vdesc_cred_offset;
  int vdesc_proc_offset;
  int vdesc_componentname_offset;
  int vdesc_context_offset;
  caddr_t *vdesc_transports;
};

/* 3253 */
struct vnop_open_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  int a_mode;
  vfs_context_t a_context;
};

/* 3254 */
struct vnop_close_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  int a_fflag;
  vfs_context_t a_context;
};

/* 3255 */
struct vnop_inactive_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  vfs_context_t a_context;
};

/* 3256 */
struct vnop_reclaim_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  vfs_context_t a_context;
};

/* 3257 */
struct vnop_readlink_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  uio *a_uio;
  vfs_context_t a_context;
};

/* 3258 */
struct vnop_pathconf_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  int a_name;
  int32_t *a_retval;
  vfs_context_t a_context;
};

/* 3259 */
struct vnop_fsync_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  int a_waitfor;
  vfs_context_t a_context;
};

/* 3260 */
struct vnop_mmap_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  int a_fflags;
  vfs_context_t a_context;
};

/* 3261 */
struct vnop_mnomap_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  vfs_context_t a_context;
};

/* 3599 */
typedef uio *uio_t;

/* 3262 */
struct vnop_getxattr_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  const char *a_name;
  uio_t a_uio;
  size_t *a_size;
  int a_options;
  vfs_context_t a_context;
};

/* 3263 */
struct vnop_pagein_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  upl_t a_pl;
  upl_offset_t a_pl_offset;
  off_t a_f_offset;
  size_t a_size;
  int a_flags;
  vfs_context_t a_context;
};

/* 3264 */
struct vnop_read_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  uio *a_uio;
  int a_ioflag;
  vfs_context_t a_context;
};

/* 3265 */
struct vnop_listxattr_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  uio_t a_uio;
  size_t *a_size;
  int a_options;
  vfs_context_t a_context;
};

/* 3266 */
struct vnop_getattr_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  vnode_attr *a_vap;
  vfs_context_t a_context;
};

/* 3267 */
struct vnop_lookup_args
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t *a_vpp;
  componentname *a_cnp;
  vfs_context_t a_context;
};

/* 3268 */
struct vnop_readdir_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  uio *a_uio;
  int a_flags;
  int *a_eofflag;
  int *a_numdirent;
  vfs_context_t a_context;
};

/* 3269 */
struct null_mount
{
  vnode *nullm_rootvp;
  vnode *nullm_secondvp;
  vnode *nullm_lowerrootvp;
  uint32_t nullm_lowerrootvid;
  lck_mtx_t nullm_lock;
  uint64_t nullm_flags;
  uid_t uid;
  gid_t gid;
};

/* 3270 */
struct __attribute__((aligned(8))) null_node
{
  struct
  {
    null_node *le_next;
    null_node **le_prev;
  } null_hash;
  vnode *null_lowervp;
  vnode *null_vnode;
  uint32_t null_lowervid;
  uint32_t null_myvid;
  uint32_t null_flags;
};

/* 3272 */
struct vnodeopv_entry_desc
{
  vnodeop_desc *opve_op;
  int (*opve_impl)(void *);
};

/* 3273 */
struct vnodeopv_desc
{
  int (***opv_desc_vector_p)(void *);
  const vnodeopv_entry_desc *opv_desc_ops;
};

/* 3274 */
typedef int (*vop_t)(void *);

/* 3275 */
struct null_node_hashhead
{
  null_node *lh_first;
};

/* 3276 */
struct grab_pgo_data_args
{
  user_addr_t_0 uuid;
  int flags;
  char flags_r_[4];
  user_addr_t_0 buffer;
  user_ssize_t size;
  char size_r_[];
};

/* 3277 */
struct proc_uuid_policy_args
{
  uint32_t operation;
  char operation_r_[4];
  user_addr_t_0 uuid;
  user_size_t uuidlen;
  uint32_t flags;
  char flags_r_[4];
};

/* 3278 */
struct __attribute__((aligned(8))) proc_uuid_policy_entry
{
  struct
  {
    proc_uuid_policy_entry *le_next;
    proc_uuid_policy_entry **le_prev;
  } entries;
  uuid_t_1 uuid;
  uint32_t flags;
};

/* 3279 */
struct proc_uuid_policy_hashhead
{
  proc_uuid_policy_entry *lh_first;
};

/* 3280 */
struct __attribute__((packed)) __attribute__((aligned(1))) kperf_kdebug_filter
{
  uint64_t types[2];
  uint32_t debugids[32];
  uint8_t n_debugids;
};

/* 7853 */
enum imageboot_type : __int32
{
  imageboot_type::IMAGEBOOT_NONE = 0x0,
  imageboot_type::IMAGEBOOT_DMG = 0x1,
  imageboot_type::IMAGEBOOT_LOCKER = 0x2,
};

/* 3281 */
typedef imageboot_type imageboot_type_t;

/* 3290 */
struct pseudo_init
{
  int ps_count;
  int (*ps_func)(int);
};

/* 3291 */
struct adjtime_args
{
  user_addr_t_0 delta;
  user_addr_t_0 olddelta;
  char olddelta_r_[];
};

/* 3292 */
struct ntp_adjtime_args
{
  user_addr_t_0 tp;
  char tp_r_[];
};

/* 3293 */
struct ntp_gettime_args
{
  user_addr_t_0 ntvp;
  char ntvp_r_[];
};

/* 7283 */
typedef __int32_t user32_time_t;

/* 3294 */
struct user32_timespec
{
  user32_time_t tv_sec;
  user32_long_t tv_nsec;
};

/* 3295 */
struct user64_timespec
{
  user64_time_t tv_sec;
  user64_long_t tv_nsec;
};

/* 3296 */
struct __attribute__((aligned(8))) ntptimeval
{
  timespec time;
  long maxerror;
  long esterror;
  long tai;
  int time_state;
};

/* 8135 */
typedef slock usimple_lock_data_t;

/* 3298 */
typedef usimple_lock_data_t simple_lock_data_t;

/* 3299 */
struct trim_list
{
  uint64_t tl_offset;
  uint64_t tl_length;
  trim_list *tl_next;
};

/* 3300 */
struct dk_extent_t
{
  uint64_t offset;
  uint64_t length;
};

/* 3303 */
struct macx_swapoff_args
{
  uint64_t filename;
  int flags;
  char flags_r_[4];
};

/* 3304 */
struct macx_swapon_args
{
  uint64_t filename;
  int flags;
  char flags_r_[4];
  int size;
  char size_r_[4];
  int priority;
  char priority_r_[4];
};

/* 8185 */
typedef ipc_port_t_0 mach_port_t_1;

/* 3305 */
struct macx_triggers_args
{
  int hi_water;
  char hi_water_r_[4];
  int low_water;
  char low_water_r_[4];
  int flags;
  char flags_r_[4];
  mach_port_t_1 alert_port;
  char alert_port_r_[];
};

/* 3306 */
struct macx_backing_store_suspend_args
{
  boolean_t suspend;
  char suspend_r_[4];
};

/* 3307 */
struct macx_backing_store_recovery_args
{
  int pid;
  char pid_r_[4];
};

/* 3308 */
struct kas_info_args
{
  int selector;
  char selector_r_[4];
  user_addr_t_0 value;
  user_addr_t_0 size;
  char size_r_[];
};

/* 3309 */
struct vm_pressure_monitor_args
{
  int wait_for_pressure;
  char wait_for_pressure_r_[4];
  int nsecs_monitored;
  char nsecs_monitored_r_[4];
  user_addr_t_0 pages_reclaimed;
  char pages_reclaimed_r_[];
};

/* 3310 */
struct map_with_linking_np_args
{
  user_addr_t_0 regions;
  uint32_t region_count;
  char region_count_r_[4];
  user_addr_t_0 link_info;
  uint32_t link_info_size;
  char link_info_size_r_[4];
};

/* 3311 */
struct shared_region_map_and_slide_2_np_args
{
  uint32_t files_count;
  char files_count_r_[4];
  user_addr_t_0 files;
  uint32_t mappings_count;
  char mappings_count_r_[4];
  user_addr_t_0 mappings;
  char mappings_r_[];
};

/* 3312 */
struct objc_bp_assist_cfg_np_args
{
  uint64_t adr;
  uint64_t ctl;
  char ctl_r_[];
};

/* 7016 */
typedef integer_t cpu_type_t_0;

/* 8200 */
typedef struct ipc_port *ipc_port_t_1;

/* 5542 */
typedef unsigned int uint_t;

/* 5756 */
typedef vm_shared_region_slide_info *vm_shared_region_slide_info_t;

/* 3313 */
struct vm_shared_region
{
  uint32_t sr_ref_count;
  uint32_t sr_slide;
  queue_chain_t_0 sr_q;
  void *sr_root_dir;
  cpu_type_t_0 sr_cpu_type;
  cpu_subtype_t_0 sr_cpu_subtype;
  ipc_port_t_1 sr_mem_entry;
  mach_vm_offset_t sr_first_mapping;
  mach_vm_offset_t sr_base_address;
  mach_vm_size_t_0 sr_size;
  mach_vm_offset_t sr_pmap_nesting_start;
  mach_vm_size_t_0 sr_pmap_nesting_size;
  thread_call_t sr_timer_call;
  uuid_t_0 sr_uuid;
  uint8_t sr_page_shift;
  bool sr_mapping_in_progress;
  bool sr_slide_in_progress;
  bool sr_64bit;
  bool sr_persists;
  bool sr_uuid_copied;
  bool sr_stale;
  bool sr_driverkit;
  bool sr_reslide;
  uint_t sr_num_auth_section;
  uint_t sr_next_auth_section;
  vm_shared_region_slide_info_t *sr_auth_section;
  uint32_t sr_rsr_version;
  uint64_t sr_install_time;
  uint32_t sr_id;
  uint32_t sr_images_count;
  dyld_uuid_info_64 *sr_images;
  uuid_t_0 sr_aot_uuid;
  boolean_t sr_aot_uuid_copied;
  mach_vm_offset_t sr_aot_mapping;
};

/* 5754 */
typedef vm_shared_region_slide_info_entry *vm_shared_region_slide_info_entry_t;

/* 5755 */
struct vm_shared_region_slide_info
{
  uint32_t si_slide;
  bool si_slid;
  bool si_ptrauth;
  uint64_t si_jop_key;
  vm_shared_region *si_shared_region;
  mach_vm_address_t_0 si_slid_address;
  mach_vm_offset_t si_start;
  mach_vm_offset_t si_end;
  vm_object_t si_slide_object;
  mach_vm_size_t_0 si_slide_info_size;
  vm_shared_region_slide_info_entry_t si_slide_info_entry;
};

/* 5746 */
struct dyld_uuid_info_64
{
  uint64_t imageLoadAddress;
  uuid_t_0 imageUUID;
};

/* 5750 */
struct vm_shared_region_slide_info_entry_v1
{
  uint32_t version;
  uint32_t toc_offset;
  uint32_t toc_count;
  uint32_t entry_offset;
  uint32_t entry_count;
  uint32_t entries_size;
};

/* 5749 */
struct vm_shared_region_slide_info_entry_v2
{
  uint32_t version;
  uint32_t page_size;
  uint32_t page_starts_offset;
  uint32_t page_starts_count;
  uint32_t page_extras_offset;
  uint32_t page_extras_count;
  uint64_t delta_mask;
  uint64_t value_add;
};

/* 5748 */
struct vm_shared_region_slide_info_entry_v3
{
  uint32_t version;
  uint32_t page_size;
  uint32_t page_starts_count;
  uint64_t value_add;
  uint16_t page_starts[];
};

/* 5747 */
struct vm_shared_region_slide_info_entry_v4
{
  uint32_t version;
  uint32_t page_size;
  uint32_t page_starts_offset;
  uint32_t page_starts_count;
  uint32_t page_extras_offset;
  uint32_t page_extras_count;
  uint64_t delta_mask;
  uint64_t value_add;
};

/* 5751 */
union vm_shared_region_slide_info_entry
{
  uint32_t version;
  vm_shared_region_slide_info_entry_v1 v1;
  vm_shared_region_slide_info_entry_v2 v2;
  vm_shared_region_slide_info_entry_v3 v3;
  vm_shared_region_slide_info_entry_v4 v4;
};

/* 3314 */
struct shared_region_check_np_args
{
  user_addr_t_0 start_address;
  char start_address_r_[];
};

/* 3315 */
struct pid_shutdown_sockets_args
{
  int pid;
  char pid_r_[4];
  int level;
  char level_r_[4];
};

/* 3316 */
struct pid_resume_args
{
  int pid;
  char pid_r_[4];
};

/* 3317 */
struct debug_control_port_for_pid_args
{
  mach_port_name_t target_tport;
  char target_tport_r_[4];
  int pid;
  char pid_r_[4];
  user_addr_t_0 t;
  char t_r_[];
};

/* 3318 */
struct pid_suspend_args
{
  int pid;
  char pid_r_[4];
};

/* 3319 */
struct task_read_for_pid_args
{
  mach_port_name_t target_tport;
  char target_tport_r_[4];
  int pid;
  char pid_r_[4];
  user_addr_t_0 t;
  char t_r_[];
};

/* 3320 */
struct task_inspect_for_pid_args
{
  mach_port_name_t target_tport;
  char target_tport_r_[4];
  int pid;
  char pid_r_[4];
  user_addr_t_0 t;
  char t_r_[];
};

/* 3321 */
struct task_name_for_pid_args
{
  mach_port_name_t target_tport;
  char target_tport_r_[4];
  int pid;
  char pid_r_[4];
  user_addr_t_0 t;
  char t_r_[];
};

/* 3322 */
struct task_for_pid_args
{
  mach_port_name_t target_tport;
  char target_tport_r_[4];
  int pid;
  char pid_r_[4];
  user_addr_t_0 t;
  char t_r_[];
};

/* 3323 */
struct pid_for_task_args
{
  mach_port_name_t t;
  char t_r_[4];
  user_addr_t_0 pid;
  char pid_r_[];
};

/* 3324 */
struct swapon_args
{
  int32_t dummy;
};

/* 6413 */
typedef unsigned __int64 memory_object_size_t;

/* 3325 */
struct _sr_file_mappings
{
  int fd;
  uint32_t mappings_count;
  shared_file_mapping_slide_np *mappings;
  uint32_t slide;
  fileproc *fp;
  vnode *vp;
  memory_object_size_t file_size;
  memory_object_control_t file_control;
};

/* 3328 */
struct shared_file_mapping_slide_np
{
  mach_vm_address_t_0 sms_address;
  mach_vm_size_t_0 sms_size;
  mach_vm_offset_t sms_file_offset;
  user_addr_t_0 sms_slide_size;
  user_addr_t_0 sms_slide_start;
  vm_prot_t sms_max_prot;
  vm_prot_t sms_init_prot;
};

/* 3326 */
struct mwl_region
{
  int mwlr_fd;
  vm_prot_t mwlr_protections;
  uint64_t mwlr_file_offset;
  mach_vm_address_t_0 mwlr_address;
  mach_vm_size_t_0 mwlr_size;
};

/* 3327 */
struct mwl_info_hdr
{
  uint32_t mwli_version;
  uint16_t mwli_page_size;
  uint16_t mwli_pointer_format;
  uint32_t mwli_binds_offset;
  uint32_t mwli_binds_count;
  uint32_t mwli_chains_offset;
  uint32_t mwli_chains_size;
  uint64_t mwli_slide;
  uint64_t mwli_image_address;
};

/* 3329 */
struct shared_file_np
{
  int sf_fd;
  uint32_t sf_mappings_count;
  uint32_t sf_slide;
};

/* 3330 */
struct hvg_hcall_vmcore_file
{
  char tag[57];
};

/* 3331 */
typedef bool (*soflow_entry_apply_func)(socket *, soflow_hash_entry *, void *);

/* 3332 */
struct nstat_domain_info
{
  char domain_name[256];
  char domain_owner[256];
  char domain_tracker_ctxt[256];
  char domain_attributed_bundle_id[256];
  union
  {
    sockaddr_in v4;
    sockaddr_in6 v6;
  } remote;
  bool is_tracker;
  bool is_non_app_initiated;
  bool is_silent;
  uint8_t reserved[1];
};

/* 3333 */
struct nstat_udp_descriptor
{
  u_int64_t upid;
  u_int64_t eupid;
  u_int64_t start_timestamp;
  u_int64_t timestamp;
  activity_bitmap_t activity_bitmap;
  union
  {
    sockaddr_in v4;
    sockaddr_in6 v6;
  } local;
  union
  {
    sockaddr_in v4;
    sockaddr_in6 v6;
  } remote;
  u_int32_t ifindex;
  u_int32_t rcvbufsize;
  u_int32_t rcvbufused;
  u_int32_t traffic_class;
  u_int32_t pid;
  char pname[64];
  u_int32_t epid;
  uuid_t_1 uuid;
  uuid_t_1 euuid;
  uuid_t_1 vuuid;
  uuid_t_1 fuuid;
  uint32_t ifnet_properties;
  uint8_t fallback_mode;
  uint8_t reserved[3];
};

/* 7674 */
typedef __uint32_t __darwin_socklen_t;

/* 5417 */
typedef __darwin_socklen_t socklen_t;

/* 3334 */
struct cmsghdr
{
  socklen_t cmsg_len;
  int cmsg_level;
  int cmsg_type;
};

/* 3335 */
struct inp_stat
{
  u_int64_t rxpackets;
  u_int64_t rxbytes;
  u_int64_t txpackets;
  u_int64_t txbytes;
};

/* 3336 */
struct necp_kernel_policy_service
{
  u_int32_t identifier;
  u_int32_t data;
};

/* 3337 */
union necp_kernel_policy_result_parameter
{
  u_int tunnel_interface_index;
  u_int scoped_interface_index;
  u_int32_t flow_divert_control_unit;
  u_int32_t filter_control_unit;
  u_int32_t skip_policy_order;
  u_int32_t route_rule_id;
  u_int32_t netagent_id;
  u_int32_t pass_flags;
  u_int32_t drop_flags;
  necp_kernel_policy_service service;
};

/* 4873 */
typedef u_int32_t necp_kernel_policy_result;

/* 4872 */
typedef u_int32_t necp_kernel_policy_filter;

/* 3338 */
struct necp_aggregate_socket_result
{
  necp_kernel_policy_result result;
  necp_kernel_policy_result_parameter result_parameter;
  necp_kernel_policy_filter filter_control_unit;
  u_int32_t flow_divert_aggregate_unit;
  u_int32_t route_rule_id;
  int32_t qos_marking_gencount;
};

/* 3339 */
struct __attribute__((aligned(8))) secasindex
{
  sockaddr_storage src;
  sockaddr_storage dst;
  u_int16_t proto;
  u_int8_t mode;
  u_int32_t reqid;
  u_int ipsec_ifindex;
};

/* 3340 */
struct ipsecrequest
{
  ipsecrequest *next;
  secasindex saidx;
  u_int level;
  secpolicy *sp;
};

/* 3341 */
struct secpolicyaddrrange
{
  sockaddr_storage start;
  sockaddr_storage end;
};

/* 3342 */
struct secpolicyindex
{
  u_int8_t dir;
  sockaddr_storage src;
  sockaddr_storage dst;
  u_int8_t prefs;
  u_int8_t prefd;
  u_int8_t ul_proto;
  ifnet_t internal_if;
  secpolicyaddrrange src_range;
  secpolicyaddrrange dst_range;
};

/* 3343 */
struct secpolicy
{
  struct
  {
    secpolicy *le_next;
    secpolicy **le_prev;
  } chain;
  int refcnt;
  secpolicyindex spidx;
  u_int32_t id;
  u_int state;
  u_int policy;
  ipsecrequest *req;
  ifnet_t ipsec_if;
  ifnet_t outgoing_if;
  char disabled;
  u_int64_t created;
  u_int64_t lastused;
  u_int64_t lifetime;
  u_int64_t validtime;
};

/* 3344 */
struct __attribute__((aligned(8))) inpcbpolicy
{
  secpolicy *sp_in;
  secpolicy *sp_out;
  int priv;
};

/* 3345 */
struct __attribute__((aligned(8))) in6_mfilter
{
  ip6_msource_tree im6f_sources;
  u_long im6f_nsrc;
  uint8_t im6f_st[2];
};

/* 3346 */
struct ip6_moptions
{
  lck_mtx_t im6o_lock;
  uint32_t im6o_refcnt;
  uint32_t im6o_debug;
  ifnet *im6o_multicast_ifp;
  u_char im6o_multicast_hlim;
  u_char im6o_multicast_loop;
  u_short im6o_num_memberships;
  u_short im6o_max_memberships;
  in6_multi **im6o_membership;
  in6_mfilter *im6o_mfilters;
  void (*im6o_trace)(ip6_moptions *, int);
};

/* 3347 */
struct in6_pktinfo
{
  in6_addr_0 ipi6_addr;
  unsigned int ipi6_ifindex;
};

/* 3348 */
struct ip6po_rhinfo
{
  ip6_rthdr *ip6po_rhi_rthdr;
  route_in6 ip6po_rhi_route;
};

/* 3601 */
struct ip6_rthdr
{
  u_int8_t ip6r_nxt;
  u_int8_t ip6r_len;
  u_int8_t ip6r_type;
  u_int8_t ip6r_segleft;
};

/* 3349 */
struct ip6po_nhinfo
{
  sockaddr *ip6po_nhi_nexthop;
  route_in6 ip6po_nhi_route;
};

/* 3350 */
struct ip6_pktopts
{
  mbuf *ip6po_m;
  int ip6po_hlim;
  in6_pktinfo *ip6po_pktinfo;
  ip6po_nhinfo ip6po_nhinfo;
  ip6_hbh *ip6po_hbh;
  ip6_dest *ip6po_dest1;
  ip6po_rhinfo ip6po_rhinfo;
  ip6_dest *ip6po_dest2;
  int ip6po_tclass;
  int ip6po_minmtu;
  int ip6po_prefer_tempaddr;
  int ip6po_flags;
};

/* 3603 */
struct ip6_hbh
{
  u_int8_t ip6h_nxt;
  u_int8_t ip6h_len;
};

/* 3602 */
struct ip6_dest
{
  u_int8_t ip6d_nxt;
  u_int8_t ip6d_len;
};

/* 3351 */
struct __attribute__((aligned(8))) in_mfilter
{
  ip_msource_tree imf_sources;
  u_long imf_nsrc;
  uint8_t imf_st[2];
};

/* 3352 */
struct ip_moptions
{
  lck_mtx_t imo_lock;
  uint32_t imo_refcnt;
  uint32_t imo_debug;
  ifnet *imo_multicast_ifp;
  u_char imo_multicast_ttl;
  u_char imo_multicast_loop;
  u_short imo_num_memberships;
  u_short imo_max_memberships;
  in_multi **imo_membership;
  in_mfilter *imo_mfilters;
  u_int32_t imo_multicast_vif;
  in_addr imo_multicast_addr;
  void (*imo_trace)(ip_moptions *, int);
};

/* 3353 */
struct __attribute__((aligned(8))) inpcbport
{
  struct
  {
    inpcbport *le_next;
    inpcbport **le_prev;
  } phd_hash;
  inpcbhead phd_pcblist;
  u_short phd_port;
};

/* 3355 */
struct inpcbhead
{
  inpcb *lh_first;
};

/* 4876 */
typedef u_quad_t inp_gen_t;

/* 3360 */
struct inp_necp_attributes
{
  char *inp_domain;
  char *inp_account;
  char *inp_domain_owner;
  char *inp_tracker_domain;
  char *inp_domain_context;
};

/* 4874 */
typedef u_int32_t necp_kernel_policy_id;

/* 3359 */
struct necp_inpcb_result
{
  u_int32_t app_id;
  necp_kernel_policy_id policy_id;
  necp_kernel_policy_id skip_policy_id;
  int32_t policy_gencount;
  u_int32_t flowhash;
  u_int32_t network_denied_notifies;
  necp_aggregate_socket_result results;
};

/* 4875 */
typedef void (*necp_client_flow_cb)(void *, int, uint32_t, uint32_t, bool *);

/* 3361 */
struct __attribute__((aligned(8))) inpcb
{
  lck_mtx_t inpcb_mtx;
  struct
  {
    inpcb *le_next;
    inpcb **le_prev;
  } inp_hash;
  struct
  {
    inpcb *le_next;
    inpcb **le_prev;
  } inp_list;
  void *inp_ppcb;
  inpcbinfo *inp_pcbinfo;
  socket *inp_socket;
  struct
  {
    inpcb *le_next;
    inpcb **le_prev;
  } inp_portlist;
  struct
  {
    inpcb *rbe_left;
    inpcb *rbe_right;
    inpcb *rbe_parent;
  } infc_link;
  inpcbport *inp_phd;
  inp_gen_t inp_gencnt;
  int inp_hash_element;
  int inp_wantcnt;
  int inp_state;
  u_short inp_fport;
  u_short inp_lport;
  u_int32_t inp_flags;
  u_int32_t inp_flags2;
  u_int32_t inp_flow;
  uint32_t inp_lifscope;
  uint32_t inp_fifscope;
  u_char inp_sndinprog_cnt;
  uint32_t inp_sndingprog_waiters;
  u_char inp_vflag;
  u_char inp_ip_ttl;
  u_char inp_ip_p;
  ifnet *inp_boundifp;
  ifnet *inp_last_outifp;
  u_int32_t inp_flowhash;
  union
  {
    in_addr_4in6 inp46_foreign;
    in6_addr_0 inp6_foreign;
  } inp_dependfaddr;
  union
  {
    in_addr_4in6 inp46_local;
    in6_addr_0 inp6_local;
  } inp_dependladdr;
  union
  {
    route_0 inp4_route;
    route_in6 inp6_route;
  } inp_dependroute;
  struct
  {
    u_char inp4_ip_tos;
    mbuf *inp4_options;
    ip_moptions *inp4_moptions;
  } inp_depend4;
  struct __attribute__((aligned(4)))
  {
    mbuf *inp6_options;
    ip6_pktopts *inp6_outputopts;
    ip6_moptions *inp6_moptions;
    icmp6_filter *inp6_icmp6filt;
    int inp6_cksum;
    short inp6_hops;
  } inp_depend6;
  uint64_t inp_fadv_flow_ctrl_cnt;
  uint64_t inp_fadv_suspended_cnt;
  caddr_t inp_saved_ppcb;
  inpcbpolicy *inp_sp;
  inp_necp_attributes inp_necp_attributes;
  necp_inpcb_result inp_policyresult;
  uuid_t_1 necp_client_uuid;
  necp_client_flow_cb necp_cb;
  u_int8_t *inp_resolver_signature;
  size_t inp_resolver_signature_length;
  netns_token inp_netns_token;
  netns_token inp_wildcard_netns_token;
  u_char *inp_keepalive_data;
  u_int8_t inp_keepalive_datalen;
  u_int8_t inp_keepalive_type;
  u_int16_t inp_keepalive_interval;
  uint32_t inp_nstat_refcnt;
  inp_stat *inp_stat;
  inp_stat *inp_cstat;
  inp_stat *inp_wstat;
  inp_stat *inp_Wstat;
  u_int8_t inp_stat_store[40];
  u_int8_t inp_cstat_store[40];
  u_int8_t inp_wstat_store[40];
  u_int8_t inp_Wstat_store[40];
  activity_bitmap_t inp_nw_activity;
  u_int64_t inp_start_timestamp;
  char inp_last_proc_name[17];
  char inp_e_proc_name[17];
};

/* 3357 */
typedef void (*inpcb_timer_func_t)(inpcbinfo *);

/* 3356 */
struct intimercount
{
  u_int32_t intimer_lazy;
  u_int32_t intimer_fast;
  u_int32_t intimer_nodelay;
};

/* 9157 */
union zone_or_view_0
{
  kalloc_type_view *zov_kt_heap;
  zone_view *zov_view;
  zone *zov_zone;
};

/* 9158 */
typedef zone_or_view_0 zone_or_view_t_0;

/* 3358 */
struct __attribute__((aligned(8))) inpcbinfo
{
  struct
  {
    inpcbinfo *tqe_next;
    inpcbinfo **tqe_prev;
  } ipi_entry;
  inpcb_timer_func_t ipi_gc;
  inpcb_timer_func_t ipi_timer;
  intimercount ipi_gc_req;
  intimercount ipi_timer_req;
  lck_rw_t ipi_lock;
  inpcbhead *ipi_listhead;
  uint32_t ipi_count;
  uint32_t ipi_twcount;
  uint64_t ipi_gencnt;
  uint16_t ipi_lastport;
  uint16_t ipi_lastlow;
  uint16_t ipi_lasthi;
  zone_or_view_t_0 ipi_zone;
  inpcbhead *ipi_hashbase;
  u_long ipi_hashmask;
  inpcbporthead *ipi_porthashbase;
  u_long ipi_porthashmask;
  lck_attr_t ipi_lock_attr;
  lck_grp_t *ipi_lock_grp;
  u_int32_t ipi_flags;
};

/* 4216 */
struct icmp6_filter
{
  u_int32_t icmp6_filt[8];
};

/* 3354 */
struct inpcbporthead
{
  inpcbport *lh_first;
};

/* 3366 */
typedef tracker_hash_entry_short tracker_hash_entry_short_t;

/* 7865 */
struct tracker_metadata_short
{
  uint32_t flags;
  char domain[64];
  char domain_owner[64];
};

/* 3368 */
typedef tracker_metadata_short tracker_metadata_short_t;

/* 9480 */
struct __attribute__((aligned(8))) tracker_hash_entry_short
{
  struct
  {
    tracker_hash_entry *le_next;
    tracker_hash_entry **le_prev;
  } entry_link;
  uuid_t_1 app_uuid;
  sa_family_t address_family;
  union
  {
    in_addr_4in6 addr46;
    in6_addr_0 addr6;
  } address;
  u_int64_t lastused;
  tracker_metadata_short_t metadata;
};

/* 7866 */
struct tracker_metadata
{
  uint32_t flags;
  char domain[254];
  char domain_owner[254];
};

/* 3369 */
typedef tracker_metadata tracker_metadata_t;

/* 3370 */
struct tracker_hash_entry
{
  struct
  {
    tracker_hash_entry *le_next;
    tracker_hash_entry **le_prev;
  } entry_link;
  uuid_t_1 app_uuid;
  sa_family_t address_family;
  union
  {
    in_addr_4in6 addr46;
    in6_addr_0 addr6;
  } address;
  u_int64_t lastused;
  tracker_metadata_t metadata;
};

/* 3367 */
struct tracker_action_args
{
  int action;
  char action_r_[4];
  user_addr_t_0 buffer;
  user_size_t buffer_size;
  char buffer_size_r_[];
};

/* 3371 */
struct trackerhashhead
{
  tracker_hash_entry *lh_first;
};

/* 3372 */
struct thread_selfcounts_args
{
  uint32_t kind;
  char kind_r_[4];
  user_addr_t_0 buf;
  user_size_t size;
  char size_r_[];
};

/* 3373 */
struct eventhandler_entry_generic
{
  eventhandler_entry ee;
  void *func;
};

/* 3374 */
struct in4in6_addr
{
  u_int32_t i46a_pad32[3];
  in_addr i46a_addr4;
};

/* 3375 */
struct vsock_sockinfo
{
  uint32_t local_cid;
  uint32_t local_port;
  uint32_t remote_cid;
  uint32_t remote_port;
};

/* 3376 */
struct kern_ctl_info
{
  uint32_t kcsi_id;
  uint32_t kcsi_reg_unit;
  uint32_t kcsi_flags;
  uint32_t kcsi_recvbufsize;
  uint32_t kcsi_sendbufsize;
  uint32_t kcsi_unit;
  char kcsi_name[96];
};

/* 3377 */
struct kern_event_info
{
  uint32_t kesi_vendor_code_filter;
  uint32_t kesi_class_filter;
  uint32_t kesi_subclass_filter;
};

/* 3378 */
struct ndrv_info
{
  uint32_t ndrvsi_if_family;
  uint32_t ndrvsi_if_unit;
  char ndrvsi_if_name[16];
};

/* 3395 */
struct sockaddr_un
{
  unsigned __int8 sun_len;
  sa_family_t sun_family;
  char sun_path[104];
};

/* 3379 */
struct __attribute__((aligned(4))) un_sockinfo
{
  uint64_t unsi_conn_so;
  uint64_t unsi_conn_pcb;
  union
  {
    sockaddr_un ua_sun;
    char ua_dummy[255];
  } unsi_addr;
  union
  {
    sockaddr_un ua_sun;
    char ua_dummy[255];
  } unsi_caddr;
};

/* 3381 */
struct in_sockinfo
{
  int insi_fport;
  int insi_lport;
  uint64_t insi_gencnt;
  uint32_t insi_flags;
  uint32_t insi_flow;
  uint8_t insi_vflag;
  uint8_t insi_ip_ttl;
  uint32_t rfu_1;
  union
  {
    in4in6_addr ina_46;
    in6_addr_0 ina_6;
  } insi_faddr;
  union
  {
    in4in6_addr ina_46;
    in6_addr_0 ina_6;
  } insi_laddr;
  struct
  {
    u_char in4_tos;
  } insi_v4;
  struct
  {
    uint8_t in6_hlim;
    int in6_cksum;
    u_short in6_ifindex;
    short in6_hops;
  } insi_v6;
};

/* 3380 */
struct tcp_sockinfo
{
  in_sockinfo tcpsi_ini;
  int tcpsi_state;
  int tcpsi_timer[4];
  int tcpsi_mss;
  uint32_t tcpsi_flags;
  uint32_t rfu_1;
  uint64_t tcpsi_tp;
};

/* 3382 */
struct sockbuf_info
{
  uint32_t sbi_cc;
  uint32_t sbi_hiwat;
  uint32_t sbi_mbcnt;
  uint32_t sbi_mbmax;
  uint32_t sbi_lowat;
  short sbi_flags;
  short sbi_timeo;
};

/* 3383 */
struct vinfo_stat
{
  uint32_t vst_dev;
  uint16_t vst_mode;
  uint16_t vst_nlink;
  uint64_t vst_ino;
  uid_t vst_uid;
  gid_t vst_gid;
  int64_t vst_atime;
  int64_t vst_atimensec;
  int64_t vst_mtime;
  int64_t vst_mtimensec;
  int64_t vst_ctime;
  int64_t vst_ctimensec;
  int64_t vst_birthtime;
  int64_t vst_birthtimensec;
  off_t vst_size;
  int64_t vst_blocks;
  int32_t vst_blksize;
  uint32_t vst_flags;
  uint32_t vst_gen;
  uint32_t vst_rdev;
  int64_t vst_qspare[2];
};

/* 3384 */
struct socket_info
{
  vinfo_stat soi_stat;
  uint64_t soi_so;
  uint64_t soi_pcb;
  int soi_type;
  int soi_protocol;
  int soi_family;
  short soi_options;
  short soi_linger;
  short soi_state;
  short soi_qlen;
  short soi_incqlen;
  short soi_qlimit;
  short soi_timeo;
  u_short soi_error;
  uint32_t soi_oobmark;
  sockbuf_info soi_rcv;
  sockbuf_info soi_snd;
  int soi_kind;
  uint32_t rfu_1;
  union
  {
    in_sockinfo pri_in;
    tcp_sockinfo pri_tcp;
    un_sockinfo pri_un;
    ndrv_info pri_ndrv;
    kern_event_info pri_kern_event;
    kern_ctl_info pri_kern_ctl;
    vsock_sockinfo pri_vsock;
  } soi_proto;
};

/* 3385 */
struct __attribute__((aligned(8))) kern_event_pcb
{
  lck_mtx_t evp_mtx;
  struct
  {
    kern_event_pcb *le_next;
    kern_event_pcb **le_prev;
  } evp_link;
  socket *evp_socket;
  u_int32_t evp_vendor_code_filter;
  u_int32_t evp_class_filter;
  u_int32_t evp_subclass_filter;
};

/* 3387 */
struct vsock_address
{
  uint32_t cid;
  uint32_t port;
};

/* 3531 */
enum vsock_operation : __int32
{
  vsock_operation::VSOCK_REQUEST = 0x0,
  vsock_operation::VSOCK_RESPONSE = 0x1,
  vsock_operation::VSOCK_PAYLOAD = 0x2,
  vsock_operation::VSOCK_SHUTDOWN = 0x3,
  vsock_operation::VSOCK_SHUTDOWN_RECEIVE = 0x4,
  vsock_operation::VSOCK_SHUTDOWN_SEND = 0x5,
  vsock_operation::VSOCK_RESET = 0x6,
  vsock_operation::VSOCK_CREDIT_UPDATE = 0x7,
  vsock_operation::VSOCK_CREDIT_REQUEST = 0x8,
};

/* 3386 */
struct vsock_transport
{
  void *provider;
  int (*get_cid)(void *, uint32_t *);
  int (*attach_socket)(void *);
  int (*detach_socket)(void *);
  int (*put_message)(void *, vsock_address, vsock_address, vsock_operation, uint32_t, uint32_t, mbuf_t);
};

/* 3532 */
typedef u_quad_t vsock_gen_t;

/* 3388 */
struct vsockpcb
{
  struct
  {
    vsockpcb *tqe_next;
    vsockpcb **tqe_prev;
  } all;
  struct
  {
    vsockpcb *le_next;
    vsockpcb **le_prev;
  } bound;
  socket *so;
  vsock_address local_address;
  vsock_address remote_address;
  vsock_transport *transport;
  uint32_t fwd_cnt;
  uint32_t tx_cnt;
  uint32_t peer_buf_alloc;
  uint32_t peer_fwd_cnt;
  uint32_t last_buf_alloc;
  uint32_t last_fwd_cnt;
  size_t waiting_send_size;
  vsock_gen_t vsock_gencnt;
};

/* 3389 */
typedef ifmultiaddr *ifmultiaddr_t;

/* 3390 */
struct ndrv_multiaddr
{
  ndrv_multiaddr *next;
  ifmultiaddr_t ifma;
  sockaddr *addr;
};

/* 3391 */
struct sockaddr_ndrv
{
  unsigned __int8 snd_len;
  unsigned __int8 snd_family;
  unsigned __int8 snd_name[16];
};

/* 4921 */
struct dlil_demux_desc;

/* 3392 */
struct dlist
{
  dlil_demux_desc *tqh_first;
  dlil_demux_desc **tqh_last;
};

/* 3393 */
struct sockproto
{
  __uint16_t sp_family;
  __uint16_t sp_protocol;
};

/* 3394 */
struct __attribute__((aligned(8))) ndrv_cb
{
  struct
  {
    ndrv_cb *tqe_next;
    ndrv_cb **tqe_prev;
  } nd_next;
  socket *nd_socket;
  u_int32_t nd_signature;
  sockaddr_ndrv *nd_faddr;
  sockaddr_ndrv *nd_laddr;
  sockproto nd_proto;
  int nd_descrcnt;
  dlist nd_dlist;
  u_int32_t nd_dlist_cnt;
  ifnet *nd_if;
  u_int32_t nd_proto_family;
  u_int32_t nd_family;
  ndrv_multiaddr *nd_multiaddrs;
  short nd_unit;
};

/* 3396 */
struct unp_head
{
  unpcb *lh_first;
};

/* 3600 */
typedef u_quad_t unp_gen_t;

/* 3397 */
struct unpcb
{
  struct
  {
    unpcb *le_next;
    unpcb **le_prev;
  } unp_link;
  socket *unp_socket;
  vnode *unp_vnode;
  ino_t unp_ino;
  unpcb *unp_conn;
  unp_head unp_refs;
  struct
  {
    unpcb *le_next;
    unpcb **le_prev;
  } unp_reflink;
  sockaddr_un *unp_addr;
  unp_gen_t unp_gencnt;
  int unp_cc;
  int unp_mbcnt;
  uint32_t unp_flags;
  uint32_t rw_thrcount;
  xucred unp_peercred;
  lck_mtx_t unp_mtx;
};

/* 4865 */
typedef u_int32_t tcp_notify_ack_id_t;

/* 3398 */
struct tcp_notify_ack_marker
{
  tcp_seq notify_snd_una;
  tcp_notify_ack_id_t notify_id;
  struct
  {
    tcp_notify_ack_marker *sle_next;
  } notify_next;
};

/* 3399 */
struct tcp_rxt_seg
{
  tcp_seq rx_start;
  tcp_seq rx_end;
  u_int16_t rx_count;
  u_int16_t rx_flags;
  struct
  {
    tcp_rxt_seg *sle_next;
  } rx_link;
};

/* 3400 */
struct tcp_ledbat_state
{
  uint32_t num_slowdown_events;
  uint32_t slowdown_ts;
  uint32_t slowdown_begin;
  uint32_t md_bytes_acked;
};

/* 3401 */
struct tcp_cubic_state
{
  u_int32_t tc_last_max;
  u_int32_t tc_epoch_start;
  u_int32_t tc_origin_point;
  u_int32_t tc_tcp_win;
  u_int32_t tc_tcp_bytes_acked;
  u_int32_t tc_avg_lastmax;
  u_int32_t tc_mean_deviation;
  float tc_epoch_period;
};

/* 3402 */
struct tcp_ccstate
{
  union
  {
    tcp_cubic_state _cubic_state_;
    tcp_ledbat_state _ledbat_state_;
  } __u__;
};

/* 3403 */
struct bwmeas
{
  tcp_seq bw_start;
  uint32_t bw_ts;
  uint32_t bw_size;
  uint32_t bw_minsizepkts;
  uint32_t bw_maxsizepkts;
  uint32_t bw_minsize;
  uint32_t bw_maxsize;
  uint32_t bw_sndbw;
  uint32_t bw_sndbw_max;
  uint32_t bw_rcvbw_max;
};

/* 3404 */
struct sackblk
{
  tcp_seq start;
  tcp_seq end;
};

/* 3405 */
struct sackhole
{
  tcp_seq start;
  tcp_seq end;
  tcp_seq rxmit;
  u_int32_t rxmit_start;
  struct
  {
    sackhole *tqe_next;
    sackhole **tqe_prev;
  } scblink;
};

/* 3406 */
struct tseg_qent
{
  struct
  {
    tseg_qent *le_next;
    tseg_qent **le_prev;
  } tqe_q;
  int tqe_len;
  tcphdr *tqe_th;
  mbuf *tqe_m;
};

/* 3407 */
struct tcp_rledbat_state
{
  uint32_t num_slowdown_events;
  uint32_t slowdown_ts;
  uint32_t slowdown_begin;
  uint32_t reduction_end;
  uint32_t rcvd_bytes;
  uint32_t md_rcvd_bytes;
  uint32_t win;
  uint32_t ssthresh;
  uint32_t drained_bytes;
  uint32_t win_ws;
};

/* 3408 */
struct __attribute__((aligned(8))) mpt_dsn_map
{
  uint64_t mpt_dsn;
  uint32_t mpt_sseq;
  uint16_t mpt_len;
  uint16_t mpt_csum;
  uint8_t mpt_dfin;
};

/* 3409 */
struct tcp_rxt_seghead
{
  tcp_rxt_seg *slh_first;
};

/* 3410 */
struct sackhint
{
  sackhole *nexthole;
  int sack_bytes_rexmit;
  int sack_bytes_acked;
};

/* 3411 */
struct sackhole_head
{
  sackhole *tqh_first;
  sackhole **tqh_last;
};

/* 3412 */
struct __attribute__((aligned(8))) tcptimerentry
{
  struct
  {
    tcptimerentry *le_next;
    tcptimerentry **le_prev;
  } le;
  uint32_t timer_start;
  uint16_t index;
  uint16_t mode;
  uint32_t runtime;
};

/* 3413 */
struct tsegqe_head
{
  tseg_qent *lh_first;
};

/* 3414 */
struct tcpcb
{
  tsegqe_head t_segq;
  uint32_t t_dupacks;
  int t_state;
  uint32_t t_timer[9];
  tcptimerentry tentry;
  inpcb *t_inpcb;
  uint32_t t_flags;
  tcp_seq snd_una;
  tcp_seq snd_max;
  tcp_seq snd_nxt;
  tcp_seq snd_up;
  tcp_seq snd_wl1;
  tcp_seq snd_wl2;
  tcp_seq iss;
  tcp_seq irs;
  tcp_seq rcv_nxt;
  tcp_seq rcv_adv;
  uint32_t rcv_wnd;
  uint32_t t_last_recwin;
  tcp_seq rcv_up;
  uint32_t snd_wnd;
  uint32_t snd_cwnd;
  uint32_t snd_ssthresh;
  tcp_seq snd_recover;
  uint32_t t_maxopd;
  uint32_t t_rcvtime;
  uint32_t t_sndtime;
  uint32_t t_starttime;
  int t_rtttime;
  tcp_seq t_rtseq;
  uint32_t rfbuf_ts;
  uint32_t rfbuf_cnt;
  uint32_t rfbuf_space;
  int t_rxtcur;
  unsigned int t_maxseg;
  int t_srtt;
  int t_rttvar;
  uint64_t t_accsleep_ms;
  uint32_t t_reassqlen;
  uint32_t t_reassq_mbcnt;
  uint16_t t_rxtshift;
  uint32_t t_rttmin;
  uint32_t t_rttbest;
  uint32_t t_rttcur;
  uint32_t t_rttupdated;
  uint32_t t_rxt_conndroptime;
  uint32_t t_rxtstart;
  uint32_t max_sndwnd;
  int t_softerror;
  char t_oobflags;
  char t_iobc;
  u_int8_t snd_scale;
  u_int8_t rcv_scale;
  u_int8_t request_r_scale;
  u_int8_t requested_s_scale;
  u_int8_t tcp_cc_index;
  u_int8_t t_adaptive_rtimo;
  u_int8_t t_adaptive_wtimo;
  u_int8_t t_stretchack_delayed;
  u_int16_t t_early_rexmt_count;
  u_int32_t t_early_rexmt_win;
  u_int32_t ts_recent;
  u_int32_t ts_recent_age;
  tcp_seq last_ack_sent;
  u_int32_t t_bytes_acked;
  int t_lastchain;
  uint16_t t_unacksegs;
  uint16_t t_forced_acks;
  uint8_t t_rexmtthresh;
  uint8_t t_rtimo_probes;
  uint32_t t_persist_timeout;
  uint32_t t_persist_stop;
  uint32_t t_notsent_lowat;
  u_int32_t rcv_unackwin;
  u_int32_t rcv_by_unackwin;
  u_int32_t rcv_by_unackhalfwin;
  u_int32_t rcv_nostrack_ts;
  u_int32_t rcv_nostrack_pkts;
  u_int16_t rcv_waitforss;
  u_int32_t ecn_flags;
  u_int32_t t_ecn_recv_ce;
  u_int32_t t_ecn_recv_cwr;
  uint32_t t_rcv_ce_packets;
  uint32_t t_snd_ce_packets;
  uint32_t t_delta_ce_packets;
  uint64_t t_rcv_ect1_bytes;
  uint64_t t_rcv_ect0_bytes;
  uint64_t t_rcv_ce_bytes;
  uint64_t t_snd_ect1_bytes;
  uint64_t t_snd_ect0_bytes;
  uint64_t t_snd_ce_bytes;
  u_int32_t snd_cwnd_prev;
  u_int32_t snd_ssthresh_prev;
  tcp_seq snd_recover_prev;
  int t_srtt_prev;
  int t_rttvar_prev;
  u_int32_t t_badrexmt_time;
  u_int32_t t_reorderwin;
  int16_t snd_numholes;
  tcp_seq sack_newdata;
  sackhole_head snd_holes;
  tcp_seq snd_fack;
  int rcv_numsacks;
  sackblk sackblks[6];
  sackhint sackhint;
  tcp_seq send_highest_sack;
  int t_new_dupacks;
  mbuf *t_pktlist_head;
  mbuf *t_pktlist_tail;
  u_int32_t t_pktlist_sentlen;
  u_int32_t t_keepidle;
  u_int32_t t_keepinit;
  u_int32_t t_keepintvl;
  u_int32_t t_keepcnt;
  u_int32_t tso_max_segment_size;
  u_int16_t t_pmtud_lastseg_size;
  u_int32_t t_pmtud_saved_maxopd;
  u_int32_t t_pmtud_start_ts;
  struct
  {
    u_int32_t rxduplicatebytes;
    u_int32_t rxoutoforderbytes;
    u_int32_t txretransmitbytes;
    u_int16_t synrxtshift;
    u_int16_t rxmitsyns;
    u_int16_t unused_pad_to_8;
    u_int32_t rxmitpkts;
    uint32_t delayed_acks_sent;
    uint32_t acks_delayed;
  } t_stat;
  u_int8_t t_syn_sent;
  u_int8_t t_syn_rcvd;
  u_int8_t t_notify_ack_count;
  u_int8_t t_ecn_recv_ce_pkt;
  u_int32_t t_cached_maxopd;
  uint32_t bg_ssthresh;
  uint32_t t_flagsext;
  uint32_t iaj_rcv_ts;
  int iaj_size;
  uint8_t iaj_small_pkt;
  uint8_t t_pipeack_ind;
  uint16_t iaj_pktcnt;
  uint32_t acc_iaj;
  uint32_t avg_iaj;
  uint32_t std_dev_iaj;
  bwmeas *t_bwmeas;
  tcp_seq t_idleat;
  uint8_t t_fin_sent;
  uint8_t t_fin_rcvd;
  uint8_t t_rst_sent;
  uint8_t t_rst_rcvd;
  struct
  {
    tcpcb *tqe_next;
    tcpcb **tqe_prev;
  } t_twentry;
  tcp_ccstate *t_ccstate;
  tcp_ccstate _t_ccstate;
  tcp_seq t_tlphighrxt;
  u_int32_t t_tlpstart;
  tcp_seq t_dsack_lseq;
  tcp_seq t_dsack_rseq;
  tcp_rxt_seghead t_rxt_segments;
  uint32_t t_rxt_seg_count;
  uint32_t t_rxt_seg_drop;
  tcp_seq t_dsack_lastuna;
  u_int32_t t_pipeack_sample[3];
  tcp_seq t_pipeack_lastuna;
  u_int32_t t_pipeack;
  u_int32_t t_lossflightsize;
  u_int32_t t_mpflags;
  tcp_seq t_mpuna;
  mptcb *t_mptcb;
  mptsub *t_mpsub;
  mpt_dsn_map t_rcv_map;
  u_int8_t t_local_aid;
  u_int8_t t_rem_aid;
  u_int8_t t_mprxtshift;
  u_int8_t t_tfo_flags;
  u_int16_t t_tfo_stats;
  u_int8_t t_tfo_probes;
  u_int8_t t_tfo_probe_state;
  u_int32_t t_rcvoopack;
  u_int32_t t_pawsdrop;
  u_int32_t t_sack_recovery_episode;
  u_int32_t t_reordered_pkts;
  u_int32_t t_dsack_sent;
  u_int32_t t_dsack_recvd;
  struct
  {
    tcp_notify_ack_marker *slh_first;
  } t_notify_ack;
  u_int32_t t_recv_throttle_ts;
  u_int32_t t_rxt_minimum_timeout;
  uint32_t t_challengeack_last;
  uint32_t t_challengeack_count;
  u_int32_t t_log_flags;
  u_int32_t t_connect_time;
  uint32_t t_comp_gencnt;
  uint32_t t_comp_lastinc;
  uint32_t t_ts_offset;
  uint32_t curr_rtt_hist[4];
  uint32_t curr_rtt_min;
  uint32_t curr_rtt_index;
  tcp_seq rcv_high;
  uint32_t tsv_high;
  tcp_rledbat_state t_rlstate;
  uint32_t rcv_srtt;
  uint32_t rcv_rtt_est_ts;
  uint32_t rcv_rtt_est_seq;
  uuid_t_1 t_fsw_uuid;
  uuid_t_1 t_flow_uuid;
};

/* 8008 */
enum mptcp_state : __int32
{
  mptcp_state::MPTCPS_CLOSED = 0x0,
  mptcp_state::MPTCPS_LISTEN = 0x1,
  mptcp_state::MPTCPS_ESTABLISHED = 0x2,
  mptcp_state::MPTCPS_CLOSE_WAIT = 0x3,
  mptcp_state::MPTCPS_FIN_WAIT_1 = 0x4,
  mptcp_state::MPTCPS_CLOSING = 0x5,
  mptcp_state::MPTCPS_LAST_ACK = 0x6,
  mptcp_state::MPTCPS_FIN_WAIT_2 = 0x7,
  mptcp_state::MPTCPS_TIME_WAIT = 0x8,
  mptcp_state::MPTCPS_TERMINATE = 0x9,
};

/* 4426 */
typedef mptcp_state mptcp_state_t;

/* 4425 */
typedef u_int64_t mptcp_key_t;

/* 4424 */
typedef u_int32_t mptcp_token_t;

/* 3597 */
struct __attribute__((aligned(8))) mptcb
{
  mptses *mpt_mpte;
  mptcp_state_t mpt_state;
  uint32_t mpt_flags;
  uint8_t mpt_version;
  u_short mpt_softerror;
  mptcp_key_t mpt_localkey;
  mptcp_key_t mpt_remotekey;
  mptcp_token_t mpt_localtoken;
  mptcp_token_t mpt_remotetoken;
  int mpt_rxtshift;
  uint64_t mpt_rxtstart;
  uint64_t mpt_rtseq;
  uint64_t mpt_timewait;
  uint32_t mpt_timer_vals;
  uint64_t mpt_snduna;
  uint64_t mpt_sndnxt;
  uint64_t mpt_sndmax;
  uint64_t mpt_local_idsn;
  uint32_t mpt_sndwnd;
  uint64_t mpt_sndwl1;
  uint64_t mpt_sndwl2;
  uint64_t mpt_rcvnxt;
  uint64_t mpt_remote_idsn;
  uint64_t mpt_rcvadv;
  uint32_t mpt_rcvwnd;
  struct
  {
    mptcp_subf_auth_entry *lh_first;
  } mpt_subauth_list;
  uint64_t mpt_dsn_at_csum_fail;
  uint32_t mpt_ssn_at_csum_fail;
  int32_t mpt_gc_ticks;
  uint32_t mpt_notsent_lowat;
  tsegqe_head mpt_segq;
  uint32_t mpt_reassqlen;
};

/* 3592 */
struct __attribute__((aligned(8))) mptsub
{
  struct
  {
    mptsub *tqe_next;
    mptsub **tqe_prev;
  } mpts_entry;
  uint32_t mpts_refcnt;
  uint32_t mpts_flags;
  uint32_t mpts_evctl;
  sae_connid_t mpts_connid;
  int mpts_oldintval;
  mptses *mpts_mpte;
  socket *mpts_socket;
  sockaddr *mpts_src;
  union
  {
    sockaddr _mpts_dst;
    sockaddr_in _mpts_dst_v4;
    sockaddr_in6 _mpts_dst_v6;
  } mpts_u_dst;
  u_int32_t mpts_rel_seq;
  u_int32_t mpts_iss;
  u_int32_t mpts_ifscope;
  uint32_t mpts_probesoon;
  uint32_t mpts_probecnt;
  uint32_t mpts_maxseg;
};

/* 3591 */
struct __attribute__((aligned(8))) mpt_itf_info
{
  uint32_t ifindex;
};

/* 3590 */
struct mptcp_itf_stats
{
  u_short ifindex;
  uint16_t switches;
  uint64_t mpis_txbytes;
  uint64_t mpis_rxbytes;
  uint64_t mpis_wifi_txbytes;
  uint64_t mpis_wifi_rxbytes;
  uint64_t mpis_wired_txbytes;
  uint64_t mpis_wired_rxbytes;
  uint64_t mpis_cell_txbytes;
  uint64_t mpis_cell_rxbytes;
};

/* 3596 */
struct mptses
{
  mppcb *mpte_mppcb;
  mptcb *mpte_mptcb;
  struct
  {
    mptopt *tqh_first;
    mptopt **tqh_last;
  } mpte_sopts;
  struct
  {
    mptsub *tqh_first;
    mptsub **tqh_last;
  } mpte_subflows;
  uint16_t mpte_numflows;
  uint16_t mpte_nummpcapflows;
  sae_associd_t mpte_associd;
  sae_connid_t mpte_connid_last;
  uint64_t mpte_time_target;
  thread_call_t mpte_time_thread;
  thread_call_t mpte_stop_urgency;
  uint32_t mpte_last_cellicon_set;
  uint32_t mpte_cellicon_increments;
  union
  {
    sockaddr _mpte_src;
    sockaddr_in _mpte_src_v4;
    sockaddr_in6 _mpte_src_v6;
  } mpte_u_src;
  union
  {
    sockaddr _mpte_dst;
    sockaddr_in _mpte_dst_v4;
    sockaddr_in6 _mpte_dst_v6;
  } mpte_u_dst;
  sockaddr_in mpte_sub_dst_v4;
  sockaddr_in6 mpte_sub_dst_v6;
  uint8_t sub_dst_addr_id_v4;
  uint8_t sub_dst_addr_id_v6;
  uint16_t mpte_alternate_port;
  int mpte_epid;
  uuid_t_1 mpte_euuid;
  mptsub *mpte_active_sub;
  uint16_t mpte_flags;
  uint8_t mpte_svctype;
  uint8_t mpte_lost_aid;
  uint8_t mpte_addrid_last;
  uint32_t mpte_itfinfo_size;
  __attribute__((packed)) __attribute__((aligned(1))) mpt_itf_info _mpte_itfinfo[4];
  mpt_itf_info *mpte_itfinfo;
  mbuf *mpte_reinjectq;
  uint32_t mpte_subflow_switches;
  __attribute__((aligned(8))) uint32_t mpte_triggered_cell;
  mptcp_itf_stats mpte_itfstats[4];
  uint64_t mpte_init_txbytes;
  uint64_t mpte_init_rxbytes;
};

/* 4422 */
typedef u_int8_t mptcp_addr_id;

/* 3589 */
struct __attribute__((aligned(8))) mptcp_subf_auth_entry
{
  struct
  {
    mptcp_subf_auth_entry *le_next;
    mptcp_subf_auth_entry **le_prev;
  } msae_next;
  u_int32_t msae_laddr_rand;
  u_int32_t msae_raddr_rand;
  mptcp_addr_id msae_laddr_id;
  mptcp_addr_id msae_raddr_id;
};

/* 8009 */
enum mppcb_state : __int32
{
  mppcb_state::MPPCB_STATE_INUSE = 0x1,
  mppcb_state::MPPCB_STATE_DEAD = 0x2,
};

/* 4423 */
typedef mppcb_state mppcb_state_t;

/* 3595 */
struct mppcb
{
  struct
  {
    mppcb *tqe_next;
    mppcb **tqe_prev;
  } mpp_entry;
  lck_mtx_t mpp_lock;
  mppcbinfo *mpp_pcbinfo;
  mptses *mpp_pcbe;
  socket *mpp_socket;
  uint32_t mpp_flags;
  mppcb_state_t mpp_state;
  int32_t mpp_inside;
  uuid_t_1 necp_client_uuid;
  inp_necp_attributes inp_necp_attributes;
  void (*necp_cb)(void *, int, uint32_t, uint32_t, bool *);
};

/* 3593 */
struct mptopt
{
  struct
  {
    mptopt *tqe_next;
    mptopt **tqe_prev;
  } mpo_entry;
  uint32_t mpo_flags;
  int mpo_level;
  int mpo_name;
  int mpo_intval;
};

/* 3594 */
struct mppcbinfo
{
  struct
  {
    mppcbinfo *tqe_next;
    mppcbinfo **tqe_prev;
  } mppi_entry;
  struct
  {
    mppcb *tqh_first;
    mppcb **tqh_last;
  } mppi_pcbs;
  uint32_t mppi_count;
  lck_attr_t mppi_lock_attr;
  mppcb *(*mppi_alloc)(void);
  void (*mppi_free)(mppcb *);
  lck_grp_t *mppi_lock_grp;
  lck_mtx_t mppi_lock;
  uint32_t (*mppi_gc)(mppcbinfo *);
  uint32_t (*mppi_timer)(mppcbinfo *);
};

/* 3415 */
struct system_override_args
{
  uint64_t timeout;
  uint64_t flags;
  char flags_r_[];
};

/* 3416 */
struct process_policy_args
{
  int scope;
  char scope_r_[4];
  int action;
  char action_r_[4];
  int policy;
  char policy_r_[4];
  int policy_subtype;
  char policy_subtype_r_[4];
  user_addr_t_0 attrp;
  pid_t target_pid;
  char target_pid_r_[4];
  uint64_t target_threadid;
  char target_threadid_r_[];
};

/* 3417 */
struct proc_info_extended_id_args
{
  int32_t callnum;
  char callnum_r_[4];
  int32_t pid;
  char pid_r_[4];
  uint32_t flavor;
  char flavor_r_[4];
  uint32_t flags;
  char flags_r_[4];
  uint64_t ext_id;
  uint64_t arg;
  user_addr_t_0 buffer;
  int32_t buffersize;
  char buffersize_r_[4];
};

/* 3418 */
struct proc_fileportinfo
{
  uint32_t proc_fileport;
  uint32_t proc_fdtype;
};

/* 3419 */
struct kqueue_info
{
  vinfo_stat kq_stat;
  uint32_t kq_state;
  uint32_t rfu_1;
};

/* 3420 */
struct psem_info
{
  vinfo_stat psem_stat;
  char psem_name[1024];
};

/* 3421 */
struct pipe_info
{
  vinfo_stat pipe_stat;
  uint64_t pipe_handle;
  uint64_t pipe_peerhandle;
  int pipe_status;
  int rfu_1;
};

/* 3422 */
struct pshm_info
{
  vinfo_stat pshm_stat;
  uint64_t pshm_mappaddr;
  char pshm_name[1024];
};

/* 3423 */
struct proc_fileinfo
{
  uint32_t fi_openflags;
  uint32_t fi_status;
  off_t fi_offset;
  int32_t fi_type;
  uint32_t fi_guardflags;
};

/* 3424 */
struct kqfile
{
  kqueue kqf_kqueue;
  kqtailq kqf_queue;
  kqtailq kqf_suppressed;
  selinfo kqf_sel;
};

/* 3425 */
struct vnode_info
{
  vinfo_stat vi_stat;
  int vi_type;
  int vi_pad;
  fsid_t vi_fsid;
};

/* 3426 */
struct vnode_info_path
{
  vnode_info vip_vi;
  char vip_path[1024];
};

/* 3427 */
struct proclist
{
  proc *lh_first;
};

/* 3428 */
struct proc_info_args
{
  int32_t callnum;
  char callnum_r_[4];
  int32_t pid;
  char pid_r_[4];
  uint32_t flavor;
  char flavor_r_[4];
  uint64_t arg;
  user_addr_t_0 buffer;
  int32_t buffersize;
  char buffersize_r_[4];
};

/* 5224 */
typedef __uint16_t nlink_t;

/* 8104 */
typedef __int64_t __darwin_blkcnt_t;

/* 5223 */
typedef __darwin_blkcnt_t blkcnt_t;

/* 8103 */
typedef __int32_t __darwin_blksize_t;

/* 5222 */
typedef __darwin_blksize_t blksize_t;

/* 3429 */
struct stat64
{
  dev_t st_dev;
  mode_t st_mode;
  nlink_t st_nlink;
  __darwin_ino64_t st_ino;
  uid_t st_uid;
  gid_t st_gid;
  dev_t st_rdev;
  timespec st_atimespec;
  timespec st_mtimespec;
  timespec st_ctimespec;
  timespec st_birthtimespec;
  off_t st_size;
  blkcnt_t st_blocks;
  blksize_t st_blksize;
  __uint32_t st_flags;
  __uint32_t st_gen;
  __int32_t st_lspare;
  __int64_t st_qspare[2];
};

/* 3467 */
typedef internal_pshminfo pshm_info_t;

/* 3430 */
struct pshmnode
{
  off_t mapp_addr;
  pshm_info_t *pinfo;
};

/* 3469 */
struct pshm_mobjhead
{
  pshm_mobj *slh_first;
};

/* 3470 */
struct internal_pshminfo
{
  pshminfo pshm_hdr;
  pshm_mobjhead pshm_mobjs;
  struct
  {
    internal_pshminfo *rbe_left;
    internal_pshminfo *rbe_right;
    internal_pshminfo *rbe_parent;
  } pshm_links;
};

/* 3468 */
struct pshm_mobj
{
  void *pshmo_memobject;
  memory_object_size_t pshmo_size;
  struct
  {
    pshm_mobj *sle_next;
  } pshmo_next;
};

/* 3431 */
struct psemnode
{
  pseminfo *pinfo;
};

/* 3432 */
struct proc_fdinfo
{
  int32_t proc_fd;
  uint32_t proc_fdtype;
};

/* 3433 */
struct solist
{
  solist *next;
  socket *so;
};

/* 3456 */
typedef void (*sock_evupcall)(socket_t_0, void *, uint32_t);

/* 3457 */
struct msghdr
{
  void *msg_name;
  socklen_t msg_namelen;
  iovec *msg_iov;
  int msg_iovlen;
  void *msg_control;
  socklen_t msg_controllen;
  int msg_flags;
};

/* 3460 */
struct iovec
{
  void *iov_base;
  size_t iov_len;
};

/* 3458 */
typedef void (*sock_upcall)(socket_t_0, void *, int);

/* 3461 */
struct shm_unlink_args
{
  user_addr_t_0 name;
  char name_r_[];
};

/* 3462 */
struct mmap_args
{
  user_addr_t_0 addr;
  user_size_t len;
  int prot;
  char prot_r_[4];
  int flags;
  char flags_r_[4];
  int fd;
  char fd_r_[4];
  off_t pos;
  char pos_r_[];
};

/* 3463 */
struct shm_open_args
{
  user_addr_t_0 name;
  int oflag;
  char oflag_r_[4];
  int mode;
  char mode_r_[4];
};

/* 3464 */
struct stat
{
  dev_t st_dev;
  ino_t st_ino;
  mode_t st_mode;
  nlink_t st_nlink;
  uid_t st_uid;
  gid_t st_gid;
  dev_t st_rdev;
  timespec st_atimespec;
  timespec st_mtimespec;
  timespec st_ctimespec;
  off_t st_size;
  blkcnt_t st_blocks;
  blksize_t st_blksize;
  __uint32_t st_flags;
  __uint32_t st_gen;
  __int32_t st_lspare;
  __int64_t st_qspare[2];
};

/* 3465 */
typedef pshm_mobj pshm_mobj_t;

/* 3466 */
typedef pshmnode pshmnode_t;

/* 3471 */
struct sem_post_args
{
  user_addr_t_0 sem;
  char sem_r_[];
};

/* 3472 */
struct sem_trywait_args
{
  user_addr_t_0 sem;
  char sem_r_[];
};

/* 3473 */
struct sem_wait_args
{
  user_addr_t_0 sem;
  char sem_r_[];
};

/* 3474 */
struct sem_close_args
{
  user_addr_t_0 sem;
  char sem_r_[];
};

/* 3475 */
struct sem_unlink_args
{
  user_addr_t_0 name;
  char name_r_[];
};

/* 3476 */
struct sem_open_args
{
  user_addr_t_0 name;
  int oflag;
  char oflag_r_[4];
  int mode;
  char mode_r_[4];
  int value;
  char value_r_[4];
};

/* 3477 */
struct __attribute__((aligned(8))) psemname
{
  char *psem_nameptr;
  size_t psem_namelen;
  u_int32_t psem_hash;
};

/* 3478 */
struct sem_wait_nocancel_args
{
  user_addr_t_0 sem;
  char sem_r_[];
};

/* 3479 */
struct psemcache
{
  struct
  {
    psemcache *le_next;
    psemcache **le_prev;
  } psem_hash;
  pseminfo *pseminfo;
  size_t psem_nlen;
  char psem_name[32];
};

/* 3480 */
struct psemhashhead
{
  psemcache *lh_first;
};

/* 7017 */
typedef uint64_t tt_entry_t;

/* 7018 */
typedef uint64_t vm_map_address_t;

/* 3481 */
struct __attribute__((aligned(8))) pmap
{
  tt_entry_t *tte;
  pmap_paddr_t ttep;
  vm_map_address_t min;
  vm_map_address_t max;
  const page_table_attr *pmap_pt_attr;
  ledger_t ledger;
  lck_rw_t_0 rwlock;
  queue_chain_t_0 pmaps;
  tt_entry_t *tt_entry_free;
  pmap *nested_pmap;
  vm_map_address_t nested_region_addr;
  vm_map_offset_t nested_region_size;
  vm_map_offset_t nested_region_true_start;
  vm_map_offset_t nested_region_true_end;
  unsigned int *nested_region_asid_bitmap;
  unsigned int nested_region_asid_bitmap_size;
  int32_t ref_count;
  uint32_t nested_no_bounds_refcnt;
  uint16_t hw_asid;
  uint8_t sw_asid;
  bool pmap_vm_map_cs_enforced;
  bool is_x86_64;
  unsigned int lpai1;
  unsigned int lpai2;
  bool is_rosetta;
  bool nx_enabled;
  bool is_64bit;
  bool nested_has_no_bounds_ref;
  bool nested_bounds_set;
  bool disable_jop;
  uint8_t type;
};

/* 5824 */
struct page_table_attr
{
  const page_table_level_info *const pta_level_info;
  const page_table_ops *const pta_ops;
  const uintptr_t ap_ro;
  const uintptr_t ap_rw;
  const uintptr_t ap_rona;
  const uintptr_t ap_rwna;
  const uintptr_t ap_xn;
  const uintptr_t ap_x;
  const unsigned int pta_root_level;
  const unsigned int pta_commpage_level;
  const unsigned int pta_max_level;
  const uint64_t pta_tcr_value;
  const uint64_t pta_page_size;
  const uint64_t pta_page_shift;
};

/* 5823 */
struct page_table_level_info
{
  const uint64_t size;
  const uint64_t offmask;
  const uint64_t shift;
  const uint64_t index_mask;
  const uint64_t valid_mask;
  const uint64_t type_mask;
  const uint64_t type_block;
};

/* 5737 */
typedef pmap *pmap_t;

/* 6836 */
typedef uint64_t pt_entry_t;

/* 5822 */
struct page_table_ops
{
  bool (*alloc_id)(pmap_t);
  void (*free_id)(pmap_t);
  void (*flush_tlb_region_async)(vm_offset_t, size_t, pmap_t, bool);
  void (*flush_tlb_async)(pmap_t);
  pt_entry_t (*wimg_to_pte)(unsigned int, pmap_paddr_t);
};

/* 3483 */
struct section
{
  char sectname[16];
  char segname[16];
  uint32_t addr;
  uint32_t size;
  uint32_t offset;
  uint32_t align;
  uint32_t reloff;
  uint32_t nreloc;
  uint32_t flags;
  uint32_t reserved1;
  uint32_t reserved2;
};

/* 3484 */
struct fat_header
{
  uint32_t magic;
  uint32_t nfat_arch;
};

/* 3485 */
union macho_vnode_header
{
  mach_header mach_header;
  fat_header fat_header;
  char __pad[512];
};

/* 3486 */
struct build_version_command_0
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint32_t platform;
  uint32_t minos;
  uint32_t sdk;
  uint32_t ntools;
};

/* 3487 */
struct version_min_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint32_t version;
  uint32_t sdk;
};

/* 3488 */
struct encryption_info_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint32_t cryptoff;
  uint32_t cryptsize;
  uint32_t cryptid;
};

/* 3489 */
struct dylinker_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  lc_str name;
};

/* 3490 */
struct entry_point_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  uint64_t entryoff;
  uint64_t stacksize;
};

/* 3491 */
struct thread_command
{
  uint32_t cmd;
  uint32_t cmdsize;
};

/* 3492 */
struct macho_data
{
  nameidata __nid;
  macho_vnode_header __header;
};

/* 3493 */
typedef _load_result load_result_t;

/* 9241 */
struct _load_result
{
  user_addr_t_0 mach_header;
  user_addr_t_0 entry_point;
  user_addr_t_0 user_stack;
  mach_vm_size_t_0 user_stack_size;
  user_addr_t_0 user_stack_alloc;
  mach_vm_size_t_0 user_stack_alloc_size;
  mach_vm_address_t_0 all_image_info_addr;
  mach_vm_size_t_0 all_image_info_size;
  int thread_count;
  __attribute__((aligned(8))) unsigned int csflags;
  unsigned __int8 uuid[16];
  mach_vm_address_t_0 min_vm_addr;
  mach_vm_address_t_0 max_vm_addr;
  unsigned int platform_binary;
  off_t cs_end_offset;
  void *threadstate;
  size_t threadstate_sz;
  uint32_t ip_platform;
  uint32_t lr_min_sdk;
  uint32_t lr_sdk;
  user_addr_t_0 dynlinker_mach_header;
  user_addr_t_0 dynlinker_max_vm_addr;
  int dynlinker_fd;
  fileproc *dynlinker_fp;
};

/* 3494 */
struct fat_arch
{
  cpu_type_t cputype;
  cpu_subtype_t_0 cpusubtype;
  uint32_t offset;
  uint32_t size;
  uint32_t align;
};

/* 3495 */
struct msgctl_args
{
  int msqid;
  char msqid_r_[4];
  int cmd;
  char cmd_r_[4];
  user_addr_t_0 buf;
  char buf_r_[];
};

/* 3496 */
struct msgget_args
{
  key_t key;
  char key_r_[4];
  int msgflg;
  char msgflg_r_[4];
};

/* 3497 */
struct msgsnd_args
{
  int msqid;
  char msqid_r_[4];
  user_addr_t_0 msgp;
  user_size_t msgsz;
  int msgflg;
  char msgflg_r_[4];
};

/* 3498 */
struct msgrcv_args
{
  int msqid;
  char msqid_r_[4];
  user_addr_t_0 msgp;
  user_size_t msgsz;
  user_long_t msgtyp;
  int msgflg;
  char msgflg_r_[4];
};

/* 3499 */
struct msgsys_args
{
  u_int which;
  char which_r_[4];
  int a2;
  char a2_r_[4];
  int a3;
  char a3_r_[4];
  int a4;
  char a4_r_[4];
  int a5;
  char a5_r_[4];
};

/* 3500 */
struct user_IPCS_command
{
  int ipcs_magic;
  int ipcs_op;
  int ipcs_cursor;
  int ipcs_datalen;
  user_addr_t_0 ipcs_data;
};

/* 3501 */
struct user32_IPCS_command
{
  int ipcs_magic;
  int ipcs_op;
  int ipcs_cursor;
  int ipcs_datalen;
  user32_addr_t ipcs_data;
};

/* 3502 */
typedef user64_ulong_t user64_msglen_t;

/* 3503 */
typedef user64_ulong_t user64_msgqnum_t;

/* 3504 */
struct __attribute__((packed)) __attribute__((aligned(4))) user64_msqid_ds
{
  ipc_perm msg_perm;
  __int32_t msg_first;
  __int32_t msg_last;
  user64_msglen_t msg_cbytes;
  user64_msgqnum_t msg_qnum;
  user64_msglen_t msg_qbytes;
  pid_t msg_lspid;
  pid_t msg_lrpid;
  user64_time_t msg_stime;
  __int32_t msg_pad1;
  user64_time_t msg_rtime;
  __int32_t msg_pad2;
  user64_time_t msg_ctime;
  __int32_t msg_pad3;
  __int32_t msg_pad4[4];
};

/* 3505 */
typedef user32_ulong_t user32_msglen_t;

/* 3506 */
typedef user32_ulong_t user32_msgqnum_t;

/* 3507 */
struct user32_msqid_ds
{
  ipc_perm msg_perm;
  __int32_t msg_first;
  __int32_t msg_last;
  user32_msglen_t msg_cbytes;
  user32_msgqnum_t msg_qnum;
  user32_msglen_t msg_qbytes;
  pid_t msg_lspid;
  pid_t msg_lrpid;
  user32_time_t msg_stime;
  __int32_t msg_pad1;
  user32_time_t msg_rtime;
  __int32_t msg_pad2;
  user32_time_t msg_ctime;
  __int32_t msg_pad3;
  __int32_t msg_pad4[4];
};

/* 3508 */
struct msgrcv_nocancel_args
{
  int msqid;
  char msqid_r_[4];
  user_addr_t_0 msgp;
  user_size_t msgsz;
  user_long_t msgtyp;
  int msgflg;
  char msgflg_r_[4];
};

/* 3509 */
struct msgsnd_nocancel_args
{
  int msqid;
  char msqid_r_[4];
  user_addr_t_0 msgp;
  user_size_t msgsz;
  int msgflg;
  char msgflg_r_[4];
};

/* 3510 */
struct msgmap
{
  short next;
};

/* 3511 */
struct semctl_args
{
  int semid;
  char semid_r_[4];
  int semnum;
  char semnum_r_[4];
  int cmd;
  char cmd_r_[4];
  user_addr_t_0 arg;
  char arg_r_[];
};

/* 3512 */
struct semget_args
{
  key_t key;
  char key_r_[4];
  int nsems;
  char nsems_r_[4];
  int semflg;
  char semflg_r_[4];
};

/* 3513 */
struct sembuf
{
  unsigned __int16 sem_num;
  short sem_op;
  short sem_flg;
};

/* 3514 */
struct semop_args
{
  int semid;
  char semid_r_[4];
  user_addr_t_0 sops;
  int nsops;
  char nsops_r_[4];
};

/* 3515 */
struct semsys_args
{
  u_int which;
  char which_r_[4];
  int a2;
  char a2_r_[4];
  int a3;
  char a3_r_[4];
  int a4;
  char a4_r_[4];
  int a5;
  char a5_r_[4];
};

/* 3516 */
struct user64_semid_ds
{
  ipc_perm sem_perm;
  int32_t sem_base;
  unsigned __int16 sem_nsems;
  user64_time_t sem_otime;
  int32_t sem_pad1;
  __attribute__((packed)) __attribute__((aligned(1))) user64_time_t sem_ctime;
  int32_t sem_pad2;
  int32_t sem_pad3[4];
};

/* 3517 */
struct user32_semid_ds
{
  ipc_perm sem_perm;
  int32_t sem_base;
  unsigned __int16 sem_nsems;
  user32_time_t sem_otime;
  int32_t sem_pad1;
  user32_time_t sem_ctime;
  int32_t sem_pad2;
  int32_t sem_pad3[4];
};

/* 3518 */
struct undo
{
  short une_adjval;
  short une_num;
  int une_id;
  undo *une_next;
};

/* 3519 */
struct sem_undo
{
  int un_next_idx;
  proc *un_proc;
  short un_cnt;
  undo *un_ent;
};

/* 3520 */
struct shmsys_args
{
  u_int which;
  char which_r_[4];
  int a2;
  char a2_r_[4];
  int a3;
  char a3_r_[4];
  int a4;
  char a4_r_[4];
};

/* 3521 */
struct shmctl_args
{
  int shmid;
  char shmid_r_[4];
  int cmd;
  char cmd_r_[4];
  user_addr_t_0 buf;
  char buf_r_[];
};

/* 3522 */
struct shmat_args
{
  int shmid;
  char shmid_r_[4];
  user_addr_t_0 shmaddr;
  int shmflg;
  char shmflg_r_[4];
};

/* 3523 */
struct shmdt_args
{
  user_addr_t_0 shmaddr;
  char shmaddr_r_[];
};

/* 3524 */
struct shmget_args
{
  key_t key;
  char key_r_[4];
  user_size_t size;
  int shmflg;
  char shmflg_r_[4];
};

/* 3525 */
struct user32_shmid_ds
{
  ipc_perm shm_perm;
  uint32_t shm_segsz;
  pid_t shm_lpid;
  pid_t shm_cpid;
  short shm_nattch;
  uint32_t shm_atime;
  uint32_t shm_dtime;
  uint32_t shm_ctime;
  user32_addr_t shm_internal;
};

/* 3526 */
struct shm_handle
{
  void *shm_object;
  memory_object_size_t shm_handle_size;
  shm_handle *shm_handle_next;
};

/* 3527 */
struct __attribute__((aligned(8))) shmmap_state
{
  mach_vm_address_t_0 va;
  int shmid;
};

/* 3528 */
struct xsockbuf
{
  u_int32_t sb_cc;
  u_int32_t sb_hiwat;
  u_int32_t sb_mbcnt;
  u_int32_t sb_mbmax;
  int32_t sb_lowat;
  short sb_flags;
  short sb_timeo;
};

/* 3529 */
struct xsocket
{
  u_int32_t xso_len;
  u_int32_t xso_so;
  short so_type;
  short so_options;
  short so_linger;
  short so_state;
  u_int32_t so_pcb;
  int xso_protocol;
  int xso_family;
  short so_qlen;
  short so_incqlen;
  short so_qlimit;
  short so_timeo;
  u_short so_error;
  pid_t so_pgid;
  u_int32_t so_oobmark;
  xsockbuf so_rcv;
  xsockbuf so_snd;
  uid_t so_uid;
};

/* 3530 */
struct sockaddr_vm
{
  __uint8_t svm_len;
  sa_family_t svm_family;
  __uint16_t svm_reserved1;
  __uint32_t svm_port;
  __uint32_t svm_cid;
};

/* 3533 */
struct __attribute__((packed)) __attribute__((aligned(4))) xsocket64
{
  u_int32_t xso_len;
  u_int64_t xso_so;
  short so_type;
  short so_options;
  short so_linger;
  short so_state;
  u_int64_t so_pcb;
  int xso_protocol;
  int xso_family;
  short so_qlen;
  short so_incqlen;
  short so_qlimit;
  short so_timeo;
  u_short so_error;
  __attribute__((aligned(4))) pid_t so_pgid;
  u_int32_t so_oobmark;
  xsockbuf so_rcv;
  xsockbuf so_snd;
  uid_t so_uid;
};

/* 3534 */
struct xunpcb64_list_entry
{
  u_int64_t le_next;
  u_int64_t le_prev;
};

/* 3535 */
struct _unpcb_list_entry
{
  u_int32_t le_next;
  u_int32_t le_prev;
};

/* 3536 */
struct unpcb_compat
{
  _unpcb_list_entry unp_link;
  u_int32_t unp_socket;
  u_int32_t unp_vnode;
  u_int32_t unp_ino;
  u_int32_t unp_conn;
  u_int32_t unp_refs;
  _unpcb_list_entry unp_reflink;
  u_int32_t unp_addr;
  int unp_cc;
  int unp_mbcnt;
  unp_gen_t unp_gencnt;
};

/* 3537 */
struct xsockstat_n
{
  u_int32_t xst_len;
  u_int32_t xst_kind;
  data_stats xst_tc_stats[4];
};

/* 3538 */
struct xsockbuf_n
{
  u_int32_t xsb_len;
  u_int32_t xsb_kind;
  u_int32_t sb_cc;
  u_int32_t sb_hiwat;
  u_int32_t sb_mbcnt;
  u_int32_t sb_mbmax;
  int32_t sb_lowat;
  short sb_flags;
  short sb_timeo;
};

/* 3539 */
struct xsocket_n
{
  u_int32_t xso_len;
  u_int32_t xso_kind;
  u_int64_t xso_so;
  short so_type;
  u_int32_t so_options;
  short so_linger;
  short so_state;
  __attribute__((packed)) __attribute__((aligned(1))) u_int64_t so_pcb;
  int xso_protocol;
  int xso_family;
  short so_qlen;
  short so_incqlen;
  short so_qlimit;
  short so_timeo;
  u_short so_error;
  pid_t so_pgid;
  u_int32_t so_oobmark;
  uid_t so_uid;
  pid_t so_last_pid;
  pid_t so_e_pid;
  __attribute__((packed)) __attribute__((aligned(1))) so_gen_t so_gencnt;
  u_int32_t so_flags;
  u_int32_t so_flags1;
  int32_t so_usecount;
  int32_t so_retaincnt;
  u_int32_t xso_filter_flags;
};

/* 3540 */
struct __attribute__((packed)) __attribute__((aligned(4))) xunpcb_n
{
  u_int32_t xunp_len;
  u_int32_t xunp_kind;
  u_int64_t xunp_unpp;
  u_int64_t xunp_vnode;
  u_int64_t xunp_ino;
  u_int64_t xunp_conn;
  u_int64_t xunp_refs;
  u_int64_t xunp_reflink;
  int xunp_cc;
  int xunp_mbcnt;
  int xunp_flags;
  unp_gen_t xunp_gencnt;
  union
  {
    sockaddr_un xuu_addr;
    char xu_dummy1[256];
  } xu_au;
  union
  {
    sockaddr_un xuu_caddr;
    char xu_dummy2[256];
  } xu_cau;
};

/* 3541 */
struct sendfile_args
{
  int fd;
  char fd_r_[4];
  int s;
  char s_r_[4];
  off_t offset;
  user_addr_t_0 nbytes;
  user_addr_t_0 hdtr;
  int flags;
  char flags_r_[4];
};

/* 3542 */
struct getpeername_args
{
  int fdes;
  char fdes_r_[4];
  user_addr_t_0 asa;
  user_addr_t_0 alen;
  char alen_r_[];
};

/* 3543 */
struct getsockname_args
{
  int fdes;
  char fdes_r_[4];
  user_addr_t_0 asa;
  user_addr_t_0 alen;
  char alen_r_[];
};

/* 3544 */
struct getsockopt_args
{
  int s;
  char s_r_[4];
  int level;
  char level_r_[4];
  int name;
  char name_r_[4];
  user_addr_t_0 val;
  user_addr_t_0 avalsize;
  char avalsize_r_[];
};

/* 3545 */
struct setsockopt_args
{
  int s;
  char s_r_[4];
  int level;
  char level_r_[4];
  int name;
  char name_r_[4];
  user_addr_t_0 val;
  socklen_t valsize;
  char valsize_r_[4];
};

/* 3546 */
struct shutdown_args
{
  int s;
  char s_r_[4];
  int how;
  char how_r_[4];
};

/* 3547 */
struct recvmsg_x_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 msgp;
  u_int cnt;
  char cnt_r_[4];
  int flags;
  char flags_r_[4];
};

/* 3548 */
struct recvmsg_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 msg;
  int flags;
  char flags_r_[4];
};

/* 3549 */
struct recvfrom_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 buf;
  user_size_t len;
  int flags;
  char flags_r_[4];
  user_addr_t_0 from;
  user_addr_t_0 fromlenaddr;
  char fromlenaddr_r_[];
};

/* 3550 */
struct sendmsg_x_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 msgp;
  u_int cnt;
  char cnt_r_[4];
  int flags;
  char flags_r_[4];
};

/* 3551 */
struct sendmsg_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 msg;
  int flags;
  char flags_r_[4];
};

/* 3552 */
struct sendto_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 buf;
  user_size_t len;
  int flags;
  char flags_r_[4];
  user_addr_t_0 to;
  socklen_t tolen;
  char tolen_r_[4];
};

/* 3553 */
struct socketpair_args
{
  int domain;
  char domain_r_[4];
  int type;
  char type_r_[4];
  int protocol;
  char protocol_r_[4];
  user_addr_t_0 rsv;
  char rsv_r_[];
};

/* 3554 */
struct peeloff_args
{
  int s;
  char s_r_[4];
  sae_associd_t aid;
  char aid_r_[4];
};

/* 3555 */
struct connect_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 name;
  socklen_t namelen;
  char namelen_r_[4];
};

/* 3556 */
struct accept_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 name;
  user_addr_t_0 anamelen;
  char anamelen_r_[];
};

/* 3557 */
struct listen_args
{
  int s;
  char s_r_[4];
  int backlog;
  char backlog_r_[4];
};

/* 3558 */
struct bind_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 name;
  socklen_t namelen;
  char namelen_r_[4];
};

/* 3559 */
struct socket_delegate_args
{
  int domain;
  char domain_r_[4];
  int type;
  char type_r_[4];
  int protocol;
  char protocol_r_[4];
  pid_t epid;
  char epid_r_[4];
};

/* 3560 */
struct socket_args
{
  int domain;
  char domain_r_[4];
  int type;
  char type_r_[4];
  int protocol;
  char protocol_r_[4];
};

/* 3561 */
typedef mbuf **mbuf_ref_ref_t;

/* 3562 */
typedef int32_t *int32_ref_t;

/* 3563 */
typedef setsockopt_args *setsockopt_args_ref_t;

/* 3564 */
typedef user_msghdr *user_msghdr_ref_t;

/* 7887 */
struct user_msghdr
{
  user_addr_t_0 msg_name;
  socklen_t msg_namelen;
  user_addr_t_0 msg_iov;
  int msg_iovlen;
  user_addr_t_0 msg_control;
  socklen_t msg_controllen;
  int msg_flags;
};

/* 3565 */
struct disconnectx_args
{
  int s;
  char s_r_[4];
  sae_associd_t aid;
  char aid_r_[4];
  sae_connid_t cid;
  char cid_r_[4];
};

/* 3566 */
struct user_iovec
{
  user_addr_t_0 iov_base;
  user_size_t iov_len;
};

/* 3567 */
struct connectx_args
{
  int socket;
  char socket_r_[4];
  user_addr_t_0 endpoints;
  sae_associd_t associd;
  char associd_r_[4];
  unsigned int flags;
  char flags_r_[4];
  user_addr_t_0 iov;
  unsigned int iovcnt;
  char iovcnt_r_[4];
  user_addr_t_0 len;
  user_addr_t_0 connid;
  char connid_r_[];
};

/* 3568 */
typedef int *int_ref_t;

/* 3569 */
typedef connectx_args *connectx_args_ref_t;

/* 3570 */
typedef struct proc *proc_ref_t;

/* 3571 */
typedef sockaddr_storage *sockaddr_storage_ref_t;

/* 3572 */
typedef sockaddr **sockaddr_ref_ref_t;

/* 3573 */
struct user32_msghdr_x
{
  user32_addr_t msg_name;
  socklen_t msg_namelen;
  user32_addr_t msg_iov;
  int msg_iovlen;
  user32_addr_t msg_control;
  socklen_t msg_controllen;
  int msg_flags;
  user32_size_t msg_datalen;
};

/* 3574 */
struct user64_msghdr_x
{
  user64_addr_t msg_name;
  socklen_t msg_namelen;
  user64_addr_t msg_iov;
  int msg_iovlen;
  user64_addr_t msg_control;
  socklen_t msg_controllen;
  int msg_flags;
  user64_size_t msg_datalen;
};

/* 3575 */
struct user32_timeval
{
  user32_time_t tv_sec;
  __int32_t tv_usec;
};

/* 3576 */
typedef socket *socket_ref_t;

/* 3577 */
typedef socklen_t *socklen_ref_t;

/* 3578 */
typedef mbuf *mbuf_ref_t;

/* 3579 */
struct __attribute__((aligned(8))) user64_timeval
{
  user64_time_t tv_sec;
  __int32_t tv_usec;
};

/* 3580 */
struct recvmsg_nocancel_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 msg;
  int flags;
  char flags_r_[4];
};

/* 3581 */
struct recvfrom_nocancel_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 buf;
  user_size_t len;
  int flags;
  char flags_r_[4];
  user_addr_t_0 from;
  user_addr_t_0 fromlenaddr;
  char fromlenaddr_r_[];
};

/* 3582 */
struct user_msghdr_x
{
  user_addr_t_0 msg_name;
  socklen_t msg_namelen;
  user_addr_t_0 msg_iov;
  int msg_iovlen;
  user_addr_t_0 msg_control;
  socklen_t msg_controllen;
  int msg_flags;
  size_t msg_datalen;
};

/* 3583 */
typedef uio *uio_ref_t;

/* 3584 */
struct sendmsg_nocancel_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 msg;
  int flags;
  char flags_r_[4];
};

/* 3585 */
struct sendto_nocancel_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 buf;
  user_size_t len;
  int flags;
  char flags_r_[4];
  user_addr_t_0 to;
  socklen_t tolen;
  char tolen_r_[4];
};

/* 3586 */
struct connect_nocancel_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 name;
  socklen_t namelen;
  char namelen_r_[4];
};

/* 3587 */
struct accept_nocancel_args
{
  int s;
  char s_r_[4];
  user_addr_t_0 name;
  user_addr_t_0 anamelen;
  char anamelen_r_[];
};

/* 3588 */
struct netpolicy_event_data
{
  __uint64_t eupid;
  __uint64_t epid;
  uuid_t_1 euuid;
};

/* 3598 */
struct kev_socket_event_data
{
  sockaddr_in_4_6 kev_sockname;
  sockaddr_in_4_6 kev_peername;
};

/* 3608 */
struct m_taghdr
{
  u_int64_t refcnt;
};

/* 3609 */
struct net_api_stats
{
  int64_t nas_iflt_attach_count;
  int64_t nas_iflt_attach_os_count;
  int64_t nas_iflt_attach_total;
  int64_t nas_iflt_attach_os_total;
  int64_t nas_ipf_add_count;
  int64_t nas_ipf_add_os_count;
  int64_t nas_ipf_add_total;
  int64_t nas_ipf_add_os_total;
  int64_t nas_sfltr_register_count;
  int64_t nas_sfltr_register_os_count;
  int64_t nas_sfltr_register_total;
  int64_t nas_sfltr_register_os_total;
  int64_t nas_socket_alloc_total;
  int64_t nas_socket_in_kernel_total;
  int64_t nas_socket_in_kernel_os_total;
  int64_t nas_socket_necp_clientuuid_total;
  int64_t nas_socket_domain_local_total;
  int64_t nas_socket_domain_route_total;
  int64_t nas_socket_domain_inet_total;
  int64_t nas_socket_domain_inet6_total;
  int64_t nas_socket_domain_system_total;
  int64_t nas_socket_domain_multipath_total;
  int64_t nas_socket_domain_key_total;
  int64_t nas_socket_domain_ndrv_total;
  int64_t nas_socket_domain_other_total;
  int64_t nas_socket_inet_stream_total;
  int64_t nas_socket_inet_dgram_total;
  int64_t nas_socket_inet_dgram_connected;
  int64_t nas_socket_inet_dgram_dns;
  int64_t nas_socket_inet_dgram_no_data;
  int64_t nas_socket_inet6_stream_total;
  int64_t nas_socket_inet6_dgram_total;
  int64_t nas_socket_inet6_dgram_connected;
  int64_t nas_socket_inet6_dgram_dns;
  int64_t nas_socket_inet6_dgram_no_data;
  int64_t nas_socket_mcast_join_total;
  int64_t nas_socket_mcast_join_os_total;
  int64_t nas_sock_inet6_stream_exthdr_in;
  int64_t nas_sock_inet6_stream_exthdr_out;
  int64_t nas_sock_inet6_dgram_exthdr_in;
  int64_t nas_sock_inet6_dgram_exthdr_out;
  int64_t nas_nx_flow_inet_stream_total;
  int64_t nas_nx_flow_inet_dgram_total;
  int64_t nas_nx_flow_inet6_stream_total;
  int64_t nas_nx_flow_inet6_dgram_total;
  int64_t nas_ifnet_alloc_count;
  int64_t nas_ifnet_alloc_total;
  int64_t nas_ifnet_alloc_os_count;
  int64_t nas_ifnet_alloc_os_total;
  int64_t nas_pf_addrule_total;
  int64_t nas_pf_addrule_os;
  int64_t nas_vmnet_total;
};

/* 3610 */
struct nstat_sysinfo_net_api_stats
{
  u_int32_t report_interval;
  u_int32_t _padding;
  net_api_stats net_api_stats;
};

/* 3611 */
struct nstat_sysinfo_lim_stats
{
  u_int8_t ifnet_signature[24];
  u_int32_t ifnet_siglen;
  u_int32_t ifnet_type;
  if_lim_perf_stat lim_stat;
};

/* 3612 */
struct nstat_sysinfo_ifnet_ecn_stats
{
  u_int32_t ifnet_proto;
  u_int32_t ifnet_type;
  if_tcp_ecn_stat ecn_stat;
};

/* 3613 */
struct nstat_sysinfo_tcp_stats
{
  u_int32_t ipv4_avgrtt;
  u_int32_t ipv6_avgrtt;
  u_int32_t send_plr;
  u_int32_t recv_plr;
  u_int32_t send_tlrto_rate;
  u_int32_t send_reorder_rate;
  u_int32_t connection_attempts;
  u_int32_t connection_accepts;
  u_int32_t ecn_client_enabled;
  u_int32_t ecn_server_enabled;
  u_int32_t ecn_client_setup;
  u_int32_t ecn_server_setup;
  u_int32_t ecn_client_success;
  u_int32_t ecn_server_success;
  u_int32_t ecn_not_supported;
  u_int32_t ecn_lost_syn;
  u_int32_t ecn_lost_synack;
  u_int32_t ecn_recv_ce;
  u_int32_t ecn_recv_ece;
  u_int32_t ecn_sent_ece;
  u_int32_t ecn_conn_recv_ce;
  u_int32_t ecn_conn_recv_ece;
  u_int32_t ecn_conn_plnoce;
  u_int32_t ecn_conn_pl_ce;
  u_int32_t ecn_conn_nopl_ce;
  u_int32_t ecn_fallback_synloss;
  u_int32_t ecn_fallback_reorder;
  u_int32_t ecn_fallback_ce;
  u_int32_t tfo_syn_data_rcv;
  u_int32_t tfo_cookie_req_rcv;
  u_int32_t tfo_cookie_sent;
  u_int32_t tfo_cookie_invalid;
  u_int32_t tfo_cookie_req;
  u_int32_t tfo_cookie_rcv;
  u_int32_t tfo_syn_data_sent;
  u_int32_t tfo_syn_data_acked;
  u_int32_t tfo_syn_loss;
  u_int32_t tfo_blackhole;
  u_int32_t tfo_cookie_wrong;
  u_int32_t tfo_no_cookie_rcv;
  u_int32_t tfo_heuristics_disable;
  u_int32_t tfo_sndblackhole;
  u_int32_t mptcp_handover_attempt;
  u_int32_t mptcp_interactive_attempt;
  u_int32_t mptcp_aggregate_attempt;
  u_int32_t mptcp_fp_handover_attempt;
  u_int32_t mptcp_fp_interactive_attempt;
  u_int32_t mptcp_fp_aggregate_attempt;
  u_int32_t mptcp_heuristic_fallback;
  u_int32_t mptcp_fp_heuristic_fallback;
  u_int32_t mptcp_handover_success_wifi;
  u_int32_t mptcp_handover_success_cell;
  u_int32_t mptcp_interactive_success;
  u_int32_t mptcp_aggregate_success;
  u_int32_t mptcp_fp_handover_success_wifi;
  u_int32_t mptcp_fp_handover_success_cell;
  u_int32_t mptcp_fp_interactive_success;
  u_int32_t mptcp_fp_aggregate_success;
  u_int32_t mptcp_handover_cell_from_wifi;
  u_int32_t mptcp_handover_wifi_from_cell;
  u_int32_t mptcp_interactive_cell_from_wifi;
  u_int32_t mptcp_back_to_wifi;
  u_int64_t mptcp_handover_cell_bytes;
  u_int64_t mptcp_interactive_cell_bytes;
  u_int64_t mptcp_aggregate_cell_bytes;
  u_int64_t mptcp_handover_all_bytes;
  u_int64_t mptcp_interactive_all_bytes;
  u_int64_t mptcp_aggregate_all_bytes;
  u_int32_t mptcp_wifi_proxy;
  u_int32_t mptcp_cell_proxy;
  u_int32_t mptcp_triggered_cell;
  u_int32_t _padding;
};

/* 3614 */
struct nstat_sysinfo_mbuf_stats
{
  u_int32_t total_256b;
  u_int32_t total_2kb;
  u_int32_t total_4kb;
  u_int32_t total_16kb;
  u_int32_t sbmb_total;
  u_int32_t sb_atmbuflimit;
  u_int32_t draincnt;
  u_int32_t memreleased;
  u_int32_t sbmb_floor;
};

/* 3615 */
union m16kcluster
{
  m16kcluster *m16kcl_next;
  char m16kcl_buf[16384];
};

/* 3616 */
union mbigcluster
{
  mbigcluster *mbc_next;
  char mbc_buf[4096];
};

/* 3617 */
union mcluster
{
  mcluster *mcl_next;
  char mcl_buf[2048];
};

/* 3618 */
struct mcl_scratch_audit_t
{
  thread *msa_thread;
  thread *msa_pthread;
  uint32_t msa_tstamp;
  uint32_t msa_ptstamp;
  uint16_t msa_depth;
  uint16_t msa_pdepth;
  void *msa_stack[16];
  void *msa_pstack[16];
};

/* 3619 */
struct mcl_saved_contents_t
{
  u_int8_t sc_mbuf[216];
  mcl_scratch_audit_t sc_scratch;
};

/* 3620 */
struct __attribute__((aligned(4))) mbuf_watchdog_defunct_args
{
  proc *top_app;
  uint32_t top_app_space_used;
  bool non_blocking;
};

/* 3643 */
typedef mcache_obj mcache_obj_t;

/* 3621 */
struct mallocation
{
  mcache_obj_t *element;
  u_int32_t trace_index;
  u_int32_t count;
  u_int64_t hitcount;
};

/* 7901 */
struct mcache_obj
{
  mcache_obj *obj_next;
};

/* 3622 */
struct mtracelarge
{
  uint64_t size;
  uint64_t depth;
  uintptr_t addr[16];
};

/* 3623 */
typedef mleak_trace_stat mleak_trace_stat_t;

/* 7894 */
struct mleak_trace_stat
{
  u_int64_t mltr_collisions;
  u_int64_t mltr_hitcount;
  u_int64_t mltr_allocs;
  u_int64_t mltr_depth;
  u_int64_t mltr_addr[16];
};

/* 3624 */
typedef mleak_stat mleak_stat_t;

/* 7895 */
struct mleak_stat
{
  u_int32_t ml_isaddr64;
  u_int32_t ml_cnt;
  mleak_trace_stat_t ml_trace[1];
};

/* 3625 */
struct mtrace
{
  u_int64_t collisions;
  u_int64_t hitcount;
  u_int64_t allocs;
  u_int64_t depth;
  uintptr_t addr[16];
};

/* 3626 */
struct mbtypes
{
  int mt_type;
  const char *mt_name;
};

/* 3627 */
struct mcl_slhead
{
  mcl_slab *tqh_first;
  mcl_slab **tqh_last;
};

/* 7896 */
struct mcl_slab
{
  mcl_slab *sl_next;
  u_int8_t sl_class;
  int8_t sl_refcnt;
  int8_t sl_chunks;
  u_int16_t sl_flags;
  u_int16_t sl_len;
  void *sl_base;
  void *sl_head;
  struct
  {
    mcl_slab *tqe_next;
    mcl_slab **tqe_prev;
  } sl_link;
};

/* 3628 */
enum mbuf_class_t : __int32
{
  MC_MBUF = 0x0,
  MC_CL = 0x1,
  MC_BIGCL = 0x2,
  MC_16KCL = 0x3,
  MC_MBUF_CL = 0x4,
  MC_MBUF_BIGCL = 0x5,
  MC_MBUF_16KCL = 0x6,
};

/* 3649 */
typedef mcache mcache_t;

/* 3632 */
typedef mb_class_stat mb_class_stat_t;

/* 3629 */
struct mbuf_table_t
{
  mbuf_class_t mtbl_class;
  mcache_t *mtbl_cache;
  mcl_slhead mtbl_slablist;
  mcache_obj_t *mtbl_cobjlist;
  mb_class_stat_t *mtbl_stats;
  u_int32_t mtbl_maxsize;
  int mtbl_minlimit;
  int mtbl_maxlimit;
  u_int32_t mtbl_wantpurge;
  uint32_t mtbl_avgtotal;
  u_int32_t mtbl_expand;
};

/* 3648 */
typedef unsigned int (*mcache_allocfn_t)(void *, mcache_obj_t ***, unsigned int, int);

/* 3647 */
typedef void (*mcache_freefn_t)(void *, mcache_obj_t *, boolean_t);

/* 3646 */
typedef void (*mcache_auditfn_t)(void *, mcache_obj_t *, boolean_t);

/* 3645 */
typedef void (*mcache_logfn_t)(u_int32_t, mcache_obj_t *, boolean_t);

/* 3740 */
typedef void (*mcache_notifyfn_t)(void *, u_int32_t);

/* 3642 */
typedef mcache_bkttype mcache_bkttype_t;

/* 3641 */
typedef mcache_bkt mcache_bkt_t;

/* 7900 */
struct mcache_bktlist
{
  mcache_bkt_t *bl_list;
  u_int32_t bl_total;
  u_int32_t bl_min;
  u_int32_t bl_reaplimit;
  u_int64_t bl_alloc;
};

/* 3644 */
typedef mcache_bktlist mcache_bktlist_t;

/* 9243 */
struct __attribute__((aligned(128))) mcache_cpu
{
  lck_mtx_t cc_lock;
  mcache_bkt_t *cc_filled;
  mcache_bkt_t *cc_pfilled;
  u_int64_t cc_alloc;
  u_int64_t cc_free;
  int cc_objs;
  int cc_pobjs;
  int cc_bktsize;
};

/* 3640 */
typedef mcache_cpu mcache_cpu_t;

/* 3741 */
struct mcache
{
  struct
  {
    mcache *le_next;
    mcache **le_prev;
  } mc_list;
  char mc_name[32];
  zone *mc_slab_zone;
  mcache_allocfn_t mc_slab_alloc;
  mcache_freefn_t mc_slab_free;
  mcache_auditfn_t mc_slab_audit;
  mcache_logfn_t mc_slab_log;
  mcache_notifyfn_t mc_slab_notify;
  void *mc_private;
  size_t mc_bufsize;
  size_t mc_align;
  u_int32_t mc_flags;
  u_int32_t mc_purge_cnt;
  u_int32_t mc_enable_cnt;
  u_int32_t mc_waiter_cnt;
  u_int32_t mc_wretry_cnt;
  u_int32_t mc_nwretry_cnt;
  u_int32_t mc_nwfail_cnt;
  lck_mtx_t mc_sync_lock;
  lck_grp_t *mc_sync_lock_grp;
  lck_grp_t *mc_cpu_lock_grp;
  lck_mtx_t mc_bkt_lock;
  lck_grp_t *mc_bkt_lock_grp;
  mcache_bkttype_t *cache_bkttype;
  mcache_bktlist_t mc_full;
  mcache_bktlist_t mc_empty;
  size_t mc_chunksize;
  u_int32_t mc_bkt_contention;
  u_int32_t mc_bkt_contention_prev;
  mcache_cpu_t mc_cpu[1];
};

/* 7892 */
struct __attribute__((aligned(8))) mb_class_stat
{
  char mbcl_cname[16];
  u_int32_t mbcl_size;
  u_int32_t mbcl_total;
  u_int32_t mbcl_active;
  u_int32_t mbcl_infree;
  u_int32_t mbcl_slab_cnt;
  u_int32_t mbcl_pad;
  u_int64_t mbcl_alloc_cnt;
  u_int64_t mbcl_free_cnt;
  u_int64_t mbcl_notified;
  u_int64_t mbcl_purge_cnt;
  u_int64_t mbcl_fail_cnt;
  u_int32_t mbcl_ctotal;
  u_int32_t mbcl_release_cnt;
  u_int32_t mbcl_mc_state;
  u_int32_t mbcl_mc_cached;
  u_int32_t mbcl_mc_waiter_cnt;
  u_int32_t mbcl_mc_wretry_cnt;
  u_int32_t mbcl_mc_nwretry_cnt;
  u_int32_t mbcl_peak_reported;
  u_int32_t mbcl_reserved[7];
};

/* 7898 */
struct mcache_bkttype
{
  int bt_bktsize;
  size_t bt_minbuf;
  size_t bt_maxbuf;
  mcache *bt_cache;
};

/* 7899 */
struct mcache_bkt
{
  void *bkt_next;
  mcache_bkttype *bkt_type;
  void *bkt_obj[1];
};

/* 3630 */
struct omb_class_stat
{
  char mbcl_cname[16];
  u_int32_t mbcl_size;
  u_int32_t mbcl_total;
  u_int32_t mbcl_active;
  u_int32_t mbcl_infree;
  u_int32_t mbcl_slab_cnt;
  u_int32_t mbcl_pad;
  u_int64_t mbcl_alloc_cnt;
  u_int64_t mbcl_free_cnt;
  u_int64_t mbcl_notified;
  u_int64_t mbcl_purge_cnt;
  u_int64_t mbcl_fail_cnt;
  u_int32_t mbcl_ctotal;
  u_int32_t mbcl_release_cnt;
  u_int32_t mbcl_mc_state;
  u_int32_t mbcl_mc_cached;
  u_int32_t mbcl_mc_waiter_cnt;
  u_int32_t mbcl_mc_wretry_cnt;
  u_int32_t mbcl_mc_nwretry_cnt;
  u_int32_t mbcl_peak_reported;
  u_int32_t mbcl_reserved[7];
  u_int32_t mbcl_pad2;
};

/* 3631 */
struct omb_stat
{
  u_int32_t mbs_cnt;
  u_int32_t mbs_pad;
  omb_class_stat mbs_class[1];
};

/* 3633 */
struct mb_stat
{
  u_int32_t mbs_cnt;
  u_int32_t mbs_pad;
  mb_class_stat_t mbs_class[1];
};

/* 3634 */
typedef mcl_slab mcl_slab_t;

/* 3635 */
struct mcl_slabg
{
  mcl_slab_t *slg_slab;
};

/* 3636 */
typedef mcl_slabg mcl_slabg_t;

/* 3637 */
struct mca_trn
{
  thread *mca_thread;
  uint32_t mca_tstamp;
  uint16_t mca_depth;
  void *mca_stack[16];
};

/* 3638 */
typedef mcache_audit mcache_audit_t;

/* 7897 */
struct mcache_audit
{
  mcache_audit *mca_next;
  void *mca_addr;
  mcache_t *mca_cache;
  size_t mca_contents_size;
  void *mca_contents;
  void *mca_uptr;
  uint32_t mca_uflags;
  uint32_t mca_next_trn;
  mca_trn mca_trns[2];
};

/* 3639 */
struct mcl_audit_t
{
  mcache_audit_t **cl_audit;
};

/* 3650 */
typedef void (*protoctl_event_fn)(eventhandler_entry_arg, ifnet *, sockaddr *, sockaddr *, uint16_t, uint16_t, uint8_t, uint32_t, protoctl_ev_val *);

/* 3651 */
struct eventhandler_entry_protoctl_event
{
  eventhandler_entry ee;
  protoctl_event_fn eh_func;
};

/* 3652 */
struct __attribute__((aligned(8))) protoctl_event
{
  ifnet *ifp;
  sockaddr_in_4_6 laddr;
  sockaddr_in_4_6 raddr;
  uint32_t protoctl_event_code;
  protoctl_ev_val val;
  uint16_t lport;
  uint16_t rport;
  uint8_t protocol;
};

/* 3653 */
struct protoctl_event_nwk_wq_entry
{
  nwk_wq_entry nwk_wqe;
  protoctl_event protoctl_ev_arg;
};

/* 3654 */
struct domain_unguard;

/* 3655 */
struct domain_guard;

/* 3656 */
typedef uint32_t ubc_setsize_opts_t;

/* 3657 */
typedef __SC_Scatter SC_Scatter;

/* 7904 */
struct __SC_Scatter
{
  uint32_t count;
  uint32_t base;
  uint64_t targetOffset;
  uint64_t spare;
};

/* 3658 */
typedef __BlobIndex CS_BlobIndex;

/* 7905 */
struct __BlobIndex
{
  uint32_t type;
  uint32_t offset;
};

/* 3659 */
typedef __SC_SuperBlob CS_SuperBlob;

/* 7906 */
struct __SC_SuperBlob
{
  uint32_t magic;
  uint32_t length;
  uint32_t count;
  CS_BlobIndex index[];
};

/* 3664 */
struct ptmx_ioctl
{
  tty *pt_tty;
  int pt_flags;
  selinfo pt_selr;
  selinfo pt_selw;
  u_char pt_send;
  u_char pt_ucntl;
  void *pt_devhandle;
};

/* 3666 */
struct tty_dev_t
{
  int primary;
  int replica;
  _BYTE gap8[4];
  int _pad;
  tty_dev_t *next;
  ptmx_ioctl *(*open)(int, int);
  int (*free)(int, int);
  int (*name)(int, char *, size_t);
  void (*revoke)(int, tty *);
};

/* 3667 */
typedef int l_modem_t(tty *, int);

/* 3668 */
typedef void l_start_t(tty *);

/* 3669 */
typedef int l_rint_t(int, tty *);

/* 3670 */
typedef int l_ioctl_t(tty *, u_long, caddr_t, int, struct proc *);

/* 3671 */
typedef int l_write_t(tty *, uio *, int);

/* 3672 */
typedef int l_read_t(tty *, uio *, int);

/* 3673 */
typedef int l_close_t(tty *, int);

/* 3674 */
typedef int l_open_t(dev_t, tty *);

/* 3675 */
struct linesw
{
  l_open_t *l_open;
  l_close_t *l_close;
  l_read_t *l_read;
  l_write_t *l_write;
  l_ioctl_t *l_ioctl;
  l_rint_t *l_rint;
  l_start_t *l_start;
  l_modem_t *l_modem;
};

/* 3676 */
struct ltchars
{
  char t_suspc;
  char t_dsuspc;
  char t_rprntc;
  char t_flushc;
  char t_werasc;
  char t_lnextc;
};

/* 3677 */
struct tchars
{
  char t_intrc;
  char t_quitc;
  char t_startc;
  char t_stopc;
  char t_eofc;
  char t_brkc;
};

/* 3678 */
struct sgttyb
{
  char sg_ispeed;
  char sg_ospeed;
  char sg_erase;
  char sg_kill;
  short sg_flags;
};

/* 3679 */
struct speedtab
{
  int sp_speed;
  int sp_code;
};

/* 3680 */
typedef time_value time_value_t;

/* 7909 */
struct time_value
{
  integer_t seconds;
  integer_t microseconds;
};

/* 3681 */
struct work_interval_ctl_args
{
  uint32_t operation;
  char operation_r_[4];
  uint64_t work_interval_id;
  user_addr_t_0 arg;
  user_size_t len;
  char len_r_[];
};

/* 3682 */
typedef stackshot_thread_waitinfo thread_waitinfo_t;

/* 4134 */
struct __attribute__((packed)) __attribute__((aligned(1))) stackshot_thread_waitinfo
{
  uint64_t owner;
  uint64_t waiter;
  uint64_t context;
  uint8_t wait_type;
};

/* 3683 */
struct ulock_wake_args
{
  uint32_t operation;
  char operation_r_[4];
  user_addr_t_0 addr;
  uint64_t wake_value;
  char wake_value_r_[];
};

/* 3684 */
struct ulock_wait_args
{
  uint32_t operation;
  char operation_r_[4];
  user_addr_t_0 addr;
  uint64_t value;
  uint32_t timeout;
  char timeout_r_[4];
};

/* 3685 */
typedef ull ull_t;

/* 3686 */
typedef ull_bucket ull_bucket_t;

/* 9245 */
struct ull_bucket
{
  queue_head_t_0 ulb_head;
  lck_spin_t ulb_lock;
};

/* 3690 */
struct persona_args
{
  uint32_t operation;
  char operation_r_[4];
  uint32_t flags;
  char flags_r_[4];
  user_addr_t_0 info;
  user_addr_t_0 id;
  user_addr_t_0 idlen;
  user_addr_t_0 path;
  char path_r_[];
};

/* 3691 */
struct coalition_ledger_args
{
  uint32_t operation;
  char operation_r_[4];
  user_addr_t_0 cid;
  user_addr_t_0 buffer;
  user_addr_t_0 bufsize;
  char bufsize_r_[];
};

/* 3692 */
struct coalition_info_args
{
  uint32_t flavor;
  char flavor_r_[4];
  user_addr_t_0 cid;
  user_addr_t_0 buffer;
  user_addr_t_0 bufsize;
  char bufsize_r_[];
};

/* 3693 */
struct coalition_args
{
  uint32_t operation;
  char operation_r_[4];
  user_addr_t_0 cid;
  uint32_t flags;
  char flags_r_[4];
};

/* 3694 */
struct record_system_event_args
{
  uint32_t type;
  char type_r_[4];
  uint32_t subsystem;
  char subsystem_r_[4];
  user_addr_t_0 event;
  user_addr_t_0 payload;
  char payload_r_[];
};

/* 3695 */
struct pipe_args
{
  int32_t dummy;
};

/* 3696 */
struct pipepair
{
  lck_mtx_t pp_mtx;
  pipe pp_rpipe;
  pipe pp_wpipe;
  uint64_t pp_pipe_id;
};

/* 3697 */
struct log_data_args
{
  unsigned int tag;
  char tag_r_[4];
  unsigned int flags;
  char flags_r_[4];
  user_addr_t_0 buffer;
  unsigned int size;
  char size_r_[4];
};

/* 3698 */
struct telemetry_args
{
  uint64_t cmd;
  uint64_t deadline;
  uint64_t interval;
  uint64_t leeway;
  uint64_t arg4;
  uint64_t arg5;
  char arg5_r_[];
};

/* 3699 */
struct ledger_args
{
  int cmd;
  char cmd_r_[4];
  user_addr_t_0 arg1;
  user_addr_t_0 arg2;
  user_addr_t_0 arg3;
  char arg3_r_[];
};

/* 3700 */
struct gethostuuid_args
{
  user_addr_t_0 uuid_buf;
  user_addr_t_0 timeoutp;
  char timeoutp_r_[];
};

/* 3701 */
struct poll_args
{
  user_addr_t_0 fds;
  u_int nfds;
  char nfds_r_[4];
  int timeout;
  char timeout_r_[4];
};

/* 3702 */
struct pselect_args
{
  int nd;
  char nd_r_[4];
  user_addr_t_0 in;
  user_addr_t_0 ou;
  user_addr_t_0 ex;
  user_addr_t_0 ts;
  user_addr_t_0 mask;
  char mask_r_[];
};

/* 3703 */
struct select_args
{
  int nd;
  char nd_r_[4];
  user_addr_t_0 in;
  user_addr_t_0 ou;
  user_addr_t_0 ex;
  user_addr_t_0 tv;
  char tv_r_[];
};

/* 3704 */
struct ioctl_args
{
  int fd;
  char fd_r_[4];
  user_ulong_t com;
  user_addr_t_0 data;
  char data_r_[];
};

/* 3705 */
struct pwritev_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 iovp;
  int iovcnt;
  char iovcnt_r_[4];
  off_t offset;
  char offset_r_[];
};

/* 3706 */
struct writev_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 iovp;
  u_int iovcnt;
  char iovcnt_r_[4];
};

/* 3707 */
struct pwrite_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 buf;
  user_size_t nbyte;
  off_t offset;
  char offset_r_[];
};

/* 3708 */
struct write_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 cbuf;
  user_size_t nbyte;
  char nbyte_r_[];
};

/* 3709 */
struct preadv_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 iovp;
  int iovcnt;
  char iovcnt_r_[4];
  off_t offset;
  char offset_r_[];
};

/* 3710 */
struct readv_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 iovp;
  u_int iovcnt;
  char iovcnt_r_[4];
};

/* 3711 */
struct pread_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 buf;
  user_size_t nbyte;
  off_t offset;
  char offset_r_[];
};

/* 3712 */
struct read_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 cbuf;
  user_size_t nbyte;
  char nbyte_r_[];
};

/* 3713 */
typedef kevent_ctx_s *kevent_ctx_t;

/* 3714 */
struct waitq_link
{
  uintptr_t wql_wqs;
  queue_chain_t_0 wql_qlink;
  queue_chain_t_0 wql_slink;
  waitq *wql_wq;
};

/* 3715 */
struct waitq_sellink
{
  uintptr_t wql_wqs;
  waitq_link_list_entry wql_next;
  uint64_t wql_setid;
};

/* 3716 */
struct waitq_link_hdr
{
  uintptr_t wql_wqs;
};

/* 3717 */
struct pollfd
{
  int fd;
  short events;
  short revents;
};

/* 3718 */
struct poll_nocancel_args
{
  user_addr_t_0 fds;
  u_int nfds;
  char nfds_r_[4];
  int timeout;
  char timeout_r_[4];
};

/* 3719 */
struct pselect_nocancel_args
{
  int nd;
  char nd_r_[4];
  user_addr_t_0 in;
  user_addr_t_0 ou;
  user_addr_t_0 ex;
  user_addr_t_0 ts;
  user_addr_t_0 mask;
  char mask_r_[];
};

/* 3720 */
struct pwritev_nocancel_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 iovp;
  int iovcnt;
  char iovcnt_r_[4];
  off_t offset;
  char offset_r_[];
};

/* 3721 */
struct writev_nocancel_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 iovp;
  u_int iovcnt;
  char iovcnt_r_[4];
};

/* 3722 */
struct pwrite_nocancel_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 buf;
  user_size_t nbyte;
  off_t offset;
  char offset_r_[];
};

/* 3723 */
struct write_nocancel_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 cbuf;
  user_size_t nbyte;
  char nbyte_r_[];
};

/* 3724 */
struct preadv_nocancel_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 iovp;
  int iovcnt;
  char iovcnt_r_[4];
  off_t offset;
  char offset_r_[];
};

/* 3725 */
struct readv_nocancel_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 iovp;
  u_int iovcnt;
  char iovcnt_r_[4];
};

/* 3726 */
struct pread_nocancel_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 buf;
  user_size_t nbyte;
  off_t offset;
  char offset_r_[];
};

/* 3727 */
struct read_nocancel_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 cbuf;
  user_size_t nbyte;
  char nbyte_r_[];
};

/* 3728 */
struct mach_eventlink_signal_wait_until_args
{
  mach_port_name_t eventlink_port;
  char eventlink_port_r_[4];
  uint64_t wait_count;
  uint64_t signal_count;
  uint64_t deadline;
  uint32_t clock_id;
  char clock_id_r_[4];
  uint32_t option;
  char option_r_[4];
};

/* 3729 */
struct mach_eventlink_wait_until_args
{
  mach_port_name_t eventlink_port;
  char eventlink_port_r_[4];
  uint64_t wait_count;
  uint64_t deadline;
  uint32_t clock_id;
  char clock_id_r_[4];
  uint32_t option;
  char option_r_[4];
};

/* 3730 */
struct mach_eventlink_signal_args
{
  mach_port_name_t eventlink_port;
  char eventlink_port_r_[4];
  uint64_t signal_count;
  char signal_count_r_[];
};

/* 3731 */
struct nosys_args
{
  int32_t dummy;
};

/* 3732 */
typedef pgrp *tpr_t;

/* 7918 */
union log_stream_ticket
{
  struct
  {
    _BYTE gap0[8];
  };
  uint64_t lst_value;
};

/* 7916 */
typedef log_stream_ticket log_stream_ticket_t;

/* 7917 */
struct log_stream_t
{
  bool ls_enabled;
  bool ls_snapshot;
  uint8_t *ls_buf;
  uint8_t *ls_blk;
  size_t ls_blk_count;
  size_t ls_reserved;
  union
  {
    size_t v;
    size_t av;
  } ls_commited;
  size_t ls_commited_wraps;
};

/* 3733 */
struct log_stream_session_t
{
  log_stream_ticket_t lss_ticket;
  log_stream_t *lss_stream;
  log_stream_t lss_snapshot;
};

/* 3734 */
struct log_stream_msg_t
{
  uint64_t lsm_ts;
  firehose_tracepoint_s lsm_ft;
};

/* 3735 */
struct msgbuf
{
  int msg_magic;
  int msg_size;
  int msg_bufx;
  int msg_bufr;
  char *msg_bufc;
};

/* 3736 */
struct microstackshot_args
{
  user_addr_t_0 tracebuf;
  uint32_t tracebuf_size;
  char tracebuf_size_r_[4];
  uint32_t flags;
  char flags_r_[4];
};

/* 3737 */
struct stack_snapshot_with_config_args
{
  int stackshot_config_version;
  char stackshot_config_version_r_[4];
  user_addr_t_0 stackshot_config;
  user_size_t stackshot_config_size;
  char stackshot_config_size_r_[];
};

/* 6916 */
typedef char ca_sstr;

/* 3738 */
struct __attribute__((packed)) __attribute__((aligned(1))) _ca_event_stackshot_entitlement_report
{
  unsigned __int64 sshot_count;
  bool sshot_refused;
  bool sshot_have_entitlement;
  bool sshot_fromtest;
  ca_sstr sshot_progress[2];
  ca_sstr sshot_pcomm[17];
  ca_sstr sshot_pname[33];
};

/* 3739 */
struct stackshot_entitlement_report
{
  uint64_t ser_lastev;
  uint32_t ser_count;
  command_t ser_pcomm;
  proc_name_t ser_pname;
  bool ser_have_entitlement;
  char ser_progress;
};

/* 3742 */
struct ptrace_args
{
  int req;
  char req_r_[4];
  pid_t pid;
  char pid_r_[4];
  user_addr_t_0 addr;
  int data;
  char data_r_[4];
};

/* 3743 */
struct usrctl_args
{
  uint32_t flags;
  char flags_r_[4];
};

/* 3744 */
struct reboot_args
{
  int opt;
  char opt_r_[4];
  user_addr_t_0 msg;
  char msg_r_[];
};

/* 3745 */
typedef _trust_cache_offsets trust_cache_offsets_t;

/* 9253 */
struct _trust_cache_offsets
{
  uint32_t num_caches;
  uint32_t offsets[];
};

/* 3746 */
struct DTTrustCacheRange
{
  vm_offset_t_0 paddr;
  size_t length;
};

/* 3748 */
typedef _TrustCacheTypeConfig TrustCacheTypeConfig_t;

/* 7927 */
struct _TrustCacheTypeConfig
{
  const img4_chip_t *(*chipEnvironment)(void);
  const img4_nonce_domain_t *(*nonceDomain)(void);
  img4_4cc_t fourCC;
  _BYTE gap14[12];
  const char *entitlementValue;
};

/* 3751 */
struct __mach_bridge_remote_time_args
{
  uint64_t local_timestamp;
  char local_timestamp_r_[];
};

/* 3752 */
struct setitimer_args
{
  u_int which;
  char which_r_[4];
  user_addr_t_0 itv;
  user_addr_t_0 oitv;
  char oitv_r_[];
};

/* 3753 */
struct settimeofday_args
{
  user_addr_t_0 tv;
  user_addr_t_0 tzp;
  char tzp_r_[];
};

/* 3754 */
struct gettimeofday_args
{
  user_addr_t_0 tp;
  user_addr_t_0 tzp;
  user_addr_t_0 mach_absolute_time;
  char mach_absolute_time_r_[];
};

/* 3755 */
struct getitimer_args
{
  u_int which;
  char which_r_[4];
  user_addr_t_0 itv;
  char itv_r_[];
};

/* 3756 */
struct sfi_pidctl_args
{
  uint32_t operation;
  char operation_r_[4];
  pid_t pid;
  char pid_r_[4];
  uint32_t sfi_flags;
  char sfi_flags_r_[4];
  user_addr_t_0 out_sfi_flags;
  char out_sfi_flags_r_[];
};

/* 3757 */
struct sfi_ctl_args
{
  uint32_t operation;
  char operation_r_[4];
  uint32_t sfi_class;
  char sfi_class_r_[4];
  uint64_t time;
  user_addr_t_0 out_time;
  char out_time_r_[];
};

/* 3758 */
struct mbuf_buffer_status_t
{
  int32_t buf_interface;
  int32_t buf_sndbuf;
};

/* 3759 */
typedef u_int32_t mbuf_pkthdr_aux_flags_t;

/* 3760 */
typedef u_int16_t mbuf_tag_type_t;

/* 3761 */
typedef u_int32_t mbuf_tag_id_t;

/* 3762 */
struct mbuf_stat
{
  u_int32_t mbufs;
  u_int32_t clusters;
  u_int32_t clfree;
  u_int32_t drops;
  u_int32_t wait;
  u_int32_t drain;
  u_short mtypes[256];
  u_int32_t mcfail;
  u_int32_t mpfail;
  u_int32_t msize;
  u_int32_t mclbytes;
  u_int32_t minclsize;
  u_int32_t mlen;
  u_int32_t mhlen;
  u_int32_t bigclusters;
  u_int32_t bigclfree;
  u_int32_t bigmclbytes;
};

/* 3763 */
typedef u_int32_t mbuf_type_t;

/* 3764 */
typedef u_int32_t mbuf_how_t;

/* 3765 */
struct m_drvaux_tag
{
  u_int32_t da_family;
  u_int32_t da_subfamily;
  u_int32_t da_reserved;
  u_int32_t da_length;
};

/* 3766 */
typedef void (*mbuf_tx_compl_func)(uintptr_t, ifnet_t, u_int64_t, uintptr_t, uintptr_t, kern_return_t);

/* 3767 */
typedef u_int32_t mbuf_csum_performed_flags_t;

/* 3768 */
typedef u_int32_t mbuf_tso_request_flags_t;

/* 3769 */
typedef u_int32_t mbuf_csum_request_flags_t;

/* 3770 */
typedef u_int32_t mbuf_flags_t;

/* 3771 */
struct memorystatus_system_health
{
  bool msh_zone_map_is_exhausted;
};

/* 3772 */
struct __attribute__((aligned(8))) jetsam_thread_state
{
  uint8_t inited;
  uint8_t limit_to_low_bands;
  int index;
  thread_t_0 thread;
  int jld_idle_kills;
  uint32_t errors;
  bool sort_flag;
  bool corpse_list_purged;
  bool post_snapshot;
  uint64_t memory_reclaimed;
  uint32_t hwm_kills;
};

/* 3773 */
struct __attribute__((packed)) __attribute__((aligned(1))) _ca_event_memorystatus_proc_notification
{
  unsigned __int64 footprint_before_notification;
  unsigned __int64 footprint_1_min_after_first_warning;
  unsigned __int64 footprint_5_min_after_first_warning;
  unsigned __int64 footprint_20_min_after_first_warning;
  unsigned __int64 footprint_1_min_after_first_critical;
  unsigned __int64 footprint_5_min_after_first_critical;
  unsigned __int64 footprint_20_min_after_first_critical;
  unsigned __int64 order_within_list;
  unsigned __int64 num_notifications_sent;
  unsigned __int64 time_between_warning_and_critical;
  ca_sstr proc_name[17];
};

/* 3774 */
struct knote_footprint_history
{
  uint32_t kfh_starting_footprint;
  uint32_t kfh_footprint_after_warn_1;
  uint32_t kfh_footprint_after_warn_5;
  uint32_t kfh_footprint_after_warn_20;
  uint32_t kfh_footprint_after_critical_1;
  uint32_t kfh_footprint_after_critical_5;
  uint32_t kfh_footprint_after_critical_20;
  uint16_t kfh_num_notifications;
  uint16_t kfh_notification_order;
};

/* 3775 */
typedef memorystatus_system_health memorystatus_system_health_t;

/* 3776 */
struct memorystatus_available_memory_args
{
  int32_t dummy;
};

/* 3777 */
struct memorystatus_control_args
{
  uint32_t command;
  char command_r_[4];
  int32_t pid;
  char pid_r_[4];
  uint32_t flags;
  char flags_r_[4];
  user_addr_t_0 buffer;
  user_size_t buffersize;
  char buffersize_r_[];
};

/* 3778 */
struct memorystatus_get_level_args
{
  user_addr_t_0 level;
  char level_r_[];
};

/* 3779 */
typedef memorystatus_memlimit_properties memorystatus_memlimit_properties_t;

/* 7933 */
struct memorystatus_memlimit_properties
{
  int32_t memlimit_active;
  uint32_t memlimit_active_attr;
  int32_t memlimit_inactive;
  uint32_t memlimit_inactive_attr;
};

/* 3780 */
typedef memorystatus_properties_entry_v1 memorystatus_properties_entry_v1_t;

/* 9255 */
struct __attribute__((aligned(8))) memorystatus_properties_entry_v1
{
  int version;
  pid_t pid;
  int32_t priority;
  int use_probability;
  uint64_t user_data;
  int32_t limit;
  uint32_t state;
  char proc_name[17];
  char __pad1[3];
};

/* 3781 */
typedef memorystatus_priority_entry memorystatus_priority_entry_t;

/* 9256 */
struct memorystatus_priority_entry
{
  pid_t pid;
  int32_t priority;
  uint64_t user_data;
  int32_t limit;
  uint32_t state;
};

/* 3782 */
typedef jetsam_thread_state jetsam_thread_state_t;

/* 3783 */
typedef memstat_bucket memstat_bucket_t;

/* 9257 */
struct memstat_bucket
{
  struct
  {
    proc *tqh_first;
    proc **tqh_last;
  } list;
  int count;
  int relaunch_high_count;
};

/* 3784 */
enum memorystatus_freeze_skip_reason : __int32
{
  memorystatus_freeze_skip_reason::kMemorystatusFreezeSkipReasonNone = 0x0,
  memorystatus_freeze_skip_reason::kMemorystatusFreezeSkipReasonExcessSharedMemory = 0x1,
  memorystatus_freeze_skip_reason::kMemorystatusFreezeSkipReasonLowPrivateSharedRatio = 0x2,
  memorystatus_freeze_skip_reason::kMemorystatusFreezeSkipReasonNoCompressorSpace = 0x3,
  memorystatus_freeze_skip_reason::kMemorystatusFreezeSkipReasonNoSwapSpace = 0x4,
  memorystatus_freeze_skip_reason::kMemorystatusFreezeSkipReasonBelowMinPages = 0x5,
  memorystatus_freeze_skip_reason::kMemorystatusFreezeSkipReasonLowProbOfUse = 0x6,
  memorystatus_freeze_skip_reason::kMemorystatusFreezeSkipReasonOther = 0x7,
  memorystatus_freeze_skip_reason::kMemorystatusFreezeSkipReasonOutOfBudget = 0x8,
  memorystatus_freeze_skip_reason::kMemorystatusFreezeSkipReasonOutOfSlots = 0x9,
  memorystatus_freeze_skip_reason::kMemorystatusFreezeSkipReasonDisabled = 0xA,
  memorystatus_freeze_skip_reason::kMemorystatusFreezeSkipReasonElevated = 0xB,
  memorystatus_freeze_skip_reason::_kMemorystatusFreezeSkipReasonMax = 0xC,
};

/* 3786 */
typedef memorystatus_freeze_skip_reason memorystatus_freeze_skip_reason_t;

/* 3787 */
typedef jetsam_snapshot_entry memorystatus_jetsam_snapshot_entry_t;

/* 9258 */
struct __attribute__((aligned(8))) jetsam_snapshot_entry
{
  pid_t pid;
  char name[33];
  int32_t priority;
  uint32_t state;
  uint32_t fds;
  memorystatus_freeze_skip_reason_t jse_freeze_skip_reason;
  uint8_t uuid[16];
  uint64_t user_data;
  uint64_t killed;
  uint64_t pages;
  uint64_t max_pages_lifetime;
  uint64_t purgeable_pages;
  uint64_t jse_internal_pages;
  uint64_t jse_internal_compressed_pages;
  uint64_t jse_purgeable_nonvolatile_pages;
  uint64_t jse_purgeable_nonvolatile_compressed_pages;
  uint64_t jse_alternate_accounting_pages;
  uint64_t jse_alternate_accounting_compressed_pages;
  uint64_t jse_iokit_mapped_pages;
  uint64_t jse_page_table_pages;
  uint64_t jse_memory_region_count;
  uint64_t jse_gencount;
  uint64_t jse_starttime;
  uint64_t jse_killtime;
  uint64_t jse_idle_delta;
  uint64_t jse_coalition_jetsam_id;
  timeval64 cpu_time;
  uint64_t jse_thaw_count;
  uint64_t jse_frozen_to_swap_pages;
  uint64_t csflags;
  uint32_t cs_trust_level;
};

/* 3788 */
typedef memorystatus_kernel_stats memorystatus_kernel_stats_t;

/* 7936 */
struct memorystatus_kernel_stats
{
  uint32_t free_pages;
  uint32_t active_pages;
  uint32_t inactive_pages;
  uint32_t throttled_pages;
  uint32_t purgeable_pages;
  uint32_t wired_pages;
  uint32_t speculative_pages;
  uint32_t filebacked_pages;
  uint32_t anonymous_pages;
  uint32_t compressor_pages;
  uint64_t compressions;
  uint64_t decompressions;
  uint64_t total_uncompressed_pages_in_compressor;
  uint64_t zone_map_size;
  uint64_t zone_map_capacity;
  uint64_t largest_zone_size;
  char largest_zone_name[80];
};

/* 3789 */
typedef jetsam_snapshot memorystatus_jetsam_snapshot_t;

/* 9259 */
struct jetsam_snapshot
{
  uint64_t snapshot_time;
  uint64_t notification_time;
  uint64_t js_gencount;
  memorystatus_kernel_stats_t stats;
  size_t entry_count;
  memorystatus_jetsam_snapshot_entry_t entries[];
};

/* 3790 */
typedef memorystatus_internal_probabilities memorystatus_internal_probabilities_t;

/* 7937 */
struct memorystatus_internal_probabilities
{
  char proc_name[17];
  int use_probability;
};

/* 3791 */
struct sysctlbyname_args
{
  user_addr_t_0 name;
  user_size_t namelen;
  user_addr_t_0 old;
  user_addr_t_0 oldlenp;
  user_addr_t_0 new;
  user_size_t newlen;
  char newlen_r_[];
};

/* 3792 */
struct sysctl_args
{
  user_addr_t_0 name;
  u_int namelen;
  char namelen_r_[4];
  user_addr_t_0 old;
  user_addr_t_0 oldlenp;
  user_addr_t_0 new;
  user_size_t newlen;
  char newlen_r_[];
};

/* 3793 */
struct __attribute__((packed)) __attribute__((aligned(2))) _ca_event_ca_test_event
{
  unsigned __int64 TestKey;
  bool TestBool;
  ca_sstr TestString[37];
};

/* 3794 */
struct __attribute__((aligned(8))) experiment_spec
{
  void *ptr;
  uint64_t min_value;
  uint64_t max_value;
  uint64_t original_value;
  bool modified;
};

/* 3795 */
struct imgsrc_info
{
  uint32_t ii_height;
  uint32_t ii_flags;
  dev_t ii_dev;
  char ii_reserved[24];
};

/* 3796 */
typedef integer_t cpu_threadtype_t;

/* 3817 */
typedef u_int32_t fixpt_t;

/* 3797 */
struct user64_loadavg
{
  fixpt_t ldavg[3];
  user64_long_t fscale;
};

/* 3798 */
struct user32_loadavg
{
  fixpt_t ldavg[3];
  user32_long_t fscale;
};

/* 3799 */
struct loadavg
{
  fixpt_t ldavg[3];
  long fscale;
};

/* 3806 */
typedef int32_t segsz_t;

/* 3800 */
struct user32_vmspace
{
  int vm_refcnt;
  uint32_t vm_shm;
  segsz_t vm_rssize;
  segsz_t vm_swrss;
  segsz_t vm_tsize;
  segsz_t vm_dsize;
  segsz_t vm_ssize;
  uint32_t vm_taddr;
  uint32_t vm_daddr;
  uint32_t vm_maxsaddr;
};

/* 3801 */
struct user32_pcred
{
  char pc_lock[72];
  user32_addr_t pc_ucred;
  uid_t p_ruid;
  uid_t p_svuid;
  gid_t p_rgid;
  gid_t p_svgid;
  int p_refcnt;
};

/* 3808 */
struct _ucred
{
  int32_t cr_ref;
  uid_t cr_uid;
  short cr_ngroups;
  gid_t cr_groups[16];
};

/* 3802 */
struct user32_eproc
{
  user32_addr_t e_paddr;
  user32_addr_t e_sess;
  user32_pcred e_pcred;
  _ucred e_ucred;
  user32_vmspace e_vm;
  pid_t e_ppid;
  pid_t e_pgid;
  int e_jobc;
  dev_t e_tdev;
  pid_t e_tpgid;
  user32_addr_t e_tsess;
  char e_wmesg[8];
  segsz_t e_xsize;
  short e_xrssize;
  short e_xccount;
  short e_xswrss;
  int32_t e_flag;
  char e_login[12];
  int32_t e_spare[4];
};

/* 3804 */
struct user32_itimerval
{
  user32_timeval it_interval;
  user32_timeval it_value;
};

/* 3805 */
struct __attribute__((aligned(8))) user32_extern_proc
{
  union
  {
    struct
    {
      uint32_t __p_forw;
      uint32_t __p_back;
    } p_st1;
    user32_timeval __p_starttime;
  } p_un;
  uint32_t p_vmspace;
  uint32_t p_sigacts;
  int p_flag;
  char p_stat;
  pid_t p_pid;
  pid_t p_oppid;
  int p_dupfd;
  uint32_t user_stack;
  uint32_t exit_thread;
  int p_debugger;
  boolean_t sigwait;
  u_int p_estcpu;
  int p_cpticks;
  fixpt_t p_pctcpu;
  uint32_t p_wchan;
  uint32_t p_wmesg;
  u_int p_swtime;
  u_int p_slptime;
  user32_itimerval p_realtimer;
  user32_timeval p_rtime;
  u_quad_t p_uticks;
  u_quad_t p_sticks;
  u_quad_t p_iticks;
  int p_traceflag;
  uint32_t p_tracep;
  int p_siglist;
  uint32_t p_textvp;
  int p_holdcnt;
  sigset_t p_sigmask;
  sigset_t p_sigignore;
  sigset_t p_sigcatch;
  u_char p_priority;
  u_char p_usrpri;
  char p_nice;
  char p_comm[17];
  uint32_t p_pgrp;
  uint32_t p_addr;
  u_short p_xstat;
  u_short p_acflag;
  uint32_t p_ru;
};

/* 3803 */
struct user32_kinfo_proc
{
  user32_extern_proc kp_proc;
  user32_eproc kp_eproc;
};

/* 3807 */
struct user_vmspace
{
  int vm_refcnt;
  user_addr_t_0 vm_shm;
  segsz_t vm_rssize;
  segsz_t vm_swrss;
  segsz_t vm_tsize;
  segsz_t vm_dsize;
  segsz_t vm_ssize;
  user_addr_t_0 vm_taddr;
  user_addr_t_0 vm_daddr;
  user_addr_t_0 vm_maxsaddr;
};

/* 3809 */
struct __attribute__((aligned(8))) user64_pcred
{
  char pc_lock[72];
  user64_addr_t pc_ucred;
  uid_t p_ruid;
  uid_t p_svuid;
  gid_t p_rgid;
  gid_t p_svgid;
  int p_refcnt;
};

/* 3810 */
struct __attribute__((aligned(8))) user64_eproc
{
  user_addr_t_0 e_paddr;
  user_addr_t_0 e_sess;
  user64_pcred e_pcred;
  _ucred e_ucred;
  user_vmspace e_vm;
  pid_t e_ppid;
  pid_t e_pgid;
  int e_jobc;
  dev_t e_tdev;
  pid_t e_tpgid;
  user64_addr_t e_tsess;
  char e_wmesg[8];
  segsz_t e_xsize;
  short e_xrssize;
  short e_xccount;
  short e_xswrss;
  int32_t e_flag;
  char e_login[12];
  int32_t e_spare[4];
};

/* 3812 */
struct user64_itimerval
{
  user64_timeval it_interval;
  user64_timeval it_value;
};

/* 3813 */
struct user64_extern_proc
{
  union
  {
    struct
    {
      user_addr_t_0 __p_forw;
      user_addr_t_0 __p_back;
    } p_st1;
    user64_timeval __p_starttime;
  } p_un;
  user_addr_t_0 p_vmspace;
  user_addr_t_0 p_sigacts;
  int p_flag;
  char p_stat;
  pid_t p_pid;
  pid_t p_oppid;
  int p_dupfd;
  user_addr_t_0 user_stack;
  user_addr_t_0 exit_thread;
  int p_debugger;
  boolean_t sigwait;
  u_int p_estcpu;
  int p_cpticks;
  fixpt_t p_pctcpu;
  user_addr_t_0 p_wchan;
  user_addr_t_0 p_wmesg;
  u_int p_swtime;
  u_int p_slptime;
  user64_itimerval p_realtimer;
  user64_timeval p_rtime;
  u_quad_t p_uticks;
  u_quad_t p_sticks;
  u_quad_t p_iticks;
  int p_traceflag;
  user_addr_t_0 p_tracep;
  int p_siglist;
  user_addr_t_0 p_textvp;
  int p_holdcnt;
  sigset_t p_sigmask;
  sigset_t p_sigignore;
  sigset_t p_sigcatch;
  u_char p_priority;
  u_char p_usrpri;
  char p_nice;
  char p_comm[17];
  user_addr_t_0 p_pgrp;
  user_addr_t_0 p_addr;
  u_short p_xstat;
  u_short p_acflag;
  user_addr_t_0 p_ru;
};

/* 3811 */
struct user64_kinfo_proc
{
  user64_extern_proc kp_proc;
  user64_eproc kp_eproc;
};

/* 3814 */
typedef _vm_object_query_data_ vm_object_query_data_t;

/* 3930 */
typedef unsigned __int64 vm_object_id_t;

/* 9025 */
struct _vm_object_query_data_
{
  vm_object_id_t object_id;
  mach_vm_size_t_0 virtual_size;
  mach_vm_size_t_0 resident_size;
  mach_vm_size_t_0 wired_size;
  mach_vm_size_t_0 reusable_size;
  mach_vm_size_t_0 compressed_size;
  struct
  {
    _BYTE gap0[8];
  };
};

/* 3815 */
struct _vmobject_list_output_
{
  uint64_t entries;
  vm_object_query_data_t data[];
};

/* 3816 */
struct _processor_statistics_np
{
  int32_t ps_cpuid;
  uint32_t ps_csw_count;
  uint32_t ps_preempt_count;
  uint32_t ps_preempted_rt_count;
  uint32_t ps_preempted_by_rt_count;
  uint32_t ps_rt_sched_count;
  uint32_t ps_interrupt_count;
  uint32_t ps_ipi_count;
  uint32_t ps_timer_pop_count;
  uint64_t ps_runq_count_sum;
  uint32_t ps_idle_transitions;
  uint32_t ps_quantum_timer_expirations;
};

/* 3818 */
struct kern_iovec
{
  u_int64_t iov_base;
  u_int64_t iov_len;
};

/* 3819 */
struct generic;

/* 3820 */
struct generic_hash_head
{
  generic *lh_first;
};

/* 3821 */
struct terminate_with_payload_args
{
  int pid;
  char pid_r_[4];
  uint32_t reason_namespace;
  char reason_namespace_r_[4];
  uint64_t reason_code;
  user_addr_t_0 payload;
  uint32_t payload_size;
  char payload_size_r_[4];
  user_addr_t_0 reason_string;
  uint64_t reason_flags;
  char reason_flags_r_[];
};

/* 3822 */
struct kill_args
{
  int pid;
  char pid_r_[4];
  int signum;
  char signum_r_[4];
  int posix;
  char posix_r_[4];
};

/* 3823 */
struct sigaltstack_args
{
  user_addr_t_0 nss;
  user_addr_t_0 oss;
  char oss_r_[];
};

/* 3824 */
struct __sigwait_args
{
  user_addr_t_0 set;
  user_addr_t_0 sig;
  char sig_r_[];
};

/* 3825 */
struct __pthread_sigmask_args
{
  int how;
  char how_r_[4];
  user_addr_t_0 set;
  user_addr_t_0 oset;
  char oset_r_[];
};

/* 3826 */
struct __pthread_kill_args
{
  int thread_port;
  char thread_port_r_[4];
  int sig;
  char sig_r_[4];
};

/* 3827 */
struct __semwait_signal_args
{
  int cond_sem;
  char cond_sem_r_[4];
  int mutex_sem;
  char mutex_sem_r_[4];
  int timeout;
  char timeout_r_[4];
  int relative;
  char relative_r_[4];
  int64_t tv_sec;
  int32_t tv_nsec;
  char tv_nsec_r_[4];
};

/* 3828 */
struct __pthread_canceled_args
{
  int action;
  char action_r_[4];
};

/* 3829 */
struct __pthread_markcancel_args
{
  int thread_port;
  char thread_port_r_[4];
};

/* 3830 */
struct __disable_threadsignal_args
{
  int value;
  char value_r_[4];
};

/* 3831 */
struct sigsuspend_args
{
  sigset_t mask;
  char mask_r_[4];
};

/* 3832 */
struct sigpending_args
{
  user_addr_t_0 osv;
  char osv_r_[];
};

/* 3833 */
struct sigprocmask_args
{
  int how;
  char how_r_[4];
  user_addr_t_0 mask;
  user_addr_t_0 omask;
  char omask_r_[];
};

/* 3834 */
struct sigaction_args
{
  int signum;
  char signum_r_[4];
  user_addr_t_0 nsa;
  user_addr_t_0 osa;
  char osa_r_[];
};

/* 3838 */
union __user64_sigaction_u
{
  user64_addr_t __sa_handler;
  user64_addr_t __sa_sigaction;
};

/* 3835 */
struct user64_sigaction
{
  __user64_sigaction_u __sigaction_u;
  sigset_t sa_mask;
  int sa_flags;
};

/* 3842 */
union __user32_sigaction_u
{
  user32_addr_t __sa_handler;
  user32_addr_t __sa_sigaction;
};

/* 3836 */
struct user32_sigaction
{
  __user32_sigaction_u __sigaction_u;
  sigset_t sa_mask;
  int sa_flags;
};

/* 3840 */
union __kern_sigaction_u
{
  user_addr_t_0 __sa_handler;
  user_addr_t_0 __sa_sigaction;
};

/* 3837 */
struct kern_sigaction
{
  __kern_sigaction_u __sigaction_u;
  sigset_t sa_mask;
  int sa_flags;
};

/* 3839 */
struct __user64_sigaction
{
  __user64_sigaction_u __sigaction_u;
  user64_addr_t sa_tramp;
  sigset_t sa_mask;
  int sa_flags;
};

/* 3841 */
struct __kern_sigaction
{
  __kern_sigaction_u __sigaction_u;
  user_addr_t_0 sa_tramp;
  sigset_t sa_mask;
  int sa_flags;
};

/* 3843 */
struct __user32_sigaction
{
  __user32_sigaction_u __sigaction_u;
  user32_addr_t sa_tramp;
  sigset_t sa_mask;
  int sa_flags;
};

/* 3844 */
struct killpg1_filtargs
{
  bool posix;
  proc_t curproc;
};

/* 3845 */
struct killpg1_iterargs
{
  proc_t curproc;
  kauth_cred_t uc;
  int signum;
  int nfound;
};

/* 3846 */
struct __sigwait_nocancel_args
{
  user_addr_t_0 set;
  user_addr_t_0 sig;
  char sig_r_[];
};

/* 3847 */
struct __semwait_signal_nocancel_args
{
  int cond_sem;
  char cond_sem_r_[4];
  int mutex_sem;
  char mutex_sem_r_[4];
  int timeout;
  char timeout_r_[4];
  int relative;
  char relative_r_[4];
  int64_t tv_sec;
  int32_t tv_nsec;
  char tv_nsec_r_[4];
};

/* 3848 */
struct sigsuspend_nocancel_args
{
  sigset_t mask;
  char mask_r_[4];
};

/* 3849 */
struct sd_filterargs
{
  int delayterm;
  int shutdownstate;
  int only_non_dext;
};

/* 3850 */
struct sd_iterargs
{
  int signo;
  int setsdstate;
  int countproc;
  int activecount;
};

/* 3851 */
struct thread_selfusage_args
{
  int32_t dummy;
};

/* 3852 */
struct proc_rlimit_control_args
{
  pid_t pid;
  char pid_r_[4];
  int flavor;
  char flavor_r_[4];
  user_addr_t_0 arg;
  char arg_r_[];
};

/* 3853 */
struct iopolicysys_args
{
  int cmd;
  char cmd_r_[4];
  user_addr_t_0 arg;
  char arg_r_[];
};

/* 3854 */
struct getrusage_args
{
  int who;
  char who_r_[4];
  user_addr_t_0 rusage;
  char rusage_r_[];
};

/* 3855 */
typedef int policy_t;

/* 3856 */
struct getrlimit_args
{
  u_int which;
  char which_r_[4];
  user_addr_t_0 rlp;
  char rlp_r_[];
};

/* 3857 */
struct setrlimit_args
{
  u_int which;
  char which_r_[4];
  user_addr_t_0 rlp;
  char rlp_r_[];
};

/* 3858 */
struct setpriority_args
{
  int which;
  char which_r_[4];
  id_t who;
  char who_r_[4];
  int prio;
  char prio_r_[4];
};

/* 3859 */
struct getpriority_args
{
  int which;
  char which_r_[4];
  id_t who;
  char who_r_[4];
};

/* 3860 */
struct _iopol_param_t
{
  int iop_scope;
  int iop_iotype;
  int iop_policy;
};

/* 3861 */
struct puser_nice_args
{
  proc_t curp;
  int prio;
  id_t who;
  int *foundp;
  int *errorp;
};

/* 3862 */
struct ppgrp_nice_args
{
  proc_t curp;
  int prio;
  int *foundp;
  int *errorp;
};

/* 3863 */
struct setlogin_args
{
  user_addr_t_0 namebuf;
  char namebuf_r_[];
};

/* 3864 */
struct getlogin_args
{
  user_addr_t_0 namebuf;
  u_int namelen;
  char namelen_r_[4];
};

/* 3865 */
struct setwgroups_args
{
  int setlen;
  char setlen_r_[4];
  user_addr_t_0 guidset;
  char guidset_r_[];
};

/* 3866 */
struct setsgroups_args
{
  int setlen;
  char setlen_r_[4];
  user_addr_t_0 guidset;
  char guidset_r_[];
};

/* 3867 */
struct setgroups_args
{
  u_int gidsetsize;
  char gidsetsize_r_[4];
  user_addr_t_0 gidset;
  char gidset_r_[];
};

/* 3868 */
struct initgroups_args
{
  u_int gidsetsize;
  char gidsetsize_r_[4];
  user_addr_t_0 gidset;
  int gmuid;
  char gmuid_r_[4];
};

/* 3869 */
struct settid_with_pid_args
{
  pid_t pid;
  char pid_r_[4];
  int assume;
  char assume_r_[4];
};

/* 3870 */
struct settid_args
{
  uid_t uid;
  char uid_r_[4];
  gid_t gid;
  char gid_r_[4];
};

/* 3871 */
struct setregid_args
{
  gid_t rgid;
  char rgid_r_[4];
  gid_t egid;
  char egid_r_[4];
};

/* 3872 */
struct setegid_args
{
  gid_t egid;
  char egid_r_[4];
};

/* 3873 */
struct setgid_args
{
  gid_t gid;
  char gid_r_[4];
};

/* 3874 */
struct setreuid_args
{
  uid_t ruid;
  char ruid_r_[4];
  uid_t euid;
  char euid_r_[4];
};

/* 3875 */
struct seteuid_args
{
  uid_t euid;
  char euid_r_[4];
};

/* 3876 */
struct setuid_args
{
  uid_t uid;
  char uid_r_[4];
};

/* 3877 */
struct issetugid_args
{
  int32_t dummy;
};

/* 3878 */
struct setpgid_args
{
  int pid;
  char pid_r_[4];
  int pgid;
  char pgid_r_[4];
};

/* 3879 */
struct setsid_args
{
  int32_t dummy;
};

/* 3880 */
struct getwgroups_args
{
  user_addr_t_0 setlen;
  user_addr_t_0 guidset;
  char guidset_r_[];
};

/* 3881 */
struct getsgroups_args
{
  user_addr_t_0 setlen;
  user_addr_t_0 guidset;
  char guidset_r_[];
};

/* 3882 */
struct getgroups_args
{
  u_int gidsetsize;
  char gidsetsize_r_[4];
  user_addr_t_0 gidset;
  char gidset_r_[];
};

/* 3883 */
struct getegid_args
{
  int32_t dummy;
};

/* 3884 */
struct getgid_args
{
  int32_t dummy;
};

/* 3885 */
struct thread_ro
{
  thread *tro_owner;
  ucred *tro_cred;
  proc *tro_proc;
  proc_ro *tro_proc_ro;
  task *tro_task;
  __attribute__((aligned(16))) ipc_port *tro_self_port;
  ipc_port *tro_settable_self_port;
  ipc_port *tro_ports[3];
  exception_action *tro_exc_actions;
};

/* 3886 */
struct gettid_args
{
  user_addr_t_0 uidp;
  user_addr_t_0 gidp;
  char gidp_r_[];
};

/* 3887 */
struct geteuid_args
{
  int32_t dummy;
};

/* 3888 */
struct getuid_args
{
  int32_t dummy;
};

/* 3889 */
struct getsid_args
{
  pid_t pid;
  char pid_r_[4];
};

/* 3890 */
struct getpgid_args
{
  pid_t pid;
  char pid_r_[4];
};

/* 3891 */
struct getpgrp_args
{
  int32_t dummy;
};

/* 3892 */
struct getppid_args
{
  int32_t dummy;
};

/* 3893 */
struct getpid_args
{
  int32_t dummy;
};

/* 3894 */
struct setprivexec_args
{
  int flag;
  char flag_r_[4];
};

/* 3895 */
typedef int (*kobject_filter_cbfunc_t)(proc_t, int, int);

/* 3896 */
typedef int (*syscall_filter_cbfunc_t)(proc_t, int);

/* 3897 */
struct syscall_filter_callbacks
{
  int version;
  const syscall_filter_cbfunc_t unix_filter_cbfunc;
  const syscall_filter_cbfunc_t mach_filter_cbfunc;
  const kobject_filter_cbfunc_t kobj_filter_cbfunc;
};

/* 3898 */
struct proc_trace_log_args
{
  pid_t pid;
  char pid_r_[4];
  uint64_t uniqueid;
  char uniqueid_r_[];
};

/* 3899 */
struct csops_audittoken_args
{
  pid_t pid;
  char pid_r_[4];
  uint32_t ops;
  char ops_r_[4];
  user_addr_t_0 useraddr;
  user_size_t usersize;
  user_addr_t_0 uaudittoken;
  char uaudittoken_r_[];
};

/* 3900 */
struct csops_args
{
  pid_t pid;
  char pid_r_[4];
  uint32_t ops;
  char ops_r_[4];
  user_addr_t_0 useraddr;
  user_size_t usersize;
  char usersize_r_[];
};

/* 3901 */
typedef syscall_filter_callbacks *syscall_filter_cbs_t;

/* 3902 */
typedef int (*proc_iterate_fn_t)(proc_t, void *);

/* 3903 */
struct __attribute__((aligned(8))) pidlist_t
{
  struct
  {
    pidlist_entry *slh_first;
  } pl_head;
  pidlist_entry *pl_active;
  u_int pl_nalloc;
};

/* 7941 */
struct pidlist_entry
{
  struct
  {
    pidlist_entry *sle_next;
  } pe_link;
  u_int pe_nused;
  pid_t pe_pid[1021];
};

/* 3904 */
enum proc_require_flags_t : __int32
{
  PROC_REQUIRE_ALLOW_ALL = 0x0,
  PROC_REQUIRE_ALLOW_NULL = 0x1,
};

/* 3905 */
typedef const task_ro_data *task_ro_data_t;

/* 3906 */
typedef const proc_ro_data *proc_ro_data_t;

/* 3907 */
typedef uint64_t unaligned_u64;

/* 3908 */
struct no_paging_space
{
  uint64_t pcs_max_size;
  uint64_t pcs_uniqueid;
  int pcs_pid;
  int pcs_proc_count;
  uint64_t pcs_total_size;
  uint64_t npcs_max_size;
  uint64_t npcs_uniqueid;
  int npcs_pid;
  int npcs_proc_count;
  uint64_t npcs_total_size;
  int apcs_proc_count;
  uint64_t apcs_total_size;
};

/* 3909 */
typedef pidlist_entry pidlist_entry_t;

/* 3910 */
struct __attribute__((aligned(8))) fixjob_iterargs
{
  pgrp *pg;
  session *mysession;
  int entering;
};

/* 3911 */
struct sesshashhead
{
  session *lh_first;
};

/* 3912 */
struct uidinfo
{
  struct
  {
    uidinfo *le_next;
    uidinfo **le_prev;
  } ui_hash;
  uid_t ui_uid;
  size_t ui_proccnt;
};

/* 3913 */
struct uihashhead
{
  uidinfo *lh_first;
};

/* 3914 */
struct pgrp_hash_traits
{
  smrh_traits smrht;
};

/* 3916 */
struct pid_hash_traits
{
  smrh_traits smrht;
};

/* 7942 */
enum e_persona_reset_op : __int32
{
  e_persona_reset_op::PROC_REMOVE_PERSONA = 0x1,
  e_persona_reset_op::PROC_RESET_OLD_PERSONA = 0x2,
};

/* 3917 */
typedef e_persona_reset_op persona_reset_op_t;

/* 3918 */
struct mremap_encrypted_args
{
  user_addr_t_0 addr;
  user_size_t len;
  uint32_t cryptid;
  char cryptid_r_[4];
  uint32_t cputype;
  char cputype_r_[4];
  uint32_t cpusubtype;
  char cpusubtype_r_[4];
};

/* 3919 */
enum crypt_origin_t : __int32
{
  CRYPT_ORIGIN_ANY = 0x0,
  CRYPT_ORIGIN_APP_LAUNCH = 0x1,
  CRYPT_ORIGIN_LIBRARY_LOAD = 0x2,
  CRYPT_ORIGIN_MAX = 0x3,
};

/* 3920 */
struct munlockall_args
{
  int how;
  char how_r_[4];
};

/* 3921 */
struct mlockall_args
{
  int how;
  char how_r_[4];
};

/* 3922 */
struct munlock_args
{
  user_addr_t_0 addr;
  user_size_t len;
  char len_r_[];
};

/* 3923 */
struct mlock_args
{
  user_addr_t_0 addr;
  user_size_t len;
  char len_r_[];
};

/* 3924 */
struct mincore_args
{
  user_addr_t_0 addr;
  user_size_t len;
  user_addr_t_0 vec;
  char vec_r_[];
};

/* 3925 */
struct madvise_args
{
  user_addr_t_0 addr;
  user_size_t len;
  int behav;
  char behav_r_[4];
};

/* 3926 */
struct minherit_args
{
  user_addr_t_0 addr;
  user_size_t len;
  int inherit;
  char inherit_r_[4];
};

/* 3927 */
struct mprotect_args
{
  user_addr_t_0 addr;
  user_size_t len;
  int prot;
  char prot_r_[4];
};

/* 3928 */
struct munmap_args
{
  user_addr_t_0 addr;
  user_size_t len;
  char len_r_[];
};

/* 3929 */
struct msync_args
{
  user_addr_t_0 addr;
  user_size_t len;
  int flags;
  char flags_r_[4];
};

/* 3931 */
struct vm_page_info_basic
{
  int disposition;
  int ref_count;
  vm_object_id_t object_id;
  memory_object_offset_t offset;
  int depth;
  int __pad;
};

/* 3932 */
struct msync_nocancel_args
{
  user_addr_t_0 addr;
  user_size_t len;
  int flags;
  char flags_r_[4];
};

/* 3933 */
struct __attribute__((aligned(8))) _OSMallocTag_
{
  queue_chain_t_0 OSMT_link;
  uint32_t OSMT_refcnt;
  uint32_t OSMT_state;
  uint32_t OSMT_attr;
  char OSMT_name[64];
};

/* 3934 */
typedef _OSMallocTag_ *OSMallocTag;

/* 3935 */
struct fork_args
{
  int32_t dummy;
};

/* 3936 */
typedef thread_ro *thread_ro_t;

/* 3937 */
struct vnop_advlock_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  caddr_t a_id;
  int a_op;
  flock *a_fl;
  int a_flags;
  vfs_context_t a_context;
  timespec *a_timeout;
};

/* 3939 */
struct waitid_args
{
  idtype_t idtype;
  char idtype_r_[4];
  id_t id;
  char id_r_[4];
  user_addr_t_0 infop;
  int options;
  char options_r_[4];
};

/* 3940 */
struct wait4_args
{
  int pid;
  char pid_r_[4];
  user_addr_t_0 status;
  int options;
  char options_r_[4];
  user_addr_t_0 rusage;
  char rusage_r_[];
};

/* 3941 */
struct exit_args
{
  int rval;
  char rval_r_[4];
};

/* 3942 */
struct os_fault_with_payload_args
{
  uint32_t reason_namespace;
  char reason_namespace_r_[4];
  uint64_t reason_code;
  user_addr_t_0 payload;
  uint32_t payload_size;
  char payload_size_r_[4];
  user_addr_t_0 reason_string;
  uint64_t reason_flags;
  char reason_flags_r_[];
};

/* 3943 */
struct abort_with_payload_args
{
  uint32_t reason_namespace;
  char reason_namespace_r_[4];
  uint64_t reason_code;
  user_addr_t_0 payload;
  uint32_t payload_size;
  char payload_size_r_[4];
  user_addr_t_0 reason_string;
  uint64_t reason_flags;
  char reason_flags_r_[];
};

/* 3944 */
typedef errno_t (*backtrace_user_copy_fn)(void *, void *, user_addr_t_0, size_t);

/* 3945 */
struct user64_rusage
{
  user64_timeval ru_utime;
  user64_timeval ru_stime;
  user64_long_t ru_maxrss;
  user64_long_t ru_ixrss;
  user64_long_t ru_idrss;
  user64_long_t ru_isrss;
  user64_long_t ru_minflt;
  user64_long_t ru_majflt;
  user64_long_t ru_nswap;
  user64_long_t ru_inblock;
  user64_long_t ru_oublock;
  user64_long_t ru_msgsnd;
  user64_long_t ru_msgrcv;
  user64_long_t ru_nsignals;
  user64_long_t ru_nvcsw;
  user64_long_t ru_nivcsw;
};

/* 3946 */
struct user32_rusage
{
  user32_timeval ru_utime;
  user32_timeval ru_stime;
  user32_long_t ru_maxrss;
  user32_long_t ru_ixrss;
  user32_long_t ru_idrss;
  user32_long_t ru_isrss;
  user32_long_t ru_minflt;
  user32_long_t ru_majflt;
  user32_long_t ru_nswap;
  user32_long_t ru_inblock;
  user32_long_t ru_oublock;
  user32_long_t ru_msgsnd;
  user32_long_t ru_msgrcv;
  user32_long_t ru_nsignals;
  user32_long_t ru_nvcsw;
  user32_long_t ru_nivcsw;
};

/* 3947 */
typedef kcdata_descriptor *kcdata_descriptor_t;

/* 3948 */
typedef int exception_type_t;

/* 3949 */
struct btinfo_thread_state_data_t
{
  uint32_t flavor;
  uint32_t count;
  int tstate[];
};

/* 3950 */
typedef mach_exception_data_type_t *mach_exception_data_t;

/* 3951 */
typedef uintptr_t current_thread_collect_backtrace_info::user_btframe_t;

/* 3952 */
struct kcdata_item
{
  uint32_t type;
  uint32_t size;
  uint64_t flags;
  char data[];
};

/* 3953 */
typedef kcdata_item *kcdata_item_t;

/* 3954 */
struct kcdata_iter
{
  kcdata_item_t item;
  void *end;
};

/* 3955 */
struct posix_spawn_args
{
  user_addr_t_0 pid;
  user_addr_t_0 path;
  user_addr_t_0 adesc;
  user_addr_t_0 argv;
  user_addr_t_0 envp;
  char envp_r_[];
};

/* 3956 */
typedef uint8_t dyld_bool;

/* 3957 */
struct exec_port_actions
{
  uint32_t portwatch_count;
  uint32_t registered_count;
  ipc_port_t_0 *portwatch_array;
  ipc_port_t_0 *registered_array;
};

/* 3958 */
enum psfa_t : __int32
{
  PSFA_OPEN = 0x0,
  PSFA_CLOSE = 0x1,
  PSFA_DUP2 = 0x2,
  PSFA_INHERIT = 0x3,
  PSFA_FILEPORT_DUP2 = 0x4,
  PSFA_CHDIR = 0x5,
  PSFA_FCHDIR = 0x6,
};

/* 3959 */
typedef _psfa_action _psfa_action_t;

/* 9264 */
struct _psfa_action
{
  psfa_t psfaa_type;
  union
  {
    int psfaa_filedes;
    mach_port_name_t psfaa_fileport;
  };
  union
  {
    struct __attribute__((aligned(4)))
    {
      int psfao_oflag;
      mode_t psfao_mode;
      char psfao_path[1024];
    } psfaa_openargs;
    struct
    {
      int psfad_newfiledes;
    } psfaa_dup2args;
    struct
    {
      char psfac_path[1024];
    } psfaa_chdirargs;
  };
};

/* 3960 */
struct _posix_spawn_file_actions
{
  int psfa_act_alloc;
  int psfa_act_count;
  _psfa_action_t psfa_act_acts[];
};

/* 3961 */
struct user32_dyld_all_image_infos
{
  uint32_t version;
  uint32_t infoArrayCount;
  user32_addr_t infoArray;
  user32_addr_t notification;
  dyld_bool processDetachedFromSharedRegion;
  dyld_bool libSystemInitialized;
  user32_addr_t dyldImageLoadAddress;
  user32_addr_t jitInfo;
  user32_addr_t dyldVersion;
  user32_addr_t errorMessage;
  user32_addr_t terminationFlags;
  user32_addr_t coreSymbolicationShmPage;
  user32_addr_t systemOrderFlag;
  user32_size_t uuidArrayCount;
  user32_addr_t uuidArray;
  user32_addr_t dyldAllImageInfosAddress;
  user32_addr_t initialImageCount;
  user32_addr_t errorKind;
  user32_addr_t errorClientOfDylibPath;
  user32_addr_t errorTargetDylibPath;
  user32_addr_t errorSymbol;
  user32_addr_t sharedCacheSlide;
  uint8_t sharedCacheUUID[16];
  user32_addr_t sharedCacheBaseAddress;
  uint64_t timestamp;
  user32_addr_t dyldpath;
  mach_port_name_t notifyMachPorts[8];
  user32_addr_t reserved[5];
  user32_addr_t compact_dyld_image_info_addr;
  user32_size_t compact_dyld_image_info_size;
};

/* 3962 */
struct user64_dyld_all_image_infos
{
  uint32_t version;
  uint32_t infoArrayCount;
  user64_addr_t infoArray;
  user64_addr_t notification;
  dyld_bool processDetachedFromSharedRegion;
  dyld_bool libSystemInitialized;
  user64_addr_t dyldImageLoadAddress;
  user64_addr_t jitInfo;
  user64_addr_t dyldVersion;
  user64_addr_t errorMessage;
  user64_addr_t terminationFlags;
  user64_addr_t coreSymbolicationShmPage;
  user64_addr_t systemOrderFlag;
  user64_size_t uuidArrayCount;
  user64_addr_t uuidArray;
  user64_addr_t dyldAllImageInfosAddress;
  user64_addr_t initialImageCount;
  user64_addr_t errorKind;
  user64_addr_t errorClientOfDylibPath;
  user64_addr_t errorTargetDylibPath;
  user64_addr_t errorSymbol;
  user64_addr_t sharedCacheSlide;
  uint8_t sharedCacheUUID[16];
  user64_addr_t sharedCacheBaseAddress;
  uint64_t timestamp;
  user64_addr_t dyldPath;
  mach_port_name_t notifyMachPorts[8];
  user64_addr_t reserved[9];
  user64_addr_t compact_dyld_image_info_addr;
  user64_size_t compact_dyld_image_info_size;
  uint32_t platform;
  uint32_t aotInfoArrayCount;
  user64_addr_t aotInfoArray;
  uint64_t aotTimestamp;
};

/* 3963 */
typedef int load_return_t;

/* 7081 */
typedef natural_t iv_index_t;

/* 3964 */
struct ipc_voucher
{
  os_ref_atomic_t iv_refs;
  iv_index_t iv_table[8];
  ipc_port_t_1 iv_port;
  smrq_slink iv_hash_link;
};

/* 3981 */
typedef errno_t (*ctl_connect_func)(kern_ctl_ref, sockaddr_ctl *, void **);

/* 3980 */
typedef errno_t (*ctl_disconnect_func)(kern_ctl_ref, u_int32_t, void *);

/* 3979 */
typedef errno_t (*ctl_send_func)(kern_ctl_ref, u_int32_t, void *, mbuf_t, int);

/* 3977 */
typedef errno_t (*ctl_setopt_func)(kern_ctl_ref, u_int32_t, void *, int, void *, size_t);

/* 3976 */
typedef errno_t (*ctl_getopt_func)(kern_ctl_ref, u_int32_t, void *, int, void *, size_t *);

/* 3975 */
typedef void (*ctl_rcvd_func)(kern_ctl_ref, u_int32_t, void *, int);

/* 3978 */
typedef errno_t (*ctl_send_list_func)(kern_ctl_ref, u_int32_t, void *, mbuf_t, int);

/* 3982 */
typedef errno_t (*ctl_bind_func)(kern_ctl_ref, sockaddr_ctl *, void **);

/* 3983 */
typedef errno_t (*ctl_setup_func)(u_int32_t *, void **);

/* 3970 */
struct kern_ctl_reg
{
  char ctl_name[96];
  u_int32_t ctl_id;
  u_int32_t ctl_unit;
  u_int32_t ctl_flags;
  u_int32_t ctl_sendsize;
  u_int32_t ctl_recvsize;
  ctl_connect_func ctl_connect;
  ctl_disconnect_func ctl_disconnect;
  ctl_send_func ctl_send;
  ctl_setopt_func ctl_setopt;
  ctl_getopt_func ctl_getopt;
  ctl_rcvd_func ctl_rcvd;
  ctl_send_list_func ctl_send_list;
  ctl_bind_func ctl_bind;
  ctl_setup_func ctl_setup;
};

/* 3974 */
struct sockaddr_ctl
{
  u_char sc_len;
  u_char sc_family;
  u_int16_t ss_sysaddr;
  u_int32_t sc_id;
  u_int32_t sc_unit;
  u_int32_t sc_reserved[5];
};

/* 3971 */
struct xkctlpcb
{
  u_int32_t xkp_len;
  u_int32_t xkp_kind;
  u_int64_t xkp_kctpcb;
  u_int32_t xkp_unit;
  u_int32_t xkp_kctlid;
  u_int64_t xkp_kctlref;
  char xkp_kctlname[96];
};

/* 3972 */
struct xkctl_reg
{
  u_int32_t xkr_len;
  u_int32_t xkr_kind;
  u_int32_t xkr_id;
  u_int32_t xkr_reg_unit;
  u_int32_t xkr_flags;
  u_int64_t xkr_kctlref;
  u_int32_t xkr_recvbufsize;
  u_int32_t xkr_sendbufsize;
  u_int32_t xkr_lastunit;
  u_int32_t xkr_pcbcount;
  u_int64_t xkr_connect;
  u_int64_t xkr_disconnect;
  u_int64_t xkr_send;
  u_int64_t xkr_send_list;
  u_int64_t xkr_setopt;
  u_int64_t xkr_getopt;
  u_int64_t xkr_rcvd;
  char xkr_name[96];
};

/* 3973 */
struct __attribute__((aligned(8))) ctl_cb
{
  struct
  {
    ctl_cb *tqe_next;
    ctl_cb **tqe_prev;
  } next;
  lck_mtx_t mtx;
  socket *so;
  kctl *kctl;
  void *userdata;
  sockaddr_ctl sac;
  u_int32_t usecount;
  u_int32_t kcb_usecount;
  u_int32_t require_clearing_count;
};

/* 3984 */
struct __attribute__((aligned(8))) kctl
{
  struct
  {
    kctl *tqe_next;
    kctl **tqe_prev;
  } next;
  kern_ctl_ref kctlref;
  char name[96];
  u_int32_t id;
  u_int32_t reg_unit;
  u_int32_t flags;
  u_int32_t recvbufsize;
  u_int32_t sendbufsize;
  ctl_setup_func setup;
  ctl_bind_func bind;
  ctl_connect_func connect;
  ctl_disconnect_func disconnect;
  ctl_send_func send;
  ctl_send_list_func send_list;
  ctl_setopt_func setopt;
  ctl_getopt_func getopt;
  ctl_rcvd_func rcvd;
  struct
  {
    ctl_cb *tqh_first;
    ctl_cb **tqh_last;
  } kcb_head;
  u_int32_t lastunit;
};

/* 3985 */
struct kevent_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 changelist;
  int nchanges;
  char nchanges_r_[4];
  user_addr_t_0 eventlist;
  int nevents;
  char nevents_r_[4];
  user_addr_t_0 timeout;
  char timeout_r_[];
};

/* 3986 */
struct kevent_qos_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 changelist;
  int nchanges;
  char nchanges_r_[4];
  user_addr_t_0 eventlist;
  int nevents;
  char nevents_r_[4];
  user_addr_t_0 data_out;
  user_addr_t_0 data_available;
  unsigned int flags;
  char flags_r_[4];
};

/* 3987 */
struct kevent_id_args
{
  uint64_t id;
  user_addr_t_0 changelist;
  int nchanges;
  char nchanges_r_[4];
  user_addr_t_0 eventlist;
  int nevents;
  char nevents_r_[4];
  user_addr_t_0 data_out;
  user_addr_t_0 data_available;
  unsigned int flags;
  char flags_r_[4];
};

/* 3988 */
struct kqueue_workloop_ctl_args
{
  user_addr_t_0 cmd;
  uint64_t options;
  user_addr_t_0 addr;
  user_size_t sz;
  char sz_r_[];
};

/* 3989 */
struct kqueue_args
{
  int32_t dummy;
};

/* 3990 */
struct kqueue_dyninfo
{
  kqueue_info kqdi_info;
  uint64_t kqdi_servicer;
  uint64_t kqdi_owner;
  uint32_t kqdi_sync_waiters;
  uint8_t kqdi_sync_waiter_qos;
  uint8_t kqdi_async_qos;
  uint16_t kqdi_request_state;
  uint8_t kqdi_events_qos;
  uint8_t kqdi_pri;
  uint8_t kqdi_pol;
  uint8_t kqdi_cpupercent;
  uint8_t _kqdi_reserved0[4];
  uint64_t _kqdi_reserved1[4];
};

/* 3991 */
typedef int (*kevent_callback_t)(kevent_qos_s *, kevent_ctx_s *);

/* 3992 */
struct kqueue_workloop_params
{
  int kqwlp_version;
  int kqwlp_flags;
  uint64_t kqwlp_id;
  int kqwlp_sched_pri;
  int kqwlp_sched_pol;
  int kqwlp_cpu_percent;
  int kqwlp_cpu_refillms;
};

/* 3993 */
typedef void (*fp_initfn_t)(fileproc *, void *);

/* 3994 */
struct filt_timer_params
{
  uint64_t deadline;
  uint64_t leeway;
  uint64_t interval;
};

/* 3995 */
union kqueue_t
{
  kqueue *kq;
  kqworkq *kqwq;
  kqfile *kqf;
  kqworkloop *kqwl;
};

/* 3996 */
struct kern_event_msg
{
  u_int32_t total_size;
  u_int32_t vendor_code;
  u_int32_t kev_class;
  u_int32_t kev_subclass;
  u_int32_t id;
  u_int32_t event_code;
  u_int32_t event_data[];
};

/* 3997 */
struct kev_vendor_code
{
  u_int32_t vendor_code;
  char vendor_string[200];
};

/* 3998 */
struct kev_request
{
  u_int32_t vendor_code;
  u_int32_t kev_class;
  u_int32_t kev_subclass;
};

/* 3999 */
struct kevent_extinfo
{
  kevent_qos_s kqext_kev;
  uint64_t kqext_sdata;
  int kqext_status;
  int kqext_sfflags;
  uint64_t kqext_reserved[2];
};

/* 4000 */
struct __attribute__((aligned(8))) xkevtpcb
{
  u_int32_t kep_len;
  u_int32_t kep_kind;
  u_int64_t kep_evtpcb;
  u_int32_t kep_vendor_code_filter;
  u_int32_t kep_class_filter;
  u_int32_t kep_subclass_filter;
};

/* 4001 */
struct guarded_writev_np_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 guard;
  user_addr_t_0 iovp;
  int iovcnt;
  char iovcnt_r_[4];
};

/* 4002 */
struct guarded_pwrite_np_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 guard;
  user_addr_t_0 buf;
  user_size_t nbyte;
  off_t offset;
  char offset_r_[];
};

/* 4003 */
struct guarded_write_np_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 guard;
  user_addr_t_0 cbuf;
  user_size_t nbyte;
  char nbyte_r_[];
};

/* 4004 */
struct change_fdguard_np_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 guard;
  u_int guardflags;
  char guardflags_r_[4];
  user_addr_t_0 nguard;
  u_int nguardflags;
  char nguardflags_r_[4];
  user_addr_t_0 fdflagsp;
  char fdflagsp_r_[];
};

/* 4005 */
struct guarded_close_np_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 guard;
  char guard_r_[];
};

/* 4006 */
struct guarded_kqueue_np_args
{
  user_addr_t_0 guard;
  u_int guardflags;
  char guardflags_r_[4];
};

/* 4007 */
struct guarded_open_dprotected_np_args
{
  user_addr_t_0 path;
  user_addr_t_0 guard;
  u_int guardflags;
  char guardflags_r_[4];
  int flags;
  char flags_r_[4];
  int dpclass;
  char dpclass_r_[4];
  int dpflags;
  char dpflags_r_[4];
  int mode;
  char mode_r_[4];
};

/* 4008 */
struct guarded_open_np_args
{
  user_addr_t_0 path;
  user_addr_t_0 guard;
  u_int guardflags;
  char guardflags_r_[4];
  int flags;
  char flags_r_[4];
  int mode;
  char mode_r_[4];
};

/* 4009 */
struct fileport_makefd_args
{
  mach_port_name_t port;
  char port_r_[4];
};

/* 4010 */
struct fileport_makeport_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 portnamep;
  char portnamep_r_[];
};

/* 4011 */
struct flock_args
{
  int fd;
  char fd_r_[4];
  int how;
  char how_r_[4];
};

/* 4012 */
struct fpathconf_args
{
  int fd;
  char fd_r_[4];
  int name;
  char name_r_[4];
};

/* 4013 */
struct fstat64_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 ub;
  char ub_r_[];
};

/* 4014 */
struct fstat64_extended_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 ub;
  user_addr_t_0 xsecurity;
  user_addr_t_0 xsecurity_size;
  char xsecurity_size_r_[];
};

/* 4015 */
struct fstat_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 ub;
  char ub_r_[];
};

/* 4016 */
struct fstat_extended_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 ub;
  user_addr_t_0 xsecurity;
  user_addr_t_0 xsecurity_size;
  char xsecurity_size_r_[];
};

/* 4017 */
struct close_nocancel_args
{
  int fd;
  char fd_r_[4];
};

/* 4018 */
struct close_args
{
  int fd;
  char fd_r_[4];
};

/* 4019 */
struct fassertbgaccess
{
  unsigned int fbga_flags;
  unsigned int reserved;
  unsigned __int64 ttl;
};

/* 4021 */
struct fcntl_args
{
  int fd;
  char fd_r_[4];
  int cmd;
  char cmd_r_[4];
  user_long_t arg;
  char arg_r_[];
};

/* 4022 */
struct dup2_args
{
  u_int from;
  char from_r_[4];
  u_int to;
  char to_r_[4];
};

/* 4023 */
struct dup_args
{
  u_int fd;
  char fd_r_[4];
};

/* 4024 */
struct getdtablesize_args
{
  int32_t dummy;
};

/* 4025 */
struct user32_stat64
{
  dev_t st_dev;
  mode_t st_mode;
  nlink_t st_nlink;
  ino64_t st_ino;
  uid_t st_uid;
  gid_t st_gid;
  dev_t st_rdev;
  user32_timespec st_atimespec;
  user32_timespec st_mtimespec;
  user32_timespec st_ctimespec;
  user32_timespec st_birthtimespec;
  off_t st_size;
  blkcnt_t st_blocks;
  blksize_t st_blksize;
  __uint32_t st_flags;
  __uint32_t st_gen;
  __uint32_t st_lspare;
  __int64_t st_qspare[2];
};

/* 4026 */
struct user64_stat64
{
  dev_t st_dev;
  mode_t st_mode;
  nlink_t st_nlink;
  ino64_t st_ino;
  uid_t st_uid;
  gid_t st_gid;
  dev_t st_rdev;
  user64_timespec st_atimespec;
  user64_timespec st_mtimespec;
  user64_timespec st_ctimespec;
  user64_timespec st_birthtimespec;
  off_t st_size;
  blkcnt_t st_blocks;
  blksize_t st_blksize;
  __uint32_t st_flags;
  __uint32_t st_gen;
  __uint32_t st_lspare;
  __int64_t st_qspare[2];
};

/* 4027 */
struct user32_stat
{
  dev_t st_dev;
  ino_t st_ino;
  mode_t st_mode;
  nlink_t st_nlink;
  uid_t st_uid;
  gid_t st_gid;
  dev_t st_rdev;
  user32_timespec st_atimespec;
  user32_timespec st_mtimespec;
  user32_timespec st_ctimespec;
  off_t st_size;
  blkcnt_t st_blocks;
  blksize_t st_blksize;
  __uint32_t st_flags;
  __uint32_t st_gen;
  __int32_t st_lspare;
  __int64_t st_qspare[2];
};

/* 4028 */
struct user64_stat
{
  dev_t st_dev;
  ino_t st_ino;
  mode_t st_mode;
  nlink_t st_nlink;
  uid_t st_uid;
  gid_t st_gid;
  dev_t st_rdev;
  user64_timespec st_atimespec;
  user64_timespec st_mtimespec;
  user64_timespec st_ctimespec;
  off_t st_size;
  blkcnt_t st_blocks;
  blksize_t st_blksize;
  __uint32_t st_flags;
  __uint32_t st_gen;
  __int32_t st_lspare;
  __int64_t st_qspare[2];
};

/* 4029 */
struct kauth_filesec
{
  u_int32_t fsec_magic;
  guid_t_0 fsec_owner;
  guid_t_0 fsec_group;
  kauth_acl fsec_acl;
};

/* 4030 */
struct fcntl_nocancel_args
{
  int fd;
  char fd_r_[4];
  int cmd;
  char cmd_r_[4];
  user_long_t arg;
  char arg_r_[];
};

/* 4031 */
typedef void (*kern_get_file_extents_callback_t)(void *, uint64_t, uint64_t);

/* 4032 */
struct debug_syscall_reject_args
{
  uint64_t packed_selectors;
  char packed_selectors_r_[];
};

/* 4033 */
struct debug_syscall_reject_config_args
{
  uint64_t packed_selectors1;
  uint64_t packed_selectors2;
  uint64_t flags;
  char flags_r_[];
};

/* 4034 */
struct csrctl_args
{
  uint32_t op;
  char op_r_[4];
  user_addr_t_0 useraddr;
  user_addr_t_0 usersize;
  char usersize_r_[];
};

/* 4035 */
struct crossarch_trap_args
{
  uint32_t name;
  char name_r_[4];
};

/* 4036 */
typedef au_session au_session_t;

/* 4037 */
struct identitysvc_args
{
  int opcode;
  char opcode_r_[4];
  user_addr_t_0 message;
  char message_r_[];
};

/* 4038 */
typedef posix_cred *posix_cred_t;

/* 4039 */
struct supgroups
{
  size_t *count;
  gid_t *groups;
};

/* 4043 */
struct ntsid_t
{
  u_int8_t sid_kind;
  u_int8_t sid_authcount;
  u_int8_t sid_authority[6];
  u_int32_t sid_authorities[16];
};

/* 4040 */
struct kauth_identity
{
  struct
  {
    kauth_identity *tqe_next;
    kauth_identity **tqe_prev;
  } ki_link;
  int ki_valid;
  uid_t ki_uid;
  gid_t ki_gid;
  uint32_t ki_supgrpcnt;
  gid_t ki_supgrps[16];
  guid_t_0 ki_guid;
  ntsid_t ki_ntsid;
  const char *ki_name;
  time_t ki_groups_expiry;
  time_t ki_guid_expiry;
  time_t ki_ntsid_expiry;
};

/* 4041 */
struct kauth_cred_entry_head
{
  ucred_rw *lh_first;
};

/* 4042 */
struct __attribute__((aligned(8))) kauth_group_membership
{
  struct
  {
    kauth_group_membership *tqe_next;
    kauth_group_membership **tqe_prev;
  } gm_link;
  uid_t gm_uid;
  gid_t gm_gid;
  time_t gm_expiry;
  int gm_flags;
};

/* 4044 */
struct __attribute__((aligned(8))) kauth_identity_extlookup
{
  u_int32_t el_seqno;
  u_int32_t el_result;
  u_int32_t el_flags;
  __darwin_pid_t el_info_pid;
  u_int64_t el_extend;
  u_int32_t el_info_reserved_1;
  uid_t el_uid;
  guid_t_0 el_uguid;
  u_int32_t el_uguid_valid;
  ntsid_t el_usid;
  u_int32_t el_usid_valid;
  gid_t el_gid;
  guid_t_0 el_gguid;
  u_int32_t el_gguid_valid;
  ntsid_t el_gsid;
  u_int32_t el_gsid_valid;
  u_int32_t el_member_valid;
  u_int32_t el_sup_grp_cnt;
  gid_t el_sup_groups[16];
};

/* 4045 */
struct kauth_resolver_work
{
  struct
  {
    kauth_resolver_work *tqe_next;
    kauth_resolver_work **tqe_prev;
  } kr_link;
  kauth_identity_extlookup kr_work;
  uint64_t kr_extend;
  uint32_t kr_seqno;
  int kr_refs;
  int kr_flags;
  int kr_result;
};

/* 4046 */
typedef int vm_behavior_t;

/* 4047 */
struct tir_t
{
  vm_offset_t_0 header;
  size_t hoffset;
  mythread_state_flavor_t *flavors;
  size_t tstate_size;
  size_t flavor_count;
};

/* 4049 */
struct mythread_state_flavor_t
{
  int flavor;
  mach_msg_type_number_t count;
};

/* 4048 */
struct note_command
{
  uint32_t cmd;
  uint32_t cmdsize;
  char data_owner[16];
  uint64_t offset;
  uint64_t size;
};

/* 4050 */
typedef void (*timeout_fcn_t)(void *);

/* 4051 */
typedef kauth_ace *kauth_ace_t;

/* 4052 */
struct kauth_acl_eval
{
  kauth_ace_t ae_acl;
  int ae_count;
  kauth_ace_rights_t ae_requested;
  kauth_ace_rights_t ae_residual;
  int ae_result;
  boolean_t ae_found_deny;
  int ae_options;
  kauth_ace_rights_t ae_exp_gall;
  kauth_ace_rights_t ae_exp_gread;
  kauth_ace_rights_t ae_exp_gwrite;
  kauth_ace_rights_t ae_exp_gexec;
};

/* 4053 */
typedef kauth_acl_eval *kauth_acl_eval_t;

/* 4054 */
typedef int (*kauth_scope_callback_t)(kauth_cred_t, void *, kauth_action_t, uintptr_t, uintptr_t, uintptr_t, uintptr_t);

/* 4055 */
struct kauth_listener
{
  struct
  {
    kauth_listener *tqe_next;
    kauth_listener **tqe_prev;
  } kl_link;
  const char *kl_identifier;
  kauth_scope_callback_t kl_callback;
  void *kl_idata;
};

/* 4056 */
typedef kauth_listener *kauth_listener_t;

/* 4057 */
struct kauth_local_listener
{
  kauth_listener_t kll_listenerp;
  kauth_scope_callback_t kll_callback;
  void *kll_idata;
};

/* 4058 */
struct __attribute__((aligned(8))) kauth_scope
{
  struct
  {
    kauth_scope *tqe_next;
    kauth_scope **tqe_prev;
  } ks_link;
  volatile kauth_local_listener ks_listeners[15];
  const char *ks_identifier;
  kauth_scope_callback_t ks_callback;
  void *ks_idata;
  u_int ks_flags;
};

/* 4059 */
typedef kauth_scope *kauth_scope_t;

/* 4060 */
struct lio_listio_args
{
  int mode;
  char mode_r_[4];
  user_addr_t_0 aiocblist;
  int nent;
  char nent_r_[4];
  user_addr_t_0 sigp;
  char sigp_r_[];
};

/* 4061 */
struct aio_write_args
{
  user_addr_t_0 aiocbp;
  char aiocbp_r_[];
};

/* 4062 */
struct aio_suspend_args
{
  user_addr_t_0 aiocblist;
  int nent;
  char nent_r_[4];
  user_addr_t_0 timeoutp;
  char timeoutp_r_[];
};

/* 4063 */
struct aio_return_args
{
  user_addr_t_0 aiocbp;
  char aiocbp_r_[];
};

/* 4064 */
struct aio_read_args
{
  user_addr_t_0 aiocbp;
  char aiocbp_r_[];
};

/* 4065 */
struct aio_fsync_args
{
  int op;
  char op_r_[4];
  user_addr_t_0 aiocbp;
  char aiocbp_r_[];
};

/* 4066 */
struct aio_error_args
{
  user_addr_t_0 aiocbp;
  char aiocbp_r_[];
};

/* 4067 */
struct aio_cancel_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 aiocbp;
  char aiocbp_r_[];
};

/* 4068 */
struct user64_sigevent
{
  int sigev_notify;
  int sigev_signo;
  user64_sigval sigev_value;
  user64_addr_t sigev_notify_function;
  user64_addr_t sigev_notify_attributes;
};

/* 4070 */
typedef __int64_t user64_off_t;

/* 4071 */
struct __attribute__((aligned(8))) user64_aiocb
{
  int aio_fildes;
  user64_off_t aio_offset;
  user64_addr_t aio_buf;
  user64_size_t aio_nbytes;
  int aio_reqprio;
  user64_sigevent aio_sigevent;
  int aio_lio_opcode;
};

/* 4072 */
struct user32_sigevent
{
  int sigev_notify;
  int sigev_signo;
  user32_sigval sigev_value;
  user32_addr_t sigev_notify_function;
  user32_addr_t sigev_notify_attributes;
};

/* 4073 */
typedef __int64_t user32_off_t;

/* 4074 */
struct __attribute__((aligned(8))) user32_aiocb
{
  int aio_fildes;
  user32_off_t aio_offset;
  user32_addr_t aio_buf;
  user32_size_t aio_nbytes;
  int aio_reqprio;
  user32_sigevent aio_sigevent;
  int aio_lio_opcode;
};

/* 4075 */
struct aio_suspend_nocancel_args
{
  user_addr_t_0 aiocblist;
  int nent;
  char nent_r_[4];
  user_addr_t_0 timeoutp;
  char timeoutp_r_[];
};

/* 4078 */
struct aio_workq
{
  struct
  {
    aio_workq_entry *tqh_first;
    aio_workq_entry **tqh_last;
  } aioq_entries;
  lck_spin_t aioq_lock;
  waitq aioq_waitq;
};

/* 4079 */
struct aio_anchor_cb
{
  volatile int aio_total_count;
  int aio_num_workqs;
  aio_workq aio_async_workqs[1];
};

/* 4080 */
struct acct_args
{
  user_addr_t_0 path;
  char path_r_[];
};

/* 4081 */
struct kdebug_trace_string_args
{
  uint32_t debugid;
  char debugid_r_[4];
  uint64_t str_id;
  user_addr_t_0 str;
  char str_r_[];
};

/* 4082 */
struct kdebug_trace_args
{
  uint32_t code;
  char code_r_[4];
  user_ulong_t arg1;
  user_ulong_t arg2;
  user_ulong_t arg3;
  user_ulong_t arg4;
  char arg4_r_[];
};

/* 4083 */
struct kdebug_typefilter_args
{
  user_addr_t_0 addr;
  user_addr_t_0 size;
  char size_r_[];
};

/* 4084 */
struct kd_cpumap_header
{
  uint32_t version_no;
  uint32_t cpu_count;
};

/* 4085 */
struct kdebug_trace64_args
{
  uint32_t code;
  char code_r_[4];
  uint64_t arg1;
  uint64_t arg2;
  uint64_t arg3;
  uint64_t arg4;
  char arg4_r_[];
};

/* 4087 */
typedef ml_topology_info ml_topology_info_t;

/* 4088 */
struct kd_cpumap
{
  uint32_t cpu_id;
  uint32_t flags;
  char name[8];
};

/* 4089 */
struct kd_cpumap_ext
{
  uint32_t cpu_id;
  uint32_t flags;
  char name[32];
};

/* 4090 */
typedef mpsc_daemon_queue *mpsc_daemon_queue_t;

/* 4091 */
typedef mpsc_queue_chain *mpsc_queue_chain_t;

/* 4093 */
typedef void (*mpsc_daemon_invoke_fn_t)(mpsc_queue_chain_t, mpsc_daemon_queue_t);

/* 4092 */
struct mpsc_queue_head
{
  mpsc_queue_chain mpqh_head;
  mpsc_queue_chain *mpqh_tail;
};

/* 7972 */
struct mpsc_daemon_queue
{
  _BYTE gap0[8];
  mpsc_daemon_invoke_fn_t mpd_invoke;
  union
  {
    mpsc_daemon_queue_t mpd_target;
    thread *mpd_thread;
    thread_call *mpd_call;
  };
  mpsc_queue_head mpd_queue;
  mpsc_queue_chain mpd_chain;
};

/* 4094 */
struct kd_threadmap
{
  uint64_t thread;
  int valid;
  char command[20];
};

/* 4109 */
typedef uint64_t kd_buf_argtype;

/* 4095 */
struct kd_buf
{
  uint64_t timestamp;
  kd_buf_argtype arg1;
  kd_buf_argtype arg2;
  kd_buf_argtype arg3;
  kd_buf_argtype arg4;
  kd_buf_argtype arg5;
  uint32_t debugid;
  uint32_t cpuid;
  kd_buf_argtype unused;
};

/* 4104 */
union kds_ptr
{
  struct
  {
    _BYTE gap0[4];
  };
  uint32_t raw;
};

/* 4096 */
struct kd_storage
{
  kds_ptr kds_next;
  uint32_t kds_bufindx;
  uint32_t kds_bufcnt;
  uint32_t kds_readlast;
  _BYTE gap10[8];
  uint64_t kds_timestamp;
  kd_buf kds_records[2048];
};

/* 4097 */
struct __attribute__((aligned(8))) kd_region
{
  kd_storage *kdr_addr;
  uint32_t kdr_size;
};

/* 4098 */
struct __attribute__((aligned(128))) kd_bufinfo
{
  kds_ptr kd_list_head;
  kds_ptr kd_list_tail;
  bool kd_lostevents;
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t _pad;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t kd_prev_timebase;
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t num_bufs;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t latest_past_event_timestamp;
  bool continuous_timestamps;
};

/* 4099 */
enum kd_callback_type : __int32
{
  KD_CALLBACK_KDEBUG_ENABLED = 0x0,
  KD_CALLBACK_KDEBUG_DISABLED = 0x1,
  KD_CALLBACK_SYNC_FLUSH = 0x2,
  KD_CALLBACK_TYPEFILTER_CHANGED = 0x3,
  KD_CALLBACK_SNAPSHOT_STATE = 0x4,
};

/* 4100 */
typedef void (*kd_callback_fn)(void *, kd_callback_type, void *);

/* 4101 */
typedef kd_callback kd_callback_t;

/* 7973 */
struct kd_callback
{
  kd_callback_fn func;
  void *context;
  char iop_name[8];
};

/* 4102 */
struct kd_coproc
{
  char full_name[32];
  _BYTE gap20[8];
  kd_callback_t callback;
  uint32_t cpu_id;
  kd_coproc *next;
  mpsc_queue_chain chain;
};

/* 4103 */
struct kd_event_matcher
{
  uint32_t kem_debugid;
  uint32_t kem_padding;
  uint64_t kem_args[4];
};

/* 4105 */
typedef ktriage_strings ktriage_strings_t;

/* 9269 */
struct ktriage_strings
{
  int num_strings;
  const char **strings;
};

/* 4106 */
struct kd_record
{
  int32_t cpu;
  uint32_t debugid;
  int64_t timestamp;
  kd_buf_argtype arg1;
  kd_buf_argtype arg2;
  kd_buf_argtype arg3;
  kd_buf_argtype arg4;
  kd_buf_argtype arg5;
};

/* 4107 */
struct kd_buffer
{
  int kdb_event_count;
  int kdb_storage_count;
  int kdb_storage_threshold;
  uint32_t kdb_region_count;
  kd_bufinfo *kdb_info;
  kd_region *kd_bufs;
  kd_buf *kdcopybuf;
};

/* 4108 */
struct kd_control
{
  kds_ptr kds_free_list;
  __attribute__((aligned(8))) uint32_t kdebug_events_per_storage_unit;
  uint32_t kdebug_min_storage_units_per_cpu;
  uint32_t kdebug_kdcopybuf_count;
  uint32_t kdebug_kdcopybuf_size;
  uint32_t kdebug_cpus;
  uint32_t alloc_cpus;
  uint32_t kdc_flags;
  _BYTE gap24[12];
  uint64_t kdc_oldest_time;
  int kdc_storage_used;
  lck_spin_t kdc_storage_lock;
  kd_coproc *kdc_coprocs;
  kd_event_matcher disable_event_match;
  kd_event_matcher disable_event_mask;
};

/* 4111 */
struct bsdthread_ctl_args
{
  user_addr_t_0 cmd;
  user_addr_t_0 arg1;
  user_addr_t_0 arg2;
  user_addr_t_0 arg3;
  char arg3_r_[];
};

/* 4112 */
struct workq_open_args
{
  int32_t dummy;
};

/* 4113 */
struct proc_workqueueinfo
{
  uint32_t pwq_nthreads;
  uint32_t pwq_runthreads;
  uint32_t pwq_blockedthreads;
  uint32_t pwq_state;
};

/* 4114 */
struct workq_kernreturn_args
{
  int options;
  char options_r_[4];
  user_addr_t_0 item;
  int affinity;
  char affinity_r_[4];
  int prio;
  char prio_r_[4];
};

/* 4115 */
typedef unsigned __int64 pthread_priority_t;

/* 4116 */
struct psynch_rw_downgrade_args
{
  user_addr_t_0 rwlock;
  uint32_t lgenval;
  char lgenval_r_[4];
  uint32_t ugenval;
  char ugenval_r_[4];
  uint32_t rw_wc;
  char rw_wc_r_[4];
  int flags;
  char flags_r_[4];
};

/* 4117 */
struct psynch_rw_upgrade_args
{
  user_addr_t_0 rwlock;
  uint32_t lgenval;
  char lgenval_r_[4];
  uint32_t ugenval;
  char ugenval_r_[4];
  uint32_t rw_wc;
  char rw_wc_r_[4];
  int flags;
  char flags_r_[4];
};

/* 4118 */
struct psynch_rw_yieldwrlock_args
{
  user_addr_t_0 rwlock;
  uint32_t lgenval;
  char lgenval_r_[4];
  uint32_t ugenval;
  char ugenval_r_[4];
  uint32_t rw_wc;
  char rw_wc_r_[4];
  int flags;
  char flags_r_[4];
};

/* 4119 */
struct psynch_rw_wrlock_args
{
  user_addr_t_0 rwlock;
  uint32_t lgenval;
  char lgenval_r_[4];
  uint32_t ugenval;
  char ugenval_r_[4];
  uint32_t rw_wc;
  char rw_wc_r_[4];
  int flags;
  char flags_r_[4];
};

/* 4120 */
struct psynch_rw_unlock2_args
{
  user_addr_t_0 rwlock;
  uint32_t lgenval;
  char lgenval_r_[4];
  uint32_t ugenval;
  char ugenval_r_[4];
  uint32_t rw_wc;
  char rw_wc_r_[4];
  int flags;
  char flags_r_[4];
};

/* 4121 */
struct psynch_rw_unlock_args
{
  user_addr_t_0 rwlock;
  uint32_t lgenval;
  char lgenval_r_[4];
  uint32_t ugenval;
  char ugenval_r_[4];
  uint32_t rw_wc;
  char rw_wc_r_[4];
  int flags;
  char flags_r_[4];
};

/* 4122 */
struct psynch_rw_rdlock_args
{
  user_addr_t_0 rwlock;
  uint32_t lgenval;
  char lgenval_r_[4];
  uint32_t ugenval;
  char ugenval_r_[4];
  uint32_t rw_wc;
  char rw_wc_r_[4];
  int flags;
  char flags_r_[4];
};

/* 4123 */
struct psynch_rw_longrdlock_args
{
  user_addr_t_0 rwlock;
  uint32_t lgenval;
  char lgenval_r_[4];
  uint32_t ugenval;
  char ugenval_r_[4];
  uint32_t rw_wc;
  char rw_wc_r_[4];
  int flags;
  char flags_r_[4];
};

/* 4124 */
struct psynch_cvclrprepost_args
{
  user_addr_t_0 cv;
  uint32_t cvgen;
  char cvgen_r_[4];
  uint32_t cvugen;
  char cvugen_r_[4];
  uint32_t cvsgen;
  char cvsgen_r_[4];
  uint32_t prepocnt;
  char prepocnt_r_[4];
  uint32_t preposeq;
  char preposeq_r_[4];
  uint32_t flags;
  char flags_r_[4];
};

/* 4125 */
struct psynch_cvwait_args
{
  user_addr_t_0 cv;
  uint64_t cvlsgen;
  uint32_t cvugen;
  char cvugen_r_[4];
  user_addr_t_0 mutex;
  uint64_t mugen;
  uint32_t flags;
  char flags_r_[4];
  int64_t sec;
  uint32_t nsec;
  char nsec_r_[4];
};

/* 4126 */
struct psynch_cvsignal_args
{
  user_addr_t_0 cv;
  uint64_t cvlsgen;
  uint32_t cvugen;
  char cvugen_r_[4];
  int thread_port;
  char thread_port_r_[4];
  user_addr_t_0 mutex;
  uint64_t mugen;
  uint64_t tid;
  uint32_t flags;
  char flags_r_[4];
};

/* 4127 */
struct psynch_cvbroad_args
{
  user_addr_t_0 cv;
  uint64_t cvlsgen;
  uint64_t cvudgen;
  uint32_t flags;
  char flags_r_[4];
  user_addr_t_0 mutex;
  uint64_t mugen;
  uint64_t tid;
  char tid_r_[];
};

/* 4128 */
struct psynch_mutexdrop_args
{
  user_addr_t_0 mutex;
  uint32_t mgen;
  char mgen_r_[4];
  uint32_t ugen;
  char ugen_r_[4];
  uint64_t tid;
  uint32_t flags;
  char flags_r_[4];
};

/* 4129 */
struct psynch_mutexwait_args
{
  user_addr_t_0 mutex;
  uint32_t mgen;
  char mgen_r_[4];
  uint32_t ugen;
  char ugen_r_[4];
  uint64_t tid;
  uint32_t flags;
  char flags_r_[4];
};

/* 4130 */
struct thread_selfid_args
{
  int32_t dummy;
};

/* 4131 */
struct bsdthread_terminate_args
{
  user_addr_t_0 stackaddr;
  user_size_t freesize;
  uint32_t port;
  char port_r_[4];
  user_addr_t_0 sema_or_ulock;
  char sema_or_ulock_r_[];
};

/* 4132 */
struct bsdthread_register_args
{
  user_addr_t_0 threadstart;
  user_addr_t_0 wqthread;
  uint32_t flags;
  char flags_r_[4];
  user_addr_t_0 stack_addr_hint;
  user_addr_t_0 targetconc_ptr;
  uint32_t dispatchqueue_offset;
  char dispatchqueue_offset_r_[4];
  uint32_t tsd_offset;
  char tsd_offset_r_[4];
};

/* 4133 */
struct bsdthread_create_args
{
  user_addr_t_0 func;
  user_addr_t_0 func_arg;
  user_addr_t_0 stack;
  user_addr_t_0 pthread;
  uint32_t flags;
  char flags_r_[4];
};

/* 4135 */
struct pthread_functions_s
{
  int version;
  void (*pthread_init)(void);
  void *__unused_was_fill_procworkqueue;
  void *__unused1;
  void *__unused2;
  void *__unused_was_workqueue_exit;
  void *__unused_was_workqueue_mark_exiting;
  void *__unused_was_workqueue_thread_yielded;
  void (*pth_proc_hashinit)(proc_t);
  void (*pth_proc_hashdelete)(proc_t);
  int (*bsdthread_create)(proc *, user_addr_t_0, user_addr_t_0, user_addr_t_0, user_addr_t_0, uint32_t, user_addr_t_0 *);
  int (*bsdthread_register)(proc *, user_addr_t_0, user_addr_t_0, int, user_addr_t_0, user_addr_t_0, uint64_t, int32_t *);
  int (*bsdthread_terminate)(proc *, user_addr_t_0, size_t, uint32_t, uint32_t, int32_t *);
  int (*thread_selfid)(proc *, uint64_t *);
  void *__unused_was_workq_kernreturn;
  void *__unused_was_workq_open;
  int (*psynch_mutexwait)(proc_t, user_addr_t_0, uint32_t, uint32_t, uint64_t, uint32_t, uint32_t *);
  int (*psynch_mutexdrop)(proc_t, user_addr_t_0, uint32_t, uint32_t, uint64_t, uint32_t, uint32_t *);
  int (*psynch_cvbroad)(proc_t, user_addr_t_0, uint64_t, uint64_t, uint32_t, user_addr_t_0, uint64_t, uint64_t, uint32_t *);
  int (*psynch_cvsignal)(proc_t, user_addr_t_0, uint64_t, uint32_t, int, user_addr_t_0, uint64_t, uint64_t, uint32_t, uint32_t *);
  int (*psynch_cvwait)(proc_t, user_addr_t_0, uint64_t, uint32_t, user_addr_t_0, uint64_t, uint32_t, int64_t, uint32_t, uint32_t *);
  int (*psynch_cvclrprepost)(proc_t, user_addr_t_0, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t, int *);
  int (*psynch_rw_longrdlock)(proc_t, user_addr_t_0, uint32_t, uint32_t, uint32_t, int, uint32_t *);
  int (*psynch_rw_rdlock)(proc_t, user_addr_t_0, uint32_t, uint32_t, uint32_t, int, uint32_t *);
  int (*psynch_rw_unlock)(proc_t, user_addr_t_0, uint32_t, uint32_t, uint32_t, int, uint32_t *);
  int (*psynch_rw_wrlock)(proc_t, user_addr_t_0, uint32_t, uint32_t, uint32_t, int, uint32_t *);
  int (*psynch_rw_yieldwrlock)(proc_t, user_addr_t_0, uint32_t, uint32_t, uint32_t, int, uint32_t *);
  void *__unused_was_workqueue_get_sched_callback;
  int (*bsdthread_register2)(proc *, user_addr_t_0, user_addr_t_0, uint32_t, user_addr_t_0, user_addr_t_0, uint32_t, uint32_t, int32_t *);
  void *__unused_was_bsdthread_ctl;
  void *__unused_was_workq_reqthreads;
  void *__unused_was_thread_qos_from_pthread_priority;
  void *__unused_was_get_pwq_state_kdp;
  void *__unused3;
  void *__unused_was_pthread_priority_canonicalize2;
  void *__unused_was_workq_thread_has_been_unbound;
  void (*pthread_find_owner)(thread_t_0, stackshot_thread_waitinfo *);
  void *(*pthread_get_thread_kwq)(thread_t_0);
  void *__unused_was_workq_threadreq;
  int (*workq_handle_stack_events)(proc_t, thread_t_0, vm_map_t_0, user_addr_t_0, mach_port_name_t, user_addr_t_0, int, int);
  int (*workq_create_threadstack)(proc_t, vm_map_t_0, mach_vm_offset_t *);
  int (*workq_destroy_threadstack)(proc_t, vm_map_t_0, mach_vm_offset_t);
  void (*workq_setup_thread)(proc_t, thread_t_0, vm_map_t_0, user_addr_t_0, mach_port_name_t, int, int, int);
  void (*workq_markfree_threadstack)(proc_t, thread_t_0, vm_map_t_0, user_addr_t_0);
  void *_pad[83];
};

/* 4136 */
typedef struct thread *thread_act_t;

/* 4137 */
typedef natural_t thread_policy_flavor_t;

/* 4138 */
typedef int *vm_page_info_t;

/* 4139 */
typedef int vm_page_info_flavor_t;

/* 9106 */
typedef natural_t ipc_table_elems_t;

/* 7084 */
typedef ipc_table_elems_t ipc_entry_num_t;

/* 7085 */
typedef uint64_t ipc_label_t;

/* 5680 */
struct bool_gen
{
  unsigned int seed[4];
  unsigned int state;
  simple_lock_data_t_0 lock;
};

/* 4140 */
struct ipc_space
{
  lck_ticket_t_0 is_lock;
  os_ref_atomic_t is_bits;
  ipc_entry_num_t is_table_hashed;
  ipc_entry_num_t is_table_free;
  struct
  {
    __attribute__((aligned(8))) _BYTE gap0[8];
  } is_table;
  _BYTE gap28[8];
  thread_t_0 is_grower;
  ipc_label_t is_label;
  ipc_entry_num_t is_low_mod;
  ipc_entry_num_t is_high_mod;
  bool_gen bool_gen;
  unsigned int is_entropy[1];
  int is_node_id;
};

/* 4141 */
enum thread_snapshot_wait_flags : __int8
{
  thread_snapshot_wait_flags::kThreadWaitNone = 0x0,
  thread_snapshot_wait_flags::kThreadWaitKernelMutex = 0x1,
  thread_snapshot_wait_flags::kThreadWaitPortReceive = 0x2,
  thread_snapshot_wait_flags::kThreadWaitPortSetReceive = 0x3,
  thread_snapshot_wait_flags::kThreadWaitPortSend = 0x4,
  thread_snapshot_wait_flags::kThreadWaitPortSendInTransit = 0x5,
  thread_snapshot_wait_flags::kThreadWaitSemaphore = 0x6,
  thread_snapshot_wait_flags::kThreadWaitKernelRWLockRead = 0x7,
  thread_snapshot_wait_flags::kThreadWaitKernelRWLockWrite = 0x8,
  thread_snapshot_wait_flags::kThreadWaitKernelRWLockUpgrade = 0x9,
  thread_snapshot_wait_flags::kThreadWaitUserLock = 0xA,
  thread_snapshot_wait_flags::kThreadWaitPThreadMutex = 0xB,
  thread_snapshot_wait_flags::kThreadWaitPThreadRWLockRead = 0xC,
  thread_snapshot_wait_flags::kThreadWaitPThreadRWLockWrite = 0xD,
  thread_snapshot_wait_flags::kThreadWaitPThreadCondVar = 0xE,
  thread_snapshot_wait_flags::kThreadWaitParkedWorkQueue = 0xF,
  thread_snapshot_wait_flags::kThreadWaitWorkloopSyncWait = 0x10,
  thread_snapshot_wait_flags::kThreadWaitOnProcess = 0x11,
  thread_snapshot_wait_flags::kThreadWaitSleepWithInheritor = 0x12,
  thread_snapshot_wait_flags::kThreadWaitEventlink = 0x13,
  thread_snapshot_wait_flags::kThreadWaitCompressor = 0x14,
};

/* 4142 */
typedef thread_snapshot_wait_flags block_hint_t;

/* 5485 */
typedef int wait_result_t;

/* 5999 */
typedef ipc_space *ipc_space_t;

/* 7981 */
typedef integer_t *thread_policy_t;

/* 4143 */
struct pthread_callbacks_s
{
  int version;
  uint32_t config_thread_max;
  uint32_t (*get_task_threadmax)(void);
  uint64_t (*proc_get_register)(proc *);
  void (*proc_set_register)(proc *);
  user_addr_t_0 (*proc_get_threadstart)(proc *);
  void (*proc_set_threadstart)(proc *, user_addr_t_0);
  user_addr_t_0 (*proc_get_wqthread)(proc *);
  void (*proc_set_wqthread)(proc *, user_addr_t_0);
  int (*proc_get_pthsize)(proc *);
  void (*proc_set_pthsize)(proc *, int);
  thread_t_0 (*task_findtid)(task_t_0, uint64_t);
  void (*thread_deallocate_safe)(thread_t_0);
  bool (*proc_get_pthread_jit_allowlist)(proc *);
  void (*proc_set_dispatchqueue_offset)(proc *, uint64_t);
  bool (*proc_get_pthread_jit_allowlist2)(proc *, bool *);
  void *__unused_was_proc_get_wqinitingptr;
  void *__unused_was_proc_get_wqptr;
  wait_result_t (*psynch_wait_prepare)(uintptr_t, turnstile **, thread_t_0, block_hint_t, uint64_t);
  void (*psynch_wait_update_complete)(turnstile *);
  void (*psynch_wait_complete)(uintptr_t, turnstile **);
  void (*psynch_wait_cleanup)(void);
  kern_return_t (*psynch_wait_wakeup)(uintptr_t, ksyn_waitq_element *, turnstile **);
  void (*psynch_wait_update_owner)(uintptr_t, thread_t_0, turnstile **);
  void *(*proc_get_pthhash)(proc *);
  void (*proc_set_pthhash)(proc *, void *);
  void *__unused_was_uthread_get_threadlist;
  void *__unused_was_uthread_set_threadlist;
  void *__unused_was_uthread_get_sigmask;
  void *__unused_was_uthread_set_sigmask;
  void *(*uthread_get_uukwe)(uthread *);
  void *__unused_was_uthread_get_returnval;
  void (*uthread_set_returnval)(uthread *, int);
  int (*uthread_is_cancelled)(uthread *);
  ipc_space_t (*task_get_ipcspace)(task_t_0);
  void *__unused_was_ipc_port_copyout_send;
  kern_return_t (*vm_map_page_info)(vm_map_t_0, vm_map_offset_t, vm_page_info_flavor_t, vm_page_info_t, mach_msg_type_number_t *);
  mach_port_name_t (*ipc_port_copyout_send_pinned)(ipc_port_t_0, ipc_space_t);
  kern_return_t (*thread_set_wq_state32)(thread_t_0, thread_state_t);
  kern_return_t (*thread_set_wq_state64)(thread_t_0, thread_state_t);
  void (*thread_exception_return)(void);
  void (*thread_bootstrap_return)(void);
  void *__unused_was_absolutetime_to_microtime;
  void *__unused_was_thread_set_workq_pri;
  void *__unused_was_thread_set_workq_qos;
  uthread *(*get_bsdthread_info)(thread_t_0);
  void *__unused_was_thread_sched_call;
  void *__unused_was_thread_static_param;
  void *__unused_was_thread_create_workq_waiting_parameter;
  kern_return_t (*thread_policy_set_internal)(thread_t_0, thread_policy_flavor_t, thread_policy_t, mach_msg_type_number_t);
  void *__unused_was_thread_affinity_set;
  void (*unix_syscall_return)(int);
  void *__unused_was_zalloc;
  void *__unused_was_zfree;
  void *__unused_was_zinit;
  void (*__pthread_testcancel)(int);
  kern_return_t (*mach_port_deallocate)(ipc_space_t, mach_port_name_t);
  kern_return_t (*semaphore_signal_internal_trap)(mach_port_name_t);
  vm_map_t_0 (*current_map)(void);
  void *__unused_was_convert_thread_to_port;
  void *__unused_was_thread_create;
  kern_return_t (*thread_resume)(thread_act_t);
  int (*kevent_workq_internal)(proc *, user_addr_t_0, int, user_addr_t_0, int, user_addr_t_0, user_size_t *, unsigned int, int32_t *);
  void *__unused_was_proc_get_dispatchqueue_serialno_offset;
  void *__unused_was_proc_set_dispatchqueue_serialno_offset;
  void *__unused_was_proc_usynch_thread_qos_add_override_for_resource_check_owner;
  void (*proc_set_workqueue_quantum_offset)(proc *, uint64_t);
  uint32_t (*proc_get_pthread_tsd_offset)(proc *);
  void (*proc_set_pthread_tsd_offset)(proc *, uint32_t);
  kern_return_t (*thread_set_tsd_base)(thread_t_0, mach_vm_offset_t);
  int (*proc_usynch_get_requested_thread_qos)(uthread *);
  uint64_t (*proc_get_mach_thread_self_tsd_offset)(proc *);
  void (*proc_set_mach_thread_self_tsd_offset)(proc *, uint64_t);
  kern_return_t (*thread_policy_get)(thread_t_0, thread_policy_flavor_t, thread_policy_t, mach_msg_type_number_t *, boolean_t *);
  boolean_t (*qos_main_thread_active)(void);
  kern_return_t (*thread_set_voucher_name)(mach_port_name_t);
  boolean_t (*proc_usynch_thread_qos_add_override_for_resource)(task_t_0, uthread *, uint64_t, int, boolean_t, user_addr_t_0, int);
  boolean_t (*proc_usynch_thread_qos_remove_override_for_resource)(task_t_0, uthread *, uint64_t, user_addr_t_0, int);
  void *__unused_was_proc_usynch_thread_qos_reset_override_for_resource;
  void *__unused_was_proc_init_wqptr_or_wait;
  uint16_t (*thread_set_tag)(thread_t_0, uint16_t);
  uint16_t (*thread_get_tag)(thread_t_0);
  void *__unused_was_thread_create_pinned;
  kern_return_t (*thread_terminate_pinned)(thread_t_0);
  ipc_port_t_0 (*convert_thread_to_port_pinned)(thread_t_0);
  user_addr_t_0 (*proc_get_stack_addr_hint)(proc *);
  void (*proc_set_stack_addr_hint)(proc *, user_addr_t_0);
  kern_return_t (*thread_create_immovable)(task_t_0, thread_t_0 *);
  void (*proc_set_return_to_kernel_offset)(proc *, uint64_t);
  void *__unused_was_workloop_fulfill_threadreq;
  void (*thread_will_park_or_terminate)(thread_t_0);
  void *__unused_was_qos_max_parallelism;
  user_addr_t_0 (*proc_get_user_stack)(proc *);
  void *__unused_was_proc_set_user_stack;
  void *_pad[69];
};

/* 4144 */
struct au_token
{
  u_char *t_data;
  size_t len;
  struct
  {
    au_token *tqe_next;
    au_token **tqe_prev;
  } tokens;
};

/* 4145 */
struct au_record
{
  char used;
  int desc;
  struct
  {
    au_token *tqh_first;
    au_token **tqh_last;
  } token_q;
  u_char *data;
  size_t len;
  struct
  {
    au_record *le_next;
    au_record **le_prev;
  } au_rec_q;
};

/* 4146 */
struct auditctl_args
{
  user_addr_t_0 path;
  char path_r_[];
};

/* 4147 */
struct setaudit_addr_args
{
  user_addr_t_0 auditinfo_addr;
  int length;
  char length_r_[4];
};

/* 4148 */
struct getaudit_addr_args
{
  user_addr_t_0 auditinfo_addr;
  int length;
  char length_r_[4];
};

/* 4149 */
struct setauid_args
{
  user_addr_t_0 auid;
  char auid_r_[];
};

/* 4150 */
struct getauid_args
{
  user_addr_t_0 auid;
  char auid_r_[];
};

/* 4151 */
struct auditon_args
{
  int cmd;
  char cmd_r_[4];
  user_addr_t_0 data;
  int length;
  char length_r_[4];
};

/* 4152 */
struct audit_args
{
  user_addr_t_0 record;
  int length;
  char length_r_[4];
};

/* 4153 */
typedef au_token token_t;

/* 4154 */
struct __attribute__((packed)) __attribute__((aligned(1))) trl_tok_partial
{
  u_char type;
  uint16_t magic;
  uint32_t len;
};

/* 4155 */
struct hdr_tok_partial
{
  u_char type;
  __attribute__((packed)) __attribute__((aligned(1))) uint32_t len;
  u_char ver;
  uint16_t e_type;
};

/* 4156 */
struct audit_session_join_args
{
  mach_port_name_t port;
  char port_r_[4];
};

/* 4157 */
struct audit_session_port_args
{
  au_asid_t asid;
  char asid_r_[4];
  user_addr_t_0 portnamep;
  char portnamep_r_[];
};

/* 4158 */
struct audit_session_self_args
{
  int32_t dummy;
};

/* 4159 */
struct au_sentry_head
{
  au_sentry *lh_first;
};

/* 7986 */
struct au_sentry
{
  auditinfo_addr_t se_auinfo;
  long se_refcnt;
  long se_procnt;
  ipc_port_t_0 se_port;
  struct
  {
    au_sentry *le_next;
    au_sentry **le_prev;
  } se_link;
};

/* 4160 */
struct audit_sdev_entry
{
  void *ase_record;
  u_int ase_record_len;
  struct
  {
    audit_sdev_entry *tqe_next;
    audit_sdev_entry **tqe_prev;
  } ase_queue;
};

/* 4161 */
struct __attribute__((aligned(8))) cv
{
  const char *cv_description;
  int cv_waiters;
};

/* 4162 */
struct slck
{
  lck_mtx_t *sl_mtx;
  int sl_locked;
  int sl_waiting;
};

/* 4163 */
struct mtx
{
  lck_mtx_t *mtx_lock;
};

/* 4164 */
struct audit_sdev
{
  int asdev_open;
  u_int asdev_flags;
  selinfo asdev_selinfo;
  pid_t asdev_sigio;
  au_id_t asdev_auid;
  au_asid_t asdev_asid;
  mtx asdev_mtx;
  slck asdev_sx;
  cv asdev_cv;
  u_int asdev_qlen;
  u_int asdev_qlimit;
  u_int asdev_qbyteslen;
  u_int asdev_qoffset;
  u_int64_t asdev_inserts;
  u_int64_t asdev_reads;
  u_int64_t asdev_drops;
  struct
  {
    audit_sdev_entry *tqh_first;
    audit_sdev_entry **tqh_last;
  } asdev_queue;
  struct
  {
    audit_sdev *tqe_next;
    audit_sdev **tqe_prev;
  } asdev_list;
};

/* 4166 */
struct auditpipe_ioctl_preselect
{
  au_id_t aip_auid;
  au_mask_t aip_mask;
};

/* 4167 */
struct audit_pipe_entry
{
  void *ape_record;
  u_int ape_record_len;
  struct
  {
    audit_pipe_entry *tqe_next;
    audit_pipe_entry **tqe_prev;
  } ape_queue;
};

/* 4168 */
struct audit_pipe_preselect
{
  au_id_t app_auid;
  au_mask_t app_mask;
  struct
  {
    audit_pipe_preselect *tqe_next;
    audit_pipe_preselect **tqe_prev;
  } app_list;
};

/* 4169 */
struct audit_pipe
{
  int ap_open;
  u_int ap_flags;
  selinfo ap_selinfo;
  pid_t ap_sigio;
  mtx ap_mtx;
  slck ap_sx;
  cv ap_cv;
  u_int ap_qlen;
  u_int ap_qlimit;
  u_int ap_qbyteslen;
  u_int ap_qoffset;
  u_int64_t ap_inserts;
  u_int64_t ap_reads;
  u_int64_t ap_drops;
  int ap_preselect_mode;
  au_mask_t ap_preselect_flags;
  au_mask_t ap_preselect_naflags;
  struct
  {
    audit_pipe_preselect *tqh_first;
    audit_pipe_preselect **tqh_last;
  } ap_preselect_list;
  struct
  {
    audit_pipe_entry *tqh_first;
    audit_pipe_entry **tqh_last;
  } ap_queue;
  struct
  {
    audit_pipe *tqe_next;
    audit_pipe **tqe_prev;
  } ap_list;
};

/* 4170 */
typedef u_int16_t au_emod_t;

/* 4171 */
struct bsm_socket_type
{
  u_short bst_bsm_socket_type;
  int bst_local_socket_type;
};

/* 4172 */
struct evclass_elem
{
  au_event_t event;
  au_class_t class;
  struct
  {
    evclass_elem *le_next;
    evclass_elem **le_prev;
  } entry;
};

/* 4173 */
struct evclass_list
{
  struct
  {
    evclass_elem *lh_first;
  } head;
};

/* 4174 */
struct bsm_domain
{
  u_short bd_bsm_domain;
  int bd_local_domain;
};

/* 4175 */
typedef bsm_fcntl_cmd bsm_fcntl_cmd_t;

/* 7987 */
struct bsm_fcntl_cmd
{
  u_short bfc_bsm_fcntl_cmd;
  int bfc_local_fcntl_cmd;
};

/* 4176 */
struct bsm_errno
{
  int be_bsm_errno;
  int be_local_errno;
};

/* 4178 */
struct rwlock
{
  lck_rw_t *rw_lock;
};

/* 4179 */
struct sadb_lifetime
{
  u_int16_t sadb_lifetime_len;
  u_int16_t sadb_lifetime_exttype;
  u_int32_t sadb_lifetime_allocations;
  u_int64_t sadb_lifetime_bytes;
  u_int64_t sadb_lifetime_addtime;
  u_int64_t sadb_lifetime_usetime;
};

/* 4180 */
struct __attribute__((aligned(8))) secreplay
{
  u_int8_t wsize;
  u_int32_t count;
  u_int32_t seq;
  u_int32_t lastseq;
  caddr_t bitmap;
  int overflow;
};

/* 4181 */
struct sadb_key
{
  u_int16_t sadb_key_len;
  u_int16_t sadb_key_exttype;
  u_int16_t sadb_key_bits;
  u_int16_t sadb_key_reserved;
};

/* 4182 */
struct __attribute__((aligned(4))) secasvar
{
  struct
  {
    secasvar *le_next;
    secasvar **le_prev;
  } chain;
  struct
  {
    secasvar *le_next;
    secasvar **le_prev;
  } spihash;
  int refcnt;
  u_int8_t state;
  u_int8_t alg_auth;
  u_int8_t alg_enc;
  u_int32_t spi;
  u_int32_t flags;
  u_int16_t flags2;
  sadb_key *key_auth;
  sadb_key *key_enc;
  caddr_t iv;
  u_int ivlen;
  void *sched;
  size_t schedlen;
  secreplay *replay[4];
  u_int64_t created;
  sadb_lifetime *lft_c;
  sadb_lifetime *lft_h;
  sadb_lifetime *lft_s;
  socket *so;
  u_int32_t seq;
  pid_t pid;
  secashead *sah;
  u_int64_t natt_last_activity;
  u_int16_t remote_ike_port;
  u_int16_t natt_encapsulated_src_port;
  u_int16_t natt_interval;
  u_int16_t natt_offload_interval;
  uint32_t flowid;
  u_int8_t always_expire;
};

/* 4183 */
struct _satree
{
  secasvar *lh_first;
};

/* 4184 */
struct secashead
{
  struct
  {
    secashead *le_next;
    secashead **le_prev;
  } chain;
  secasindex saidx;
  ifnet_t ipsec_if;
  u_int outgoing_if;
  u_int8_t dir;
  u_int8_t state;
  _satree savtree[4];
  route_in6 sa_route;
  uint16_t flags;
  u_int32_t use_count;
};

/* 4185 */
struct __attribute__((aligned(8))) rawcb
{
  struct
  {
    rawcb *le_next;
    rawcb **le_prev;
  } list;
  socket *rcb_socket;
  sockaddr *rcb_faddr;
  sockaddr *rcb_laddr;
  sockproto rcb_proto;
  uint32_t reserved[4];
};

/* 4186 */
struct keycb
{
  rawcb kp_raw;
  int kp_promisc;
  int kp_registered;
};

/* 4187 */
struct sadb_msg
{
  u_int8_t sadb_msg_version;
  u_int8_t sadb_msg_type;
  u_int8_t sadb_msg_errno;
  u_int8_t sadb_msg_satype;
  u_int16_t sadb_msg_len;
  u_int16_t sadb_msg_reserved;
  u_int32_t sadb_msg_seq;
  u_int32_t sadb_msg_pid;
};

/* 4188 */
struct ifnet_keepalive_offload_frame
{
  u_int8_t data[128];
  u_int8_t type;
  u_int8_t length;
  u_int16_t interval;
  u_int8_t ether_type;
  u_int8_t keep_cnt;
  u_int16_t keep_retry;
  u_int8_t reply_length;
  u_int8_t addr_length;
  u_int8_t flags;
  u_int8_t reserved[1];
  u_int8_t reply_data[128];
  u_int8_t local_addr[16];
  u_int8_t remote_addr[16];
  u_int16_t local_port;
  u_int16_t remote_port;
  u_int32_t local_seq;
  u_int32_t remote_seq;
};

/* 4189 */
struct in_ifaddr
{
  ifaddr ia_ifa;
  u_int32_t ia_net;
  u_int32_t ia_netmask;
  u_int32_t ia_subnet;
  u_int32_t ia_subnetmask;
  in_addr ia_netbroadcast;
  struct
  {
    in_ifaddr *tqe_next;
    in_ifaddr **tqe_prev;
  } ia_link;
  sockaddr_in ia_addr;
  sockaddr_in ia_dstaddr;
  sockaddr_in ia_sockmask;
  struct
  {
    in_ifaddr *tqe_next;
    in_ifaddr **tqe_prev;
  } ia_hash;
};

/* 4190 */
struct ah_algorithm_state
{
  secasvar *sav;
  void *foo;
};

/* 4191 */
struct ah_algorithm
{
  int (*sumsiz)(secasvar *);
  int (*mature)(secasvar *);
  u_int16_t keymin;
  u_int16_t keymax;
  const char *name;
  int (*init)(ah_algorithm_state *, secasvar *);
  void (*update)(ah_algorithm_state *, caddr_t, size_t);
  void (*result)(ah_algorithm_state *, caddr_t, size_t);
};

/* 4192 */
struct esp_algorithm
{
  uint32_t padbound;
  int ivlenval;
  int (*mature)(secasvar *);
  u_int16_t keymin;
  u_int16_t keymax;
  size_t (*schedlen)(const esp_algorithm *);
  const char *name;
  int (*ivlen)(const esp_algorithm *, secasvar *);
  int (*decrypt)(mbuf *, size_t, secasvar *, const esp_algorithm *, int);
  int (*encrypt)(mbuf *, size_t, size_t, secasvar *, const esp_algorithm *, int);
  int (*schedule)(const esp_algorithm *, secasvar *);
  int (*blockdecrypt)(const esp_algorithm *, secasvar *, u_int8_t *, u_int8_t *);
  int (*blockencrypt)(const esp_algorithm *, secasvar *, u_int8_t *, u_int8_t *);
  size_t icvlen;
  int (*finalizedecrypt)(secasvar *, u_int8_t *, size_t);
  int (*finalizeencrypt)(secasvar *, u_int8_t *, size_t);
};

/* 4193 */
struct sadb_session_id
{
  u_int16_t sadb_session_id_len;
  u_int16_t sadb_session_id_exttype;
  u_int64_t sadb_session_id_v[2];
};

/* 4194 */
struct sadb_sastat
{
  u_int16_t sadb_sastat_len;
  u_int16_t sadb_sastat_exttype;
  u_int32_t sadb_sastat_dir;
  u_int32_t sadb_sastat_reserved;
  u_int32_t sadb_sastat_list_len;
};

/* 4195 */
struct sastat
{
  u_int32_t spi;
  u_int32_t created;
  sadb_lifetime lft_c;
};

/* 4196 */
struct __attribute__((aligned(8))) sav_dump_elem
{
  secasvar *sav;
  u_int8_t satype;
};

/* 4197 */
struct sadb_alg
{
  u_int8_t sadb_alg_id;
  u_int8_t sadb_alg_ivlen;
  u_int16_t sadb_alg_minbits;
  u_int16_t sadb_alg_maxbits;
  u_int16_t sadb_alg_reserved;
};

/* 4198 */
struct sadb_supported
{
  u_int16_t sadb_supported_len;
  u_int16_t sadb_supported_exttype;
  u_int32_t sadb_supported_reserved;
};

/* 4199 */
struct sadb_x_ipsecif
{
  u_int16_t sadb_x_ipsecif_len;
  u_int16_t sadb_x_ipsecif_exttype;
  char sadb_x_ipsecif_internal_if[24];
  char sadb_x_ipsecif_outgoing_if[24];
  char sadb_x_ipsecif_ipsec_if[24];
  u_int16_t sadb_x_ipsecif_init_disabled;
  u_int16_t reserved;
};

/* 4200 */
struct sadb_spirange
{
  u_int16_t sadb_spirange_len;
  u_int16_t sadb_spirange_exttype;
  u_int32_t sadb_spirange_min;
  u_int32_t sadb_spirange_max;
  u_int32_t sadb_spirange_reserved;
};

/* 4201 */
struct sadb_x_sa2
{
  u_int16_t sadb_x_sa2_len;
  u_int16_t sadb_x_sa2_exttype;
  u_int8_t sadb_x_sa2_mode;
  union
  {
    u_int8_t sadb_x_sa2_reserved1;
    u_int8_t sadb_x_sa2_alwaysexpire;
  };
  union
  {
    u_int16_t sadb_x_sa2_reserved2;
    u_int16_t sadb_x_sa2_flags;
  };
  u_int32_t sadb_x_sa2_sequence;
  u_int32_t sadb_x_sa2_reqid;
};

/* 4202 */
struct sadb_comb
{
  u_int8_t sadb_comb_auth;
  u_int8_t sadb_comb_encrypt;
  u_int16_t sadb_comb_flags;
  u_int16_t sadb_comb_auth_minbits;
  u_int16_t sadb_comb_auth_maxbits;
  u_int16_t sadb_comb_encrypt_minbits;
  u_int16_t sadb_comb_encrypt_maxbits;
  u_int32_t sadb_comb_reserved;
  u_int32_t sadb_comb_soft_allocations;
  u_int32_t sadb_comb_hard_allocations;
  u_int64_t sadb_comb_soft_bytes;
  u_int64_t sadb_comb_hard_bytes;
  u_int64_t sadb_comb_soft_addtime;
  u_int64_t sadb_comb_hard_addtime;
  u_int64_t sadb_comb_soft_usetime;
  u_int64_t sadb_comb_hard_usetime;
};

/* 4203 */
struct sadb_prop
{
  u_int16_t sadb_prop_len;
  u_int16_t sadb_prop_exttype;
  u_int8_t sadb_prop_replay;
  u_int8_t sadb_prop_reserved[3];
};

/* 4204 */
struct sadb_sa
{
  u_int16_t sadb_sa_len;
  u_int16_t sadb_sa_exttype;
  u_int32_t sadb_sa_spi;
  u_int8_t sadb_sa_replay;
  u_int8_t sadb_sa_state;
  u_int8_t sadb_sa_auth;
  u_int8_t sadb_sa_encrypt;
  u_int32_t sadb_sa_flags;
};

/* 4205 */
struct sadb_address
{
  u_int16_t sadb_address_len;
  u_int16_t sadb_address_exttype;
  u_int8_t sadb_address_proto;
  u_int8_t sadb_address_prefixlen;
  u_int16_t sadb_address_reserved;
};

/* 4206 */
struct sadb_x_policy
{
  u_int16_t sadb_x_policy_len;
  u_int16_t sadb_x_policy_exttype;
  u_int16_t sadb_x_policy_type;
  u_int8_t sadb_x_policy_dir;
  u_int8_t sadb_x_policy_reserved;
  u_int32_t sadb_x_policy_id;
  u_int32_t sadb_x_policy_reserved2;
};

/* 4207 */
struct sadb_x_ipsecrequest
{
  u_int16_t sadb_x_ipsecrequest_len;
  u_int16_t sadb_x_ipsecrequest_proto;
  u_int8_t sadb_x_ipsecrequest_mode;
  u_int8_t sadb_x_ipsecrequest_level;
  u_int16_t sadb_x_ipsecrequest_reqid;
};

/* 4208 */
struct sadb_ext
{
  u_int16_t sadb_ext_len;
  u_int16_t sadb_ext_type;
};

/* 4209 */
struct sadb_msghdr
{
  sadb_msg *msg;
  sadb_ext *ext[30];
  int extoff[30];
  int extlen[30];
};

/* 4210 */
struct __attribute__((aligned(8))) secspacq
{
  struct
  {
    secspacq *le_next;
    secspacq **le_prev;
  } chain;
  secpolicyindex spidx;
  u_int64_t created;
  int count;
};

/* 4211 */
struct __attribute__((aligned(8))) secacq
{
  struct
  {
    secacq *le_next;
    secacq **le_prev;
  } chain;
  secasindex saidx;
  u_int32_t seq;
  u_int64_t created;
  int count;
};

/* 4212 */
struct _spihash
{
  secasvar *lh_first;
};

/* 4213 */
struct secreg
{
  struct
  {
    secreg *le_next;
    secreg **le_prev;
  } chain;
  socket *so;
};

/* 4214 */
struct _regtree
{
  secreg *lh_first;
};

/* 4215 */
struct _sptree
{
  secpolicy *lh_first;
};

/* 4217 */
struct icmp6_hdr
{
  u_int8_t icmp6_type;
  u_int8_t icmp6_code;
  u_int16_t icmp6_cksum;
  union
  {
    u_int32_t icmp6_un_data32[1];
    u_int16_t icmp6_un_data16[2];
    u_int8_t icmp6_un_data8[4];
  } icmp6_dataun;
};

/* 4218 */
struct __attribute__((aligned(8))) ip6ctlparam
{
  mbuf *ip6c_m;
  icmp6_hdr *ip6c_icmp6;
  ip6_hdr *ip6c_ip6;
  int ip6c_off;
  sockaddr_in6 *ip6c_src;
  sockaddr_in6 *ip6c_dst;
  in6_addr_0 *ip6c_finaldst;
  void *ip6c_cmdarg;
  u_int8_t ip6c_nxt;
};

/* 4219 */
struct in6_cga_prepare
{
  in6_cga_modifier cga_modifier;
  u_int8_t cga_security_level;
  u_int8_t reserved_A[15];
};

/* 4220 */
struct nd_drhead
{
  nd_defrouter *tqh_first;
  nd_defrouter **tqh_last;
};

/* 4221 */
struct __attribute__((aligned(8))) nd_route_info
{
  nd_drhead nd_rti_router_list;
  struct
  {
    nd_route_info *tqe_next;
    nd_route_info **tqe_prev;
  } nd_rti_entry;
  in6_addr_0 nd_rti_prefix;
  u_int8_t nd_rti_prefixlen;
};

/* 4222 */
struct nd_opt_nonce
{
  u_int8_t nd_opt_nonce_type;
  u_int8_t nd_opt_nonce_len;
  u_int8_t nd_opt_nonce[6];
};

/* 4223 */
struct nd_opt_mtu
{
  u_int8_t nd_opt_mtu_type;
  u_int8_t nd_opt_mtu_len;
  u_int16_t nd_opt_mtu_reserved;
  u_int32_t nd_opt_mtu_mtu;
};

/* 4224 */
struct nd_opt_rd_hdr
{
  u_int8_t nd_opt_rh_type;
  u_int8_t nd_opt_rh_len;
  u_int16_t nd_opt_rh_reserved1;
  u_int32_t nd_opt_rh_reserved2;
};

/* 4228 */
struct in6_addrlifetime
{
  time_t ia6t_expire;
  time_t ia6t_preferred;
  u_int32_t ia6t_vltime;
  u_int32_t ia6t_pltime;
};

/* 7990 */
struct ctrace
{
  void *th;
  void *pc[8];
};

/* 4230 */
typedef ctrace ctrace_t;

/* 4229 */
struct nd_prefix_dbg
{
  nd_prefix ndpr_pr;
  u_int16_t ndpr_refhold_cnt;
  u_int16_t ndpr_refrele_cnt;
  ctrace_t ndpr_refhold[32];
  ctrace_t ndpr_refrele[32];
};

/* 4231 */
struct nd_defrouter_dbg
{
  nd_defrouter nddr_dr;
  uint16_t nddr_refhold_cnt;
  uint16_t nddr_refrele_cnt;
  ctrace_t nddr_refhold[32];
  ctrace_t nddr_refrele[32];
};

/* 4232 */
struct __attribute__((aligned(4))) in6_defrouter_32
{
  sockaddr_in6 rtaddr;
  u_char flags;
  u_char stateflags;
  u_short rtlifetime;
  u_int32_t expire;
  u_short if_index;
};

/* 4233 */
struct __attribute__((aligned(8))) in6_defrouter_64
{
  sockaddr_in6 rtaddr;
  u_char flags;
  u_char stateflags;
  u_short rtlifetime;
  u_long expire;
  u_short if_index;
};

/* 4234 */
struct nd_prefix_list
{
  nd_prefix_list *next;
  nd_prefix pr;
};

/* 4235 */
struct nd_opt_prefix_info
{
  u_int8_t nd_opt_pi_type;
  u_int8_t nd_opt_pi_len;
  u_int8_t nd_opt_pi_prefix_len;
  u_int8_t nd_opt_pi_flags_reserved;
  u_int32_t nd_opt_pi_valid_time;
  u_int32_t nd_opt_pi_preferred_time;
  u_int32_t nd_opt_pi_reserved2;
  in6_addr_0 nd_opt_pi_prefix;
};

/* 4236 */
struct nd_opt_route_info
{
  u_int8_t nd_opt_rti_type;
  u_int8_t nd_opt_rti_len;
  u_int8_t nd_opt_rti_prefixlen;
  u_int8_t nd_opt_rti_flags;
  u_int32_t nd_opt_rti_lifetime;
};

/* 4237 */
struct nd_opt_hdr
{
  u_int8_t nd_opt_type;
  u_int8_t nd_opt_len;
};

/* 4238 */
struct nd_router_advert
{
  icmp6_hdr nd_ra_hdr;
  u_int32_t nd_ra_reachable;
  u_int32_t nd_ra_retransmit;
};

/* 4239 */
struct nd_router_solicit
{
  icmp6_hdr nd_rs_hdr;
};

/* 4240 */
struct __attribute__((aligned(8))) nd6_prproxy_prelist
{
  struct
  {
    nd6_prproxy_prelist *sle_next;
  } ndprl_le;
  nd_prefix *ndprl_pr;
  nd_prefix *ndprl_up;
  ifnet *ndprl_fwd_ifp;
  boolean_t ndprl_sol;
  in6_addr_0 ndprl_sol_saddr;
};

/* 4241 */
struct nd6_prproxy_prelist_head
{
  nd6_prproxy_prelist *slh_first;
};

/* 4245 */
struct __attribute__((aligned(4))) ip6aux
{
  u_int32_t ip6a_flags;
  u_char ip6a_ehsrc[6];
};

/* 4246 */
struct net_event_data
{
  u_int32_t if_family;
  u_int32_t if_unit;
  char if_name[16];
};

/* 4247 */
struct nd_neighbor_advert
{
  icmp6_hdr nd_na_hdr;
  in6_addr_0 nd_na_target;
};

/* 4248 */
struct nd_neighbor_solicit
{
  icmp6_hdr nd_ns_hdr;
  in6_addr_0 nd_ns_target;
};

/* 4251 */
struct __attribute__((aligned(8))) dadq
{
  lck_mtx_t dad_lock;
  u_int32_t dad_refcount;
  int dad_attached;
  struct
  {
    dadq *tqe_next;
    dadq **tqe_prev;
  } dad_list;
  ifaddr *dad_ifa;
  int dad_count;
  int dad_ns_tcount;
  int dad_ns_ocount;
  int dad_ns_icount;
  int dad_na_icount;
  int dad_ns_lcount;
  int dad_loopbackprobe;
  uint8_t dad_lladdr[6];
  uint8_t dad_lladdrlen;
  uint32_t dad_nonce[2];
};

/* 4252 */
struct in6_addrlifetime_64
{
  u_int64_t ia6t_expire;
  u_int64_t ia6t_preferred;
  u_int32_t ia6t_vltime;
  u_int32_t ia6t_pltime;
};

/* 4253 */
struct __attribute__((aligned(8))) in6_cgareq_64
{
  char cgar_name[16];
  int cgar_flags;
  in6_cga_prepare cgar_cgaprep;
  in6_addrlifetime_64 cgar_lifetime;
  uint8_t cgar_collision_count;
};

/* 4254 */
struct in6_addrlifetime_32
{
  u_int32_t ia6t_expire;
  u_int32_t ia6t_preferred;
  u_int32_t ia6t_vltime;
  u_int32_t ia6t_pltime;
};

/* 4255 */
struct __attribute__((aligned(4))) in6_cgareq_32
{
  char cgar_name[16];
  int cgar_flags;
  in6_cga_prepare cgar_cgaprep;
  in6_addrlifetime_32 cgar_lifetime;
  uint8_t cgar_collision_count;
};

/* 4256 */
struct nd6_ra_prefix
{
  sockaddr_in6 prefix;
  prf_ra raflags;
  u_int32_t prefixlen;
  u_int32_t origin;
  u_int64_t vltime;
  u_int64_t pltime;
  u_int64_t expire;
  u_int32_t flags;
  u_int32_t refcnt;
  u_int32_t if_index;
  u_int32_t pad;
};

/* 4257 */
struct nd6svc_arg
{
  int draining;
  uint32_t killed;
  uint32_t aging_lazy;
  uint32_t aging;
  uint32_t sticky;
  uint32_t found;
};

/* 4258 */
union nd_opts
{
  nd_opt_hdr *nd_opt_array[26];
  struct
  {
    nd_opt_hdr *zero;
    nd_opt_hdr *src_lladdr;
    nd_opt_hdr *tgt_lladdr;
    nd_opt_prefix_info *pi_beg;
    nd_opt_rd_hdr *rh;
    nd_opt_mtu *mtu;
    nd_opt_hdr *__res6;
    nd_opt_hdr *__res7;
    nd_opt_hdr *__res8;
    nd_opt_hdr *__res9;
    nd_opt_hdr *__res10;
    nd_opt_hdr *__res11;
    nd_opt_hdr *__res12;
    nd_opt_hdr *__res13;
    nd_opt_nonce *nonce;
    nd_opt_hdr *__res15;
    nd_opt_hdr *__res16;
    nd_opt_hdr *__res17;
    nd_opt_hdr *__res18;
    nd_opt_hdr *__res19;
    nd_opt_hdr *__res20;
    nd_opt_hdr *__res21;
    nd_opt_hdr *__res22;
    nd_opt_hdr *__res23;
    nd_opt_route_info *rti_beg;
    nd_opt_hdr *__res25;
    nd_opt_hdr *search;
    nd_opt_hdr *last;
    int done;
    nd_opt_prefix_info *pi_end;
    nd_opt_route_info *rti_end;
  } nd_opt_each;
};

/* 4259 */
struct in6_prlist_32
{
  char ifname[16];
  struct {in6_addr_0 prefix;prf_ra raflags;u_char prefixlen;u_char origin;u_int32_t vltime;u_int32_t pltime;u_int32_t expire;u_short if_index;u_short advrtrs;in6_addr_0 advrtr[10];}; prefix[10];
};

/* 4260 */
struct in6_prlist_64
{
  char ifname[16];
  struct {in6_addr_0 prefix;prf_ra raflags;u_char prefixlen;u_char origin;u_long vltime;u_long pltime;u_long expire;u_short if_index;u_short advrtrs;u_int32_t pad;in6_addr_0 advrtr[10];}; prefix[10];
};

/* 4261 */
struct in6_drlist_32
{
  char ifname[16];
  struct __attribute__((aligned(4))) {in6_addr_0 rtaddr;u_char flags;u_short rtlifetime;u_int32_t expire;u_short if_index;}; defrouter[10];
};

/* 4262 */
struct in6_drlist_64
{
  char ifname[16];
  struct __attribute__((aligned(8))) {in6_addr_0 rtaddr;u_char flags;u_short rtlifetime;u_long expire;u_short if_index;}; defrouter[10];
};

/* 4263 */
struct in6_ndifreq_32
{
  char ifname[16];
  u_int32_t ifindex;
};

/* 4264 */
struct in6_ndifreq_64
{
  char ifname[16];
  u_int64_t ifindex;
};

/* 4265 */
struct __attribute__((aligned(4))) nd_ifinfo_compat
{
  u_int32_t linkmtu;
  u_int32_t maxmtu;
  u_int32_t basereachable;
  u_int32_t reachable;
  u_int32_t retrans;
  u_int32_t flags;
  int recalctm;
  u_int8_t chlim;
  u_int8_t receivedra;
  u_int8_t randomseed0[8];
  u_int8_t randomseed1[8];
  u_int8_t randomid[8];
};

/* 4266 */
struct in6_ndireq
{
  char ifname[16];
  nd_ifinfo_compat ndi;
};

/* 4267 */
struct in6_ondireq
{
  char ifname[16];
  struct __attribute__((aligned(2)))
  {
    u_int32_t linkmtu;
    u_int32_t maxmtu;
    u_int32_t basereachable;
    u_int32_t reachable;
    u_int32_t retrans;
    u_int32_t flags;
    int recalctm;
    u_int8_t chlim;
    u_int8_t receivedra;
    u_int8_t collision_count;
  } ndi;
};

/* 4268 */
typedef rtentry *route_t;

/* 4269 */
struct __attribute__((aligned(4))) mld_tparams
{
  int qpt;
  int it;
  int cst;
  int sct;
  bool fast;
};

/* 4270 */
struct mldv2_report
{
  icmp6_hdr mld_icmp6_hdr;
};

/* 4271 */
struct mldv2_record
{
  uint8_t mr_type;
  uint8_t mr_datalen;
  uint16_t mr_numsrc;
  in6_addr_0 mr_addr;
};

/* 4272 */
struct mldv2_query
{
  icmp6_hdr mld_icmp6_hdr;
  in6_addr_0 mld_addr;
  uint8_t mld_misc;
  uint8_t mld_qqi;
  uint16_t mld_numsrc;
};

/* 4273 */
struct mld_hdr
{
  icmp6_hdr mld_icmp6_hdr;
  in6_addr_0 mld_addr;
};

/* 4274 */
struct mld_in6m_relhead
{
  in6_multi *slh_first;
};

/* 4275 */
struct ip6_opt_router
{
  u_int8_t ip6or_type;
  u_int8_t ip6or_len;
  u_int8_t ip6or_value[2];
};

/* 4276 */
struct ip6_opt
{
  u_int8_t ip6o_type;
  u_int8_t ip6o_len;
};

/* 4278 */
struct ip6protosw
{
  struct
  {
    ip6protosw *tqe_next;
    ip6protosw **tqe_prev;
  } pr_entry;
  domain *pr_domain;
  protosw *pr_protosw;
  u_int16_t pr_type;
  u_int16_t pr_protocol;
  u_int32_t pr_flags;
  int (*pr_input)(mbuf **, int *, int);
  int (*pr_output)(mbuf *, socket *, sockaddr_in6 *, mbuf *);
  void (*pr_ctlinput)(int, sockaddr *, void *, ifnet *);
  int (*pr_ctloutput)(socket *, sockopt *);
  pr_usrreqs *pr_usrreqs;
  void (*pr_init)(ip6protosw *, domain *);
  void (*pr_drain)(void);
  int (*pr_sysctl)(void);
  int (*pr_lock)(socket *, int, void *);
  int (*pr_unlock)(socket *, int, void *);
  lck_mtx_t *(*pr_getlock)(socket *, int);
  struct
  {
    socket_filter *tqh_first;
    socket_filter **tqh_last;
  } pr_filter_head;
  protosw_old *pr_old;
  void (*pr_update_last_owner)(socket *, proc *, proc *);
  void (*pr_copy_last_owner)(socket *, socket *);
};

/* 4279 */
struct __attribute__((aligned(8))) in6_msource
{
  struct
  {
    ip6_msource *rbe_left;
    ip6_msource *rbe_right;
    ip6_msource *rbe_parent;
  } im6s_link;
  in6_addr_0 im6s_addr;
  uint8_t im6sl_st[2];
};

/* 4280 */
struct in6_multi_dbg
{
  in6_multi in6m;
  u_int16_t in6m_refhold_cnt;
  u_int16_t in6m_refrele_cnt;
  ctrace_t in6m_refhold[32];
  ctrace_t in6m_refrele[32];
  struct
  {
    in6_multi_dbg *tqe_next;
    in6_multi_dbg **tqe_prev;
  } in6m_trash_link;
};

/* 4281 */
struct walkarg
{
  sysctl_req_0 *w_req;
};

/* 4282 */
struct ip6_out_args
{
  unsigned int ip6oa_boundif;
  flowadv ip6oa_flowadv;
  u_int32_t ip6oa_flags;
  int ip6oa_sotc;
  int ip6oa_netsvctype;
  int32_t qos_marking_gencount;
};

/* 4283 */
struct addrsel_policyent
{
  struct
  {
    addrsel_policyent *tqe_next;
    addrsel_policyent **tqe_prev;
  } ape_entry;
  in6_addrpolicy ape_policy;
};

/* 4284 */
struct in6_addrpolicy
{
  sockaddr_in6 addr;
  sockaddr_in6 addrmask;
  int preced;
  int label;
  u_quad_t use;
};

/* 4285 */
struct ip_flow_id
{
  u_int32_t dst_ip;
  u_int32_t src_ip;
  u_int16_t dst_port;
  u_int16_t src_port;
  u_int8_t proto;
  u_int8_t flags;
  u_int8_t addr_type;
  in6_addr_0 dst_ip6;
  in6_addr_0 src_ip6;
  u_int32_t flow_id6;
  u_int32_t frag_id6;
};

/* 4286 */
struct __attribute__((aligned(8))) ip_fw_args
{
  mbuf *fwa_m;
  ifnet *fwa_oif;
  pf_rule *fwa_pf_rule;
  ether_header *fwa_eh;
  int fwa_flags;
  int fwa_oflags;
  union
  {
    ip_out_args *_fwa_ipoa;
    ip6_out_args *_fwa_ip6oa;
  } fwa_ipoa_;
  union
  {
    route *_fwa_ro;
    route_in6 *_fwa_ro6;
  } fwa_ro_;
  union
  {
    sockaddr_in *_fwa_dst;
    sockaddr_in6 *_fwa_dst6;
  } fwa_dst_;
  route_in6 *fwa_ro6_pmtu;
  ifnet *fwa_origifp;
  u_int32_t fwa_mtu;
  u_int32_t fwa_unfragpartlen;
  ip6_exthdrs *fwa_exthdrs;
  ip_flow_id fwa_id;
  u_int32_t fwa_cookie;
};

/* 4319 */
struct ip_out_args
{
  unsigned int ipoa_boundif;
  flowadv ipoa_flowadv;
  u_int32_t ipoa_flags;
  int ipoa_sotc;
  int ipoa_netsvctype;
  int32_t qos_marking_gencount;
};

/* 4320 */
struct __attribute__((aligned(8))) ip6_exthdrs
{
  mbuf *ip6e_ip6;
  mbuf *ip6e_hbh;
  mbuf *ip6e_dest1;
  mbuf *ip6e_rthdr;
  mbuf *ip6e_dest2;
  boolean_t merged;
};

/* 4287 */
struct ipsec_output_state
{
  int tunneled;
  mbuf *m;
  route_in6 ro;
  sockaddr *dst;
  u_int outgoing_if;
  u_int32_t dscp_mapping;
};

/* 4288 */
struct ip6_moptions_dbg
{
  ip6_moptions im6o;
  u_int16_t im6o_refhold_cnt;
  u_int16_t im6o_refrele_cnt;
  ctrace_t im6o_alloc;
  ctrace_t im6o_free;
  ctrace_t im6o_refhold[32];
  ctrace_t im6o_refrele[32];
};

/* 4289 */
struct ipfilter_list
{
  ipfilter *tqh_first;
  ipfilter **tqh_last;
};

/* 4295 */
struct __attribute__((aligned(8))) ipfilter
{
  struct
  {
    ipfilter *tqe_next;
    ipfilter **tqe_prev;
  } ipf_link;
  ipf_filter ipf_filter;
  ipfilter_list *ipf_head;
  struct
  {
    ipfilter *tqe_next;
    ipfilter **tqe_prev;
  } ipf_tbr;
  uint32_t ipf_flags;
};

/* 4293 */
typedef errno_t (*ipf_input_func)(void *, mbuf_t *, int, u_int8_t);

/* 4291 */
typedef ipf_pktopts *ipf_pktopts_t;

/* 4292 */
typedef errno_t (*ipf_output_func)(void *, mbuf_t *, ipf_pktopts_t);

/* 4448 */
typedef void (*ipf_detach_func)(void *);

/* 4294 */
struct ipf_filter
{
  void *cookie;
  const char *name;
  ipf_input_func ipf_input;
  ipf_output_func ipf_output;
  ipf_detach_func ipf_detach;
};

/* 4290 */
struct __attribute__((aligned(4))) ipf_pktopts
{
  u_int32_t ippo_flags;
  ifnet_t ippo_mcast_ifnet;
  int ippo_mcast_loop;
  u_int8_t ippo_mcast_ttl;
};

/* 4296 */
struct ip6_ext
{
  u_int8_t ip6e_nxt;
  u_int8_t ip6e_len;
};

/* 4472 */
typedef u_int64_t dn_key;

/* 4321 */
struct __attribute__((aligned(8))) dn_pkt_tag
{
  void *dn_pf_rule;
  int dn_dir;
  dn_key dn_output_time;
  ifnet *dn_ifp;
  union
  {
    sockaddr_in _dn_dst;
    sockaddr_in6 _dn_dst6;
  } dn_dst_;
  union
  {
    route_0 _dn_ro;
    route_in6 _dn_ro6;
  } dn_ro_;
  route_in6 dn_ro6_pmtu;
  ifnet *dn_origifp;
  u_int32_t dn_mtu;
  u_int32_t dn_unfragpartlen;
  ip6_exthdrs dn_exthdrs;
  int dn_flags;
  union
  {
    ip_out_args _dn_ipoa;
    ip6_out_args _dn_ip6oa;
  } dn_ipoa_;
};

/* 4322 */
struct in6_ifaddrhashhead
{
  in6_ifaddr *tqh_first;
  in6_ifaddr **tqh_last;
};

/* 4323 */
struct __attribute__((aligned(8))) in6_cgareq
{
  char cgar_name[16];
  int cgar_flags;
  in6_cga_prepare cgar_cgaprep;
  in6_addrlifetime cgar_lifetime;
  uint8_t cgar_collision_count;
};

/* 4324 */
struct pf_fragment_tag
{
  uint32_t ft_id;
  uint16_t ft_hdrlen;
  uint16_t ft_unfragpartlen;
  uint16_t ft_extoff;
  uint16_t ft_maxlen;
};

/* 4325 */
struct encaptab
{
  struct
  {
    encaptab *le_next;
    encaptab **le_prev;
  } chain;
  int af;
  int proto;
  sockaddr_storage src;
  sockaddr_storage srcmask;
  sockaddr_storage dst;
  sockaddr_storage dstmask;
  int (*func)(const mbuf *, int, int, void *);
  const protosw *psw;
  void *arg;
};

/* 9224 */
typedef errno_t (*bpf_packet_func_0)(ifnet_t, mbuf_t);

/* 4326 */
struct gif_softc
{
  ifnet_t gif_if;
  sockaddr *gif_psrc;
  sockaddr *gif_pdst;
  protocol_family_t gif_proto;
  union
  {
    route_0 gifscr_ro;
    route_in6 gifscr_ro6;
  } gifsc_gifscr;
  int gif_flags;
  int gif_called;
  const encaptab *encap_cookie4;
  const encaptab *encap_cookie6;
  struct
  {
    gif_softc *tqe_next;
    gif_softc **tqe_prev;
  } gif_link;
  bpf_tap_mode tap_mode;
  bpf_packet_func_0 tap_callback;
  char gif_ifname[16];
  lck_mtx_t gif_lock;
};

/* 4327 */
struct in6_cga_nodecfg
{
  iovec cga_privkey;
  iovec cga_pubkey;
  in6_cga_prepare cga_prepare;
};

/* 4328 */
struct tcp_conn_status
{
  union
  {
    struct
    {
      _BYTE gap0[4];
    };
    uint32_t pad_field;
  };
};

/* 4329 */
struct tcp_info
{
  u_int8_t tcpi_state;
  u_int8_t tcpi_options;
  u_int8_t tcpi_snd_wscale;
  u_int8_t tcpi_rcv_wscale;
  u_int32_t tcpi_flags;
  u_int32_t tcpi_rto;
  u_int32_t tcpi_snd_mss;
  u_int32_t tcpi_rcv_mss;
  u_int32_t tcpi_rttcur;
  u_int32_t tcpi_srtt;
  u_int32_t tcpi_rttvar;
  u_int32_t tcpi_rttbest;
  u_int32_t tcpi_snd_ssthresh;
  u_int32_t tcpi_snd_cwnd;
  u_int32_t tcpi_rcv_space;
  u_int32_t tcpi_snd_wnd;
  u_int32_t tcpi_snd_nxt;
  u_int32_t tcpi_rcv_nxt;
  int32_t tcpi_last_outif;
  u_int32_t tcpi_snd_sbbytes;
  __attribute__((packed)) __attribute__((aligned(1))) u_int64_t tcpi_txpackets;
  __attribute__((packed)) __attribute__((aligned(1))) u_int64_t tcpi_txbytes;
  __attribute__((packed)) __attribute__((aligned(1))) u_int64_t tcpi_txretransmitbytes;
  __attribute__((packed)) __attribute__((aligned(1))) u_int64_t tcpi_txunacked;
  __attribute__((packed)) __attribute__((aligned(1))) u_int64_t tcpi_rxpackets;
  __attribute__((packed)) __attribute__((aligned(1))) u_int64_t tcpi_rxbytes;
  __attribute__((packed)) __attribute__((aligned(1))) u_int64_t tcpi_rxduplicatebytes;
  __attribute__((packed)) __attribute__((aligned(1))) u_int64_t tcpi_rxoutoforderbytes;
  __attribute__((packed)) __attribute__((aligned(1))) u_int64_t tcpi_snd_bw;
  u_int8_t tcpi_synrexmits;
  u_int8_t tcpi_unused1;
  u_int16_t tcpi_unused2;
  u_int64_t tcpi_cell_rxpackets;
  u_int64_t tcpi_cell_rxbytes;
  u_int64_t tcpi_cell_txpackets;
  u_int64_t tcpi_cell_txbytes;
  u_int64_t tcpi_wifi_rxpackets;
  u_int64_t tcpi_wifi_rxbytes;
  u_int64_t tcpi_wifi_txpackets;
  u_int64_t tcpi_wifi_txbytes;
  u_int64_t tcpi_wired_rxpackets;
  u_int64_t tcpi_wired_rxbytes;
  u_int64_t tcpi_wired_txpackets;
  u_int64_t tcpi_wired_txbytes;
  tcp_conn_status tcpi_connstatus;
  __attribute__((aligned(8))) u_int32_t tcpi_ecn_recv_ce;
  u_int32_t tcpi_ecn_recv_cwr;
  u_int32_t tcpi_rcvoopack;
  u_int32_t tcpi_pawsdrop;
  u_int32_t tcpi_sack_recovery_episode;
  u_int32_t tcpi_reordered_pkts;
  u_int32_t tcpi_dsack_sent;
  u_int32_t tcpi_dsack_recvd;
  u_int32_t tcpi_flowhash;
  __attribute__((packed)) __attribute__((aligned(1))) u_int64_t tcpi_txretransmitpackets;
  u_int32_t tcpi_rcv_srtt;
};

/* 4330 */
struct kev_in6_addrlifetime
{
  u_int32_t ia6t_expire;
  u_int32_t ia6t_preferred;
  u_int32_t ia6t_vltime;
  u_int32_t ia6t_pltime;
};

/* 4331 */
struct in6_aliasreq
{
  char ifra_name[16];
  sockaddr_in6 ifra_addr;
  sockaddr_in6 ifra_dstaddr;
  sockaddr_in6 ifra_prefixmask;
  int ifra_flags;
  in6_addrlifetime ifra_lifetime;
};

/* 4332 */
struct __attribute__((aligned(8))) so_cinforeq64
{
  sae_connid_t scir_cid;
  __uint32_t scir_flags;
  __uint32_t scir_ifindex;
  __int32_t scir_error;
  user64_addr_t scir_src;
  socklen_t scir_src_len;
  user64_addr_t scir_dst;
  socklen_t scir_dst_len;
  __uint32_t scir_aux_type;
  user64_addr_t scir_aux_data;
  __uint32_t scir_aux_len;
};

/* 4333 */
struct so_cinforeq32
{
  sae_connid_t scir_cid;
  __uint32_t scir_flags;
  __uint32_t scir_ifindex;
  __int32_t scir_error;
  user32_addr_t scir_src;
  socklen_t scir_src_len;
  user32_addr_t scir_dst;
  socklen_t scir_dst_len;
  __uint32_t scir_aux_type;
  user32_addr_t scir_aux_data;
  __uint32_t scir_aux_len;
};

/* 4334 */
struct so_aidreq64
{
  __uint32_t sar_cnt;
  user64_addr_t sar_aidp;
};

/* 4335 */
struct so_aidreq32
{
  __uint32_t sar_cnt;
  user32_addr_t sar_aidp;
};

/* 4336 */
struct so_cidreq64
{
  sae_associd_t scr_aid;
  __uint32_t scr_cnt;
  user64_addr_t scr_cidp;
};

/* 4337 */
struct so_cidreq32
{
  sae_associd_t scr_aid;
  __uint32_t scr_cnt;
  user32_addr_t scr_cidp;
};

/* 4346 */
enum in6_evhdlr_code_t : __int32
{
  IN6_ADDR_MARKED_DUPLICATED = 0x0,
  IN6_ADDR_MARKED_DETACHED = 0x1,
  IN6_ADDR_MARKED_DEPRECATED = 0x2,
  IN6_NDP_RTR_EXPIRY = 0x3,
  IN6_NDP_PFX_EXPIRY = 0x4,
  IN6_NDP_ADDR_EXPIRY = 0x5,
  IN6_EVENT_MAX = 0x6,
};

/* 4338 */
typedef void (*in6_event_fn)(eventhandler_entry_arg, in6_evhdlr_code_t, ifnet *, in6_addr_0 *, uint32_t);

/* 4339 */
struct eventhandler_entry_in6_event
{
  eventhandler_entry ee;
  in6_event_fn eh_func;
};

/* 4340 */
struct in6_aliasreq_64
{
  char ifra_name[16];
  sockaddr_in6 ifra_addr;
  sockaddr_in6 ifra_broadaddr;
  sockaddr_in6 ifra_prefixmask;
  int ifra_flags;
  in6_addrlifetime_64 ifra_lifetime;
};

/* 4341 */
struct in6_aliasreq_32
{
  char ifra_name[16];
  sockaddr_in6 ifra_addr;
  sockaddr_in6 ifra_broadaddr;
  sockaddr_in6 ifra_prefixmask;
  int ifra_flags;
  in6_addrlifetime_32 ifra_lifetime;
};

/* 4342 */
struct __attribute__((aligned(8))) in6_event
{
  in6_evhdlr_code_t in6_event_code;
  ifnet *in6_ifp;
  in6_addr_0 in6_address;
  uint32_t val;
};

/* 4343 */
struct in6_event_nwk_wq_entry
{
  nwk_wq_entry nwk_wqe;
  in6_event in6_ev_arg;
};

/* 4344 */
struct in6_ifreq
{
  char ifr_name[16];
  union
  {
    sockaddr_in6 ifru_addr;
    sockaddr_in6 ifru_dstaddr;
    int ifru_flags;
    int ifru_flags6;
    int ifru_metric;
    int ifru_intval;
    caddr_t ifru_data;
    in6_addrlifetime ifru_lifetime;
    in6_ifstat ifru_stat;
    icmp6_ifstat ifru_icmp6stat;
    u_int32_t ifru_scope_id[16];
  } ifr_ifru;
};

/* 4345 */
struct in6_ifaddr_dbg
{
  in6_ifaddr in6ifa;
  in6_ifaddr in6ifa_old;
  u_int16_t in6ifa_refhold_cnt;
  u_int16_t in6ifa_refrele_cnt;
  ctrace_t in6ifa_alloc;
  ctrace_t in6ifa_free;
  ctrace_t in6ifa_refhold[32];
  ctrace_t in6ifa_refrele[32];
  struct
  {
    in6_ifaddr_dbg *tqe_next;
    in6_ifaddr_dbg **tqe_prev;
  } in6ifa_trash_link;
};

/* 4347 */
struct in6_event2kev
{
  in6_evhdlr_code_t in6_event_code;
  uint32_t in6_event_kev_subclass;
  uint32_t in6_event_kev_code;
  const char *in6_event_str;
};

/* 4348 */
struct ni_reply_fqdn
{
  u_int32_t ni_fqdn_ttl;
  u_int8_t ni_fqdn_namelen;
  u_int8_t ni_fqdn_name[3];
};

/* 4349 */
struct icmp6_nodeinfo
{
  icmp6_hdr icmp6_ni_hdr;
  u_int8_t icmp6_ni_nonce[8];
};

/* 4350 */
struct ip6_rthdr0
{
  u_int8_t ip6r0_nxt;
  u_int8_t ip6r0_len;
  u_int8_t ip6r0_type;
  u_int8_t ip6r0_segleft;
  u_int32_t ip6r0_reserved;
};

/* 4351 */
struct nd_redirect
{
  icmp6_hdr nd_rd_hdr;
  in6_addr_0 nd_rd_target;
  in6_addr_0 nd_rd_dst;
};

/* 4352 */
struct icmp6errstat
{
  u_quad_t icp6errs_dst_unreach_noroute;
  u_quad_t icp6errs_dst_unreach_admin;
  u_quad_t icp6errs_dst_unreach_beyondscope;
  u_quad_t icp6errs_dst_unreach_addr;
  u_quad_t icp6errs_dst_unreach_noport;
  u_quad_t icp6errs_packet_too_big;
  u_quad_t icp6errs_time_exceed_transit;
  u_quad_t icp6errs_time_exceed_reassembly;
  u_quad_t icp6errs_paramprob_header;
  u_quad_t icp6errs_paramprob_nextheader;
  u_quad_t icp6errs_paramprob_option;
  u_quad_t icp6errs_redirect;
  u_quad_t icp6errs_unknown;
};

/* 4353 */
struct fq6_head
{
  mbuf *mq_first;
  mbuf **mq_last;
};

/* 4354 */
struct __attribute__((aligned(4))) ip6asfrag
{
  ip6asfrag *ip6af_down;
  ip6asfrag *ip6af_up;
  mbuf *ip6af_m;
  int ip6af_offset;
  int ip6af_frglen;
  int ip6af_off;
  u_int16_t ip6af_mff;
};

/* 4355 */
struct ipsec_history
{
  int ih_proto;
  u_int32_t ih_spi;
};

/* 4356 */
struct __attribute__((aligned(8))) ipsec_tag
{
  socket *socket;
  u_int32_t history_count;
};

/* 4358 */
struct __attribute__((aligned(4))) _esp_chachapoly_ctx
{
  chacha20poly1305_ctx ccp_ctx;
  uint8_t ccp_salt[4];
  bool ccp_implicit_iv;
};

/* 4359 */
struct aes_gcm_ctx
{
  ccgcm_ctx *decrypt;
  ccgcm_ctx *encrypt;
  ccgcm_ctx ctxt[];
};

/* 4360 */
struct ipsecstat
{
  u_quad_t in_success;
  u_quad_t in_polvio;
  u_quad_t in_nosa;
  u_quad_t in_inval;
  u_quad_t in_nomem;
  u_quad_t in_badspi;
  u_quad_t in_ahreplay;
  u_quad_t in_espreplay;
  u_quad_t in_ahauthsucc;
  u_quad_t in_ahauthfail;
  u_quad_t in_espauthsucc;
  u_quad_t in_espauthfail;
  u_quad_t in_esphist[256];
  u_quad_t in_ahhist[256];
  u_quad_t in_comphist[256];
  u_quad_t out_success;
  u_quad_t out_polvio;
  u_quad_t out_nosa;
  u_quad_t out_inval;
  u_quad_t out_nomem;
  u_quad_t out_noroute;
  u_quad_t out_esphist[256];
  u_quad_t out_ahhist[256];
  u_quad_t out_comphist[256];
};

/* 4361 */
struct esptail
{
  u_int8_t esp_padlen;
  u_int8_t esp_nxt;
};

/* 4362 */
struct newesp
{
  u_int32_t esp_spi;
  u_int32_t esp_seq;
};

/* 4363 */
struct esp
{
  u_int32_t esp_spi;
};

/* 4364 */
struct newah
{
  u_int8_t ah_nxt;
  u_int8_t ah_len;
  u_int16_t ah_reserve;
  u_int32_t ah_spi;
  u_int32_t ah_seq;
};

/* 4365 */
struct ah
{
  u_int8_t ah_nxt;
  u_int8_t ah_len;
  u_int16_t ah_reserve;
  u_int32_t ah_spi;
};

/* 4366 */
struct tcpopt
{
  uint32_t to_flags;
  uint32_t to_tsval;
  uint32_t to_tsecr;
  uint16_t to_mss;
  uint8_t to_requested_s_scale;
  uint8_t to_nsacks;
  u_char *to_sacks;
  u_char *to_tfo;
};

/* 4382 */
struct mptcp_mpcapable_opt_common
{
  uint8_t mmco_kind;
  uint8_t mmco_len;
  _BYTE gap2;
  uint8_t mmco_flags;
};

/* 4367 */
struct __attribute__((packed)) __attribute__((aligned(4))) mptcp_mpcapable_opt_rsp1
{
  mptcp_mpcapable_opt_common mmc_common;
  mptcp_key_t mmc_localkey;
  mptcp_key_t mmc_remotekey;
};

/* 4368 */
struct mptcp_add_addr_opt
{
  uint8_t maddr_kind;
  uint8_t maddr_len;
  _BYTE gap2;
  uint8_t maddr_addrid;
  union
  {
    struct
    {
      in_addr maddr_addrv4;
      uint32_t maddr_pad[3];
    };
    struct
    {
      in6_addr_0 maddr_addrv6;
    };
  } maddr_u;
};

/* 4369 */
struct __attribute__((packed)) __attribute__((aligned(4))) mptcp_mpfail_opt
{
  uint8_t mfail_kind;
  uint8_t mfail_len;
  _BYTE gap2;
  uint8_t mfail_reserved1;
  uint64_t mfail_dsn;
};

/* 4370 */
struct __attribute__((packed)) __attribute__((aligned(4))) mptcp_fastclose_opt
{
  uint8_t mfast_kind;
  uint8_t mfast_len;
  _BYTE gap2;
  uint8_t mfast_reserved1;
  uint64_t mfast_key;
};

/* 4379 */
struct mptcp_dss_copt
{
  uint8_t mdss_kind;
  uint8_t mdss_len;
  _BYTE gap2;
  uint8_t mdss_flags;
};

/* 4371 */
struct __attribute__((packed)) __attribute__((aligned(2))) mptcp_dss64_ack64_opt
{
  mptcp_dss_copt mdss_copt;
  uint64_t mdss_ack;
  uint64_t mdss_dsn;
  uint32_t mdss_subflow_seqn;
  uint16_t mdss_data_len;
};

/* 4372 */
struct __attribute__((packed)) __attribute__((aligned(2))) mptcp_dss32_ack64_opt
{
  mptcp_dss_copt mdss_copt;
  uint64_t mdss_ack;
  uint32_t mdss_dsn;
  uint32_t mdss_subflow_seqn;
  uint16_t mdss_data_len;
};

/* 4373 */
struct __attribute__((packed)) __attribute__((aligned(2))) mptcp_dss64_ack32_opt
{
  mptcp_dss_copt mdss_copt;
  uint32_t mdss_ack;
  uint64_t mdss_dsn;
  uint32_t mdss_subflow_seqn;
  uint16_t mdss_data_len;
};

/* 4374 */
struct __attribute__((packed)) __attribute__((aligned(4))) mptcp_data_ack64_opt
{
  mptcp_dss_copt mdss_copt;
  uint64_t mdss_ack;
};

/* 4375 */
struct __attribute__((packed)) __attribute__((aligned(2))) mptcp_dsn64_opt
{
  mptcp_dss_copt mdss_copt;
  uint64_t mdss_dsn;
  uint32_t mdss_subflow_seqn;
  uint16_t mdss_data_len;
};

/* 4376 */
struct __attribute__((packed)) __attribute__((aligned(2))) mptcp_dss_ack_opt
{
  mptcp_dss_copt mdss_copt;
  uint32_t mdss_ack;
  uint32_t mdss_dsn;
  uint32_t mdss_subflow_seqn;
  uint16_t mdss_data_len;
};

/* 4377 */
struct mptcp_data_ack_opt
{
  mptcp_dss_copt mdss_copt;
  uint32_t mdss_ack;
};

/* 4378 */
struct __attribute__((packed)) __attribute__((aligned(2))) mptcp_dsn_opt
{
  mptcp_dss_copt mdss_copt;
  uint32_t mdss_dsn;
  uint32_t mdss_subflow_seqn;
  uint16_t mdss_data_len;
};

/* 4380 */
struct mptcp_mpjoin_opt_rsp
{
  uint8_t mmjo_kind;
  uint8_t mmjo_len;
  uint8_t mmjo_subtype_bkp;
  uint8_t mmjo_addr_id;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t mmjo_mac;
  uint32_t mmjo_rand;
};

/* 4381 */
struct __attribute__((packed)) __attribute__((aligned(4))) mptcp_mpcapable_opt_rsp
{
  mptcp_mpcapable_opt_common mmc_common;
  mptcp_key_t mmc_localkey;
};

/* 4383 */
struct mptcp_remaddr_opt
{
  uint8_t mr_kind;
  uint8_t mr_len;
  _BYTE gap2;
  uint8_t mr_addr_id;
};

/* 4384 */
struct tcptemp
{
  u_char tt_ipgen[40];
  tcphdr tt_t;
};

/* 4385 */
struct __attribute__((aligned(8))) mptcp_uuid_search_info
{
  uuid_t_1 target_uuid;
  proc_t found_proc;
  boolean_t is_proc_found;
};

/* 4386 */
typedef conninfo_tcp conninfo_tcp_t;

/* 4413 */
struct conninfo_tcp
{
  tcp_info tcpci_tcp_info;
};

/* 4387 */
typedef mptcp_flow mptcp_flow_t;

/* 9485 */
struct __attribute__((aligned(8))) mptcp_flow
{
  uint64_t flow_len;
  uint64_t flow_tcpci_offset;
  uint32_t flow_flags;
  sae_connid_t flow_cid;
  sockaddr_storage flow_src;
  sockaddr_storage flow_dst;
  uint32_t flow_relseq;
  int32_t flow_soerror;
  uint32_t flow_probecnt;
  __attribute__((packed)) __attribute__((aligned(1))) conninfo_tcp_t flow_ci;
};

/* 4388 */
struct mpp_mtp
{
  mppcb mpp;
  mptses mpp_ses;
  mptcb mtcb;
};

/* 4389 */
typedef mptcp_subflow_event_entry mptsub_ev_entry_t;

/* 9277 */
enum ev_ret_t : __int32
{
  MPTS_EVRET_DELETE = 0x1,
  MPTS_EVRET_OK = 0x2,
  MPTS_EVRET_CONNECT_PENDING = 0x3,
  MPTS_EVRET_DISCONNECT_FALLBACK = 0x4,
};

/* 9278 */
struct mptcp_subflow_event_entry
{
  uint32_t sofilt_hint_mask;
  ev_ret_t (*sofilt_hint_ev_hdlr)(mptses *, mptsub *, uint32_t *, uint32_t);
};

/* 4390 */
struct uuid_search_info
{
  uuid_t_1 target_uuid;
  char *found_signing_id;
  boolean_t found_multiple_signing_ids;
  proc_t found_proc;
};

/* 4392 */
struct encaptabtag
{
  void **arg;
};

/* 4393 */
struct ipctlparam
{
  ip *ipc_icmp_ip;
  mbuf *ipc_m;
  icmp *ipc_icmp;
  size_t ipc_off;
};

/* 4689 */
typedef __uint16_t n_short;

/* 4399 */
struct ih_idseq
{
  n_short icd_id;
  n_short icd_seq;
};

/* 4398 */
struct ih_pmtu
{
  n_short ipm_void;
  n_short ipm_nextmtu;
};

/* 4397 */
struct ih_rtradv
{
  u_char irt_num_addrs;
  u_char irt_wpa;
  u_int16_t irt_lifetime;
};

/* 4688 */
typedef __uint32_t n_time;

/* 4396 */
struct id_ts
{
  n_time its_otime;
  n_time its_rtime;
  n_time its_ttime;
};

/* 9489 */
struct id_ip_0
{
  ip idi_ip;
};

/* 4394 */
struct icmp_ra_addr
{
  u_int32_t ira_addr;
  u_int32_t ira_preference;
};

/* 4400 */
struct icmp
{
  u_char icmp_type;
  u_char icmp_code;
  u_short icmp_cksum;
  union
  {
    u_char ih_pptr;
    in_addr ih_gwaddr;
    ih_idseq ih_idseq;
    int ih_void;
    ih_pmtu ih_pmtu;
    ih_rtradv ih_rtradv;
  } icmp_hun;
  union
  {
    id_ts id_ts;
    id_ip_0 id_ip;
    icmp_ra_addr id_radv;
    u_int32_t id_mask;
    char id_data[1];
  } icmp_dun;
};

/* 9486 */
struct ip_0
{
  u_char ip_vhl;
  u_char ip_tos;
  u_short ip_len;
  u_short ip_id;
  u_short ip_off;
  u_char ip_ttl;
  u_char ip_p;
  u_short ip_sum;
  in_addr ip_src;
  in_addr ip_dst;
};

/* 4395 */
struct id_ip
{
  ip_0 idi_ip;
};

/* 4401 */
struct inpcb64_list_entry
{
  u_int64_t le_next;
  u_int64_t le_prev;
};

/* 4402 */
struct _inpcb_list_entry
{
  u_int32_t le_next;
  u_int32_t le_prev;
};

/* 4480 */
typedef unsigned __int16 ushort;

/* 4403 */
struct inpcb_compat
{
  _inpcb_list_entry inp_hash;
  in_addr reserved1;
  in_addr reserved2;
  u_short inp_fport;
  u_short inp_lport;
  _inpcb_list_entry inp_list;
  u_int32_t inp_ppcb;
  u_int32_t inp_pcbinfo;
  u_int32_t inp_socket;
  u_char nat_owner;
  u_int32_t nat_cookie;
  _inpcb_list_entry inp_portlist;
  u_int32_t inp_phd;
  __attribute__((packed)) __attribute__((aligned(1))) inp_gen_t inp_gencnt;
  int inp_flags;
  u_int32_t inp_flow;
  u_char inp_vflag;
  u_char inp_ip_ttl;
  u_char inp_ip_p;
  union
  {
    in_addr_4in6 inp46_foreign;
    in6_addr_0 inp6_foreign;
  } inp_dependfaddr;
  union
  {
    in_addr_4in6 inp46_local;
    in6_addr_0 inp6_local;
  } inp_dependladdr;
  union
  {
    u_char inp4_route[20];
    u_char inp6_route[32];
  } inp_dependroute;
  struct
  {
    u_char inp4_ip_tos;
    u_int32_t inp4_options;
    u_int32_t inp4_moptions;
  } inp_depend4;
  struct
  {
    u_int32_t inp6_options;
    u_int8_t inp6_hlim;
    u_int8_t unused_uint8_1;
    ushort unused_uint16_1;
    u_int32_t inp6_outputopts;
    u_int32_t inp6_moptions;
    u_int32_t inp6_icmp6filt;
    int inp6_cksum;
    u_short inp6_ifindex;
    short inp6_hops;
  } inp_depend6;
  int hash_element;
  u_int32_t inp_saved_ppcb;
  u_int32_t inp_sp;
  u_int32_t reserved[3];
};

/* 4404 */
struct in_pktinfo
{
  unsigned int ipi_ifindex;
  in_addr ipi_spec_dst;
  in_addr ipi_addr;
};

/* 4405 */
struct ipovly
{
  u_char ih_x1[9];
  u_char ih_pr;
  u_short ih_len;
  in_addr ih_src;
  in_addr ih_dst;
};

/* 4406 */
struct udpiphdr
{
  ipovly ui_i;
  udphdr ui_u;
};

/* 4407 */
typedef uint8_t bitstr_t;

/* 4408 */
struct tcp_globals
{
};

/* 4409 */
struct cbrt_table_entry
{
  double x;
  double cbrt_x;
  double recip_cbrt_x;
  double recip_x;
};

/* 4410 */
struct tcp_cc_algo
{
  char name[16];
  uint32_t num_sockets;
  uint32_t flags;
  int (*init)(tcpcb *);
  int (*cleanup)(tcpcb *);
  void (*cwnd_init)(tcpcb *);
  void (*congestion_avd)(tcpcb *, tcphdr *);
  void (*ack_rcvd)(tcpcb *, tcphdr *);
  void (*pre_fr)(tcpcb *);
  void (*post_fr)(tcpcb *, tcphdr *);
  void (*after_idle)(tcpcb *);
  void (*after_timeout)(tcpcb *);
  int (*delay_ack)(tcpcb *, tcphdr *);
  void (*switch_to)(tcpcb *);
};

/* 4411 */
struct skmem_sysctl
{
  uint32_t version;
  struct
  {
    int32_t bg_target_qdelay;
    int32_t bg_allowed_increase;
    int32_t bg_tether_shift;
    uint32_t bg_ss_fltsz;
    int32_t use_newreno;
    int32_t cubic_tcp_friendliness;
    int32_t cubic_fast_convergence;
    int32_t cubic_use_minrtt;
    int32_t delayed_ack;
    int32_t recvbg;
    int32_t drop_synfin;
    int32_t slowlink_wsize;
    int32_t maxseg_unacked;
    int32_t rfc3465;
    int32_t rfc3465_lim2;
    int32_t recv_allowed_iaj;
    uint32_t doautorcvbuf;
    uint32_t autorcvbufmax;
    int32_t rcvsspktcnt;
    int32_t path_mtu_discovery;
    int32_t local_slowstart_flightsize;
    uint32_t ecn_setup_percentage;
    int32_t ecn_initiate_out;
    int32_t ecn_negotiate_in;
    int32_t packetchain;
    int32_t socket_unlocked_on_output;
    int32_t min_iaj_win;
    int32_t acc_iaj_react_limit;
    uint32_t autosndbufinc;
    uint32_t autosndbufmax;
    uint32_t rtt_recvbg;
    uint32_t recv_throttle_minwin;
    int32_t enable_tlp;
    int32_t sack;
    int32_t sack_maxholes;
    int32_t sack_globalmaxholes;
    int32_t mssdflt;
    int32_t v6mssdflt;
    int32_t fastopen_backlog;
    int32_t fastopen;
    int32_t minmss;
    int32_t icmp_may_rst;
    int32_t rtt_min;
    int32_t rexmt_slop;
    int32_t randomize_ports;
    int32_t win_scale_factor;
    int32_t keepinit;
    int32_t keepidle;
    int32_t keepintvl;
    int32_t keepcnt;
    int32_t msl;
    uint32_t max_persist_timeout;
    int32_t always_keepalive;
    uint32_t timer_fastmode_idlemax;
    int32_t broken_peer_syn_rexmit_thres;
    int32_t pmtud_blackhole_detection;
    uint32_t pmtud_blackhole_mss;
    int32_t sendspace;
    int32_t recvspace;
    uint32_t microuptime_init;
    uint32_t now_init;
    uint32_t challengeack_limit;
    int32_t do_rfc5961;
    int32_t init_rtt_from_cache;
    uint32_t autotunereorder;
    uint32_t do_ack_compression;
    uint32_t ack_compression_rate;
    int32_t do_better_lr;
    int32_t cubic_minor_fixes;
    int32_t cubic_rfc_compliant;
    int32_t aggressive_rcvwnd_inc;
    int32_t ack_strategy;
    int32_t flow_control_response;
    int32_t randomize_timestamps;
    uint32_t ledbat_plus_plus;
    uint32_t use_ledbat;
    uint32_t rledbat;
    uint32_t use_min_curr_rtt;
    uint32_t fin_timeout;
    uint32_t accurate_ecn;
    int32_t tso;
  } tcp;
  struct
  {
    struct
    {
      uint32_t throttle_best_effort;
    } ipc;
  } kern;
};

/* 4412 */
struct so_mpkl_send_info
{
  uuid_t_1 mpkl_uuid;
  __uint8_t mpkl_proto;
};

/* 4414 */
struct timerlisthead
{
  tcptimerentry *lh_first;
};

/* 4415 */
struct __attribute__((aligned(8))) tcp_respond_args
{
  unsigned int ifscope;
};

/* 4416 */
struct tcp_notify_ack_complete
{
  u_int32_t notify_pending;
  u_int32_t notify_complete_count;
  tcp_notify_ack_id_t notify_complete_id[10];
};

/* 4417 */
struct __attribute__((aligned(8))) ifnet_stats_per_flow
{
  u_int64_t bk_txpackets;
  u_int64_t txpackets;
  u_int64_t rxpackets;
  u_int32_t txretransmitbytes;
  u_int32_t rxoutoforderbytes;
  u_int32_t rxmitpkts;
  u_int32_t rcvoopack;
  u_int32_t pawsdrop;
  u_int32_t sack_recovery_episodes;
  u_int32_t reordered_pkts;
  u_int32_t dsack_sent;
  u_int32_t dsack_recvd;
  u_int32_t srtt;
  u_int32_t rttupdated;
  u_int32_t rttvar;
  u_int32_t rttmin;
  u_int32_t bw_sndbw_max;
  u_int32_t bw_rcvbw_max;
  u_int32_t ecn_recv_ece;
  u_int32_t ecn_recv_ce;
  u_int32_t ecn_flags;
  _BYTE gap60[8];
};

/* 4418 */
struct __attribute__((packed)) __attribute__((aligned(4))) xinpcb64
{
  u_int64_t xi_len;
  u_int64_t xi_inpp;
  u_short inp_fport;
  u_short inp_lport;
  inpcb64_list_entry inp_list;
  u_int64_t inp_ppcb;
  u_int64_t inp_pcbinfo;
  inpcb64_list_entry inp_portlist;
  u_int64_t inp_phd;
  inp_gen_t inp_gencnt;
  int inp_flags;
  u_int32_t inp_flow;
  u_char inp_vflag;
  u_char inp_ip_ttl;
  u_char inp_ip_p;
  union
  {
    in_addr_4in6 inp46_foreign;
    __attribute__((aligned(2))) in6_addr_0 inp6_foreign;
  } inp_dependfaddr;
  union
  {
    in_addr_4in6 inp46_local;
    in6_addr_0 inp6_local;
  } inp_dependladdr;
  struct
  {
    u_char inp4_ip_tos;
  } inp_depend4;
  struct
  {
    u_int8_t inp6_hlim;
    int inp6_cksum;
    u_short inp6_ifindex;
    __attribute__((aligned(4))) short inp6_hops;
  } inp_depend6;
  xsocket64 xi_socket;
  u_quad_t xi_alignment_hack;
};

/* 4869 */
typedef __uint32_t tcp_cc;

/* 4419 */
struct xtcpcb64
{
  u_int32_t xt_len;
  xinpcb64 xt_inpcb;
  u_int64_t t_segq;
  int t_dupacks;
  int t_timer[4];
  int t_state;
  u_int t_flags;
  int t_force;
  tcp_seq snd_una;
  tcp_seq snd_max;
  tcp_seq snd_nxt;
  tcp_seq snd_up;
  tcp_seq snd_wl1;
  tcp_seq snd_wl2;
  tcp_seq iss;
  tcp_seq irs;
  tcp_seq rcv_nxt;
  tcp_seq rcv_adv;
  u_int32_t rcv_wnd;
  tcp_seq rcv_up;
  u_int32_t snd_wnd;
  u_int32_t snd_cwnd;
  u_int32_t snd_ssthresh;
  u_int t_maxopd;
  u_int32_t t_rcvtime;
  u_int32_t t_starttime;
  int t_rtttime;
  tcp_seq t_rtseq;
  int t_rxtcur;
  u_int t_maxseg;
  int t_srtt;
  int t_rttvar;
  int t_rxtshift;
  u_int t_rttmin;
  u_int32_t t_rttupdated;
  u_int32_t max_sndwnd;
  int t_softerror;
  char t_oobflags;
  char t_iobc;
  u_char snd_scale;
  u_char rcv_scale;
  u_char request_r_scale;
  u_char requested_s_scale;
  u_int32_t ts_recent;
  u_int32_t ts_recent_age;
  tcp_seq last_ack_sent;
  tcp_cc cc_send;
  tcp_cc cc_recv;
  tcp_seq snd_recover;
  u_int32_t snd_cwnd_prev;
  u_int32_t snd_ssthresh_prev;
  u_int32_t t_badrxtwin;
  u_quad_t xt_alignment_hack;
};

/* 4420 */
struct otcpcb
{
  u_int32_t t_segq;
  int t_dupacks;
  u_int32_t unused;
  int t_timer[4];
  u_int32_t t_inpcb;
  int t_state;
  u_int t_flags;
  int t_force;
  tcp_seq snd_una;
  tcp_seq snd_max;
  tcp_seq snd_nxt;
  tcp_seq snd_up;
  tcp_seq snd_wl1;
  tcp_seq snd_wl2;
  tcp_seq iss;
  tcp_seq irs;
  tcp_seq rcv_nxt;
  tcp_seq rcv_adv;
  u_int32_t rcv_wnd;
  tcp_seq rcv_up;
  u_int32_t snd_wnd;
  u_int32_t snd_cwnd;
  u_int32_t snd_ssthresh;
  u_int t_maxopd;
  u_int32_t t_rcvtime;
  u_int32_t t_starttime;
  int t_rtttime;
  tcp_seq t_rtseq;
  int t_rxtcur;
  u_int t_maxseg;
  int t_srtt;
  int t_rttvar;
  int t_rxtshift;
  u_int t_rttmin;
  u_int32_t t_rttupdated;
  u_int32_t max_sndwnd;
  int t_softerror;
  char t_oobflags;
  char t_iobc;
  u_char snd_scale;
  u_char rcv_scale;
  u_char request_r_scale;
  u_char requested_s_scale;
  u_int32_t ts_recent;
  u_int32_t ts_recent_age;
  tcp_seq last_ack_sent;
  tcp_cc cc_send;
  tcp_cc cc_recv;
  tcp_seq snd_recover;
  u_int32_t snd_cwnd_prev;
  u_int32_t snd_ssthresh_prev;
  u_int32_t t_badrxtwin;
};

/* 4421 */
struct inp_tp
{
  inpcb inp;
  __attribute__((aligned(32))) tcpcb tcb;
};

/* 4427 */
struct __attribute__((aligned(2))) necp_tcp_tfo_cache
{
  u_int8_t necp_tcp_tfo_cookie[16];
  u_int8_t necp_tcp_tfo_cookie_len;
};

/* 4428 */
struct necp_tcp_ecn_cache
{
  _BYTE gap0;
};

/* 4433 */
union in_4_6_addr
{
  in_addr addr;
  in6_addr_0 addr6;
};

/* 4429 */
struct __attribute__((aligned(8))) tcp_cache_key_src
{
  ifnet *ifp;
  in_4_6_addr laddr;
  in_4_6_addr faddr;
  int af;
};

/* 4434 */
struct __attribute__((aligned(4))) tcp_heuristic_key
{
  union
  {
    uint8_t thk_net_signature[20];
    in_4_6_addr thk_ip;
  };
  sa_family_t thk_family;
};

/* 4430 */
struct __attribute__((aligned(8))) tcp_heuristic
{
  struct
  {
    tcp_heuristic *sle_next;
  } list;
  uint32_t th_last_access;
  tcp_heuristic_key th_key;
  uint8_t th_tfo_data_loss;
  uint8_t th_tfo_req_loss;
  uint8_t th_tfo_data_rst;
  uint8_t th_tfo_req_rst;
  uint8_t th_mptcp_loss;
  uint8_t th_mptcp_success;
  uint8_t th_ecn_loss;
  uint8_t th_ecn_aggressive;
  uint8_t th_ecn_droprst;
  uint8_t th_ecn_droprxmt;
  uint8_t th_ecn_synrst;
  uint32_t th_tfo_enabled_time;
  uint32_t th_tfo_backoff_until;
  uint32_t th_tfo_backoff;
  uint32_t th_mptcp_backoff;
  uint32_t th_ecn_backoff;
};

/* 4431 */
struct tcp_heur_bucket
{
  tcp_heuristic *slh_first;
};

/* 4432 */
struct tcp_heuristics_head
{
  tcp_heur_bucket tcp_heuristics;
  lck_mtx_t thh_mtx;
};

/* 4435 */
struct tcp_cache_key
{
  sa_family_t tck_family;
  tcp_heuristic_key tck_src;
  in_4_6_addr tck_dst;
};

/* 4436 */
struct tcp_cache
{
  struct
  {
    tcp_cache *sle_next;
  } list;
  uint32_t tc_last_access;
  tcp_cache_key tc_key;
  uint8_t tc_tfo_cookie[16];
  uint8_t tc_tfo_cookie_len;
  __attribute__((aligned(2))) uint8_t tc_mptcp_version;
  uint32_t tc_mptcp_next_version_try;
};

/* 4437 */
struct tcp_cache_bucket
{
  tcp_cache *slh_first;
};

/* 4438 */
struct tcp_cache_head
{
  tcp_cache_bucket tcp_caches;
  lck_mtx_t tch_mtx;
};

/* 4439 */
typedef int ip_dn_ctl_t(sockopt *);

/* 4440 */
struct ip_moptions_dbg
{
  ip_moptions imo;
  u_int16_t imo_refhold_cnt;
  u_int16_t imo_refrele_cnt;
  ctrace_t imo_alloc;
  ctrace_t imo_free;
  ctrace_t imo_refhold[32];
  ctrace_t imo_refrele[32];
};

/* 4441 */
struct ipoption
{
  in_addr ipopt_dst;
  char ipopt_list[40];
};

/* 4442 */
typedef pktchain_elm pktchain_elm_t;

/* 9487 */
struct pktchain_elm
{
  mbuf *pkte_head;
  mbuf *pkte_tail;
  in_addr pkte_saddr;
  in_addr pkte_daddr;
  uint16_t pkte_npkts;
  uint16_t pkte_proto;
  uint32_t pkte_nbytes;
};

/* 4443 */
struct ip_fw_in_args
{
  pf_rule *fwai_pf_rule;
};

/* 4445 */
typedef __uint32_t n_long;

/* 4444 */
struct ipt_ta
{
  in_addr ipt_addr;
  n_long ipt_time;
};

/* 4446 */
union ipt_timestamp
{
  n_long ipt_time[1];
  ipt_ta ipt_ta[1];
};

/* 4447 */
struct ip_timestamp
{
  u_char ipt_code;
  u_char ipt_len;
  u_char ipt_ptr;
  ipt_timestamp ipt_timestamp;
};

/* 4449 */
typedef int ip_dn_io_t(mbuf *, int, int, ip_fw_args *);

/* 4450 */
struct in_ifaddrhashhead
{
  in_ifaddr *tqh_first;
  in_ifaddr **tqh_last;
};

/* 4451 */
struct ipq
{
  struct
  {
    ipq *tqe_next;
    ipq **tqe_prev;
  } ipq_list;
  mbuf *ipq_frags;
  u_char ipq_ttl;
  u_char ipq_p;
  u_short ipq_id;
  in_addr ipq_src;
  in_addr ipq_dst;
  u_int32_t ipq_nfrags;
  uint32_t ipq_csum_flags;
  uint32_t ipq_csum;
};

/* 4452 */
struct ipqhead
{
  ipq *tqh_first;
  ipq **tqh_last;
};

/* 4453 */
typedef void (*dummynet_event_fn)(eventhandler_entry_arg, dummynet_event *);

/* 4464 */
struct dn_pipe_mini_config
{
  uint32_t bandwidth;
  uint32_t delay;
  uint32_t plr;
};

/* 4463 */
struct dn_rule_mini_config
{
  uint32_t dir;
  uint32_t af;
  uint32_t proto;
  uint32_t src_port;
  uint32_t dst_port;
  char ifname[24];
};

/* 4465 */
struct dummynet_event
{
  uint32_t dn_event_code;
  union
  {
    dn_pipe_mini_config _dnev_pipe_config;
    dn_rule_mini_config _dnev_rule_config;
  } dn_event;
};

/* 4454 */
struct eventhandler_entry_dummynet_event
{
  eventhandler_entry ee;
  dummynet_event_fn eh_func;
};

/* 4455 */
struct dn_flow_queue_64
{
  user64_addr_t next;
  ip_flow_id id;
  user64_addr_t head;
  user64_addr_t tail;
  u_int len;
  u_int len_bytes;
  u_int32_t numbytes;
  u_int64_t tot_pkts;
  u_int64_t tot_bytes;
  u_int32_t drops;
  int hash_slot;
  int avg;
  int count;
  int random;
  u_int32_t q_time;
  user64_addr_t fs;
  int heap_pos;
  dn_key sched_time;
  dn_key S;
  dn_key F;
};

/* 4456 */
struct dn_flow_queue_32
{
  user32_addr_t next;
  ip_flow_id id;
  user32_addr_t head;
  user32_addr_t tail;
  u_int len;
  u_int len_bytes;
  u_int32_t numbytes;
  u_int64_t tot_pkts;
  u_int64_t tot_bytes;
  u_int32_t drops;
  int hash_slot;
  int avg;
  int count;
  int random;
  u_int32_t q_time;
  user32_addr_t fs;
  int heap_pos;
  dn_key sched_time;
  dn_key S;
  dn_key F;
};

/* 4457 */
struct dn_flow_set_32
{
  user32_addr_t next;
  u_short fs_nr;
  u_short flags_fs;
  user32_addr_t pipe;
  u_short parent_nr;
  int weight;
  int qsize;
  int plr;
  ip_flow_id flow_mask;
  int rq_size;
  int rq_elements;
  user32_addr_t rq;
  u_int32_t last_expired;
  int backlogged;
  int w_q;
  int max_th;
  int min_th;
  int max_p;
  u_int c_1;
  u_int c_2;
  u_int c_3;
  u_int c_4;
  user32_addr_t w_q_lookup;
  u_int lookup_depth;
  int lookup_step;
  int lookup_weight;
  int avg_pkt_size;
  int max_pkt_size;
};

/* 4458 */
struct dn_heap_32
{
  int size;
  int elements;
  int offset;
  user32_addr_t p;
};

/* 4459 */
struct dn_pipe_32
{
  user32_addr_t next;
  int pipe_nr;
  int bandwidth;
  int delay;
  user32_addr_t head;
  user32_addr_t tail;
  dn_heap_32 scheduler_heap;
  dn_heap_32 not_eligible_heap;
  dn_heap_32 idle_heap;
  dn_key V;
  int sum;
  int numbytes;
  dn_key sched_time;
  char if_name[16];
  user32_addr_t ifp;
  int ready;
  dn_flow_set_32 fs;
};

/* 4460 */
struct __attribute__((aligned(8))) dn_flow_set_64
{
  user64_addr_t next;
  u_short fs_nr;
  u_short flags_fs;
  user64_addr_t pipe;
  u_short parent_nr;
  int weight;
  int qsize;
  int plr;
  ip_flow_id flow_mask;
  int rq_size;
  int rq_elements;
  user64_addr_t rq;
  u_int32_t last_expired;
  int backlogged;
  int w_q;
  int max_th;
  int min_th;
  int max_p;
  u_int c_1;
  u_int c_2;
  u_int c_3;
  u_int c_4;
  user64_addr_t w_q_lookup;
  u_int lookup_depth;
  int lookup_step;
  int lookup_weight;
  int avg_pkt_size;
  int max_pkt_size;
};

/* 4461 */
struct dn_heap_64
{
  int size;
  int elements;
  int offset;
  user64_addr_t p;
};

/* 4462 */
struct dn_pipe_64
{
  user64_addr_t next;
  int pipe_nr;
  int bandwidth;
  int delay;
  user64_addr_t head;
  user64_addr_t tail;
  dn_heap_64 scheduler_heap;
  dn_heap_64 not_eligible_heap;
  dn_heap_64 idle_heap;
  dn_key V;
  int sum;
  int numbytes;
  dn_key sched_time;
  char if_name[16];
  user64_addr_t ifp;
  int ready;
  dn_flow_set_64 fs;
};

/* 4466 */
struct dn_event_nwk_wq_entry
{
  nwk_wq_entry nwk_wqe;
  dummynet_event dn_ev_arg;
};

/* 4467 */
struct dn_flow_set_head
{
  dn_flow_set *slh_first;
};

/* 4469 */
struct __attribute__((aligned(8))) dn_flow_set
{
  struct
  {
    dn_flow_set *sle_next;
  } next;
  u_short fs_nr;
  u_short flags_fs;
  dn_pipe *pipe;
  u_short parent_nr;
  int weight;
  int qsize;
  int plr;
  ip_flow_id flow_mask;
  int rq_size;
  int rq_elements;
  dn_flow_queue **rq;
  u_int32_t last_expired;
  int backlogged;
  int w_q;
  int max_th;
  int min_th;
  int max_p;
  u_int c_1;
  u_int c_2;
  u_int c_3;
  u_int c_4;
  u_int *w_q_lookup;
  u_int lookup_depth;
  int lookup_step;
  int lookup_weight;
  int avg_pkt_size;
  int max_pkt_size;
};

/* 8012 */
struct dn_heap
{
  int size;
  int elements;
  int offset;
  dn_heap_entry *p;
};

/* 4470 */
struct dn_pipe
{
  struct
  {
    dn_pipe *sle_next;
  } next;
  int pipe_nr;
  int bandwidth;
  int delay;
  mbuf *head;
  mbuf *tail;
  dn_heap scheduler_heap;
  dn_heap not_eligible_heap;
  dn_heap idle_heap;
  dn_key V;
  int sum;
  int numbytes;
  dn_key sched_time;
  char if_name[16];
  ifnet *ifp;
  int ready;
  dn_flow_set fs;
};

/* 4468 */
struct dn_flow_queue
{
  dn_flow_queue *next;
  ip_flow_id id;
  mbuf *head;
  mbuf *tail;
  u_int len;
  u_int len_bytes;
  u_int32_t numbytes;
  u_int64_t tot_pkts;
  u_int64_t tot_bytes;
  u_int32_t drops;
  int hash_slot;
  int avg;
  int count;
  int random;
  u_int64_t q_time;
  dn_flow_set *fs;
  int heap_pos;
  dn_key sched_time;
  dn_key S;
  dn_key F;
};

/* 4473 */
struct dn_heap_entry
{
  dn_key key;
  void *object;
};

/* 4471 */
struct dn_pipe_head
{
  dn_pipe *slh_first;
};

/* 4474 */
struct net_qos_guideline_args
{
  user_addr_t_0 param;
  uint32_t param_len;
  char param_len_r_[4];
};

/* 7828 */
enum mbuf_svc_class_t : __int32
{
  MBUF_SC_UNSPEC = 0xFFFFFFFF,
  MBUF_SC_BK_SYS = 0x80090,
  MBUF_SC_BK = 0x100080,
  MBUF_SC_BE = 0x0,
  MBUF_SC_RD = 0x180010,
  MBUF_SC_OAM = 0x200020,
  MBUF_SC_AV = 0x280120,
  MBUF_SC_RV = 0x300110,
  MBUF_SC_VI = 0x380100,
  MBUF_SC_SIG = 0x380130,
  MBUF_SC_VO = 0x400180,
  MBUF_SC_CTL = 0x480190,
};

/* 4475 */
struct dcsp_msc_map
{
  uint8_t dscp;
  mbuf_svc_class_t msc;
};

/* 4476 */
struct __attribute__((aligned(4))) netsvctype_dscp_map
{
  int netsvctype;
  u_int8_t dscp;
};

/* 4478 */
struct __attribute__((packed)) __attribute__((aligned(4))) xtcpcb_n
{
  u_int32_t xt_len;
  u_int32_t xt_kind;
  u_int64_t t_segq;
  int t_dupacks;
  int t_timer[4];
  int t_state;
  u_int t_flags;
  int t_force;
  tcp_seq snd_una;
  tcp_seq snd_max;
  tcp_seq snd_nxt;
  tcp_seq snd_up;
  tcp_seq snd_wl1;
  tcp_seq snd_wl2;
  tcp_seq iss;
  tcp_seq irs;
  tcp_seq rcv_nxt;
  tcp_seq rcv_adv;
  u_int32_t rcv_wnd;
  tcp_seq rcv_up;
  u_int32_t snd_wnd;
  u_int32_t snd_cwnd;
  u_int32_t snd_ssthresh;
  u_int t_maxopd;
  u_int32_t t_rcvtime;
  u_int32_t t_starttime;
  int t_rtttime;
  tcp_seq t_rtseq;
  int t_rxtcur;
  u_int t_maxseg;
  int t_srtt;
  int t_rttvar;
  int t_rxtshift;
  u_int t_rttmin;
  u_int32_t t_rttupdated;
  u_int32_t max_sndwnd;
  int t_softerror;
  char t_oobflags;
  char t_iobc;
  u_char snd_scale;
  u_char rcv_scale;
  u_char request_r_scale;
  u_char requested_s_scale;
  __attribute__((aligned(4))) u_int32_t ts_recent;
  u_int32_t ts_recent_age;
  tcp_seq last_ack_sent;
  tcp_cc cc_send;
  tcp_cc cc_recv;
  tcp_seq snd_recover;
  u_int32_t snd_cwnd_prev;
  u_int32_t snd_ssthresh_prev;
};

/* 4479 */
struct xinpcb_n
{
  u_int32_t xi_len;
  u_int32_t xi_kind;
  u_int64_t xi_inpp;
  u_short inp_fport;
  u_short inp_lport;
  __attribute__((packed)) __attribute__((aligned(1))) u_int64_t inp_ppcb;
  __attribute__((packed)) __attribute__((aligned(1))) inp_gen_t inp_gencnt;
  int inp_flags;
  u_int32_t inp_flow;
  u_char inp_vflag;
  u_char inp_ip_ttl;
  u_char inp_ip_p;
  union
  {
    in_addr_4in6 inp46_foreign;
    in6_addr_0 inp6_foreign;
  } inp_dependfaddr;
  union
  {
    in_addr_4in6 inp46_local;
    in6_addr_0 inp6_local;
  } inp_dependladdr;
  struct
  {
    u_char inp4_ip_tos;
  } inp_depend4;
  struct
  {
    u_int8_t inp6_hlim;
    int inp6_cksum;
    u_short inp6_ifindex;
    short inp6_hops;
  } inp_depend6;
  u_int32_t inp_flowhash;
  u_int32_t inp_flags2;
};

/* 4481 */
struct __attribute__((aligned(4))) so_procinfo
{
  pid_t spi_pid;
  pid_t spi_epid;
  uuid_t_1 spi_uuid;
  uuid_t_1 spi_euuid;
  int spi_delegated;
  char spi_proc_name[17];
  char spi_e_proc_name[17];
};

/* 4482 */
struct __attribute__((aligned(4))) in_msource
{
  struct
  {
    ip_msource *rbe_left;
    ip_msource *rbe_right;
    ip_msource *rbe_parent;
  } ims_link;
  in_addr_t ims_haddr;
  uint8_t imsl_st[2];
};

/* 4483 */
struct in_multi_dbg
{
  in_multi inm;
  u_int16_t inm_refhold_cnt;
  u_int16_t inm_refrele_cnt;
  ctrace_t inm_refhold[32];
  ctrace_t inm_refrele[32];
  struct
  {
    in_multi_dbg *tqe_next;
    in_multi_dbg **tqe_prev;
  } inm_trash_link;
};

/* 4484 */
struct __attribute__((aligned(4))) kev_in_collision
{
  net_event_data link_data;
  in_addr ia_ipaddr;
  u_char hw_len;
};

/* 4485 */
struct llinfo_arp
{
  struct
  {
    llinfo_arp *le_next;
    llinfo_arp **le_prev;
  } la_le;
  rtentry *la_rt;
  class_queue_t la_holdq;
  if_llreach *la_llreach;
  u_int64_t la_lastused;
  u_int32_t la_asked;
  u_int32_t la_maxtries;
  u_int64_t la_probeexp;
  u_int32_t la_prbreq_cnt;
  u_int32_t la_flags;
};

/* 4486 */
struct dhcp
{
  u_char dp_op;
  u_char dp_htype;
  u_char dp_hlen;
  u_char dp_hops;
  u_int32_t dp_xid;
  u_int16_t dp_secs;
  u_int16_t dp_flags;
  in_addr dp_ciaddr;
  in_addr dp_yiaddr;
  in_addr dp_siaddr;
  in_addr dp_giaddr;
  u_char dp_chaddr[16];
  u_char dp_sname[64];
  u_char dp_file[128];
  u_char dp_options[];
};

/* 4487 */
typedef ptrlist_t dhcpol_t;

/* 4488 */
struct ptrlist_t
{
  const void **array;
  uint32_t size;
  uint32_t count;
};

/* 4489 */
struct rt_msghdr
{
  u_short rtm_msglen;
  u_char rtm_version;
  u_char rtm_type;
  u_short rtm_index;
  int rtm_flags;
  int rtm_addrs;
  pid_t rtm_pid;
  int rtm_seq;
  int rtm_errno;
  int rtm_use;
  u_int32_t rtm_inits;
  rt_metrics rtm_rmx;
};

/* 4490 */
struct in_llentry
{
  llentry base;
};

/* 4491 */
struct in_aliasreq
{
  char ifra_name[16];
  sockaddr_in ifra_addr;
  sockaddr_in ifra_broadaddr;
  sockaddr_in ifra_mask;
};

/* 4492 */
struct ifreq
{
  char ifr_name[16];
  union
  {
    sockaddr ifru_addr;
    sockaddr ifru_dstaddr;
    sockaddr ifru_broadaddr;
    short ifru_flags;
    int ifru_metric;
    int ifru_mtu;
    int ifru_phys;
    int ifru_media;
    int ifru_intval;
    caddr_t ifru_data;
    u_int64_t ifru_data64;
    ifdevmtu ifru_devmtu;
    ifkpi ifru_kpi;
    u_int32_t ifru_wake_flags;
    u_int32_t ifru_route_refcnt;
    int ifru_link_quality_metric;
    int ifru_cap[2];
    struct
    {
      uint32_t ifo_flags;
      uint32_t ifo_inuse;
    } ifru_opportunistic;
    u_int64_t ifru_eflags;
    u_int64_t ifru_xflags;
    struct
    {
      int32_t ifl_level;
      uint32_t ifl_flags;
      int32_t ifl_category;
      int32_t ifl_subcategory;
    } ifru_log;
    u_int32_t ifru_delegated;
    struct
    {
      uint32_t ift_type;
      uint32_t ift_family;
      uint32_t ift_subfamily;
    } ifru_type;
    u_int32_t ifru_functional_type;
    u_int32_t ifru_expensive;
    u_int32_t ifru_constrained;
    u_int32_t ifru_2kcl;
    struct
    {
      u_int32_t qlen;
      u_int32_t timeout;
    } ifru_start_delay;
    if_interface_state ifru_interface_state;
    u_int32_t ifru_probe_connectivity;
    u_int32_t ifru_ecn_mode;
    u_int32_t ifru_qosmarking_mode;
    u_int32_t ifru_qosmarking_enabled;
    u_int32_t ifru_disable_output;
    u_int32_t ifru_low_internet;
    int ifru_low_power_mode;
    u_int32_t ifru_tcp_kao_max;
    int ifru_mpk_log;
    u_int32_t ifru_noack_prio;
    struct
    {
      u_int8_t up_bucket;
      u_int8_t down_bucket;
    } ifru_estimated_throughput;
    struct
    {
      u_int8_t technology;
      u_int8_t channel;
    } ifru_radio_details;
  } ifr_ifru;
};

/* 4493 */
struct in_ifaddr_dbg
{
  in_ifaddr inifa;
  in_ifaddr inifa_old;
  u_int16_t inifa_refhold_cnt;
  u_int16_t inifa_refrele_cnt;
  ctrace_t inifa_alloc;
  ctrace_t inifa_free;
  ctrace_t inifa_refhold[32];
  ctrace_t inifa_refrele[32];
  struct
  {
    in_ifaddr_dbg *tqe_next;
    in_ifaddr_dbg **tqe_prev;
  } inifa_trash_link;
};

/* 4494 */
struct __attribute__((aligned(4))) igmp_tparams
{
  int qpt;
  int it;
  int cst;
  int sct;
  bool fast;
};

/* 4495 */
struct net_thread_marks
{
};

/* 4496 */
struct igmp_report
{
  u_char ir_type;
  u_char ir_rsv1;
  u_short ir_cksum;
  u_short ir_rsv2;
  u_short ir_numgrps;
};

/* 4497 */
struct sk_protect;

/* 4498 */
struct igmp_grouprec
{
  u_char ig_type;
  u_char ig_datalen;
  u_short ig_numsrc;
  in_addr ig_group;
};

/* 4499 */
struct igmpv3
{
  u_char igmp_type;
  u_char igmp_code;
  u_short igmp_cksum;
  in_addr igmp_group;
  u_char igmp_misc;
  u_char igmp_qqi;
  u_short igmp_numsrc;
};

/* 4500 */
struct igmp
{
  u_char igmp_type;
  u_char igmp_code;
  u_short igmp_cksum;
  in_addr igmp_group;
};

/* 4501 */
struct igmp_inm_relhead
{
  in_multi *slh_first;
};

/* 4502 */
struct __attribute__((aligned(8))) _mbuf
{
  _mbuf *_m_next;
  void *_m_pad;
  uint8_t *_m_data;
  int32_t _m_len;
};

/* 4503 */
typedef int netem_output_func_t(void *, pktsched_pkt_t *, uint32_t);

/* 4517 */
struct fq_codel_flowstats
{
  u_int32_t fqst_min_qdelay;
  u_int32_t fqst_flags;
  u_int32_t fqst_bytes;
  u_int32_t fqst_flowhash;
};

/* 4515 */
struct fq_codel_classstats
{
  u_int32_t fcls_pri;
  u_int32_t fcls_service_class;
  u_int32_t fcls_quantum;
  u_int32_t fcls_drr_max;
  int64_t fcls_budget;
  u_int64_t fcls_target_qdelay;
  u_int64_t fcls_l4s_target_qdelay;
  u_int64_t fcls_update_interval;
  u_int32_t fcls_flow_control;
  u_int32_t fcls_flow_feedback;
  u_int32_t fcls_dequeue_stall;
  u_int32_t fcls_flow_control_fail;
  u_int64_t fcls_drop_overflow;
  u_int64_t fcls_drop_early;
  u_int32_t fcls_drop_memfailure;
  u_int32_t fcls_flows_cnt;
  u_int32_t fcls_newflows_cnt;
  u_int32_t fcls_oldflows_cnt;
  u_int64_t fcls_pkt_cnt;
  u_int64_t fcls_dequeue;
  u_int64_t fcls_dequeue_bytes;
  u_int64_t fcls_byte_cnt;
  u_int32_t fcls_throttle_on;
  u_int32_t fcls_throttle_off;
  u_int32_t fcls_throttle_drops;
  u_int32_t fcls_dup_rexmts;
  u_int32_t fcls_flowstats_cnt;
  fq_codel_flowstats fcls_flowstats[20];
  u_int32_t fcls_pkts_compressible;
  u_int32_t fcls_pkts_compressed;
  uint64_t fcls_min_qdelay;
  uint64_t fcls_max_qdelay;
  uint64_t fcls_avg_qdelay;
  uint32_t fcls_overwhelming;
  uint64_t fcls_ce_marked;
  uint64_t fcls_ce_mark_failures;
  uint64_t fcls_l4s_pkts;
};

/* 4516 */
struct if_ifclassq_stats
{
  u_int32_t ifqs_len;
  u_int32_t ifqs_maxlen;
  pktcntr ifqs_xmitcnt;
  pktcntr ifqs_dropcnt;
  u_int32_t ifqs_scheduler;
  fq_codel_classstats ifqs_fq_codel_stats;
};

/* 4518 */
struct flowq_dqlist_t
{
  flowq *stqh_first;
  flowq **stqh_last;
};

/* 4529 */
struct mbufq_head
{
  mbuf *mq_first;
  mbuf **mq_last;
};

/* 4528 */
struct __attribute__((packed)) __attribute__((aligned(4))) kpktq_head
{
  __kern_packet *kq_first;
  __kern_packet **kq_last;
  uint32_t kq_len;
};

/* 4527 */
typedef fq_codel_classq_group fq_if_group_t;

/* 4530 */
struct flowq
{
  union __attribute__((packed)) __attribute__((aligned(4)))
  {
    mbufq_head __mbufq;
    kpktq_head __kpktq;
  } __fq_pktq_u;
  uint32_t fq_flowhash;
  uint32_t fq_bytes;
  int32_t fq_deficit;
  fq_if_group_t *fq_group;
  uint8_t fq_flags;
  uint8_t fq_sc_index;
  bool fq_in_dqlist;
  __attribute__((aligned(2))) uint8_t __fq_pad_uint8[4];
  uint64_t fq_min_qdelay;
  uint64_t fq_getqtime;
  union
  {
    uint64_t fq_updatetime;
    uint64_t fq_empty_purge_time;
  };
  struct
  {
    flowq *sle_next;
  } fq_hashlink;
  union
  {
    struct
    {
      flowq *stqe_next;
    } fq_actlink;
    struct
    {
      flowq *tqe_next;
      flowq **tqe_prev;
    } fq_empty_link;
  };
  struct
  {
    flowq *stqe_next;
  } fq_dqlink;
  classq_pkt_t fq_dq_head;
  classq_pkt_t fq_dq_tail;
};

/* 4541 */
typedef u_int32_t pktsched_bitmap_t;

/* 4532 */
struct flowq_stailq_t
{
  flowq *stqh_first;
  flowq **stqh_last;
};

/* 4531 */
struct fcl_stat
{
  u_int32_t fcl_flow_control;
  u_int32_t fcl_flow_feedback;
  u_int32_t fcl_dequeue_stall;
  u_int32_t fcl_flow_control_fail;
  u_int64_t fcl_drop_overflow;
  u_int64_t fcl_drop_early;
  u_int32_t fcl_drop_memfailure;
  u_int32_t fcl_flows_cnt;
  u_int32_t fcl_newflows_cnt;
  u_int32_t fcl_oldflows_cnt;
  u_int64_t fcl_pkt_cnt;
  u_int64_t fcl_dequeue;
  u_int64_t fcl_dequeue_bytes;
  u_int64_t fcl_byte_cnt;
  u_int32_t fcl_throttle_on;
  u_int32_t fcl_throttle_off;
  u_int32_t fcl_throttle_drops;
  u_int32_t fcl_dup_rexmts;
  u_int32_t fcl_pkts_compressible;
  u_int32_t fcl_pkts_compressed;
  uint64_t fcl_min_qdelay;
  uint64_t fcl_max_qdelay;
  uint64_t fcl_avg_qdelay;
  uint32_t fcl_overwhelming;
  uint64_t fcl_ce_marked;
  uint64_t fcl_ce_mark_failures;
  uint64_t fcl_l4s_pkts;
};

/* 8021 */
struct fq_if_classq
{
  uint32_t fcl_pri;
  uint32_t fcl_service_class;
  uint32_t fcl_quantum;
  uint32_t fcl_drr_max;
  int64_t fcl_budget;
  flowq_stailq_t fcl_new_flows;
  flowq_stailq_t fcl_old_flows;
  fcl_stat fcl_stat;
};

/* 4533 */
typedef fq_if_classq fq_if_classq_t;

/* 4534 */
struct fq_codel_classq_group
{
  uint64_t fqg_target_qdelays[2];
  uint64_t fqg_update_intervals[2];
  pktsched_bitmap_t fqg_bitmaps[4];
  struct
  {
    fq_codel_classq_group *tqe_next;
    fq_codel_classq_group **tqe_prev;
  } fqg_grp_link;
  uint32_t fqg_bytes;
  uint32_t fqg_len;
  uint8_t fqg_flags;
  uint8_t fqg_index;
  fq_if_classq_t fqg_classq[10];
  flowq *fqg_large_flow;
};

/* 4519 */
typedef flowq fq_t;

/* 8018 */
enum cqrq : __int32
{
  cqrq::CLASSQRQ_PURGE = 0x1,
  cqrq::CLASSQRQ_PURGE_SC = 0x2,
  cqrq::CLASSQRQ_EVENT = 0x3,
  cqrq::CLASSQRQ_THROTTLE = 0x4,
  cqrq::CLASSQRQ_STAT_SC = 0x5,
};

/* 4520 */
typedef cqrq cqrq_t;

/* 4521 */
typedef cqrq_stat_sc cqrq_stat_sc_t;

/* 9282 */
struct cqrq_stat_sc
{
  mbuf_svc_class_t sc;
  u_int8_t grp_idx;
  u_int32_t packets;
  u_int32_t bytes;
};

/* 4522 */
typedef cqrq_throttle cqrq_throttle_t;

/* 8019 */
struct cqrq_throttle
{
  u_int32_t set;
  u_int32_t level;
};

/* 4523 */
typedef cqrq_purge_sc cqrq_purge_sc_t;

/* 9283 */
struct cqrq_purge_sc
{
  mbuf_svc_class_t sc;
  u_int32_t flow;
  u_int32_t packets;
  u_int32_t bytes;
};

/* 4524 */
struct flowq_list_t
{
  flowq *slh_first;
};

/* 4525 */
struct flowadv_fclist
{
  flowadv_fcentry *stqh_first;
  flowadv_fcentry **stqh_last;
};

/* 4526 */
typedef fq_codel_sched_data fq_if_t;

/* 4535 */
struct fq_grp_tailq_t
{
  fq_codel_classq_group *tqh_first;
  fq_codel_classq_group **tqh_last;
};

/* 4540 */
typedef fq_if_bitmap_ops bitmap_ops_t;

/* 9284 */
struct fq_codel_sched_data
{
  ifclassq *fqs_ifq;
  flowq_list_t fqs_flows[256];
  uint32_t fqs_pkt_droplimit;
  uint8_t fqs_throttle;
  uint8_t fqs_flags;
  flowadv_fclist fqs_fclist;
  flowq *fqs_large_flow;
  struct
  {
    flowq *tqh_first;
    flowq **tqh_last;
  } fqs_empty_list;
  fq_grp_tailq_t fqs_combined_grp_list;
  uint32_t fqs_empty_list_cnt;
  pktsched_bitmap_t fqs_combined_grp_bitmap;
  classq_pkt_type_t fqs_ptype;
  bitmap_ops_t *fqs_bm_ops;
  fq_if_group_t *fqs_classq_groups[16];
};

/* 8022 */
struct fq_if_bitmap_ops
{
  _BYTE gap0[32];
};

/* 4536 */
typedef void fq_if_bitmaps_clr;

/* 4537 */
typedef void fq_if_bitmaps_cpy;

/* 4538 */
typedef void fq_if_bitmaps_zeros;

/* 4539 */
typedef void fq_if_bitmaps_ffs;

/* 8020 */
enum cqev : __int32
{
  cqev::CLASSQ_EV_INIT = 0x0,
  cqev::CLASSQ_EV_LINK_BANDWIDTH = 0x1,
  cqev::CLASSQ_EV_LINK_LATENCY = 0x2,
  cqev::CLASSQ_EV_LINK_MTU = 0x3,
  cqev::CLASSQ_EV_LINK_UP = 0x4,
  cqev::CLASSQ_EV_LINK_DOWN = 0x5,
};

/* 4542 */
typedef cqev cqev_t;

/* 4543 */
struct timeval32
{
  __int32_t tv_sec;
  __int32_t tv_usec;
};

/* 4544 */
struct pktap_header
{
  uint32_t pth_length;
  uint32_t pth_type_next;
  uint32_t pth_dlt;
  char pth_ifname[24];
  uint32_t pth_flags;
  uint32_t pth_protocol_family;
  uint32_t pth_frame_pre_length;
  uint32_t pth_frame_post_length;
  pid_t pth_pid;
  char pth_comm[17];
  uint8_t pth_pad1;
  uint16_t pth_trace_tag;
  uint32_t pth_svc;
  uint16_t pth_iftype;
  uint16_t pth_ifunit;
  pid_t pth_epid;
  char pth_ecomm[17];
  uint8_t pth_pad2;
  uint16_t pth_pad3;
  uint32_t pth_flowid;
  uint32_t pth_ipproto;
  timeval32 pth_tstamp;
  uuid_t_1 pth_uuid;
  uuid_t_1 pth_euuid;
};

/* 4545 */
struct rvi_client_t
{
  struct
  {
    rvi_client_t *le_next;
    rvi_client_t **le_prev;
  } _cle;
  ifnet_t _ifp;
  uint32_t _unit;
  uint32_t _vif;
  uint32_t _raw_count;
  uint32_t _pktap_count;
};

/* 4546 */
struct __attribute__((aligned(8))) prefix_match_data
{
  const sockaddr *addr;
  const sockaddr *mask;
  llentries dchain;
  uint16_t flags;
};

/* 4547 */
struct cfil_crypto_data
{
  uuid_t_1 flow_id;
  u_int64_t sock_id;
  u_int32_t direction;
  sockaddr_in_4_6 remote;
  sockaddr_in_4_6 local;
  u_int32_t socketProtocol;
  pid_t pid;
  pid_t effective_pid;
  uuid_t_1 uuid;
  uuid_t_1 effective_uuid;
  u_int64_t byte_count_in;
  u_int64_t byte_count_out;
};

/* 4548 */
typedef cfil_crypto_data *cfil_crypto_data_t;

/* 4550 */
struct cfe_buf_stat
{
  uint64_t cbs_pending_first;
  uint64_t cbs_pending_last;
  uint64_t cbs_ctl_first;
  uint64_t cbs_ctl_last;
  uint64_t cbs_pass_offset;
  uint64_t cbs_peek_offset;
  uint64_t cbs_peeked;
};

/* 4551 */
struct cfil_entry_stat
{
  uint32_t ces_len;
  uint32_t ces_filter_id;
  uint32_t ces_flags;
  uint32_t ces_necp_control_unit;
  timeval64 ces_last_event;
  timeval64 ces_last_action;
  cfe_buf_stat ces_snd;
  cfe_buf_stat ces_rcv;
};

/* 4552 */
struct cfi_buf_stat
{
  uint64_t cbs_pending_first;
  uint64_t cbs_pending_last;
  uint64_t cbs_pass_offset;
  uint64_t cbs_inject_q_len;
};

/* 4567 */
typedef uint64_t cfil_sock_id_t;

/* 4568 */
struct cfil_msg_hdr
{
  uint32_t cfm_len;
  uint32_t cfm_version;
  uint32_t cfm_type;
  uint32_t cfm_op;
  cfil_sock_id_t cfm_sock_id;
};

/* 4563 */
typedef uint8_t cfil_crypto_signature[32];

/* 4553 */
struct __attribute__((aligned(8))) cfil_msg_sock_closed
{
  cfil_msg_hdr cfc_msghdr;
  timeval64 cfc_first_event;
  uint32_t cfc_op_list_ctr;
  uint32_t cfc_op_time[6];
  unsigned __int8 cfc_op_list[6];
  uint64_t cfc_byte_inbound_count;
  uint64_t cfc_byte_outbound_count;
  cfil_crypto_signature cfc_signature;
  uint32_t cfc_signature_length;
};

/* 4554 */
struct cfil_udp_notify_shutdown_context
{
  int how;
  int drop_flag;
  int shut_flag;
  int done_count;
};

/* 4555 */
struct cfil_udp_data_pending_context
{
  sockbuf *sb;
  uint64_t total_pending;
};

/* 4556 */
struct __attribute__((aligned(8))) cfil_udp_attached_context
{
  bool need_wait;
  lck_mtx_t *mutex_held;
  int attached;
};

/* 4557 */
struct cfil_msg_sock_attached
{
  cfil_msg_hdr cfs_msghdr;
  int cfs_sock_family;
  int cfs_sock_type;
  int cfs_sock_protocol;
  int cfs_unused;
  pid_t cfs_pid;
  pid_t cfs_e_pid;
  uuid_t_1 cfs_uuid;
  uuid_t_1 cfs_e_uuid;
  sockaddr_in_4_6 cfs_src;
  sockaddr_in_4_6 cfs_dst;
  int cfs_conn_dir;
  unsigned int cfs_audit_token[8];
  unsigned int cfs_real_audit_token[8];
  cfil_crypto_signature cfs_signature;
  uint32_t cfs_signature_length;
  char cfs_remote_domain_name[256];
};

/* 4558 */
struct __attribute__((aligned(8))) cfil_opt_sock_info
{
  cfil_sock_id_t cfs_sock_id;
  int cfs_sock_family;
  int cfs_sock_type;
  int cfs_sock_protocol;
  sockaddr_in_4_6 cfs_local;
  sockaddr_in_4_6 cfs_remote;
  pid_t cfs_pid;
  pid_t cfs_e_pid;
  uuid_t_1 cfs_uuid;
  uuid_t_1 cfs_e_uuid;
};

/* 4559 */
struct cfil_msg_set_crypto_key
{
  cfil_msg_hdr cfb_msghdr;
  cfil_crypto_key crypto_key;
};

/* 4560 */
struct cfil_msg_bless_client
{
  cfil_msg_hdr cfb_msghdr;
  uuid_t_1 cfb_client_uuid;
};

/* 4561 */
struct __attribute__((aligned(8))) cfil_msg_action
{
  cfil_msg_hdr cfa_msghdr;
  uint64_t cfa_in_pass_offset;
  uint64_t cfa_in_peek_offset;
  uint64_t cfa_out_pass_offset;
  uint64_t cfa_out_peek_offset;
  uint32_t cfa_stats_frequency;
};

/* 4562 */
struct cfil_sign_parameters
{
  cfil_crypto_state_t csp_state;
  cfil_crypto_data *csp_data;
  uint8_t *csp_signature;
  uint32_t *csp_signature_size;
};

/* 4564 */
struct cfil_msg_data_event
{
  cfil_msg_hdr cfd_msghdr;
  sockaddr_in_4_6 cfc_src;
  sockaddr_in_4_6 cfc_dst;
  uint64_t cfd_start_offset;
  uint64_t cfd_end_offset;
  cfil_crypto_signature cfd_signature;
  uint32_t cfd_signature_length;
  uint32_t cfd_flags;
};

/* 4565 */
struct cfil_tag
{
  sockaddr_in_4_6 cfil_faddr;
  uint32_t cfil_so_state_change_cnt;
  uint32_t cfil_so_options;
  int cfil_inp_flags;
};

/* 4566 */
struct __attribute__((aligned(8))) cfil_msg_sock_stats
{
  cfil_sock_id_t cfs_sock_id;
  uint64_t cfs_byte_inbound_count;
  uint64_t cfs_byte_outbound_count;
  sockaddr_in_4_6 cfs_laddr;
};

/* 4569 */
struct cfil_stats_report_buffer
{
  cfil_msg_hdr msghdr;
  uint32_t count;
  cfil_msg_sock_stats stats[50];
};

/* 4579 */
typedef u_int32_t net_flowhash_fn_t(const void *, u_int32_t, const u_int32_t);

/* 4580 */
struct __attribute__((aligned(8))) if_llreach_info
{
  u_int32_t lri_refcnt;
  u_int32_t lri_ifindex;
  u_int64_t lri_expire;
  u_int32_t lri_probes;
  u_int16_t lri_reserved;
  u_int16_t lri_proto;
  u_int8_t lri_addr[64];
  int32_t lri_rssi;
  int32_t lri_lqm;
  int32_t lri_npm;
  u_int8_t lri_reserved2[16];
};

/* 4581 */
struct bpf_packet
{
  int bpfp_type;
  void *bpfp_header;
  size_t bpfp_header_length;
  union
  {
    mbuf *bpfpu_mbuf;
    void *bpfpu_ptr;
    kern_packet_t bpfpu_pkt;
  } bpfp_u;
  size_t bpfp_total_length;
};

/* 4582 */
union pktap_header_extra
{
  uint8_t llhdr[16];
  uint32_t proto;
};

/* 4586 */
struct pktap_v2_hdr
{
  uint8_t pth_length;
  uint8_t pth_uuid_offset;
  uint8_t pth_e_uuid_offset;
  uint8_t pth_ifname_offset;
  uint8_t pth_comm_offset;
  uint8_t pth_e_comm_offset;
  uint16_t pth_dlt;
  uint16_t pth_frame_pre_length;
  uint16_t pth_frame_post_length;
  uint16_t pth_iftype;
  uint16_t pth_ipproto;
  uint32_t pth_protocol_family;
  uint32_t pth_svc;
  uint32_t pth_flowid;
  pid_t pth_pid;
  pid_t pth_e_pid;
  uint32_t pth_flags;
};

/* 4583 */
struct __attribute__((aligned(4))) pktap_v2_hdr_space
{
  pktap_v2_hdr pth_hdr;
  uint8_t pth_uuid[16];
  uint8_t pth_e_uuid[16];
  uint8_t pth_ifname[24];
  uint8_t pth_comm[17];
  uint8_t pth_e_comm[17];
};

/* 4584 */
struct x_pktap_filter
{
  uint32_t filter_op;
  uint32_t filter_param;
  union
  {
    uint32_t _filter_if_type;
    char _filter_if_name[24];
  } param_;
};

/* 4585 */
typedef void (*tap_packet_func)(ifnet_t, u_int32_t, kern_packet_t, void *, size_t);

/* 4587 */
struct ifdrv64
{
  char ifd_name[16];
  u_int64_t ifd_cmd;
  u_int64_t ifd_len;
  user64_addr_t ifd_data;
};

/* 4588 */
struct ifdrv32
{
  char ifd_name[16];
  u_int32_t ifd_cmd;
  u_int32_t ifd_len;
  user32_addr_t ifd_data;
};

/* 4589 */
struct pktap_filter
{
  uint32_t filter_op;
  uint32_t filter_param;
  union
  {
    uint32_t _filter_if_type;
    char _filter_if_name[24];
  } param_;
  size_t filter_ifname_prefix_len;
};

/* 4590 */
struct pktap_softc
{
  struct
  {
    pktap_softc *le_next;
    pktap_softc **le_prev;
  } pktp_link;
  uint32_t pktp_unit;
  uint32_t pktp_dlt_raw_count;
  uint32_t pktp_dlt_pkttap_count;
  ifnet *pktp_ifp;
  pktap_filter pktp_filters[8];
};

/* 4591 */
struct opaque_ipfilter;

/* 4592 */
struct iptap_softc
{
  struct
  {
    iptap_softc *le_next;
    iptap_softc **le_prev;
  } iptap_link;
  uint32_t iptap_unit;
  uint32_t iptap_dlt_raw_count;
  uint32_t iptap_dlt_pkttap_count;
  ifnet *iptap_ifp;
};

/* 4593 */
struct pfr_ktableworkq
{
  pfr_ktable *slh_first;
};

/* 4594 */
struct pfr_addr
{
  union
  {
    in_addr _pfra_ip4addr;
    in6_addr_0 _pfra_ip6addr;
  } pfra_u;
  uint8_t pfra_af;
  uint8_t pfra_net;
  uint8_t pfra_not;
  uint8_t pfra_fback;
};

/* 4595 */
struct pfr_kentryworkq
{
  pfr_kentry *slh_first;
};

/* 8027 */
union sockaddr_union
{
  sockaddr sa;
  sockaddr_in sin;
  sockaddr_in6 sin6;
};

/* 4596 */
struct __attribute__((aligned(4))) pfr_kentry
{
  radix_node pfrke_node[2];
  sockaddr_union pfrke_sa;
  u_int64_t pfrke_packets[2][2];
  u_int64_t pfrke_bytes[2][2];
  struct
  {
    pfr_kentry *sle_next;
  } pfrke_workq;
  u_int64_t pfrke_tzero;
  u_int8_t pfrke_af;
  u_int8_t pfrke_net;
  u_int8_t pfrke_not;
  u_int8_t pfrke_mark;
  u_int8_t pfrke_intrpool;
};

/* 4597 */
struct pfioc_rule
{
  u_int32_t action;
  u_int32_t ticket;
  u_int32_t pool_ticket;
  u_int32_t nr;
  char anchor[1024];
  char anchor_call[1024];
  pf_rule rule;
};

/* 8032 */
enum pbuf_action : __int32
{
  pbuf_action::PBUF_ACTION_DESTROY = 0x0,
};

/* 4598 */
struct pbuf_memory
{
  uint8_t *pm_buffer;
  u_int pm_buffer_len;
  u_int pm_offset;
  u_int pm_len;
  uint32_t pm_csum_flags;
  uint32_t pm_csum_data;
  uint8_t pm_proto;
  uint8_t pm_flowsrc;
  uint32_t pm_flowid;
  uint32_t pm_flow_gencnt;
  uint32_t pm_flags;
  pf_mtag pm_pftag;
  pf_fragment_tag pm_pf_fragtag;
  int (*pm_action)(pbuf_memory *, pbuf_action);
  void *pm_action_cookie;
};

/* 4599 */
typedef pbuf pbuf_t;

/* 8033 */
enum pbuf_type : __int32
{
  pbuf_type::PBUF_TYPE_ZOMBIE = 0x0,
  pbuf_type::PBUF_TYPE_MBUF = 0x1,
  pbuf_type::PBUF_TYPE_MEMORY = 0x2,
};

/* 8031 */
struct pbuf
{
  pbuf_type pb_type;
  union
  {
    mbuf *pbu_mbuf;
    pbuf_memory pbu_memory;
  } pb_u;
  void *pb_data;
  uint32_t pb_packet_len;
  uint32_t pb_contig_len;
  uint32_t *pb_csum_flags;
  uint32_t *pb_csum_data;
  uint8_t *pb_proto;
  uint8_t *pb_flowsrc;
  uint32_t *pb_flowid;
  uint32_t *pb_flow_gencnt;
  uint32_t *pb_flags;
  pf_mtag *pb_pftag;
  pf_fragment_tag *pb_pf_fragtag;
  ifnet *pb_ifp;
  pbuf *pb_next;
};

/* 4602 */
struct pf_osfp_entry
{
  struct
  {
    pf_osfp_entry *sle_next;
  } fp_entry;
  pf_osfp_t fp_os;
  int fp_enflags;
  char fp_class_nm[32];
  char fp_version_nm[32];
  char fp_subtype_nm[32];
};

/* 4630 */
typedef u_int64_t pf_tcpopts_t;

/* 4600 */
struct pf_osfp_ioctl
{
  pf_osfp_entry fp_os;
  pf_tcpopts_t fp_tcpopts;
  u_int16_t fp_wsize;
  u_int16_t fp_psize;
  u_int16_t fp_mss;
  u_int16_t fp_flags;
  u_int8_t fp_optcnt;
  u_int8_t fp_wscale;
  u_int8_t fp_ttl;
  int fp_getnum;
};

/* 4601 */
struct __attribute__((aligned(8))) pf_pdesc
{
  struct
  {
    int done;
    uid_t uid;
    gid_t gid;
    pid_t pid;
  } lookup;
  u_int64_t tot_len;
  union
  {
    tcphdr *tcp;
    udphdr *udp;
    icmp *icmp;
    icmp6_hdr *icmp6;
    pf_grev1_hdr *grev1;
    pf_esp_hdr *esp;
    void *any;
  } hdr;
  pf_addr baddr;
  pf_addr bdaddr;
  pf_addr naddr;
  pf_addr ndaddr;
  pf_rule *nat_rule;
  pf_addr *src;
  pf_addr *dst;
  ether_header *eh;
  pbuf_t *mp;
  int lmw;
  pf_mtag *pf_mtag;
  u_int16_t *ip_sum;
  u_int32_t off;
  u_int32_t hdrlen;
  u_int32_t p_len;
  u_int16_t flags;
  sa_family_t af;
  sa_family_t naf;
  u_int8_t proto;
  u_int8_t tos;
  u_int8_t ttl;
  u_int8_t proto_variant;
  mbuf_svc_class_t sc;
  u_int32_t pktflags;
  u_int32_t flowsrc;
  u_int32_t flowhash;
};

/* 4608 */
struct pf_grev1_hdr
{
  u_int16_t flags;
  u_int16_t protocol_type;
  u_int16_t payload_length;
  u_int16_t call_id;
};

/* 4607 */
struct pf_esp_hdr
{
  u_int32_t spi;
  u_int32_t seqno;
  u_int8_t payload[];
};

/* 4603 */
struct pf_osfp_enlist
{
  pf_osfp_entry *slh_first;
};

/* 4604 */
struct pf_os_fingerprint
{
  pf_osfp_enlist fp_oses;
  pf_tcpopts_t fp_tcpopts;
  u_int16_t fp_wsize;
  u_int16_t fp_psize;
  u_int16_t fp_mss;
  u_int16_t fp_flags;
  u_int8_t fp_optcnt;
  u_int8_t fp_wscale;
  u_int8_t fp_ttl;
  struct
  {
    pf_os_fingerprint *sle_next;
  } fp_next;
};

/* 4605 */
struct pf_threshold
{
  u_int32_t limit;
  u_int32_t seconds;
  u_int32_t count;
  u_int32_t last;
};

/* 4606 */
struct __attribute__((aligned(8))) pf_src_node
{
  struct
  {
    pf_src_node *rbe_left;
    pf_src_node *rbe_right;
    pf_src_node *rbe_parent;
  } entry;
  pf_addr addr;
  pf_addr raddr;
  pf_rule_ptr rule;
  pfi_kif *kif;
  u_int64_t bytes[2];
  u_int64_t packets[2];
  u_int32_t states;
  u_int32_t conn;
  pf_threshold conn_rate;
  u_int64_t creation;
  u_int64_t expire;
  sa_family_t af;
  u_int8_t ruletype;
};

/* 4609 */
struct pf_ike_state
{
  u_int64_t cookie;
};

/* 4610 */
struct pf_grev1_state
{
  pf_state *pptp_state;
};

/* 4621 */
struct __attribute__((aligned(8))) pf_state_peer
{
  u_int32_t seqlo;
  u_int32_t seqhi;
  u_int32_t seqdiff;
  u_int16_t max_win;
  u_int8_t state;
  u_int8_t wscale;
  u_int16_t mss;
  u_int8_t tcp_est;
  pf_state_scrub *scrub;
  u_int8_t pad[3];
};

/* 4620 */
struct hook_desc_head
{
  hook_desc *tqh_first;
  hook_desc **tqh_last;
};

/* 4622 */
struct pf_state
{
  u_int64_t id;
  u_int32_t creatorid;
  u_int32_t pad;
  struct
  {
    pf_state *tqe_next;
    pf_state **tqe_prev;
  } entry_list;
  struct
  {
    pf_state *tqe_next;
    pf_state **tqe_prev;
  } next;
  struct
  {
    pf_state *rbe_left;
    pf_state *rbe_right;
    pf_state *rbe_parent;
  } entry_id;
  pf_state_peer src;
  pf_state_peer dst;
  pf_rule_ptr rule;
  pf_rule_ptr anchor;
  pf_rule_ptr nat_rule;
  pf_addr rt_addr;
  hook_desc_head unlink_hooks;
  pf_state_key *state_key;
  pfi_kif *kif;
  pfi_kif *rt_kif;
  pf_src_node *src_node;
  pf_src_node *nat_src_node;
  u_int64_t packets[2];
  u_int64_t bytes[2];
  u_int64_t creation;
  u_int64_t expire;
  u_int64_t pfsync_time;
  u_int16_t tag;
  u_int8_t log;
  u_int8_t allow_opts;
  u_int8_t timeout;
  u_int8_t sync_flags;
  netns_token nstoken;
};

/* 4619 */
struct __attribute__((aligned(8))) pf_state_scrub
{
  timeval pfss_last;
  u_int32_t pfss_tsecr;
  u_int32_t pfss_tsval;
  u_int32_t pfss_tsval0;
  u_int16_t pfss_flags;
  u_int8_t pfss_ttl;
  u_int8_t pad;
  u_int32_t pfss_ts_mod;
};

/* 4682 */
typedef void (*hook_fn_t)(void *);

/* 4637 */
struct hook_desc
{
  struct
  {
    hook_desc *tqe_next;
    hook_desc **tqe_prev;
  } hd_list;
  hook_fn_t hd_fn;
  void *hd_arg;
};

/* 4615 */
union pf_state_xport
{
  u_int16_t port;
  u_int16_t call_id;
  u_int32_t spi;
};

/* 4617 */
struct pf_state_host
{
  pf_addr addr;
  pf_state_xport xport;
};

/* 4618 */
struct __attribute__((aligned(8))) pf_state_key
{
  pf_state_host lan;
  pf_state_host gwy;
  pf_state_host ext_lan;
  pf_state_host ext_gwy;
  sa_family_t af_lan;
  sa_family_t af_gwy;
  u_int8_t proto;
  u_int8_t direction;
  u_int8_t proto_variant;
  pf_app_state *app_state;
  u_int32_t flowsrc;
  u_int32_t flowhash;
  struct
  {
    pf_state_key *rbe_left;
    pf_state_key *rbe_right;
    pf_state_key *rbe_parent;
  } entry_lan_ext;
  struct
  {
    pf_state_key *rbe_left;
    pf_state_key *rbe_right;
    pf_state_key *rbe_parent;
  } entry_ext_gwy;
  pf_statelist states;
  u_int32_t refcnt;
};

/* 4613 */
typedef void (*pf_app_handler)(pf_state *, int, int, pf_pdesc *, pfi_kif *);

/* 4612 */
typedef int (*pf_app_compare)(pf_app_state *, pf_app_state *);

/* 4611 */
struct pf_pptp_state
{
  pf_state *grev1_state;
};

/* 4614 */
struct pf_app_state
{
  pf_app_handler handler;
  pf_app_compare compare_lan_ext;
  pf_app_compare compare_ext_gwy;
  union
  {
    pf_pptp_state pptp;
    pf_grev1_state grev1;
    pf_ike_state ike;
  } u;
};

/* 4616 */
struct pf_statelist
{
  pf_state *tqh_first;
  pf_state **tqh_last;
};

/* 4623 */
struct __attribute__((aligned(8))) pf_frcache
{
  struct
  {
    pf_frcache *le_next;
    pf_frcache **le_prev;
  } fr_next;
  uint16_t fr_off;
  uint16_t fr_end;
};

/* 4624 */
struct __attribute__((aligned(8))) pf_frent
{
  struct
  {
    pf_frent *le_next;
    pf_frent **le_prev;
  } fr_next;
  mbuf *fr_m;
  union
  {
    ip *fru_ipv4;
    ip6_hdr *fru_ipv6;
  } fr_u;
  ip6_frag fr_ip6f_opt;
  uint16_t fr_ip6f_hlen;
  uint16_t fr_ip6f_extoff;
};

/* 4625 */
struct pf_cacheq
{
  pf_frcache *lh_first;
};

/* 4626 */
struct pf_fragq
{
  pf_frent *lh_first;
};

/* 4627 */
struct __attribute__((aligned(8))) pf_fragment
{
  struct
  {
    pf_fragment *rbe_left;
    pf_fragment *rbe_right;
    pf_fragment *rbe_parent;
  } fr_entry;
  struct
  {
    pf_fragment *tqe_next;
    pf_fragment **tqe_prev;
  } frag_next;
  pf_addr fr_srcx;
  pf_addr fr_dstx;
  u_int8_t fr_p;
  u_int8_t fr_flags;
  u_int16_t fr_max;
  union
  {
    u_int16_t fru_id4;
    u_int32_t fru_id6;
  } fr_uid;
  int fr_af;
  u_int32_t fr_timeout;
  union
  {
    pf_fragq fru_queue;
    pf_cacheq fru_cache;
  } fr_u;
  uint32_t fr_csum_flags;
  uint32_t fr_csum;
  uint16_t fr_ip6_maxlen;
};

/* 4628 */
struct pfioc_trans_e
{
  int rs_num;
  char anchor[1024];
  u_int32_t ticket;
};

/* 4629 */
struct pfioc_src_node_kill
{
  sa_family_t psnk_af;
  pf_rule_addr psnk_src;
  pf_rule_addr psnk_dst;
};

/* 4631 */
struct pfioc_ruleset
{
  u_int32_t nr;
  char path[1024];
  char name[64];
};

/* 4632 */
struct pfioc_pooladdr
{
  u_int32_t action;
  u_int32_t ticket;
  u_int32_t nr;
  u_int32_t r_num;
  u_int8_t r_action;
  u_int8_t r_last;
  u_int8_t af;
  char anchor[1024];
  pf_pooladdr addr;
};

/* 4633 */
struct pf_ifspeed
{
  char ifname[16];
  u_int64_t baudrate;
};

/* 4634 */
struct pfioc_natlook
{
  pf_addr saddr;
  pf_addr daddr;
  pf_addr rsaddr;
  pf_addr rdaddr;
  pf_state_xport sxport;
  pf_state_xport dxport;
  pf_state_xport rsxport;
  pf_state_xport rdxport;
  sa_family_t af;
  u_int8_t proto;
  u_int8_t proto_variant;
  u_int8_t direction;
};

/* 4635 */
struct pfioc_if
{
  char ifname[16];
};

/* 4636 */
struct pf_status
{
  u_int64_t counters[17];
  u_int64_t lcounters[7];
  u_int64_t fcounters[3];
  u_int64_t scounters[3];
  u_int64_t pcounters[2][2][3];
  u_int64_t bcounters[2][2];
  u_int64_t stateid;
  u_int32_t running;
  u_int32_t states;
  u_int32_t src_nodes;
  u_int64_t since;
  u_int32_t debug;
  u_int32_t hostid;
  char ifname[16];
  u_int8_t pf_chksum[16];
};

/* 4638 */
struct pfsync_state_scrub
{
  u_int16_t pfss_flags;
  u_int8_t pfss_ttl;
  u_int8_t scrub_flag;
  u_int32_t pfss_ts_mod;
};

/* 4639 */
struct pfsync_state_peer
{
  pfsync_state_scrub scrub;
  u_int32_t seqlo;
  u_int32_t seqhi;
  u_int32_t seqdiff;
  u_int16_t max_win;
  u_int16_t mss;
  u_int8_t state;
  u_int8_t wscale;
  u_int8_t pad[6];
};

/* 4640 */
struct pfsync_state_host
{
  pf_addr addr;
  pf_state_xport xport;
  u_int16_t pad[2];
};

/* 4641 */
struct __attribute__((packed)) __attribute__((aligned(1))) pfsync_state
{
  u_int32_t id[2];
  char ifname[16];
  pfsync_state_host lan;
  pfsync_state_host gwy;
  pfsync_state_host ext_lan;
  pfsync_state_host ext_gwy;
  pfsync_state_peer src;
  pfsync_state_peer dst;
  pf_addr rt_addr;
  hook_desc_head unlink_hooks;
  u_int32_t rule;
  u_int32_t anchor;
  u_int32_t nat_rule;
  u_int64_t creation;
  u_int64_t expire;
  u_int32_t packets[2][2];
  u_int32_t bytes[2][2];
  u_int32_t creatorid;
  u_int16_t tag;
  sa_family_t af_lan;
  sa_family_t af_gwy;
  u_int8_t proto;
  u_int8_t direction;
  u_int8_t log;
  u_int8_t allow_opts;
  u_int8_t timeout;
  u_int8_t sync_flags;
  u_int8_t updates;
  u_int8_t proto_variant;
  u_int8_t __pad;
  u_int32_t flowhash;
};

/* 4642 */
struct pfioc_state
{
  pfsync_state state;
};

/* 4643 */
struct __attribute__((aligned(8))) pfioc_state_addr_kill
{
  pf_addr_wrap addr;
  u_int8_t reserved_[3];
  u_int8_t neg;
  pf_rule_xport xport;
};

/* 4644 */
struct pfioc_state_kill
{
  sa_family_t psk_af;
  u_int8_t psk_proto;
  u_int8_t psk_proto_variant;
  u_int8_t _pad;
  pfioc_state_addr_kill psk_src;
  pfioc_state_addr_kill psk_dst;
  char psk_ifname[16];
  char psk_ownername[64];
};

/* 4645 */
struct pf_tagname
{
  struct
  {
    pf_tagname *tqe_next;
    pf_tagname **tqe_prev;
  } entries;
  char name[64];
  u_int16_t tag;
  int ref;
};

/* 4646 */
struct pf_reserved_tag_table_t
{
  char tag_name[64];
  uint16_t tag_id;
};

/* 4647 */
struct __attribute__((packed)) __attribute__((aligned(4))) pfioc_token
{
  u_int64_t token_value;
  u_int64_t timestamp;
  pid_t pid;
  char proc_name[64];
};

/* 4648 */
struct __attribute__((aligned(8))) pfioc_kernel_token
{
  struct
  {
    pfioc_kernel_token *sle_next;
  } next;
  pfioc_token token;
};

/* 4649 */
struct pfioc_iface_64
{
  char pfiio_name[16];
  user64_addr_t pfiio_buffer;
  int pfiio_esize;
  int pfiio_size;
  int pfiio_nzero;
  int pfiio_flags;
};

/* 4650 */
struct pfioc_iface_32
{
  char pfiio_name[16];
  user32_addr_t pfiio_buffer;
  __attribute__((aligned(8))) int pfiio_esize;
  int pfiio_size;
  int pfiio_nzero;
  int pfiio_flags;
};

/* 4651 */
struct pfioc_src_nodes_64
{
  int psn_len;
  union
  {
    user64_addr_t psu_buf;
    user64_addr_t psu_src_nodes;
  } psn_u;
};

/* 4652 */
struct pfioc_src_nodes_32
{
  int psn_len;
  union
  {
    user32_addr_t psu_buf;
    __attribute__((aligned(8))) user32_addr_t psu_src_nodes;
  } psn_u;
};

/* 4653 */
struct pfioc_trans_64
{
  int size;
  int esize;
  user64_addr_t array;
};

/* 4654 */
struct __attribute__((aligned(8))) pfioc_trans_32
{
  int size;
  int esize;
  user32_addr_t array;
};

/* 4655 */
struct pfioc_table_64
{
  pfr_table pfrio_table;
  user64_addr_t pfrio_buffer;
  int pfrio_esize;
  int pfrio_size;
  int pfrio_size2;
  int pfrio_nadd;
  int pfrio_ndel;
  int pfrio_nchange;
  int pfrio_flags;
  u_int32_t pfrio_ticket;
};

/* 4656 */
struct pfioc_table_32
{
  pfr_table pfrio_table;
  user32_addr_t pfrio_buffer;
  __attribute__((aligned(8))) int pfrio_esize;
  int pfrio_size;
  int pfrio_size2;
  int pfrio_nadd;
  int pfrio_ndel;
  int pfrio_nchange;
  int pfrio_flags;
  u_int32_t pfrio_ticket;
};

/* 4657 */
struct pfioc_states_64
{
  int ps_len;
  union
  {
    user64_addr_t psu_buf;
    user64_addr_t psu_states;
  } ps_u;
};

/* 4658 */
struct pfioc_states_32
{
  int ps_len;
  union
  {
    user32_addr_t psu_buf;
    __attribute__((aligned(8))) user32_addr_t psu_states;
  } ps_u;
};

/* 4659 */
struct pfioc_tokens_64
{
  int size;
  union
  {
    user64_addr_t pgtu_buf;
    user64_addr_t pgtu_tokens;
  } pgt_u;
};

/* 4660 */
struct pfioc_tokens_32
{
  int size;
  union
  {
    user32_addr_t pgtu_buf;
    __attribute__((aligned(8))) user32_addr_t pgtu_tokens;
  } pgt_u;
};

/* 4661 */
struct pf_pptp_ctrl_set_linkinfo
{
  u_int16_t peer_call_id;
  u_int16_t reserved_1;
  u_int32_t tx_accm;
  u_int32_t rx_accm;
};

/* 4662 */
struct pf_pptp_ctrl_error
{
  u_int16_t peer_call_id;
  u_int16_t reserved_1;
  u_int32_t crc_errors;
  u_int32_t fr_errors;
  u_int32_t hw_errors;
  u_int32_t buf_errors;
  u_int32_t tim_errors;
  u_int32_t align_errors;
};

/* 4663 */
struct pf_pptp_ctrl_call_disc
{
  u_int16_t call_id;
  u_int8_t result_code;
  u_int8_t error_code;
  u_int16_t cause_code;
  u_int16_t reserved_1;
  u_int8_t statistics[128];
};

/* 4664 */
struct pf_pptp_ctrl_call_clr
{
  u_int16_t call_id;
  u_int16_t reserved_1;
};

/* 4665 */
struct pf_pptp_ctrl_call_in_3rd
{
  u_int16_t call_id;
  u_int16_t reserved_1;
  u_int32_t connect_speed;
  u_int16_t rxwindow_size;
  u_int16_t txdelay;
  u_int32_t framing_type;
};

/* 4666 */
struct pf_pptp_ctrl_call_in_2nd
{
  u_int16_t call_id;
  u_int16_t peer_call_id;
  u_int8_t result_code;
  u_int8_t error_code;
  u_int16_t rxwindow_size;
  u_int16_t txdelay;
  u_int16_t reserved_1;
};

/* 4667 */
struct pf_pptp_ctrl_call_in_1st
{
  u_int16_t call_id;
  u_int16_t call_sernum;
  u_int32_t bearer_type;
  u_int32_t phy_channel_id;
  u_int16_t dialed_number_len;
  u_int16_t dialing_number_len;
  u_int8_t dialed_num[64];
  u_int8_t dialing_num[64];
  u_int8_t sub_addr[64];
};

/* 4668 */
struct pf_pptp_ctrl_call_out_rpy
{
  u_int16_t call_id;
  u_int16_t peer_call_id;
  u_int8_t result_code;
  u_int8_t error_code;
  u_int16_t cause_code;
  u_int32_t connect_speed;
  u_int16_t rxwindow_size;
  u_int16_t proc_delay;
  u_int32_t phy_channel_id;
};

/* 4669 */
struct pf_pptp_ctrl_call_out_req
{
  u_int16_t call_id;
  u_int16_t call_sernum;
  u_int32_t min_bps;
  u_int32_t bearer_type;
  u_int32_t framing_type;
  u_int16_t rxwindow_size;
  u_int16_t proc_delay;
  u_int8_t phone_num[64];
  u_int8_t sub_addr[64];
};

/* 4670 */
struct pf_pptp_ctrl_echo_rpy
{
  u_int32_t identifier;
  u_int8_t result_code;
  u_int8_t error_code;
  u_int16_t reserved_1;
};

/* 4671 */
struct pf_pptp_ctrl_echo_req
{
  u_int32_t identifier;
};

/* 4672 */
struct pf_pptp_ctrl_stop_rpy
{
  u_int8_t reason;
  u_int8_t error_code;
  u_int16_t reserved_1;
};

/* 4673 */
struct pf_pptp_ctrl_stop_req
{
  u_int8_t reason;
  u_int8_t reserved_1;
  u_int16_t reserved_2;
};

/* 4674 */
struct pf_pptp_ctrl_start_rpy
{
  u_int16_t protocol_version;
  u_int8_t result_code;
  u_int8_t error_code;
  u_int32_t framing_capabilities;
  u_int32_t bearer_capabilities;
  u_int16_t maximum_channels;
  u_int16_t firmware_revision;
  u_int8_t host_name[64];
  u_int8_t vendor_string[64];
};

/* 4675 */
struct pf_pptp_ctrl_start_req
{
  u_int16_t protocol_version;
  u_int16_t reserved_1;
  u_int32_t framing_capabilities;
  u_int32_t bearer_capabilities;
  u_int16_t maximum_channels;
  u_int16_t firmware_revision;
  u_int8_t host_name[64];
  u_int8_t vendor_string[64];
};

/* 4676 */
union pf_pptp_ctrl_msg_union
{
  pf_pptp_ctrl_start_req start_req;
  pf_pptp_ctrl_start_rpy start_rpy;
  pf_pptp_ctrl_stop_req stop_req;
  pf_pptp_ctrl_stop_rpy stop_rpy;
  pf_pptp_ctrl_echo_req echo_req;
  pf_pptp_ctrl_echo_rpy echo_rpy;
  pf_pptp_ctrl_call_out_req call_out_req;
  pf_pptp_ctrl_call_out_rpy call_out_rpy;
  pf_pptp_ctrl_call_in_1st call_in_1st;
  pf_pptp_ctrl_call_in_2nd call_in_2nd;
  pf_pptp_ctrl_call_in_3rd call_in_3rd;
  pf_pptp_ctrl_call_clr call_clr;
  pf_pptp_ctrl_call_disc call_disc;
  pf_pptp_ctrl_error error;
  pf_pptp_ctrl_set_linkinfo set_linkinfo;
  u_int8_t data[];
};

/* 4677 */
struct pf_pptp_ctrl_hdr
{
  u_int16_t type;
  u_int16_t reserved_0;
};

/* 4678 */
struct pf_pptp_hdr
{
  u_int16_t length;
  u_int16_t type;
  u_int32_t magic;
};

/* 4679 */
struct pf_state_cmp
{
  u_int64_t id;
  u_int32_t creatorid;
  u_int32_t pad;
};

/* 4680 */
struct pf_state_key_cmp
{
  pf_state_host lan;
  pf_state_host gwy;
  pf_state_host ext_lan;
  pf_state_host ext_gwy;
  sa_family_t af_lan;
  sa_family_t af_gwy;
  u_int8_t proto;
  u_int8_t direction;
  u_int8_t proto_variant;
  pf_app_state *app_state;
};

/* 4681 */
struct pf_anchor_stackframe
{
  pf_ruleset *rs;
  pf_rule *r;
  pf_anchor_node *parent;
  pf_anchor *child;
};

/* 4683 */
struct __attribute__((aligned(8))) pf_pool_limit
{
  void *pp;
  unsigned int limit;
};

/* 8047 */
enum in6_clat46_evhdlr_code_t : __int32
{
  in6_clat46_evhdlr_code_t::IN6_CLAT46_EVENT_V4_FLOW = 0x0,
  in6_clat46_evhdlr_code_t::IN6_CLAT46_EVENT_V6_ADDR_CONFFAIL = 0x1,
};

/* 4684 */
typedef void (*in6_clat46_event_fn)(eventhandler_entry_arg, in6_clat46_evhdlr_code_t, pid_t, unsigned __int8 *);

/* 4685 */
struct eventhandler_entry_in6_clat46_event
{
  eventhandler_entry ee;
  in6_clat46_event_fn eh_func;
};

/* 4686 */
struct kev_netevent_clat46_data
{
  in6_clat46_evhdlr_code_t clat46_event_code;
  pid_t epid;
  uuid_t_1 euuid;
};

/* 4687 */
struct in6_clat46_event_nwk_wq_entry
{
  nwk_wq_entry nwk_wqe;
  kev_netevent_clat46_data in6_clat46_ev_arg;
};

/* 4690 */
struct nat464_addr
{
  union
  {
    in_addr _v4addr;
    in6_addr_0 _v6addr;
    uint8_t _addr8[16];
    uint16_t _addr16[8];
    uint32_t _addr32[4];
  } nat464a;
};

/* 4691 */
struct pflog_softc
{
  ifnet *sc_if;
  u_int32_t sc_flags;
  int sc_unit;
  struct
  {
    pflog_softc *le_next;
    pflog_softc **le_prev;
  } sc_list;
};

/* 4692 */
struct net_bloom_filter
{
  uint32_t b_table_num_bits;
  uint32_t b_table[];
};

/* 4693 */
struct netagent_trigger_args
{
  user_addr_t_0 agent_uuid;
  user_size_t agent_uuidlen;
  char agent_uuidlen_r_[];
};

/* 4694 */
struct netagent_client_message
{
  uuid_t_1 client_id;
};

/* 4695 */
struct netagent_client_group_message
{
  uuid_t_1 client_id;
  u_int8_t group_members[];
};

/* 4696 */
struct netagent_client_error_message
{
  uuid_t_1 client_id;
  int32_t error_code;
};

/* 4697 */
struct netagent_trigger_message
{
  u_int32_t trigger_flags;
  pid_t trigger_pid;
  uuid_t_1 trigger_proc_uuid;
};

/* 4698 */
struct netagent_assign_nexus_message
{
  uuid_t_1 assign_client_id;
  u_int8_t assign_necp_results[];
};

/* 4699 */
struct netagentlist_req64
{
  u_int32_t data_size;
  user64_addr_t data;
};

/* 4700 */
struct netagentlist_req32
{
  u_int32_t data_size;
  user32_addr_t data;
};

/* 4701 */
struct netagent_req64
{
  uuid_t_1 netagent_uuid;
  char netagent_domain[32];
  char netagent_type[32];
  char netagent_desc[128];
  u_int32_t netagent_flags;
  u_int32_t netagent_data_size;
  user64_addr_t netagent_data;
};

/* 4702 */
struct netagent_req32
{
  uuid_t_1 netagent_uuid;
  char netagent_domain[32];
  char netagent_type[32];
  char netagent_desc[128];
  u_int32_t netagent_flags;
  u_int32_t netagent_data_size;
  user32_addr_t netagent_data;
};

/* 4709 */
typedef errno_t (*netagent_event_f)(u_int8_t, unsigned __int8 *, pid_t, void *, void *, necp_client_agent_parameters *, void **, size_t *);

/* 4703 */
struct netagent_session
{
  u_int32_t control_unit;
  lck_mtx_t session_lock;
  netagent_wrapper *wrapper;
  netagent_event_f event_handler;
  void *event_context;
};

/* 4708 */
struct netagent_token_list_s
{
  netagent_token *tqh_first;
  netagent_token **tqh_last;
};

/* 4707 */
struct netagent_client_list_s
{
  netagent_client *lh_first;
};

/* 4710 */
struct netagent_wrapper
{
  struct
  {
    netagent_wrapper *le_next;
    netagent_wrapper **le_prev;
  } list_chain;
  lck_rw_t agent_lock;
  u_int32_t control_unit;
  netagent_event_f event_handler;
  void *event_context;
  u_int32_t generation;
  u_int64_t use_count;
  u_int64_t need_tokens_event_deadline;
  u_int32_t token_count;
  u_int32_t token_low_water;
  int32_t last_client_error;
  u_int32_t client_error_count;
  u_int8_t __pad_bytes[3];
  netagent_token_list_s token_list;
  netagent_client_list_s pending_triggers_list;
  netagent *netagent;
};

/* 4706 */
struct netagent_token
{
  struct
  {
    netagent_token *tqe_next;
    netagent_token **tqe_prev;
  } token_chain;
  u_int32_t token_length;
  u_int8_t *token_bytes;
};

/* 4705 */
struct __attribute__((aligned(8))) netagent_client
{
  struct
  {
    netagent_client *le_next;
    netagent_client **le_prev;
  } client_chain;
  uuid_t_1 client_id;
  uuid_t_1 client_proc_uuid;
  pid_t client_pid;
};

/* 4704 */
enum netagent_error_domain_t : __int32
{
  kNetagentErrorDomainPOSIX = 0x0,
  kNetagentErrorDomainUserDefined = 0x1,
};

/* 4711 */
struct necp_match_policy_args
{
  user_addr_t_0 parameters;
  user_size_t parameters_size;
  user_addr_t_0 returned_result;
  char returned_result_r_[];
};

/* 4712 */
struct necp_client_result_interface
{
  u_int32_t generation;
  u_int32_t index;
};

/* 4713 */
struct __attribute__((packed)) __attribute__((aligned(1))) necp_tlv_header
{
  u_int8_t type;
  u_int32_t length;
};

/* 4714 */
struct necp_client_flow_header
{
  necp_tlv_header outer_header;
  necp_tlv_header flow_id_tlv_header;
  uuid_t_1 flow_id;
  necp_tlv_header flags_tlv_header;
  __attribute__((packed)) __attribute__((aligned(1))) u_int32_t flags_value;
  necp_tlv_header interface_tlv_header;
  necp_client_result_interface interface_value;
};

/* 4715 */
struct nstat_progress_digest
{
  u_int64_t rxbytes;
  u_int64_t txbytes;
  u_int32_t rxduplicatebytes;
  u_int32_t rxoutoforderbytes;
  u_int32_t txretransmit;
  u_int32_t ifindex;
  u_int32_t state;
  u_int32_t txunacked;
  u_int32_t txwindow;
  union
  {
    tcp_conn_status connstatus;
    uint8_t __pad_connstatus[4];
  };
};

/* 4716 */
struct necp_cache_buffer
{
  u_int8_t necp_cache_buf_type;
  u_int8_t necp_cache_buf_ver;
  u_int32_t necp_cache_buf_size;
  mach_vm_address_t_0 necp_cache_buf_addr;
};

/* 4717 */
struct necp_interface_signature
{
  u_int8_t signature[20];
  u_int8_t signature_len;
};

/* 4718 */
struct necp_client_action_args
{
  int necp_fd;
  char necp_fd_r_[4];
  uint32_t action;
  char action_r_[4];
  user_addr_t_0 client_id;
  user_size_t client_id_len;
  user_addr_t_0 buffer;
  user_size_t buffer_size;
  char buffer_size_r_[];
};

/* 4719 */
struct necp_open_args
{
  int flags;
  char flags_r_[4];
};

/* 4721 */
struct necp_stats_bufreq
{
  u_int32_t necp_stats_bufreq_id;
  u_int32_t necp_stats_bufreq_type;
  u_int32_t necp_stats_bufreq_ver;
  u_int32_t necp_stats_bufreq_size;
  union
  {
    void *necp_stats_bufreq_addr;
    mach_vm_address_t_0 necp_stats_bufreq_uaddr;
  };
};

/* 4722 */
struct _necp_flow_defunct_list
{
  necp_flow_defunct *lh_first;
};

/* 4740 */
struct __attribute__((aligned(8))) necp_flow_defunct
{
  struct
  {
    necp_flow_defunct *le_next;
    necp_flow_defunct **le_prev;
  } chain;
  uuid_t_1 flow_id;
  uuid_t_1 nexus_agent;
  void *agent_handle;
  int proc_pid;
  u_int32_t flags;
  necp_client_agent_parameters close_parameters;
  bool has_close_parameters;
};

/* 4723 */
union necp_kernel_policy_routing_result_parameter
{
  u_int tunnel_interface_index;
  u_int scoped_interface_index;
  u_int32_t flow_divert_control_unit;
  u_int32_t filter_control_unit;
  u_int32_t pass_flags;
  u_int32_t drop_flags;
};

/* 4724 */
typedef nstat_tcp_descriptor nstat_quic_descriptor;

/* 4725 */
struct nstat_tcp_descriptor
{
  u_int64_t upid;
  u_int64_t eupid;
  u_int64_t start_timestamp;
  u_int64_t timestamp;
  u_int64_t rx_transfer_size;
  u_int64_t tx_transfer_size;
  activity_bitmap_t activity_bitmap;
  u_int32_t ifindex;
  u_int32_t state;
  u_int32_t sndbufsize;
  u_int32_t sndbufused;
  u_int32_t rcvbufsize;
  u_int32_t rcvbufused;
  u_int32_t txunacked;
  u_int32_t txwindow;
  u_int32_t txcwindow;
  u_int32_t traffic_class;
  u_int32_t traffic_mgt_flags;
  u_int32_t pid;
  u_int32_t epid;
  union
  {
    sockaddr_in v4;
    sockaddr_in6 v6;
  } local;
  union
  {
    sockaddr_in v4;
    sockaddr_in6 v6;
  } remote;
  char cc_algo[16];
  char pname[64];
  uuid_t_1 uuid;
  uuid_t_1 euuid;
  uuid_t_1 vuuid;
  uuid_t_1 fuuid;
  union
  {
    tcp_conn_status connstatus;
    uint8_t __pad_connstatus[4];
  };
  uint32_t ifnet_properties;
  uint8_t fallback_mode;
  uint8_t reserved[3];
};

/* 4726 */
struct necp_client_flow_stats
{
  u_int32_t stats_type;
  u_int32_t stats_version;
  u_int32_t stats_size;
  mach_vm_address_t_0 stats_addr;
};

/* 4727 */
struct __attribute__((packed)) __attribute__((aligned(4))) necp_client_add_flow
{
  uuid_t_1 agent_uuid;
  uuid_t_1 registration_id;
  u_int16_t flags;
  u_int16_t stats_request_count;
  necp_client_flow_stats stats_requests[];
};

/* 4728 */
struct nstat_connection_descriptor
{
  u_int64_t start_timestamp;
  u_int64_t timestamp;
  u_int64_t upid;
  u_int64_t eupid;
  u_int32_t pid;
  u_int32_t epid;
  u_int32_t ifnet_properties;
  char pname[64];
  uuid_t_1 uuid;
  uuid_t_1 euuid;
  uuid_t_1 cuuid;
  uuid_t_1 puuid;
  uuid_t_1 fuuid;
  uint8_t reserved[4];
};

/* 4729 */
struct necp_extra_quic_metadata
{
  u_int32_t sndbufsize;
  u_int32_t sndbufused;
  u_int32_t txunacked;
  u_int32_t txwindow;
  u_int32_t txcwindow;
  u_int32_t traffic_mgt_flags;
  u_int32_t cc_alg_index;
  u_int32_t state;
  u_int8_t ssr_token[16];
};

/* 4730 */
struct necp_connection_probe_status
{
  _BYTE gap0[4];
};

/* 4731 */
struct necp_extra_tcp_metadata
{
  necp_connection_probe_status probestatus;
  u_int32_t sndbufsize;
  u_int32_t sndbufused;
  u_int32_t txunacked;
  u_int32_t txwindow;
  u_int32_t txcwindow;
  u_int32_t flags;
  u_int32_t flags1;
  u_int32_t traffic_mgt_flags;
  u_int32_t cc_alg_index;
  u_int32_t state;
};

/* 4732 */
struct necp_basic_metadata
{
  u_int32_t rcvbufsize;
  u_int32_t rcvbufused;
};

/* 4733 */
struct __attribute__((aligned(8))) necp_stat_counts
{
  u_int64_t necp_stat_rxpackets;
  u_int64_t necp_stat_rxbytes;
  u_int64_t necp_stat_txpackets;
  u_int64_t necp_stat_txbytes;
  u_int32_t necp_stat_rxduplicatebytes;
  u_int32_t necp_stat_rxoutoforderbytes;
  u_int32_t necp_stat_txretransmit;
  u_int32_t necp_stat_connectattempts;
  u_int32_t necp_stat_connectsuccesses;
  u_int32_t necp_stat_min_rtt;
  u_int32_t necp_stat_avg_rtt;
  u_int32_t necp_stat_var_rtt;
  u_int32_t necp_stat_route_flags;
};

/* 4734 */
struct necp_stats_hdr
{
  u_int32_t necp_stats_type;
  u_int32_t necp_stats_ver;
  u_int64_t __necp_stats_reserved;
};

/* 4736 */
struct necp_udp_stats
{
  necp_stats_hdr necp_udp_hdr;
  necp_stat_counts necp_udp_counts;
  necp_basic_metadata necp_udp_basic;
};

/* 4735 */
struct necp_quic_stats
{
  necp_udp_stats necp_quic_udp_stats;
  necp_extra_quic_metadata necp_quic_extra;
};

/* 4737 */
struct __attribute__((aligned(8))) necp_tcp_stats
{
  necp_stats_hdr necp_tcp_hdr;
  necp_stat_counts necp_tcp_counts;
  necp_basic_metadata necp_tcp_basic;
  necp_extra_tcp_metadata necp_tcp_extra;
};

/* 4738 */
struct necp_all_stats
{
  union
  {
    necp_tcp_stats tcp_stats;
    necp_udp_stats udp_stats;
    necp_quic_stats quic_stats;
  } all_stats_u;
};

/* 4739 */
struct necp_all_kstats
{
  necp_all_stats necp_stats_comm;
  necp_all_stats *necp_stats_ustats;
};

/* 4745 */
struct necp_client_signable
{
  uuid_t_1 client_id;
  u_int32_t sign_type;
  u_int8_t signable_data[];
};

/* 4741 */
struct __attribute__((packed)) __attribute__((aligned(2))) necp_client_service_resolver_answer
{
  necp_client_signable header;
  u_int32_t metadata_hash;
  u_int16_t service_length;
  u_int16_t port;
  u_int16_t hostname_length;
  char service[];
  char hostname[];
};

/* 4742 */
struct __attribute__((packed)) __attribute__((aligned(2))) necp_client_browse_result
{
  necp_client_signable header;
  u_int32_t metadata_hash;
  u_int16_t service_length;
  char service[];
};

/* 4743 */
struct __attribute__((packed)) __attribute__((aligned(1))) necp_policy_condition_addr
{
  u_int8_t prefix;
  union
  {
    sockaddr sa;
    __sockaddr_header sah;
    sockaddr_in sin;
    sockaddr_in6 sin6;
  } address;
};

/* 4744 */
struct necp_client_host_resolver_answer
{
  necp_client_signable header;
  u_int32_t metadata_hash;
  sockaddr_in_4_6 address_answer;
  u_int32_t hostname_length;
  char hostname[];
};

/* 4746 */
struct necp_client_signature
{
  u_int8_t signed_tag[32];
};

/* 4747 */
struct necp_client_validatable
{
  necp_client_signature signature;
  necp_client_signable signable;
};

/* 4748 */
struct necp_client_parameter_netagent_type
{
  char netagent_domain[32];
  char netagent_type[32];
};

/* 4749 */
struct __attribute__((aligned(4))) necp_client_parsed_parameters
{
  u_int32_t valid_fields;
  u_int32_t flags;
  u_int64_t delegated_upid;
  necp_sockaddr_union local_addr;
  necp_sockaddr_union remote_addr;
  u_int32_t required_interface_index;
  char prohibited_interfaces[16][24];
  u_int8_t required_interface_type;
  u_int8_t local_address_preference;
  u_int8_t prohibited_interface_types[16];
  necp_client_parameter_netagent_type required_netagent_types[4];
  necp_client_parameter_netagent_type prohibited_netagent_types[4];
  necp_client_parameter_netagent_type preferred_netagent_types[4];
  necp_client_parameter_netagent_type avoided_netagent_types[4];
  uuid_t_1 required_netagents[4];
  uuid_t_1 prohibited_netagents[4];
  uuid_t_1 preferred_netagents[4];
  uuid_t_1 avoided_netagents[4];
  u_int8_t ip_protocol;
  u_int8_t transport_protocol;
  u_int16_t ethertype;
  pid_t effective_pid;
  uuid_t_1 effective_uuid;
  uuid_t_1 parent_uuid;
  u_int32_t traffic_class;
  necp_demux_pattern demux_patterns[4];
  u_int8_t demux_pattern_count;
};

/* 4750 */
struct necp_client_endpoint
{
  union
  {
    sockaddr sa;
    sockaddr_in sin;
    sockaddr_in6 sin6;
    struct
    {
      u_int8_t endpoint_length;
      u_int8_t endpoint_family;
      u_int16_t endpoint_port;
      u_int32_t endpoint_type;
      char endpoint_data[];
    } endpoint;
  } u;
};

/* 4751 */
struct necp_client_observer_update
{
  u_int32_t update_type;
  u_int8_t tlv_buffer[];
};

/* 4752 */
struct necp_client_update
{
  struct
  {
    necp_client_update *tqe_next;
    necp_client_update **tqe_prev;
  } chain;
  uuid_t_1 client_id;
  size_t update_length;
  necp_client_observer_update *update;
};

/* 4753 */
struct _necp_arena_info_list
{
  necp_arena_info *lh_first;
};

/* 4758 */
struct __attribute__((aligned(8))) necp_arena_info
{
  struct
  {
    necp_arena_info *le_next;
    necp_arena_info **le_prev;
  } nai_chain;
  u_int32_t nai_flags;
  pid_t nai_proc_pid;
  skmem_arena *nai_arena;
  skmem_arena_mmap_info nai_mmap;
  mach_vm_offset_t nai_roff;
  u_int32_t nai_use_count;
};

/* 4754 */
struct _necp_client_update_list
{
  necp_client_update *tqh_first;
  necp_client_update **tqh_last;
};

/* 4755 */
struct _necp_fd_flow_tree
{
  necp_client_flow_registration *rbh_root;
};

/* 4767 */
struct _necp_registration_flow_list
{
  necp_client_flow *lh_first;
};

/* 4889 */
typedef void *nstat_userland_context;

/* 4768 */
struct necp_client_flow_registration
{
  struct
  {
    necp_client_flow_registration *rbe_left;
    necp_client_flow_registration *rbe_right;
    necp_client_flow_registration *rbe_parent;
  } fd_link;
  struct
  {
    necp_client_flow_registration *rbe_left;
    necp_client_flow_registration *rbe_right;
    necp_client_flow_registration *rbe_parent;
  } global_link;
  struct
  {
    necp_client_flow_registration *rbe_left;
    necp_client_flow_registration *rbe_right;
    necp_client_flow_registration *rbe_parent;
  } client_link;
  struct
  {
    necp_client_flow_registration *le_next;
    necp_client_flow_registration **le_prev;
  } collect_stats_chain;
  uuid_t_1 registration_id;
  u_int32_t flags;
  void *interface_handle;
  necp_client_flow_cb interface_cb;
  necp_client *client;
  _necp_registration_flow_list flow_list;
  necp_arena_info *stats_arena;
  void *kstats_kaddr;
  mach_vm_address_t_0 ustats_uaddr;
  nstat_userland_context stats_handler_context;
  flow_stats *nexus_stats;
  u_int64_t last_interface_details;
};

/* 4765 */
struct _necp_client_flow_tree
{
  necp_client_flow_registration *rbh_root;
};

/* 4764 */
struct _necp_client_assertion_list
{
  necp_client_assertion *lh_first;
};

/* 4761 */
struct necp_client_interface_option
{
  u_int32_t interface_index;
  u_int32_t interface_generation;
  uuid_t_1 nexus_agent;
};

/* 4763 */
struct necp_client_result_netagent
{
  u_int32_t generation;
  uuid_t_1 netagent_uuid;
};

/* 4766 */
struct necp_client
{
  struct
  {
    necp_client *rbe_left;
    necp_client *rbe_right;
    necp_client *rbe_parent;
  } link;
  struct
  {
    necp_client *rbe_left;
    necp_client *rbe_right;
    necp_client *rbe_parent;
  } global_link;
  lck_mtx_t lock;
  lck_mtx_t route_lock;
  os_refcnt_t reference_count;
  uuid_t_1 client_id;
  size_t result_length;
  u_int8_t result[1024];
  necp_policy_id policy_id;
  u_int8_t ip_protocol;
  int proc_pid;
  u_int64_t delegated_upid;
  _necp_client_flow_tree flow_registrations;
  _necp_client_assertion_list assertion_list;
  size_t assigned_group_members_length;
  u_int8_t *assigned_group_members;
  rtentry *current_route;
  necp_client_interface_option interface_options[4];
  necp_client_interface_option *extra_interface_options;
  u_int8_t interface_option_count;
  necp_client_result_netagent failed_trigger_agent;
  void *agent_handle;
  uuid_t_1 override_euuid;
  netns_token port_reservation;
  nstat_context nstat_context;
  uuid_t_1 latest_flow_registration_id;
  uuid_t_1 parent_client_id;
  necp_client *original_parameters_source;
  size_t parameters_length;
  u_int8_t *parameters;
};

/* 4759 */
struct necp_client_flow_protoctl_event
{
  uint32_t protoctl_event_code;
  uint32_t protoctl_event_val;
  uint32_t protoctl_event_tcp_seq_num;
};

/* 4760 */
struct necp_client_flow
{
  struct
  {
    necp_client_flow *le_next;
    necp_client_flow **le_prev;
  } flow_chain;
  _BYTE gap10[8];
  union
  {
    uuid_t_1 nexus_agent;
    struct
    {
      void *socket_handle;
      necp_client_flow_cb cb;
    };
  } u;
  uint32_t interface_index;
  u_short delegated_interface_index;
  uint16_t interface_flags;
  uint32_t necp_flow_flags;
  necp_client_flow_protoctl_event protoctl_event;
  necp_sockaddr_union local_addr;
  necp_sockaddr_union remote_addr;
  size_t assigned_results_length;
  u_int8_t *assigned_results;
};

/* 4762 */
struct necp_client_assertion
{
  struct
  {
    necp_client_assertion *le_next;
    necp_client_assertion **le_prev;
  } assertion_chain;
  uuid_t_1 asserted_netagent;
};

/* 4756 */
struct _necp_client_tree
{
  necp_client *rbh_root;
};

/* 4757 */
struct necp_fd_data
{
  u_int8_t necp_fd_type;
  struct
  {
    necp_fd_data *le_next;
    necp_fd_data **le_prev;
  } chain;
  _necp_client_tree clients;
  _necp_fd_flow_tree flows;
  _necp_client_update_list update_list;
  int update_count;
  int flags;
  _BYTE gap40[4];
  int proc_pid;
  lck_mtx_t fd_lock;
  selinfo si;
  necp_arena_info *stats_arena_active;
  _necp_arena_info_list stats_arena_list;
  u_int32_t stats_arena_gencnt;
  skmem_arena *sysctl_arena;
  skmem_arena_mmap_info sysctl_mmap;
  mach_vm_offset_t system_sysctls_roff;
};

/* 4769 */
struct __attribute__((aligned(4))) necp_aggregate_result
{
  necp_kernel_policy_result routing_result;
  necp_kernel_policy_routing_result_parameter routing_result_parameter;
  necp_kernel_policy_filter filter_control_unit;
  u_int32_t flow_divert_aggregate_unit;
  necp_kernel_policy_result service_action;
  uuid_t_1 service_uuid;
  u_int32_t service_flags;
  u_int32_t service_data;
  u_int routed_interface_index;
  u_int32_t policy_id;
  uuid_t_1 netagents[16];
  u_int32_t netagent_use_flags[16];
  ipv6_prefix nat64_prefixes[4];
  u_int8_t mss_recommended;
};

/* 4770 */
struct necp_session_open_args
{
  int flags;
  char flags_r_[4];
};

/* 4771 */
struct __attribute__((aligned(8))) necp_socket_info
{
  pid_t pid;
  int32_t pid_version;
  uid_t uid;
  necp_sockaddr_union local_addr;
  necp_sockaddr_union remote_addr;
  u_int32_t bound_interface_index;
  u_int32_t traffic_class;
  u_int16_t protocol;
  u_int16_t scheme_port;
  u_int32_t application_id;
  u_int32_t real_application_id;
  u_int32_t account_id;
  u_int32_t drop_order;
  u_int32_t client_flags;
  char *domain;
  _BYTE gap70[8];
};

/* 4772 */
struct necp_session_action_args
{
  int necp_fd;
  char necp_fd_r_[4];
  uint32_t action;
  char action_r_[4];
  user_addr_t_0 in_buffer;
  user_size_t in_buffer_length;
  user_addr_t_0 out_buffer;
  user_size_t out_buffer_length;
  char out_buffer_length_r_[];
};

/* 4773 */
struct kev_necp_policies_changed_data
{
  u_int32_t changed_count;
};

/* 6677 */
struct recount_coalition
{
  recount_usage *rco_exited;
};

/* 6815 */
struct i_resource_coalition
{
  ledger_t ledger;
  uint64_t bytesread;
  uint64_t byteswritten;
  uint64_t energy;
  uint64_t gpu_time;
  uint64_t logical_immediate_writes;
  uint64_t logical_deferred_writes;
  uint64_t logical_invalidated_writes;
  uint64_t logical_metadata_writes;
  uint64_t logical_immediate_writes_to_external;
  uint64_t logical_deferred_writes_to_external;
  uint64_t logical_invalidated_writes_to_external;
  uint64_t logical_metadata_writes_to_external;
  uint64_t cpu_time_eqos[7];
  uint64_t cpu_time_rqos[7];
  uint64_t cpu_instructions;
  uint64_t cpu_cycles;
  recount_coalition co_recount;
  uint64_t task_count;
  uint64_t dead_task_count;
  uint64_t last_became_nonempty_time;
  uint64_t time_nonempty;
  queue_head_t_0 tasks;
  ledger_t resource_monitor_ledger;
  uint64_t fs_metadata_writes;
};

/* 6814 */
struct __attribute__((aligned(8))) i_jetsam_coalition
{
  task_t_0 leader;
  queue_head_t_0 extensions;
  queue_head_t_0 services;
  queue_head_t_0 other;
  thread_group *thread_group;
  bool swap_enabled;
};

/* 4774 */
struct coalition
{
  uint64_t id;
  uint32_t type;
  uint32_t role;
  os_ref_atomic_t ref_count;
  uint32_t active_count;
  uint32_t focal_task_count;
  uint32_t nonfocal_task_count;
  _BYTE gap20[8];
  smrq_slink link;
  lck_mtx_t_0 lock;
  union
  {
    i_resource_coalition r;
    i_jetsam_coalition j;
  };
};

/* 4775 */
struct necp_policy_condition_addr_range
{
  union
  {
    sockaddr sa;
    __sockaddr_header sah;
    sockaddr_in sin;
    sockaddr_in6 sin6;
  } start_address;
  union
  {
    sockaddr sa;
    __sockaddr_header sah;
    sockaddr_in sin;
    sockaddr_in6 sin6;
  } end_address;
};

/* 4776 */
struct __attribute__((aligned(4))) necp_drop_dest_entry
{
  u_int32_t level;
  u_int32_t order;
  necp_policy_condition_addr cond_addr;
};

/* 4777 */
struct __attribute__((aligned(8))) necp_aggregate_route_rule
{
  struct
  {
    necp_aggregate_route_rule *le_next;
    necp_aggregate_route_rule **le_prev;
  } chain;
  u_int32_t id;
  u_int32_t rule_ids[16];
};

/* 4778 */
struct necp_route_rule
{
  struct
  {
    necp_route_rule *le_next;
    necp_route_rule **le_prev;
  } chain;
  u_int32_t id;
  u_int32_t netagent_id;
  u_int32_t control_unit;
  u_int32_t match_netagent_id;
  u_int8_t default_action;
  u_int8_t cellular_action;
  u_int8_t wifi_action;
  u_int8_t wired_action;
  u_int8_t expensive_action;
  u_int8_t constrained_action;
  u_int8_t companion_action;
  u_int exception_if_indices[10];
  u_int8_t exception_if_actions[10];
  os_refcnt_t refcount;
};

/* 4779 */
typedef u_int32_t necp_app_id;

/* 4780 */
struct necp_string_id_mapping
{
  struct
  {
    necp_string_id_mapping *le_next;
    necp_string_id_mapping **le_prev;
  } chain;
  char *string;
  necp_app_id id;
  os_refcnt_t refcount;
};

/* 4781 */
struct __attribute__((aligned(8))) necp_uuid_id_mapping
{
  struct
  {
    necp_uuid_id_mapping *le_next;
    necp_uuid_id_mapping **le_prev;
  } chain;
  uuid_t_1 uuid;
  u_int32_t id;
  os_refcnt_t refcount;
  u_int32_t table_usecount;
};

/* 4782 */
struct necp_uuid_id_mapping_head
{
  necp_uuid_id_mapping *lh_first;
};

/* 4789 */
typedef u_int32_t necp_policy_order;

/* 4783 */
struct necp_kernel_ip_output_policy
{
  struct
  {
    necp_kernel_ip_output_policy *le_next;
    necp_kernel_ip_output_policy **le_prev;
  } chain;
  necp_kernel_policy_id id;
  necp_policy_order suborder;
  necp_policy_order order;
  u_int32_t session_order;
  int session_pid;
  u_int64_t condition_mask;
  u_int64_t condition_negated_mask;
  necp_kernel_policy_id cond_policy_id;
  ifnet_t cond_bound_interface;
  u_int16_t cond_protocol;
  necp_sockaddr_union cond_local_start;
  necp_sockaddr_union cond_local_end;
  u_int8_t cond_local_prefix;
  necp_sockaddr_union cond_remote_start;
  necp_sockaddr_union cond_remote_end;
  u_int8_t cond_remote_prefix;
  u_int32_t cond_last_interface_index;
  u_int16_t cond_packet_filter_tags;
  u_int16_t cond_scheme_port;
  necp_kernel_policy_result result;
  necp_kernel_policy_result_parameter result_parameter;
};

/* 4784 */
struct necp_policy_condition_sdk_version
{
  uint32_t platform;
  uint32_t min_version;
  uint32_t version;
};

/* 4785 */
struct necp_policy_condition_agent_type
{
  char agent_domain[32];
  char agent_type[32];
};

/* 4786 */
struct necp_policy_condition_tc_range
{
  u_int32_t start_tc;
  u_int32_t end_tc;
};

/* 4787 */
struct __attribute__((aligned(8))) necp_kernel_socket_policy
{
  struct
  {
    necp_kernel_socket_policy *le_next;
    necp_kernel_socket_policy **le_prev;
  } chain;
  necp_kernel_policy_id id;
  necp_policy_order order;
  u_int32_t session_order;
  int session_pid;
  u_int64_t condition_mask;
  u_int64_t condition_negated_mask;
  u_int32_t cond_client_flags;
  necp_kernel_policy_id cond_policy_id;
  u_int32_t cond_app_id;
  u_int32_t cond_real_app_id;
  char *cond_custom_entitlement;
  u_int32_t cond_account_id;
  char *cond_domain;
  u_int8_t cond_domain_dot_count;
  u_int32_t cond_domain_filter;
  pid_t cond_pid;
  uid_t cond_uid;
  ifnet_t cond_bound_interface;
  necp_policy_condition_tc_range cond_traffic_class;
  u_int16_t cond_protocol;
  necp_sockaddr_union cond_local_start;
  necp_sockaddr_union cond_local_end;
  u_int8_t cond_local_prefix;
  necp_sockaddr_union cond_remote_start;
  necp_sockaddr_union cond_remote_end;
  u_int8_t cond_remote_prefix;
  necp_policy_condition_agent_type cond_agent_type;
  __attribute__((packed)) __attribute__((aligned(1))) necp_policy_condition_sdk_version cond_sdk_version;
  char *cond_signing_identifier;
  u_int16_t cond_packet_filter_tags;
  u_int16_t cond_scheme_port;
  int32_t cond_pid_version;
  necp_kernel_policy_result result;
  necp_kernel_policy_result_parameter result_parameter;
};

/* 4788 */
struct __attribute__((aligned(8))) necp_service_registration
{
  struct
  {
    necp_service_registration *le_next;
    necp_service_registration **le_prev;
  } session_chain;
  struct
  {
    necp_service_registration *le_next;
    necp_service_registration **le_prev;
  } kernel_chain;
  u_int32_t service_id;
};

/* 4790 */
struct __attribute__((aligned(8))) necp_session_policy
{
  struct
  {
    necp_session_policy *le_next;
    necp_session_policy **le_prev;
  } chain;
  bool applied;
  bool pending_deletion;
  bool pending_update;
  necp_policy_id local_id;
  necp_policy_order order;
  u_int8_t *result;
  u_int32_t result_size;
  u_int8_t *conditions;
  u_int32_t conditions_size;
  u_int8_t *route_rules;
  u_int32_t route_rules_size;
  uuid_t_1 applied_app_uuid;
  uuid_t_1 applied_real_app_uuid;
  char *applied_account;
  u_int32_t applied_account_size;
  uuid_t_1 applied_result_uuid;
  u_int32_t applied_route_rules_id;
  necp_kernel_policy_id kernel_socket_policies[1];
  necp_kernel_policy_id kernel_ip_output_policies[4];
};

/* 4791 */
struct _services
{
  necp_service_registration *lh_first;
};

/* 4792 */
struct _policies
{
  necp_session_policy *lh_first;
};

/* 8053 */
struct necp_domain_filter_list
{
  necp_domain_filter *lh_first;
};

/* 4794 */
struct necp_session
{
  u_int8_t necp_fd_type;
  u_int32_t control_unit;
  u_int32_t session_priority;
  u_int32_t session_order;
  necp_policy_id last_policy_id;
  lck_mtx_t lock;
  bool proc_locked;
  uuid_t_1 proc_uuid;
  int proc_pid;
  bool dirty;
  _policies policies;
  _services services;
  necp_domain_filter_list domain_filters;
  struct
  {
    necp_session *tqe_next;
    necp_session **tqe_prev;
  } chain;
};

/* 4795 */
struct __attribute__((aligned(8))) necp_domain_filter
{
  struct
  {
    necp_domain_filter *le_next;
    necp_domain_filter **le_prev;
  } owner_chain;
  struct
  {
    necp_domain_filter *le_next;
    necp_domain_filter **le_prev;
  } chain;
  u_int32_t id;
  net_bloom_filter *filter;
  os_refcnt_t refcount;
};

/* 4797 */
typedef errno_t (*proto_media_resolve_multi)(ifnet_t, const sockaddr *, sockaddr_dl *, size_t);

/* 4798 */
typedef errno_t (*proto_media_detached)(ifnet_t, protocol_family_t);

/* 4799 */
typedef errno_t (*proto_media_ioctl)(ifnet_t, protocol_family_t, unsigned __int64, void *);

/* 4800 */
typedef void (*proto_media_event)(ifnet_t, protocol_family_t, const kev_msg *);

/* 4801 */
typedef errno_t (*proto_media_preout)(ifnet_t, protocol_family_t, mbuf_t *, const sockaddr *, void *, char *, char *);

/* 4802 */
typedef errno_t (*proto_media_input)(ifnet_t, protocol_family_t, mbuf_t, char *);

/* 4803 */
typedef ifaddr *ifaddr_t;

/* 4804 */
struct ipsec_detached_channels
{
  int count;
  kern_pbufpool_t pp;
  uuid_t_1 uuids[4];
};

/* 4805 */
struct ipsec_stats_param
{
  u_int64_t utsp_packets;
  u_int64_t utsp_bytes;
  u_int64_t utsp_errors;
};

/* 4806 */
struct ipsec_nx
{
  uuid_t_1 if_provider;
  uuid_t_1 if_instance;
  uuid_t_1 fsw_provider;
  uuid_t_1 fsw_instance;
  uuid_t_1 fsw_device;
  uuid_t_1 fsw_agent;
};

/* 4807 */
enum ipsec_dscp_mapping_t : __int32
{
  IPSEC_DSCP_MAPPING_COPY = 0x0,
  IPSEC_DSCP_MAPPING_LEGACY = 0x1,
};

/* 4808 */
struct __attribute__((aligned(8))) ipsec_pcb
{
  struct
  {
    ipsec_pcb *tqe_next;
    ipsec_pcb **tqe_prev;
  } ipsec_chain;
  kern_ctl_ref ipsec_ctlref;
  ifnet_t ipsec_ifp;
  u_int32_t ipsec_unit;
  u_int32_t ipsec_unique_id;
  u_int32_t ipsec_external_flags;
  u_int32_t ipsec_internal_flags;
  u_int32_t ipsec_input_frag_size;
  bool ipsec_frag_size_set;
  int ipsec_ext_ifdata_stats;
  mbuf_svc_class_t ipsec_output_service_class;
  char ipsec_if_xname[24];
  char ipsec_unique_name[24];
  lck_rw_t ipsec_pcb_lock;
  lck_mtx_t ipsec_pcb_data_move_lock;
  u_int32_t ipsec_pcb_data_move;
  u_int32_t ipsec_pcb_drainers;
  u_int32_t ipsec_pcb_data_path_state;
  ipsec_dscp_mapping_t ipsec_output_dscp_mapping;
  lck_mtx_t ipsec_input_chain_lock;
  lck_mtx_t ipsec_kpipe_encrypt_lock;
  lck_mtx_t ipsec_kpipe_decrypt_lock;
  mbuf *ipsec_input_chain;
  mbuf *ipsec_input_chain_last;
  u_int32_t ipsec_input_chain_count;
  ipsec_nx ipsec_nx;
  u_int32_t ipsec_kpipe_count;
  pid_t ipsec_kpipe_pid;
  uuid_t_1 ipsec_kpipe_proc_uuid;
  uuid_t_1 ipsec_kpipe_uuid[4];
  void *ipsec_kpipe_rxring[4];
  void *ipsec_kpipe_txring[4];
  kern_pbufpool_t ipsec_kpipe_pp;
  u_int32_t ipsec_kpipe_tx_ring_size;
  u_int32_t ipsec_kpipe_rx_ring_size;
  kern_nexus_t ipsec_netif_nexus;
  kern_pbufpool_t ipsec_netif_pp;
  void *ipsec_netif_rxring[1];
  void *ipsec_netif_txring[4];
  uint64_t ipsec_netif_txring_size;
  u_int32_t ipsec_slot_size;
  u_int32_t ipsec_netif_ring_size;
  u_int32_t ipsec_tx_fsw_ring_size;
  u_int32_t ipsec_rx_fsw_ring_size;
  bool ipsec_use_netif;
  bool ipsec_needs_netagent;
};

/* 4809 */
struct utun_stats_param
{
  u_int64_t utsp_packets;
  u_int64_t utsp_bytes;
  u_int64_t utsp_errors;
};

/* 4810 */
struct utun_nx
{
  uuid_t_1 if_provider;
  uuid_t_1 if_instance;
  uuid_t_1 fsw_provider;
  uuid_t_1 fsw_instance;
  uuid_t_1 fsw_device;
  uuid_t_1 fsw_agent;
};

/* 4811 */
struct __attribute__((aligned(8))) utun_pcb
{
  struct
  {
    utun_pcb *tqe_next;
    utun_pcb **tqe_prev;
  } utun_chain;
  kern_ctl_ref utun_ctlref;
  ifnet_t utun_ifp;
  u_int32_t utun_unit;
  u_int32_t utun_unique_id;
  u_int32_t utun_flags;
  int utun_ext_ifdata_stats;
  u_int32_t utun_max_pending_packets;
  char utun_if_xname[24];
  char utun_unique_name[24];
  lck_rw_t utun_pcb_lock;
  mbuf *utun_input_chain;
  mbuf *utun_input_chain_last;
  u_int32_t utun_input_chain_count;
  lck_mtx_t utun_input_chain_lock;
  lck_mtx_t utun_pcb_data_move_lock;
  u_int32_t utun_pcb_data_move;
  u_int32_t utun_pcb_drainers;
  u_int32_t utun_pcb_data_path_state;
  utun_nx utun_nx;
  int utun_kpipe_enabled;
  uuid_t_1 utun_kpipe_uuid;
  void *utun_kpipe_rxring;
  void *utun_kpipe_txring;
  kern_pbufpool_t utun_kpipe_pp;
  u_int32_t utun_kpipe_tx_ring_size;
  u_int32_t utun_kpipe_rx_ring_size;
  kern_nexus_t utun_netif_nexus;
  kern_pbufpool_t utun_netif_pp;
  void *utun_netif_rxring;
  void *utun_netif_txring;
  uint64_t utun_netif_txring_size;
  u_int32_t utun_slot_size;
  u_int32_t utun_netif_ring_size;
  u_int32_t utun_tx_fsw_ring_size;
  u_int32_t utun_rx_fsw_ring_size;
  bool utun_attach_fsw;
  bool utun_netif_connected;
  bool utun_use_netif;
  bool utun_needs_netagent;
};

/* 4812 */
struct __attribute__((aligned(4))) if_family_id
{
  u_int32_t iffmid_len;
  u_int32_t iffmid_id;
  char iffmid_str[1];
};

/* 4813 */
struct __attribute__((aligned(8))) net_str_id_entry
{
  struct
  {
    net_str_id_entry *sle_next;
  } nsi_next;
  u_int32_t nsi_flags;
  u_int32_t nsi_id;
  char nsi_string[1];
};

/* 4814 */
typedef void (*iff_detached_func)(void *, ifnet_t);

/* 4815 */
typedef errno_t (*iff_ioctl_func)(void *, ifnet_t, protocol_family_t, unsigned __int64, void *);

/* 4816 */
typedef void (*iff_event_func)(void *, ifnet_t, protocol_family_t, const kev_msg *);

/* 4817 */
typedef errno_t (*iff_output_func)(void *, ifnet_t, protocol_family_t, mbuf_t *);

/* 4818 */
typedef errno_t (*iff_input_func)(void *, ifnet_t, protocol_family_t, mbuf_t *, char **);

/* 4819 */
struct iff_filter
{
  void *iff_cookie;
  const char *iff_name;
  protocol_family_t iff_protocol;
  iff_input_func iff_input;
  iff_output_func iff_output;
  iff_event_func iff_event;
  iff_ioctl_func iff_ioctl;
  iff_detached_func iff_detached;
};

/* 4820 */
typedef void (*proto_unplumb_handler)(ifnet_t, protocol_family_t);

/* 4821 */
typedef errno_t (*proto_plumb_handler)(ifnet_t, protocol_family_t);

/* 4822 */
struct proto_family_str
{
  struct
  {
    proto_family_str *tqe_next;
    proto_family_str **tqe_prev;
  } proto_fam_next;
  protocol_family_t proto_family;
  ifnet_family_t if_family;
  proto_plumb_handler attach_proto;
  proto_unplumb_handler detach_proto;
};

/* 4823 */
typedef void (*proto_input_detached_handler)(protocol_family_t);

/* 4824 */
typedef void (*proto_input_handler)(protocol_family_t, mbuf_t);

/* 4825 */
struct proto_input_entry
{
  proto_input_entry *next;
  int detach;
  domain *domain;
  int hash;
  int chain;
  protocol_family_t protocol;
  proto_input_handler input;
  proto_input_detached_handler detached;
  mbuf_t inject_first;
  mbuf_t inject_last;
  proto_input_entry *input_next;
  mbuf_t input_first;
  mbuf_t input_last;
};

/* 4826 */
struct ifnet_buffer_status_t
{
  int32_t buf_interface;
  int32_t buf_sndbuf;
};

/* 4827 */
typedef if_clone *if_clone_t;

/* 4835 */
struct __attribute__((aligned(8))) if_clone
{
  struct
  {
    if_clone *le_next;
    if_clone **le_prev;
  } ifc_list;
  lck_mtx_t ifc_mutex;
  u_int32_t ifc_minifs;
  u_int32_t ifc_maxunit;
  unsigned __int8 *ifc_units;
  u_int32_t ifc_bmlen;
  int (*ifc_create)(if_clone *, u_int32_t, void *);
  int (*ifc_destroy)(ifnet *);
  uint8_t ifc_namelen;
  char ifc_name[17];
};

/* 4828 */
typedef errno_t (*ifnet_clone_destroy_func)(ifnet_t);

/* 4829 */
typedef errno_t (*ifnet_clone_create_func)(if_clone_t, u_int32_t, void *);

/* 4830 */
struct ifnet_clone_params
{
  const char *ifc_name;
  ifnet_clone_create_func ifc_create;
  ifnet_clone_destroy_func ifc_destroy;
};

/* 4831 */
typedef u_int32_t tx_compl_val_t;

/* 4832 */
struct __attribute__((aligned(8))) ifnet_init_params
{
  const void *uniqueid;
  u_int32_t uniqueid_len;
  const char *name;
  u_int32_t unit;
  ifnet_family_t family;
  u_int32_t type;
  ifnet_output_func output;
  ifnet_demux_func_0 demux;
  ifnet_add_proto_func add_proto;
  ifnet_del_proto_func del_proto;
  ifnet_check_multi check_multi;
  ifnet_framer_func_1 framer;
  void *softc;
  ifnet_ioctl_func ioctl;
  ifnet_set_bpf_tap set_bpf_tap;
  ifnet_detached_func detach;
  ifnet_event_func event;
  const void *broadcast_addr;
  u_int32_t broadcast_len;
};

/* 4833 */
struct ifnet_stats_param
{
  u_int64_t packets_in;
  u_int64_t bytes_in;
  u_int64_t multicasts_in;
  u_int64_t errors_in;
  u_int64_t packets_out;
  u_int64_t bytes_out;
  u_int64_t multicasts_out;
  u_int64_t errors_out;
  u_int64_t collisions;
  u_int64_t dropped;
  u_int64_t no_protocol;
};

/* 4834 */
struct ifnet_list
{
  struct
  {
    ifnet_list *sle_next;
  } ifl_le;
  ifnet *ifl_ifp;
};

/* 4836 */
struct ifnet_addr_list
{
  struct
  {
    ifnet_addr_list *sle_next;
  } ifal_le;
  ifaddr *ifal_ifa;
};

/* 4837 */
typedef u_int32_t ifnet_offload_t;

/* 4838 */
enum if_low_power_ev_code_t : __int32
{
  IF_LOW_POWER_EVENT_OFF = 0x0,
  IF_LOW_POWER_EVENT_ON = 0x1,
};

/* 4842 */
union in_addr_4_6
{
  in_addr _in_a_4;
  in6_addr_0 _in_a_6;
};

/* 4839 */
struct __attribute__((aligned(4))) net_port_info
{
  uint16_t npi_if_index;
  uint16_t npi_flags;
  timeval32 npi_timestamp;
  uuid_t_1 npi_flow_uuid;
  in_port_t npi_local_port;
  in_port_t npi_foreign_port;
  in_addr_4_6 npi_local_addr_;
  in_addr_4_6 npi_foreign_addr_;
  pid_t npi_owner_pid;
  pid_t npi_effective_pid;
  char npi_owner_pname[17];
  char npi_effective_pname[17];
  uuid_t_1 npi_owner_uuid;
  uuid_t_1 npi_effective_uuid;
};

/* 4840 */
struct __attribute__((aligned(8))) net_port_entry
{
  struct
  {
    net_port_entry *sle_next;
  } npe_list_next;
  struct
  {
    net_port_entry *tqe_next;
    net_port_entry **tqe_prev;
  } npe_hash_next;
  net_port_info npe_npi;
};

/* 4841 */
struct net_port_entry_hash_table
{
  net_port_entry *tqh_first;
  net_port_entry **tqh_last;
};

/* 4843 */
struct stf_softc
{
  ifnet_t sc_if;
  u_int32_t sc_protocol_family;
  union
  {
    route_0 __sc_ro4;
    route_in6 __sc_ro6;
  } __sc_ro46;
  lck_mtx_t sc_ro_mtx;
  const encaptab *encap_cookie;
  bpf_tap_mode tap_mode;
  bpf_packet_func tap_callback;
};

/* 4844 */
typedef net_perf net_perf_t;

/* 9273 */
struct __attribute__((aligned(8))) net_perf
{
  uint64_t np_total_pkts;
  uint64_t np_total_usecs;
  uint64_t np_hist1;
  uint64_t np_hist2;
  uint64_t np_hist3;
  uint64_t np_hist4;
  uint64_t np_hist5;
  uint8_t np_hist_bars[4];
};

/* 4890 */
struct nstat_msg_hdr
{
  u_int64_t context;
  u_int32_t type;
  u_int16_t length;
  u_int16_t flags;
};

/* 4899 */
typedef u_int64_t nstat_src_ref_t;

/* 4902 */
typedef u_int32_t nstat_provider_id_t;

/* 4845 */
struct nstat_msg_src_added
{
  nstat_msg_hdr hdr;
  nstat_src_ref_t srcref;
  nstat_provider_id_t provider;
  u_int8_t reserved[4];
};

/* 4846 */
struct xtcpprogress_indicators
{
  u_int32_t xp_numflows;
  u_int32_t xp_conn_probe_fails;
  u_int32_t xp_read_probe_fails;
  u_int32_t xp_write_probe_fails;
  u_int32_t xp_recentflows;
  u_int32_t xp_recentflows_unacked;
  u_int64_t xp_recentflows_rxbytes;
  u_int64_t xp_recentflows_txbytes;
  u_int64_t xp_recentflows_rxooo;
  u_int64_t xp_recentflows_rxdup;
  u_int64_t xp_recentflows_retx;
  u_int64_t xp_reserved1;
  u_int64_t xp_reserved2;
  u_int64_t xp_reserved3;
  u_int64_t xp_reserved4;
};

/* 4847 */
enum nstat_provider_type_t : __int32
{
  NSTAT_PROVIDER_NONE = 0x0,
  NSTAT_PROVIDER_ROUTE = 0x1,
  NSTAT_PROVIDER_TCP_KERNEL = 0x2,
  NSTAT_PROVIDER_TCP_USERLAND = 0x3,
  NSTAT_PROVIDER_UDP_KERNEL = 0x4,
  NSTAT_PROVIDER_UDP_USERLAND = 0x5,
  NSTAT_PROVIDER_IFNET = 0x6,
  NSTAT_PROVIDER_SYSINFO = 0x7,
  NSTAT_PROVIDER_QUIC_USERLAND = 0x8,
  NSTAT_PROVIDER_CONN_USERLAND = 0x9,
  NSTAT_PROVIDER_UDP_SUBFLOW = 0xA,
};

/* 4848 */
struct nstat_msg_src_removed
{
  nstat_msg_hdr hdr;
  nstat_src_ref_t srcref;
};

/* 4849 */
struct nstat_msg_set_filter
{
  nstat_msg_hdr hdr;
  nstat_src_ref_t srcref;
  u_int32_t filter;
  u_int8_t reserved[4];
};

/* 4850 */
struct nstat_msg_get_src_description
{
  nstat_msg_hdr hdr;
  nstat_src_ref_t srcref;
};

/* 4891 */
typedef u_int64_t nstat_event_flags_t;

/* 4851 */
struct nstat_msg_src_counts
{
  nstat_msg_hdr hdr;
  nstat_src_ref_t srcref;
  nstat_event_flags_t event_flags;
  nstat_counts counts;
};

/* 4852 */
typedef nstat_msg_add_src nstat_msg_add_src_req;

/* 9292 */
struct nstat_msg_add_src
{
  nstat_msg_hdr hdr;
  nstat_provider_id_t provider;
  u_int8_t reserved[4];
  u_int8_t param[];
};

/* 4853 */
struct nstat_msg_src_extended_item_hdr
{
  u_int32_t type;
  u_int32_t length;
};

/* 4854 */
struct nstat_msg_src_update
{
  nstat_msg_hdr hdr;
  nstat_src_ref_t srcref;
  nstat_event_flags_t event_flags;
  nstat_counts counts;
  nstat_provider_id_t provider;
  u_int8_t reserved[4];
  u_int8_t data[];
};

/* 4855 */
struct nstat_sysinfo_keyval
{
  u_int32_t nstat_sysinfo_key;
  u_int32_t nstat_sysinfo_flags;
  union
  {
    int64_t nstat_sysinfo_scalar;
    double nstat_sysinfo_distribution;
    u_int8_t nstat_sysinfo_string[24];
  } u;
  u_int32_t nstat_sysinfo_valsize;
  u_int8_t reserved[4];
};

/* 4856 */
struct nstat_sysinfo_counts
{
  u_int32_t nstat_sysinfo_len;
  u_int32_t pad;
  u_int8_t nstat_sysinfo_keyvals[];
};

/* 4857 */
struct nstat_msg_sysinfo_counts
{
  nstat_msg_hdr hdr;
  nstat_src_ref_t srcref;
  nstat_sysinfo_counts counts;
};

/* 4858 */
struct nstat_ifnet_desc_wifi_status
{
  u_int32_t valid_bitmask;
  u_int32_t link_quality_metric;
  u_int32_t ul_effective_bandwidth;
  u_int32_t ul_max_bandwidth;
  u_int32_t ul_min_latency;
  u_int32_t ul_effective_latency;
  u_int32_t ul_max_latency;
  u_int32_t ul_retxt_level;
  u_int32_t ul_bytes_lost;
  u_int32_t ul_error_rate;
  u_int32_t dl_effective_bandwidth;
  u_int32_t dl_max_bandwidth;
  u_int32_t dl_min_latency;
  u_int32_t dl_effective_latency;
  u_int32_t dl_max_latency;
  u_int32_t dl_error_rate;
  u_int32_t config_frequency;
  u_int32_t config_multicast_rate;
  u_int32_t scan_count;
  u_int32_t scan_duration;
};

/* 4859 */
struct nstat_ifnet_desc_cellular_status
{
  u_int32_t valid_bitmask;
  u_int32_t link_quality_metric;
  u_int32_t ul_effective_bandwidth;
  u_int32_t ul_max_bandwidth;
  u_int32_t ul_min_latency;
  u_int32_t ul_effective_latency;
  u_int32_t ul_max_latency;
  u_int32_t ul_retxt_level;
  u_int32_t ul_bytes_lost;
  u_int32_t ul_min_queue_size;
  u_int32_t ul_avg_queue_size;
  u_int32_t ul_max_queue_size;
  u_int32_t dl_effective_bandwidth;
  u_int32_t dl_max_bandwidth;
  u_int32_t config_inactivity_time;
  u_int32_t config_backoff_time;
  u_int16_t mss_recommended;
  u_int8_t reserved[2];
};

/* 4860 */
struct nstat_ifnet_desc_link_status
{
  u_int32_t link_status_type;
  union
  {
    nstat_ifnet_desc_cellular_status cellular;
    nstat_ifnet_desc_wifi_status wifi;
  } u;
};

/* 4861 */
struct nstat_ifnet_descriptor
{
  u_int64_t threshold;
  u_int32_t ifindex;
  nstat_ifnet_desc_link_status link_status;
  unsigned int type;
  char description[128];
  char name[17];
  u_int8_t reserved[3];
};

/* 4862 */
struct nstat_msg_src_description
{
  nstat_msg_hdr hdr;
  nstat_src_ref_t srcref;
  nstat_event_flags_t event_flags;
  nstat_provider_id_t provider;
  u_int8_t reserved[4];
  u_int8_t data[];
};

/* 4863 */
struct nstat_ifnet_add_param
{
  u_int64_t threshold;
  u_int32_t ifindex;
  u_int8_t reserved[4];
};

/* 4864 */
struct nstat_tcp_add_param
{
  union
  {
    sockaddr_in v4;
    sockaddr_in6 v6;
  } local;
  union
  {
    sockaddr_in v4;
    sockaddr_in6 v6;
  } remote;
};

/* 4866 */
struct align_header
{
  u_int32_t offset;
  u_int32_t length;
};

/* 4867 */
struct nstat_route_descriptor
{
  u_int64_t id;
  u_int64_t parent_id;
  u_int64_t gateway_id;
  union
  {
    sockaddr_in v4;
    sockaddr_in6 v6;
    sockaddr sa;
  } dst;
  union
  {
    sockaddr_in v4;
    sockaddr_in6 v6;
    sockaddr sa;
  } mask;
  union
  {
    sockaddr_in v4;
    sockaddr_in6 v6;
    sockaddr sa;
  } gateway;
  u_int32_t ifindex;
  u_int32_t flags;
  u_int8_t reserved[4];
};

/* 4868 */
struct nstat_route_add_param
{
  union
  {
    sockaddr_in v4;
    sockaddr_in6 v6;
  } dst;
  union
  {
    sockaddr_in v4;
    sockaddr_in6 v6;
  } mask;
  u_int32_t ifindex;
};

/* 4870 */
struct nstat_flow_data
{
  nstat_counts counts;
  union
  {
    nstat_udp_descriptor udp_descriptor;
    nstat_tcp_descriptor tcp_descriptor;
  } flow_descriptor;
};

/* 4871 */
struct nstat_ifnet_cookie
{
  ifnet *ifp;
  uint64_t threshold;
};

/* 4877 */
struct __attribute__((aligned(8))) nstat_tucookie
{
  inpcb *inp;
  char pname[17];
  bool cached;
  union
  {
    sockaddr_in v4;
    sockaddr_in6 v6;
  } local;
  union
  {
    sockaddr_in v4;
    sockaddr_in6 v6;
  } remote;
  unsigned int if_index;
  uint32_t ifnet_properties;
};

/* 4880 */
typedef void *nstat_provider_context;

/* 4878 */
typedef size_t nstat_provider_request_extensions_fn(nstat_provider_context, int, void *, size_t);

/* 4879 */
typedef bool nstat_provider_request_vals_fn(nstat_provider_context, u_int32_t *, nstat_counts *, void *);

/* 4881 */
struct tailq_entry_generic_shadow
{
  nstat_generic_shadow *tqe_next;
  nstat_generic_shadow **tqe_prev;
};

/* 4882 */
struct __attribute__((aligned(8))) nstat_generic_shadow
{
  tailq_entry_generic_shadow gshad_link;
  nstat_provider_context gshad_provider_context;
  nstat_provider_request_vals_fn *gshad_getvals_fn;
  nstat_provider_request_extensions_fn *gshad_getextensions_fn;
  u_int64_t gshad_properties;
  u_int64_t gshad_start_timestamp;
  nstat_procdetails *gshad_procdetails;
  nstat_provider_id_t gshad_provider;
  int32_t gshad_refcnt;
  uint32_t gshad_magic;
};

/* 4893 */
struct tailq_entry_procdetails
{
  nstat_procdetails *tqe_next;
  nstat_procdetails **tqe_prev;
};

/* 4894 */
struct nstat_procdetails
{
  tailq_entry_procdetails pdet_link;
  int pdet_pid;
  u_int64_t pdet_upid;
  char pdet_procname[64];
  uuid_t_1 pdet_uuid;
  u_int32_t pdet_refcnt;
  u_int32_t pdet_magic;
};

/* 4884 */
typedef void *userland_stats_provider_context;

/* 4883 */
typedef size_t userland_stats_request_extension_fn(userland_stats_provider_context *, int, void *, size_t);

/* 4885 */
typedef bool userland_stats_request_vals_fn(userland_stats_provider_context *, u_int16_t *, nstat_progress_digest *, nstat_counts *, void *);

/* 4886 */
enum nstat_rnf_override : __int32
{
  nstat_rnf_override::nstat_rnf_override_not_set = 0x0,
  nstat_rnf_override::nstat_rnf_override_enabled = 0x1,
  nstat_rnf_override::nstat_rnf_override_disabled = 0x2,
};

/* 4887 */
struct tailq_entry_tu_shadow
{
  nstat_tu_shadow *tqe_next;
  nstat_tu_shadow **tqe_prev;
};

/* 4888 */
struct __attribute__((aligned(8))) nstat_tu_shadow
{
  tailq_entry_tu_shadow shad_link;
  userland_stats_request_vals_fn *shad_getvals_fn;
  userland_stats_request_extension_fn *shad_get_extension_fn;
  userland_stats_provider_context *shad_provider_context;
  u_int64_t shad_properties;
  u_int64_t shad_start_timestamp;
  nstat_provider_id_t shad_provider;
  nstat_procdetails *shad_procdetails;
  bool shad_live;
  nstat_rnf_override shad_rnf_override;
  uint32_t shad_magic;
};

/* 4892 */
struct nstat_msg_add_all_srcs
{
  nstat_msg_hdr hdr;
  u_int64_t filter;
  nstat_event_flags_t events;
  nstat_provider_id_t provider;
  pid_t target_pid;
  uuid_t_1 target_uuid;
};

/* 4895 */
struct __attribute__((aligned(8))) nstat_provider_filter
{
  u_int64_t npf_flags;
  u_int64_t npf_events;
  u_int64_t npf_extensions;
  pid_t npf_pid;
  uuid_t_1 npf_uuid;
};

/* 4896 */
struct tailq_entry_nstat_src
{
  nstat_src *tqe_next;
  nstat_src **tqe_prev;
};

/* 4901 */
typedef void *nstat_provider_cookie_t;

/* 4897 */
struct nstat_src
{
  tailq_entry_nstat_src ns_control_link;
  nstat_control_state *ns_control;
  nstat_src_ref_t srcref;
  nstat_provider *provider;
  nstat_provider_cookie_t cookie;
  uint32_t filter;
  bool ns_reported;
  uint64_t seq;
};

/* 4898 */
struct tailq_head_nstat_src
{
  nstat_src *tqh_first;
  nstat_src **tqh_last;
};

/* 4900 */
struct nstat_control_state
{
  nstat_control_state *ncs_next;
  u_int32_t ncs_watching;
  lck_mtx_t ncs_mtx;
  kern_ctl_ref ncs_kctl;
  u_int32_t ncs_unit;
  nstat_src_ref_t ncs_next_srcref;
  tailq_head_nstat_src ncs_src_queue;
  mbuf_t ncs_accumulated;
  u_int32_t ncs_flags;
  nstat_provider_filter ncs_provider_filters[11];
  u_int64_t ncs_context;
  u_int64_t ncs_seq;
  nstat_procdetails *ncs_procdetails;
};

/* 4903 */
struct nstat_provider
{
  nstat_provider *next;
  nstat_provider_id_t nstat_provider_id;
  size_t nstat_descriptor_length;
  errno_t (*nstat_lookup)(const void *, u_int32_t, nstat_provider_cookie_t *);
  int (*nstat_gone)(nstat_provider_cookie_t);
  errno_t (*nstat_counts)(nstat_provider_cookie_t, nstat_counts *, int *);
  errno_t (*nstat_watcher_add)(nstat_control_state *, nstat_msg_add_all_srcs *);
  void (*nstat_watcher_remove)(nstat_control_state *);
  errno_t (*nstat_copy_descriptor)(nstat_provider_cookie_t, void *, size_t);
  void (*nstat_release)(nstat_provider_cookie_t, boolean_t);
  bool (*nstat_reporting_allowed)(nstat_provider_cookie_t, nstat_provider_filter *, u_int64_t);
  size_t (*nstat_copy_extension)(nstat_provider_cookie_t, u_int32_t, void *, size_t);
};

/* 4904 */
struct netsrc_req
{
  unsigned int nrq_ver;
  unsigned int nrq_ifscope;
  union
  {
    sockaddr_in_4_6 nrq_dst;
    sockaddr_in_4_6 _usa;
  };
};

/* 4905 */
struct rt_addrinfo
{
  int rti_addrs;
  sockaddr *rti_info[8];
};

/* 4906 */
struct ifma_msghdr2
{
  u_short ifmam_msglen;
  u_char ifmam_version;
  u_char ifmam_type;
  int ifmam_addrs;
  int ifmam_flags;
  u_short ifmam_index;
  int32_t ifmam_refcount;
};

/* 4907 */
struct if_data64
{
  u_char ifi_type;
  u_char ifi_typelen;
  u_char ifi_physical;
  u_char ifi_addrlen;
  u_char ifi_hdrlen;
  u_char ifi_recvquota;
  u_char ifi_xmitquota;
  u_char ifi_unused1;
  u_int32_t ifi_mtu;
  u_int32_t ifi_metric;
  u_int64_t ifi_baudrate;
  u_int64_t ifi_ipackets;
  u_int64_t ifi_ierrors;
  u_int64_t ifi_opackets;
  u_int64_t ifi_oerrors;
  u_int64_t ifi_collisions;
  u_int64_t ifi_ibytes;
  u_int64_t ifi_obytes;
  u_int64_t ifi_imcasts;
  u_int64_t ifi_omcasts;
  u_int64_t ifi_iqdrops;
  u_int64_t ifi_noproto;
  u_int32_t ifi_recvtiming;
  u_int32_t ifi_xmittiming;
  timeval32 ifi_lastchange;
};

/* 4908 */
struct if_msghdr2
{
  u_short ifm_msglen;
  u_char ifm_version;
  u_char ifm_type;
  int ifm_addrs;
  int ifm_flags;
  u_short ifm_index;
  int ifm_snd_len;
  int ifm_snd_maxlen;
  int ifm_snd_drops;
  int ifm_timer;
  if_data64 ifm_data;
};

/* 4909 */
struct rt_msghdr_ext
{
  u_short rtm_msglen;
  u_char rtm_version;
  u_char rtm_type;
  u_int32_t rtm_index;
  u_int32_t rtm_flags;
  u_int32_t rtm_reserved;
  u_int32_t rtm_addrs;
  pid_t rtm_pid;
  int rtm_seq;
  int rtm_errno;
  u_int32_t rtm_use;
  u_int32_t rtm_inits;
  rt_metrics rtm_rmx;
  rt_reach_info rtm_ri;
};

/* 4910 */
struct rt_msghdr2
{
  u_short rtm_msglen;
  u_char rtm_version;
  u_char rtm_type;
  u_short rtm_index;
  int rtm_flags;
  int rtm_addrs;
  int32_t rtm_refcnt;
  int rtm_parentflags;
  int rtm_reserved;
  int rtm_use;
  u_int32_t rtm_inits;
  rt_metrics rtm_rmx;
};

/* 4911 */
struct __attribute__((aligned(4))) ifma_msghdr
{
  unsigned __int16 ifmam_msglen;
  unsigned __int8 ifmam_version;
  unsigned __int8 ifmam_type;
  int ifmam_addrs;
  int ifmam_flags;
  unsigned __int16 ifmam_index;
};

/* 4912 */
struct ifa_msghdr
{
  unsigned __int16 ifam_msglen;
  unsigned __int8 ifam_version;
  unsigned __int8 ifam_type;
  int ifam_addrs;
  int ifam_flags;
  unsigned __int16 ifam_index;
  int ifam_metric;
};

/* 4913 */
struct if_data
{
  u_char ifi_type;
  u_char ifi_typelen;
  u_char ifi_physical;
  u_char ifi_addrlen;
  u_char ifi_hdrlen;
  u_char ifi_recvquota;
  u_char ifi_xmitquota;
  u_char ifi_unused1;
  u_int32_t ifi_mtu;
  u_int32_t ifi_metric;
  u_int32_t ifi_baudrate;
  u_int32_t ifi_ipackets;
  u_int32_t ifi_ierrors;
  u_int32_t ifi_opackets;
  u_int32_t ifi_oerrors;
  u_int32_t ifi_collisions;
  u_int32_t ifi_ibytes;
  u_int32_t ifi_obytes;
  u_int32_t ifi_imcasts;
  u_int32_t ifi_omcasts;
  u_int32_t ifi_iqdrops;
  u_int32_t ifi_noproto;
  u_int32_t ifi_recvtiming;
  u_int32_t ifi_xmittiming;
  timeval32 ifi_lastchange;
  u_int32_t ifi_unused2;
  u_int32_t ifi_hwassist;
  u_int32_t ifi_reserved1;
  u_int32_t ifi_reserved2;
};

/* 4914 */
struct if_msghdr
{
  unsigned __int16 ifm_msglen;
  unsigned __int8 ifm_version;
  unsigned __int8 ifm_type;
  int ifm_addrs;
  int ifm_flags;
  unsigned __int16 ifm_index;
  if_data ifm_data;
};

/* 4915 */
typedef void (*route_event_fn)(eventhandler_entry_arg, sockaddr *, int, sockaddr *, int);

/* 4916 */
struct eventhandler_entry_route_event
{
  eventhandler_entry ee;
  route_event_fn eh_func;
};

/* 4918 */
struct route_event
{
  rtentry *rt;
  rtentry *gwrt;
  union
  {
    sockaddr_in_4_6 _rtev_ipaddr;
    char _rtev_addr_bytes[64];
  } rt_addr;
  uint32_t route_event_code;
  eventhandler_tag evtag;
};

/* 4917 */
struct route_event_nwk_wq_entry
{
  nwk_wq_entry nwk_wqe;
  route_event rt_ev_arg;
};

/* 4919 */
struct rtentry_dbg
{
  rtentry rtd_entry;
  rtentry rtd_entry_saved;
  uint32_t rtd_inuse;
  uint16_t rtd_refhold_cnt;
  uint16_t rtd_refrele_cnt;
  uint32_t rtd_lock_cnt;
  uint32_t rtd_unlock_cnt;
  ctrace_t rtd_alloc;
  ctrace_t rtd_free;
  ctrace_t rtd_refhold[4];
  ctrace_t rtd_refrele[4];
  ctrace_t rtd_lock[4];
  ctrace_t rtd_unlock[4];
  struct
  {
    rtentry_dbg *tqe_next;
    rtentry_dbg **tqe_prev;
  } rtd_trash_link;
};

/* 4920 */
struct ndrv_demux_desc
{
  u_int16_t type;
  u_int16_t length;
  union
  {
    u_int16_t ether_type;
    u_int8_t sap[3];
    u_int8_t snap[5];
    u_int8_t other[28];
  } data;
};

/* 4922 */
typedef int devtimer_process_func_event;

/* 4925 */
typedef devtimer_s *devtimer_ref;

/* 4923 */
typedef void (*devtimer_process_func)(devtimer_ref, devtimer_process_func_event);

/* 8064 */
typedef void (*devtimer_timeout_func)(void *, void *, void *);

/* 4924 */
struct devtimer_s
{
  void *dt_callout;
  devtimer_timeout_func dt_timeout_func;
  devtimer_process_func dt_process_func;
  void *dt_arg0;
  void *dt_arg1;
  void *dt_arg2;
  int dt_generation;
  os_refcnt dt_retain_count;
};

/* 4939 */
struct lacp_system
{
  u_char system_id[6];
};

/* 4938 */
typedef u_int16_t lacp_system_priority;

/* 4937 */
typedef u_int16_t lacp_key;

/* 4942 */
typedef u_int16_t lacp_port;

/* 4941 */
typedef u_int16_t lacp_port_priority;

/* 4940 */
typedef u_char lacp_actor_partner_state;

/* 4926 */
struct if_bond_partner_state
{
  lacp_system ibps_system;
  lacp_system_priority ibps_system_priority;
  lacp_key ibps_key;
  lacp_port ibps_port;
  lacp_port_priority ibps_port_priority;
  lacp_actor_partner_state ibps_state;
  u_char ibps_reserved1;
};

/* 4927 */
struct __attribute__((packed)) __attribute__((aligned(4))) if_bond_status_req
{
  int ibsr_version;
  int ibsr_total;
  int ibsr_count;
  union
  {
    void *ibsru_buffer;
    u_int64_t ibsru_buffer64;
  } ibsr_ibsru;
  lacp_key ibsr_key;
  u_int8_t ibsr_mode;
  u_int8_t ibsr_reserved0;
  u_int32_t ibsr_reserved[3];
};

/* 4928 */
enum LAEvent : __int32
{
  LAEventStart = 0x0,
  LAEventTimeout = 0x1,
  LAEventPacket = 0x2,
  LAEventMediaChange = 0x3,
  LAEventSelectedChange = 0x4,
  LAEventPortMoved = 0x5,
  LAEventReady = 0x6,
};

/* 4929 */
struct event
{
  u_int32_t ifnet_family;
  u_int32_t unit;
  char if_name[16];
};

/* 4930 */
struct lacp_collector_tlv_s
{
  u_char lac_tlv_type;
  u_char lac_length;
  u_char lac_max_delay[2];
  u_char lac_reserved[12];
};

/* 4931 */
struct la_marker_pdu_s
{
  u_char lm_subtype;
  u_char lm_version;
  u_char lm_marker_tlv_type;
  u_char lm_marker_tlv_length;
  u_char lm_requestor_port[2];
  u_char lm_requestor_system[6];
  u_char lm_requestor_transaction_id[4];
  u_char lm_pad[2];
  u_char lm_terminator_type;
  u_char lm_terminator_length;
  u_char lm_reserved[90];
};

/* 4932 */
struct lacp_actor_partner_tlv_s
{
  u_char lap_tlv_type;
  u_char lap_length;
  u_char lap_system_priority[2];
  u_char lap_system[6];
  u_char lap_key[2];
  u_char lap_port_priority[2];
  u_char lap_port[2];
  u_char lap_state;
  u_char lap_reserved[3];
};

/* 4933 */
struct lacpdu_s
{
  u_char la_subtype;
  u_char la_version;
  u_char la_actor_tlv[20];
  u_char la_partner_tlv[20];
  u_char la_collector_tlv[16];
  u_char la_terminator_type;
  u_char la_terminator_length;
  u_char la_reserved[50];
};

/* 4934 */
struct __attribute__((packed)) __attribute__((aligned(4))) ifmediareq
{
  char ifm_name[16];
  int ifm_current;
  int ifm_mask;
  int ifm_status;
  int ifm_active;
  int ifm_count;
  int *ifm_ulist;
};

/* 4935 */
typedef bondport_s *bondport_ref;

/* 4952 */
typedef ifbond_s *ifbond_ref;

/* 4951 */
struct multicast_list
{
  multicast_entry *slh_first;
};

/* 5075 */
typedef ifnet_filter *interface_filter_t;

/* 8071 */
struct LAG_info_s
{
  lacp_system li_system;
  lacp_system_priority li_system_priority;
  lacp_key li_key;
};

/* 4943 */
typedef LAG_info_s LAG_info;

/* 8076 */
struct __attribute__((aligned(2))) partner_state_s
{
  LAG_info ps_lag_info;
  lacp_port ps_port;
  lacp_port_priority ps_port_priority;
  lacp_actor_partner_state ps_state;
};

/* 4950 */
typedef partner_state_s partner_state;

/* 4949 */
typedef u_char ReceiveState;

/* 4948 */
typedef u_char MuxState;

/* 4947 */
typedef u_char SelectedState;

/* 4946 */
struct media_info
{
  int mi_active;
  int mi_status;
};

/* 4945 */
typedef LAG_s *LAG_ref;

/* 4953 */
struct bondport_s
{
  struct
  {
    bondport_s *tqe_next;
    bondport_s **tqe_prev;
  } po_port_list;
  ifbond_ref po_bond;
  multicast_list po_multicast;
  ifnet *po_ifp;
  ether_addr po_saved_addr;
  int po_enabled;
  char po_name[16];
  ifdevmtu po_devmtu;
  uint32_t po_control_flags;
  interface_filter_t po_filter;
  struct
  {
    bondport_s *tqe_next;
    bondport_s **tqe_prev;
  } po_lag_port_list;
  devtimer_ref po_current_while_timer;
  devtimer_ref po_periodic_timer;
  devtimer_ref po_wait_while_timer;
  devtimer_ref po_transmit_timer;
  partner_state po_partner_state;
  lacp_port_priority po_priority;
  lacp_actor_partner_state po_actor_state;
  u_char po_flags;
  u_char po_periodic_interval;
  u_char po_n_transmit;
  ReceiveState po_receive_state;
  MuxState po_mux_state;
  SelectedState po_selected;
  int32_t po_last_transmit_secs;
  media_info po_media_info;
  uint64_t po_force_link_event_time;
  LAG_ref po_lag;
};

/* 4955 */
struct port_list
{
  bondport_s *tqh_first;
  bondport_s **tqh_last;
};

/* 4954 */
struct lag_list
{
  LAG_s *tqh_first;
  LAG_s **tqh_last;
};

/* 4956 */
struct ifbond_s
{
  struct
  {
    ifbond_s *tqe_next;
    ifbond_s **tqe_prev;
  } ifb_bond_list;
  int ifb_flags;
  os_refcnt ifb_retain_count;
  char ifb_name[16];
  ifnet *ifb_ifp;
  bpf_packet_func_0 ifb_bpf_input;
  bpf_packet_func_0 ifb_bpf_output;
  int ifb_altmtu;
  port_list ifb_port_list;
  short ifb_port_count;
  lag_list ifb_lag_list;
  lacp_key ifb_key;
  short ifb_max_active;
  LAG_ref ifb_active_lag;
  ifmultiaddr *ifb_ifma_slow_proto;
  bondport_ref *ifb_distributing_array;
  int ifb_distributing_count;
  int ifb_distributing_max;
  int ifb_last_link_event;
  int ifb_mode;
};

/* 4944 */
struct multicast_entry
{
  struct
  {
    multicast_entry *sle_next;
  } mc_entries;
  ifmultiaddr_t mc_ifma;
};

/* 4936 */
struct __attribute__((aligned(8))) LAG_s
{
  struct
  {
    LAG_s *tqe_next;
    LAG_s **tqe_prev;
  } lag_list;
  port_list lag_port_list;
  short lag_port_count;
  short lag_selected_port_count;
  int lag_active_media;
  LAG_info lag_info;
};

/* 4957 */
struct ifbond_list
{
  ifbond_s *tqh_first;
  ifbond_s **tqh_last;
};

/* 4958 */
struct bond_globals_s
{
  ifbond_list ifbond_list;
  lacp_system system;
  lacp_system_priority system_priority;
};

/* 4959 */
struct if_fake_media
{
  int32_t iffm_current;
  uint32_t iffm_count;
  uint32_t iffm_reserved[3];
  int32_t iffm_list[27];
};

/* 4960 */
struct kern_nexus_capab_qset_extensions
{
  uint32_t cqe_version;
  void *cqe_prov_ctx;
  kern_nexus_capab_qsext_notify_steering_info_fn_t cqe_notify_steering_info;
};

/* 4962 */
typedef errno_t (*kern_nexus_capab_interface_advisory_notify_fn_t)(void *, const ifnet_interface_advisory *);

/* 4961 */
struct kern_nexus_capab_interface_advisory
{
  uint32_t kncia_version;
  void *const kncia_kern_context;
  void *kncia_provider_context;
  const kern_nexus_capab_interface_advisory_notify_fn_t kncia_notify;
  kern_nexus_capab_interface_advisory_config_fn_t kncia_config;
};

/* 4963 */
struct fake_nx
{
  uuid_t_1 fnx_provider;
  uuid_t_1 fnx_instance;
};

/* 4964 */
typedef uint16_t iff_flags_t;

/* 8080 */
enum iff_pktpool_mode_t : __int32
{
  IFF_PP_MODE_GLOBAL = 0x0,
  IFF_PP_MODE_PRIVATE = 0x1,
  IFF_PP_MODE_PRIVATE_SPLIT = 0x2,
};

/* 8079 */
enum iff_tx_completion_mode_t : __int32
{
  IFF_TX_COMPL_MODE_SYNC = 0x0,
  IFF_TX_COMPL_MODE_ASYNC = 0x1,
};

/* 4965 */
struct if_fake
{
  char iff_name[16];
  ifnet_t iff_ifp;
  iff_flags_t iff_flags;
  uint32_t iff_retain_count;
  ifnet_t iff_peer;
  int iff_media_current;
  int iff_media_active;
  uint32_t iff_media_count;
  int iff_media_list[27];
  mbuf *iff_pending_tx_packet;
  boolean_t iff_start_busy;
  unsigned int iff_max_mtu;
  uint32_t iff_fcs;
  uint32_t iff_trailer_length;
  fake_nx iff_nx;
  netif_stats *iff_nifs;
  uint32_t iff_nifs_ref;
  uint32_t iff_llink_cnt;
  kern_channel_ring_t iff_rx_ring[1];
  kern_channel_ring_t iff_tx_ring[4];
  fake_llink *iff_llink;
  thread_call_t iff_doorbell_tcall;
  thread_call_t iff_if_adv_tcall;
  boolean_t iff_doorbell_tcall_active;
  boolean_t iff_waiting_for_tcall;
  boolean_t iff_channel_connected;
  iff_pktpool_mode_t iff_pp_mode;
  kern_pbufpool_t iff_rx_pp;
  kern_pbufpool_t iff_tx_pp;
  uint32_t iff_tx_headroom;
  unsigned int iff_adv_interval;
  uint32_t iff_tx_drop_rate;
  uint32_t iff_tx_pkts_count;
  iff_tx_completion_mode_t iff_tx_completion_mode;
  bool iff_intf_adv_enabled;
  void *iff_intf_adv_kern_ctx;
  kern_nexus_capab_interface_advisory_notify_fn_t iff_intf_adv_notify;
};

/* 4966 */
struct fake_queue
{
  kern_netif_queue_t fq_queue;
};

/* 4967 */
struct __attribute__((aligned(8))) fake_qset
{
  kern_netif_qset_t fqs_qset;
  fake_queue fqs_rx_queue[1];
  fake_queue fqs_tx_queue[4];
  uint32_t fqs_rx_queue_cnt;
  uint32_t fqs_tx_queue_cnt;
  uint32_t fqs_llink_idx;
  uint32_t fqs_idx;
  uint32_t fqs_dequeue_cnt;
  uint64_t fqs_id;
  boolean_t fqs_combined_mode;
};

/* 4968 */
struct fake_llink
{
  uint64_t fl_id;
  uint32_t fl_idx;
  uint32_t fl_qset_cnt;
  fake_qset fl_qset[16];
};

/* 4969 */
typedef ifvlan *ifvlan_ref;

/* 4972 */
struct ifvlan_entry
{
  ifvlan *le_next;
  ifvlan **le_prev;
};

/* 4971 */
typedef vlan_parent *vlan_parent_ref;

/* 4970 */
struct ifv_linkmib
{
  u_int16_t ifvm_encaplen;
  u_int16_t ifvm_mtufudge;
  u_int16_t ifvm_proto;
  u_int16_t ifvm_tag;
};

/* 4973 */
struct __attribute__((aligned(8))) ifvlan
{
  ifvlan_entry ifv_vlan_list;
  char ifv_name[16];
  ifnet *ifv_ifp;
  vlan_parent_ref ifv_vlp;
  ifv_linkmib ifv_mib;
  multicast_list ifv_multicast;
  u_int32_t ifv_flags;
  int32_t ifv_retain_count;
  u_int32_t ifv_signature;
};

/* 4975 */
struct vlan_parent_entry
{
  vlan_parent *le_next;
  vlan_parent **le_prev;
};

/* 4974 */
struct ifvlan_list
{
  ifvlan *lh_first;
};

/* 4976 */
struct __attribute__((aligned(8))) vlan_parent
{
  vlan_parent_entry vlp_parent_list;
  ifnet *vlp_ifp;
  ifvlan_list vlp_vlan_list;
  u_int32_t vlp_flags;
  u_int32_t vlp_event_code;
  ifdevmtu vlp_devmtu;
  int32_t vlp_retain_count;
  u_int32_t vlp_signature;
};

/* 4977 */
struct vlan_parent_list
{
  vlan_parent *lh_first;
};

/* 4978 */
struct vlan_globals_s
{
  vlan_parent_list parent_list;
};

/* 4979 */
struct if_packet_stats
{
  u_int64_t ifi_tcp_badformat;
  u_int64_t ifi_tcp_unspecv6;
  u_int64_t ifi_tcp_synfin;
  u_int64_t ifi_tcp_badformatipsec;
  u_int64_t ifi_tcp_noconnnolist;
  u_int64_t ifi_tcp_noconnlist;
  u_int64_t ifi_tcp_listbadsyn;
  u_int64_t ifi_tcp_icmp6unreach;
  u_int64_t ifi_tcp_deprecate6;
  u_int64_t ifi_tcp_rstinsynrcv;
  u_int64_t ifi_tcp_ooopacket;
  u_int64_t ifi_tcp_dospacket;
  u_int64_t ifi_tcp_cleanup;
  u_int64_t ifi_tcp_synwindow;
  u_int64_t reserved[6];
  u_int64_t ifi_udp_port_unreach;
  u_int64_t ifi_udp_faithprefix;
  u_int64_t ifi_udp_port0;
  u_int64_t ifi_udp_badlength;
  u_int64_t ifi_udp_badchksum;
  u_int64_t ifi_udp_badmcast;
  u_int64_t ifi_udp_cleanup;
  u_int64_t ifi_udp_badipsec;
  u_int64_t _reserved[4];
};

/* 4980 */
struct if_data_extended
{
  u_int64_t ifi_alignerrs;
  u_int64_t ifi_dt_bytes;
  u_int64_t ifi_fpackets;
  u_int64_t ifi_fbytes;
  u_int64_t reserved[12];
};

/* 4981 */
struct ifmibdata_supplemental
{
  if_traffic_class ifmd_traffic_class;
  if_data_extended ifmd_data_extended;
  if_packet_stats ifmd_packet_stats;
  if_rxpoll_stats ifmd_rxpoll_stats;
  if_netif_stats ifmd_netif_stats;
};

/* 4982 */
typedef errno_t (*proto_media_input_v2)(ifnet_t, protocol_family_t, mbuf_t);

/* 4983 */
struct loopback_header
{
  protocol_family_t protocol;
};

/* 4984 */
struct lo_statics_str
{
  int bpf_mode;
  bpf_packet_func_0 bpf_callback;
};

/* 4985 */
struct arphdr
{
  u_short ar_hrd;
  u_short ar_pro;
  u_char ar_hln;
  u_char ar_pln;
  u_short ar_op;
};

/* 4986 */
struct ether_arp
{
  arphdr ea_hdr;
  u_char arp_sha[6];
  u_char arp_spa[4];
  u_char arp_tha[6];
  u_char arp_tpa[4];
};

/* 4987 */
struct sockaddr_inarp
{
  u_char sin_len;
  u_char sin_family;
  u_short sin_port;
  in_addr sin_addr;
  in_addr sin_srcaddr;
  u_short sin_tos;
  u_short sin_other;
};

/* 4988 */
struct en_desc
{
  u_int16_t type;
  u_int32_t protocol_family;
  u_int32_t data[2];
};

/* 4989 */
struct ether_desc_blk_str
{
  u_int32_t n_max_used;
  u_int32_t n_count;
  u_int32_t n_used;
  en_desc block_ptr[1];
};

/* 4990 */
typedef int32_t ifnet_log_subcategory_t;

/* 4991 */
typedef int32_t ifnet_log_category_t;

/* 4992 */
typedef u_int32_t ifnet_log_flags_t;

/* 4993 */
typedef int32_t ifnet_log_level_t;

/* 4994 */
struct ifnet_attach_proto_param_v2
{
  ifnet_demux_desc *demux_array;
  u_int32_t demux_count;
  proto_media_input_v2_0 input;
  proto_media_preout_0 pre_output;
  proto_media_event_0 event;
  proto_media_ioctl_0 ioctl;
  proto_media_detached_0 detached;
  proto_media_resolve_multi_1 resolve;
  proto_media_send_arp send_arp;
};

/* 4995 */
struct ifnet_attach_proto_param
{
  ifnet_demux_desc *demux_array;
  u_int32_t demux_count;
  proto_media_input_0 input;
  proto_media_preout_0 pre_output;
  proto_media_event_0 event;
  proto_media_ioctl_0 ioctl;
  proto_media_detached_0 detached;
  proto_media_resolve_multi_1 resolve;
  proto_media_send_arp send_arp;
};

/* 4996 */
typedef struct *if_nexus_netif_t;

/* 4997 */
typedef struct *if_nexus_flowswitch_t;

/* 9886 */
struct route_in6_1
{
  rtentry *ro_rt;
  llentry *ro_lle;
  ifaddr *ro_srcia;
  uint32_t ro_flags;
  sockaddr_in6 ro_dst;
};

/* 9910 */
struct ifnet_4
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func if_output_dlil;
  volatile ifnet_start_func if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func if_input_ctl;
  ifnet_ioctl_func if_ioctl;
  ifnet_set_bpf_tap if_set_bpf_tap;
  ifnet_detached_func if_free;
  ifnet_demux_func if_demux;
  ifnet_event_func if_event;
  ifnet_framer_func_0 if_framer_legacy;
  ifnet_framer_extended_func if_framer;
  ifnet_add_proto_func if_add_proto;
  ifnet_del_proto_func if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route_0 if_fwd_route;
  route_0 if_src_route;
  route_in6_1 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 5003 */
struct dlil_ifnet
{
  ifnet_4 dl_if;
  lck_mtx_t dl_if_lock;
  struct
  {
    dlil_ifnet *tqe_next;
    dlil_ifnet **tqe_prev;
  } dl_if_link;
  u_int32_t dl_if_flags;
  u_int32_t dl_if_refcnt;
  void (*dl_if_trace)(dlil_ifnet *, int);
  void *dl_if_uniqueid;
  size_t dl_if_uniqueid_len;
  char dl_if_namestorage[16];
  char dl_if_xnamestorage[24];
  struct
  {
    ifaddr ifa;
    u_int8_t asdl[64];
    u_int8_t msdl[64];
  } dl_if_lladdr;
  u_int8_t dl_if_descstorage[128];
  u_int8_t dl_if_permanent_ether[6];
  u_int8_t dl_if_permanent_ether_is_set;
  u_int8_t dl_if_unused;
  dlil_threading_info dl_if_inpstorage;
  ctrace_t dl_if_attach;
  ctrace_t dl_if_detach;
};

/* 4998 */
struct dlil_ifnet_dbg
{
  dlil_ifnet dldbg_dlif;
  u_int16_t dldbg_if_refhold_cnt;
  u_int16_t dldbg_if_refrele_cnt;
  ctrace_t dldbg_if_refhold[8];
  ctrace_t dldbg_if_refrele[8];
};

/* 4999 */
struct ifnet_ioctl_event
{
  ifnet *ifp;
  u_long ioctl_code;
};

/* 5000 */
struct ifnet_ioctl_event_nwk_wq_entry
{
  nwk_wq_entry nwk_wqe;
  ifnet_ioctl_event ifnet_ioctl_ev_arg;
};

/* 5001 */
struct rxpoll_time_tbl
{
  u_int64_t speed;
  u_int32_t plowat;
  u_int32_t phiwat;
  u_int32_t blowat;
  u_int32_t bhiwat;
};

/* 5002 */
struct ifnet_fc_entry
{
  struct
  {
    ifnet_fc_entry *rbe_left;
    ifnet_fc_entry *rbe_right;
    ifnet_fc_entry *rbe_parent;
  } ifce_entry;
  u_int32_t ifce_flowhash;
  ifnet *ifce_ifp;
};

/* 5011 */
typedef void (*net_init_func_ptr)(void);

/* 5012 */
struct init_list_entry
{
  init_list_entry *next;
  net_init_func_ptr func;
};

/* 5013 */
struct if_agentidsreq64
{
  char ifar_name[16];
  u_int32_t ifar_count;
  user64_addr_t ifar_uuids;
};

/* 5014 */
struct if_agentidsreq32
{
  char ifar_name[16];
  u_int32_t ifar_count;
  user32_addr_t ifar_uuids;
};

/* 5015 */
enum intf_event_code_t : __int32
{
  INTF_EVENT_CODE_CREATED = 0x0,
  INTF_EVENT_CODE_REMOVED = 0x1,
  INTF_EVENT_CODE_STATUS_UPDATE = 0x2,
  INTF_EVENT_CODE_IPADDR_ATTACHED = 0x3,
  INTF_EVENT_CODE_IPADDR_DETACHED = 0x4,
  INTF_EVENT_CODE_LLADDR_UPDATE = 0x5,
  INTF_EVENT_CODE_MTU_CHANGED = 0x6,
  INTF_EVENT_CODE_LOW_POWER_UPDATE = 0x7,
};

/* 5016 */
typedef void (*ifnet_event_fn)(eventhandler_entry_arg, ifnet *, sockaddr *, intf_event_code_t);

/* 5017 */
struct eventhandler_entry_ifnet_event
{
  eventhandler_entry ee;
  ifnet_event_fn eh_func;
};

/* 5018 */
struct if_ipv6_address
{
  in6_addr_0 v6_address;
  uint32_t v6_prefixlen;
};

/* 5019 */
struct if_clat46req
{
  char ifclat46_name[16];
  if_ipv6_address ifclat46_addr;
};

/* 5020 */
struct if_nat64req
{
  char ifnat64_name[16];
  ipv6_prefix ifnat64_prefixes[4];
};

/* 5021 */
struct if_order
{
  u_int32_t ifo_count;
  u_int32_t ifo_reserved;
  mach_vm_address_t_0 ifo_ordered_indices;
};

/* 5022 */
struct osockaddr
{
  __uint16_t sa_family;
  char sa_data[14];
};

/* 5023 */
struct intf_event
{
  ifnet *ifp;
  sockaddr_in_4_6 addr;
  uint32_t intf_event_code;
};

/* 5024 */
struct intf_event_nwk_wq_entry
{
  nwk_wq_entry nwk_wqe;
  intf_event intf_ev_arg;
};

/* 5025 */
struct if_nexusreq
{
  char ifnr_name[16];
  uint64_t ifnr_flags;
  uuid_t_1 ifnr_netif;
  uuid_t_1 ifnr_flowswitch;
  uint64_t ifnr_reserved[5];
};

/* 5026 */
struct if_netidreq
{
  char ifnetid_name[16];
  u_int8_t ifnetid_len;
  u_int8_t ifnetid[32];
};

/* 5027 */
struct if_nsreq
{
  char ifnsr_name[16];
  u_int8_t ifnsr_family;
  u_int8_t ifnsr_len;
  u_int16_t ifnsr_flags;
  u_int8_t ifnsr_data[20];
};

/* 5028 */
struct if_agentidreq
{
  char ifar_name[16];
  uuid_t_1 ifar_uuid;
};

/* 5029 */
struct if_throttlereq
{
  char ifthr_name[16];
  u_int32_t ifthr_level;
};

/* 5030 */
struct __attribute__((aligned(8))) if_qstatsreq
{
  char ifqr_name[16];
  u_int32_t ifqr_grp_idx;
  u_int32_t ifqr_slot;
  void *ifqr_buf;
  int ifqr_len;
};

/* 5032 */
struct if_linkparamsreq
{
  char iflpr_name[16];
  u_int32_t iflpr_flags;
  u_int32_t iflpr_output_sched;
  u_int64_t iflpr_output_tbr_rate;
  u_int32_t iflpr_output_tbr_percent;
  u_int64_t iflpr_input_tbr_rate;
  if_bandwidths iflpr_output_bw;
  if_bandwidths iflpr_input_bw;
  if_latencies iflpr_output_lt;
  if_latencies iflpr_input_lt;
  if_netem_params iflpr_input_netem;
  if_netem_params iflpr_output_netem;
};

/* 5033 */
struct if_descreq
{
  char ifdr_name[16];
  u_int32_t ifdr_len;
  u_int8_t ifdr_desc[128];
};

/* 5034 */
struct ifstat
{
  char ifs_name[16];
  char ascii[801];
};

/* 5035 */
struct ifmultiaddr_dbg
{
  ifmultiaddr ifma;
  u_int16_t ifma_refhold_cnt;
  u_int16_t ifma_refrele_cnt;
  ctrace_t ifma_refhold[32];
  ctrace_t ifma_refrele[32];
  struct
  {
    ifmultiaddr_dbg *tqe_next;
    ifmultiaddr_dbg **tqe_prev;
  } ifma_trash_link;
};

/* 5036 */
struct ifbpstpconf32
{
  uint32_t ifbpstp_len;
  union
  {
    user32_addr_t ifbpstpu_buf;
    user32_addr_t ifbpstpu_req;
  } ifbpstp_ifbpstpu;
};

/* 5037 */
struct __attribute__((packed)) __attribute__((aligned(4))) ifbpstpconf64
{
  uint32_t ifbpstp_len;
  union
  {
    user64_addr_t ifbpstpu_buf;
    user64_addr_t ifbpstpu_req;
  } ifbpstp_ifbpstpu;
};

/* 5038 */
struct ifbrhostfilter
{
  uint32_t ifbrhf_flags;
  char ifbrhf_ifsname[16];
  uint8_t ifbrhf_hwsrca[6];
  uint32_t ifbrhf_ipsrc;
};

/* 5039 */
union ifbrip
{
  in_addr ifbrip_addr;
  in6_addr_0 ifbrip_addr6;
};

/* 5040 */
struct ifbrmnelist32
{
  uint32_t ifbml_len;
  uint16_t ifbml_elsize;
  uint16_t ifbml_pad;
  user32_addr_t ifbml_buf;
};

/* 5041 */
struct ifbrmnelist64
{
  uint32_t ifbml_len;
  uint16_t ifbml_elsize;
  uint16_t ifbml_pad;
  user64_addr_t ifbml_buf;
};

/* 5042 */
struct ifbrmreq64
{
  char brmr_ifname[16];
  uint32_t brmr_len;
  uint32_t brmr_elsize;
  user64_addr_t brmr_buf;
};

/* 5043 */
typedef struct *ip_packet_info_t;

/* 5046 */
union iphdr
{
  ip *ip;
  ip6_hdr *ip6;
  void *ptr;
};

/* 5044 */
struct __attribute__((aligned(8))) gso_ip_tcp_state
{
  void (*update)(gso_ip_tcp_state *, mbuf *);
  void (*internal)(gso_ip_tcp_state *, mbuf *);
  iphdr hdr;
  tcphdr *tcp;
  int mac_hlen;
  int ip_hlen;
  int tcp_hlen;
  int hlen;
  int pay_len;
  int sw_csum;
  uint32_t tcp_seq;
  uint16_t ip_id;
  boolean_t is_tx;
};

/* 5045 */
enum ChecksumOperation : __int32
{
  CHECKSUM_OPERATION_NONE = 0x0,
  CHECKSUM_OPERATION_CLEAR_OFFLOAD = 0x1,
  CHECKSUM_OPERATION_FINALIZE = 0x2,
  CHECKSUM_OPERATION_COMPUTE = 0x3,
};

/* 5047 */
struct mac_nat_record
{
  uint16_t mnr_ether_type;
  union
  {
    uint16_t mnru_arp_offset;
    struct __attribute__((aligned(2)))
    {
      uint16_t mnruip_dhcp_flags;
      uint16_t mnruip_udp_csum;
      uint8_t mnruip_header_len;
    } mnru_ip;
    struct
    {
      uint16_t mnruip6_icmp6_len;
      uint16_t mnruip6_lladdr_offset;
      uint8_t mnruip6_icmp6_type;
      uint8_t mnruip6_header_len;
    } mnru_ip6;
  } mnr_u;
};

/* 5048 */
struct ifbrmreq32
{
  char brmr_ifname[16];
  uint32_t brmr_len;
  uint32_t brmr_elsize;
  user32_addr_t brmr_buf;
};

/* 5050 */
struct llc
{
  u_int8_t llc_dsap;
  u_int8_t llc_ssap;
  union
  {
    struct
    {
      u_int8_t control;
      u_int8_t format_id;
      u_int8_t class_id;
      u_int8_t window_x2;
    } type_u;
    struct
    {
      u_int8_t num_snd_x2;
      u_int8_t num_rcv_x2;
    } type_i;
    struct
    {
      u_int8_t control;
      u_int8_t num_rcv_x2;
    } type_s;
    struct
    {
      u_int8_t control;
      u_int8_t frmr_rej_pdu0;
      u_int8_t frmr_rej_pdu1;
      u_int8_t frmr_control;
      u_int8_t frmr_control_ext;
      u_int8_t frmr_cause;
    } type_frmr;
    struct
    {
      u_int8_t control;
      u_int8_t org_code[3];
      u_int16_t ether_type;
    } type_snap;
    struct
    {
      u_int8_t control;
      u_int8_t control_ext;
    } type_raw;
  } llc_un;
};

/* 5051 */
struct bridge_control
{
  int (*bc_func)(bridge_softc *, void *);
  unsigned int bc_argsize;
  unsigned int bc_flags;
};

/* 5079 */
struct _bridge_rtnode_list
{
  bridge_rtnode *lh_first;
};

/* 5063 */
typedef void (*bridge_delayed_func_t)(bridge_softc *);

/* 5110 */
struct bridge_delayed_call
{
  bridge_softc *bdc_sc;
  bridge_delayed_func_t bdc_func;
  timespec bdc_ts;
  u_int32_t bdc_flags;
  thread_call_t bdc_thread_call;
};

/* 5070 */
struct __attribute__((aligned(8))) bstp_pri_vector
{
  uint64_t pv_root_id;
  uint32_t pv_cost;
  uint64_t pv_dbridge_id;
  uint16_t pv_dport_id;
  uint16_t pv_port_id;
};

/* 5069 */
struct bstp_timer
{
  int active;
  int latched;
  int value;
};

/* 5068 */
typedef void (*bstp_state_cb_t)(ifnet *, int);

/* 5067 */
typedef void (*bstp_rtage_cb_t)(ifnet *, int);

/* 5071 */
struct bstp_state
{
  struct
  {
    bstp_state *le_next;
    bstp_state **le_prev;
  } bs_list;
  uint8_t bs_running;
  lck_mtx_t bs_mtx;
  bstp_pri_vector bs_bridge_pv;
  bstp_pri_vector bs_root_pv;
  bstp_port *bs_root_port;
  uint8_t bs_protover;
  uint16_t bs_migration_delay;
  uint16_t bs_edge_delay;
  uint16_t bs_bridge_max_age;
  uint16_t bs_bridge_fdelay;
  uint16_t bs_bridge_htime;
  uint16_t bs_root_msg_age;
  uint16_t bs_root_max_age;
  uint16_t bs_root_fdelay;
  uint16_t bs_root_htime;
  uint16_t bs_hold_time;
  uint16_t bs_bridge_priority;
  uint8_t bs_txholdcount;
  uint8_t bs_allsynced;
  bstp_timer bs_link_timer;
  timeval bs_last_tc_time;
  struct
  {
    bstp_port *lh_first;
  } bs_bplist;
  bstp_state_cb_t bs_state_cb;
  bstp_rtage_cb_t bs_rtage_cb;
};

/* 5109 */
struct mac_nat_entry_list
{
  mac_nat_entry *lh_first;
};

/* 5111 */
struct __attribute__((aligned(8))) bridge_softc
{
  ifnet *sc_ifp;
  u_int32_t sc_flags;
  struct
  {
    bridge_softc *le_next;
    bridge_softc **le_prev;
  } sc_list;
  lck_mtx_t sc_mtx;
  _bridge_rtnode_list *sc_rthash;
  _bridge_rtnode_list sc_rtlist;
  uint32_t sc_rthash_key;
  uint32_t sc_rthash_size;
  bridge_delayed_call sc_aging_timer;
  bridge_delayed_call sc_resize_call;
  struct
  {
    bridge_iflist *tqh_first;
    bridge_iflist **tqh_last;
  } sc_spanlist;
  bstp_state sc_stp;
  bpf_packet_func_0 sc_bpf_input;
  bpf_packet_func_0 sc_bpf_output;
  void *sc_cv;
  uint32_t sc_brtmax;
  uint32_t sc_brtcnt;
  uint32_t sc_brttimeout;
  uint32_t sc_iflist_ref;
  uint32_t sc_iflist_xcnt;
  struct
  {
    bridge_iflist *tqh_first;
    bridge_iflist **tqh_last;
  } sc_iflist;
  uint32_t sc_brtexceeded;
  uint32_t sc_filter_flags;
  ifnet *sc_ifaddr;
  u_char sc_defaddr[6];
  char sc_if_xname[16];
  bridge_iflist *sc_mac_nat_bif;
  mac_nat_entry_list sc_mne_list;
  mac_nat_entry_list sc_mne_list_v6;
  uint32_t sc_mne_max;
  uint32_t sc_mne_count;
  uint32_t sc_mne_allocation_failures;
  void *lock_lr[4];
  int next_lock_lr;
  void *unlock_lr[4];
  int next_unlock_lr;
};

/* 5078 */
struct __attribute__((aligned(8))) bridge_rtnode
{
  struct
  {
    bridge_rtnode *le_next;
    bridge_rtnode **le_prev;
  } brt_hash;
  struct
  {
    bridge_rtnode *le_next;
    bridge_rtnode **le_prev;
  } brt_list;
  bridge_iflist *brt_dst;
  unsigned __int64 brt_expire;
  uint8_t brt_flags;
  uint8_t brt_addr[6];
  uint16_t brt_vlan;
};

/* 5073 */
struct bstp_config_unit
{
  bstp_pri_vector cu_pv;
  uint16_t cu_message_age;
  uint16_t cu_max_age;
  uint16_t cu_forward_delay;
  uint16_t cu_hello_time;
  uint8_t cu_message_type;
  uint8_t cu_topology_change_ack;
  uint8_t cu_topology_change;
  uint8_t cu_proposal;
  uint8_t cu_agree;
  uint8_t cu_learning;
  uint8_t cu_forwarding;
  uint8_t cu_role;
};

/* 5066 */
typedef void bstp_task_func_t(void *, int);

/* 5072 */
struct bstp_task
{
  struct
  {
    bstp_task *tqe_next;
    bstp_task **tqe_prev;
  } bt_next;
  int bt_count;
  bstp_task_func_t *bt_func;
  void *bt_context;
};

/* 5076 */
struct __attribute__((aligned(8))) bstp_port
{
  struct
  {
    bstp_port *le_next;
    bstp_port **le_prev;
  } bp_next;
  ifnet *bp_ifp;
  bstp_state *bp_bs;
  uint8_t bp_active;
  uint8_t bp_protover;
  uint32_t bp_flags;
  uint32_t bp_path_cost;
  uint16_t bp_port_msg_age;
  uint16_t bp_port_max_age;
  uint16_t bp_port_fdelay;
  uint16_t bp_port_htime;
  uint16_t bp_desg_msg_age;
  uint16_t bp_desg_max_age;
  uint16_t bp_desg_fdelay;
  uint16_t bp_desg_htime;
  bstp_timer bp_edge_delay_timer;
  bstp_timer bp_forward_delay_timer;
  bstp_timer bp_hello_timer;
  bstp_timer bp_message_age_timer;
  bstp_timer bp_migrate_delay_timer;
  bstp_timer bp_recent_backup_timer;
  bstp_timer bp_recent_root_timer;
  bstp_timer bp_tc_timer;
  bstp_config_unit bp_msg_cu;
  bstp_pri_vector bp_desg_pv;
  bstp_pri_vector bp_port_pv;
  uint16_t bp_port_id;
  uint8_t bp_state;
  uint8_t bp_tcstate;
  uint8_t bp_role;
  uint8_t bp_infois;
  uint8_t bp_tc_ack;
  uint8_t bp_tc_prop;
  uint8_t bp_fdbflush;
  uint8_t bp_priority;
  uint8_t bp_ptp_link;
  uint8_t bp_agree;
  uint8_t bp_agreed;
  uint8_t bp_sync;
  uint8_t bp_synced;
  uint8_t bp_proposing;
  uint8_t bp_proposed;
  uint8_t bp_operedge;
  uint8_t bp_reroot;
  uint8_t bp_rcvdtc;
  uint8_t bp_rcvdtca;
  uint8_t bp_rcvdtcn;
  uint32_t bp_forward_transitions;
  uint8_t bp_txcount;
  bstp_task bp_statetask;
  bstp_task bp_rtagetask;
  uint32_t bp_if_link_state;
};

/* 5065 */
struct bripstats
{
  uint64_t bips_ip;
  uint64_t bips_ip6;
  uint64_t bips_udp;
  uint64_t bips_tcp;
  uint64_t bips_bad_ip;
  uint64_t bips_bad_ip6;
  uint64_t bips_bad_udp;
  uint64_t bips_bad_tcp;
};

/* 5064 */
struct brcsumstats
{
  uint64_t brcs_ip_checksum;
  uint64_t brcs_udp_checksum;
  uint64_t brcs_tcp_checksum;
};

/* 5074 */
struct ifbrmstats
{
  bripstats brms_in_ip;
  bripstats brms_out_ip;
  brcsumstats brms_in_computed_cksum;
  brcsumstats brms_out_cksum_good;
  brcsumstats brms_out_cksum_good_hw;
  brcsumstats brms_out_cksum_bad;
  brcsumstats brms_out_cksum_bad_hw;
};

/* 5077 */
struct bridge_iflist
{
  struct
  {
    bridge_iflist *tqe_next;
    bridge_iflist **tqe_prev;
  } bif_next;
  ifnet *bif_ifp;
  bstp_port bif_stp;
  uint32_t bif_ifflags;
  int bif_savedcaps;
  uint32_t bif_addrmax;
  uint32_t bif_addrcnt;
  uint32_t bif_addrexceeded;
  interface_filter_t bif_iff_ref;
  bridge_softc *bif_sc;
  uint32_t bif_flags;
  in_addr bif_hf_ipsrc;
  uint8_t bif_hf_hwsrc[6];
  ifbrmstats bif_stats;
};

/* 5062 */
struct mac_nat_entry
{
  struct
  {
    mac_nat_entry *le_next;
    mac_nat_entry **le_prev;
  } mne_list;
  bridge_iflist *mne_bif;
  unsigned __int64 mne_expire;
  union
  {
    in_addr mneu_ip;
    in6_addr_0 mneu_ip6;
  } mne_u;
  uint8_t mne_mac[6];
  uint8_t mne_flags;
  uint8_t mne_reserved;
};

/* 5052 */
struct ifbropreq64
{
  uint8_t ifbop_holdcount;
  uint8_t ifbop_maxage;
  uint8_t ifbop_hellotime;
  uint8_t ifbop_fwddelay;
  uint8_t ifbop_protocol;
  uint16_t ifbop_priority;
  uint16_t ifbop_root_port;
  uint32_t ifbop_root_path_cost;
  uint64_t ifbop_bridgeid;
  uint64_t ifbop_designated_root;
  uint64_t ifbop_designated_bridge;
  timeval64 ifbop_last_tc_time;
};

/* 5053 */
struct ifbrparam
{
  union
  {
    uint32_t ifbrpu_int32;
    uint16_t ifbrpu_int16;
    uint8_t ifbrpu_int8;
  } ifbrp_ifbrpu;
};

/* 5054 */
struct __attribute__((packed)) __attribute__((aligned(4))) ifbaconf64
{
  uint32_t ifbac_len;
  union
  {
    user64_addr_t ifbacu_buf;
    user64_addr_t ifbacu_req;
  } ifbac_ifbacu;
};

/* 5055 */
struct __attribute__((packed)) __attribute__((aligned(4))) ifbareq64
{
  char ifba_ifsname[16];
  uint64_t ifba_expire;
  uint8_t ifba_flags;
  uint8_t ifba_dst[6];
  __attribute__((aligned(2))) uint16_t ifba_vlan;
};

/* 5056 */
struct __attribute__((packed)) __attribute__((aligned(4))) ifbifconf64
{
  uint32_t ifbic_len;
  union
  {
    user64_addr_t ifbicu_buf;
    user64_addr_t ifbicu_req;
  } ifbic_ifbicu;
};

/* 5057 */
struct ifbreq
{
  char ifbr_ifsname[16];
  uint32_t ifbr_ifsflags;
  uint32_t ifbr_stpflags;
  uint32_t ifbr_path_cost;
  uint8_t ifbr_portno;
  uint8_t ifbr_priority;
  uint8_t ifbr_proto;
  uint8_t ifbr_role;
  uint8_t ifbr_state;
  uint32_t ifbr_addrcnt;
  uint32_t ifbr_addrmax;
  uint32_t ifbr_addrexceeded;
  uint8_t pad[32];
};

/* 5058 */
struct ifbropreq32
{
  uint8_t ifbop_holdcount;
  uint8_t ifbop_maxage;
  uint8_t ifbop_hellotime;
  uint8_t ifbop_fwddelay;
  uint8_t ifbop_protocol;
  uint16_t ifbop_priority;
  uint16_t ifbop_root_port;
  uint32_t ifbop_root_path_cost;
  uint64_t ifbop_bridgeid;
  uint64_t ifbop_designated_root;
  uint64_t ifbop_designated_bridge;
  timeval32 ifbop_last_tc_time;
};

/* 5059 */
struct ifbaconf32
{
  uint32_t ifbac_len;
  union
  {
    user32_addr_t ifbacu_buf;
    user32_addr_t ifbacu_req;
  } ifbac_ifbacu;
};

/* 5060 */
struct __attribute__((aligned(4))) ifbareq32
{
  char ifba_ifsname[16];
  uint32_t ifba_expire;
  uint8_t ifba_flags;
  uint8_t ifba_dst[6];
  uint16_t ifba_vlan;
};

/* 5061 */
struct ifbifconf32
{
  uint32_t ifbic_len;
  union
  {
    user32_addr_t ifbicu_buf;
    user32_addr_t ifbicu_req;
  } ifbic_ifbicu;
};

/* 5115 */
struct xbpf_d
{
  uint32_t bd_structsize;
  int32_t bd_dev_minor;
  int32_t bd_sig;
  uint32_t bd_slen;
  uint32_t bd_hlen;
  uint32_t bd_bufsize;
  pid_t bd_pid;
  uint8_t bd_promisc;
  uint8_t bd_immediate;
  uint8_t bd_hdrcmplt;
  uint8_t bd_async;
  uint8_t bd_headdrop;
  uint8_t bd_seesent;
  uint8_t bh_compreq;
  uint8_t bh_compenabled;
  uint8_t bd_exthdr;
  uint8_t bd_trunc;
  uint8_t bd_pkthdrv2;
  uint8_t bd_pad;
  uint64_t bd_rcount;
  uint64_t bd_dcount;
  uint64_t bd_fcount;
  uint64_t bd_wcount;
  uint64_t bd_wdcount;
  char bd_ifname[16];
  uint64_t bd_comp_count;
  uint64_t bd_comp_size;
  uint32_t bd_scnt;
  uint32_t bd_hcnt;
  uint64_t bd_read_count;
  uint64_t bd_fsize;
};

/* 5116 */
struct bpf_comp_hdr
{
  timeval32 bh_tstamp;
  bpf_u_int32 bh_caplen;
  bpf_u_int32 bh_datalen;
  u_short bh_hdrlen;
  u_char bh_complen;
  u_char bh_padding;
};

/* 5117 */
struct __attribute__((aligned(4))) bpf_hdr
{
  timeval32 bh_tstamp;
  bpf_u_int32 bh_caplen;
  bpf_u_int32 bh_datalen;
  u_short bh_hdrlen;
};

/* 5118 */
struct bpf_hdr_ext
{
  timeval32 bh_tstamp;
  bpf_u_int32 bh_caplen;
  bpf_u_int32 bh_datalen;
  u_short bh_hdrlen;
  u_char bh_complen;
  u_char bh_flags;
  pid_t bh_pid;
  char bh_comm[17];
  u_char bh_pktflags;
  uint16_t bh_trace_tag;
  bpf_u_int32 bh_svc;
  bpf_u_int32 bh_flowid;
  bpf_u_int32 bh_unsent_bytes;
  bpf_u_int32 bh_unsent_snd;
};

/* 5155 */
struct decmpfs_cnode
{
  uint8_t cmp_state;
  uint8_t cmp_minimal_xattr;
  uint32_t cmp_type;
  uint32_t lockcount;
  void *lockowner;
  uint64_t uncompressed_size;
  uint64_t nchildren;
  uint64_t total_size;
  uint64_t decompression_flags;
  lck_rw_t compressed_data_lock;
};

/* 5156 */
struct decmpfs_vector
{
  void *buf;
  user_ssize_t size;
};

/* 5157 */
struct decmpfs_raw_item_size
{
  uint64_t value;
};

/* 5158 */
struct __attribute__((packed)) __attribute__((aligned(4))) decmpfs_header
{
  uint32_t attr_size;
  uint32_t compression_magic;
  uint32_t compression_type;
  union
  {
    uint64_t uncompressed_size;
    decmpfs_raw_item_size _size;
  };
  unsigned __int8 attr_bytes[];
};

/* 5159 */
typedef uint64_t (*decmpfs_get_decompression_flags_func)(vnode_t, vfs_context_t, decmpfs_header *);

/* 5160 */
typedef int (*decmpfs_free_compressed_data_func)(vnode_t, vfs_context_t, decmpfs_header *);

/* 5161 */
typedef int (*decmpfs_fetch_uncompressed_data_func)(vnode_t, vfs_context_t, decmpfs_header *, off_t, user_ssize_t, int, decmpfs_vector *, uint64_t *);

/* 5162 */
typedef void (*decmpfs_adjust_fetch_region_func)(vnode_t, vfs_context_t, decmpfs_header *, off_t *, user_ssize_t *);

/* 5163 */
typedef int (*decmpfs_validate_compressed_file_func)(vnode_t, vfs_context_t, decmpfs_header *);

/* 5164 */
struct decmpfs_registration
{
  int decmpfs_registration;
  decmpfs_validate_compressed_file_func validate;
  decmpfs_adjust_fetch_region_func adjust_fetch;
  decmpfs_fetch_uncompressed_data_func fetch;
  decmpfs_free_compressed_data_func free_data;
  decmpfs_get_decompression_flags_func get_flags;
};

/* 5165 */
struct vnop_mknod_args
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t *a_vpp;
  componentname *a_cnp;
  vnode_attr *a_vap;
  vfs_context_t a_context;
};

/* 5166 */
struct vnop_setattr_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  vnode_attr *a_vap;
  vfs_context_t a_context;
};

/* 5167 */
struct vnop_write_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  uio *a_uio;
  int a_ioflag;
  vfs_context_t a_context;
};

/* 5168 */
struct vnop_link_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  vnode_t a_tdvp;
  componentname *a_cnp;
  vfs_context_t a_context;
};

/* 5169 */
struct vnop_rename_args
{
  vnodeop_desc *a_desc;
  vnode_t a_fdvp;
  vnode_t a_fvp;
  componentname *a_fcnp;
  vnode_t a_tdvp;
  vnode_t a_tvp;
  componentname *a_tcnp;
  vfs_context_t a_context;
};

/* 5170 */
struct vnop_mkdir_args
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t *a_vpp;
  componentname *a_cnp;
  vnode_attr *a_vap;
  vfs_context_t a_context;
};

/* 5171 */
struct vnop_rmdir_args
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t a_vp;
  componentname *a_cnp;
  vfs_context_t a_context;
};

/* 5172 */
struct vnop_symlink_args
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t *a_vpp;
  componentname *a_cnp;
  vnode_attr *a_vap;
  char *a_target;
  vfs_context_t a_context;
};

/* 5173 */
struct vnop_setlabel_args
{
  vnodeop_desc *a_desc;
  vnode *a_vp;
  label *a_vl;
  vfs_context_t a_context;
};

/* 8096 */
typedef devfs_vnode_event *devfs_vnode_event_t;

/* 5174 */
struct devfs_event_log
{
  size_t del_max;
  size_t del_used;
  devfs_vnode_event_t del_entries;
};

/* 5176 */
struct devfs_vnode_event
{
  vnode_t dve_vp;
  uint32_t dve_vid;
  uint32_t dve_events;
};

/* 5175 */
typedef devfs_event_log *devfs_event_log_t;

/* 5177 */
struct __throttle_info_handle;

/* 5178 */
typedef struct __throttle_info_handle *throttle_info_handle_t;

/* 5179 */
struct vnop_ioctl_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  u_long a_command;
  caddr_t a_data;
  int a_fflag;
  vfs_context_t a_context;
};

/* 5180 */
struct vnop_select_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  int a_which;
  int a_fflags;
  void *a_wql;
  vfs_context_t a_context;
};

/* 5181 */
struct vnop_strategy_args
{
  vnodeop_desc *a_desc;
  buf *a_bp;
};

/* 5182 */
struct vnop_blktooff_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  daddr64_t a_lblkno;
  off_t *a_offset;
};

/* 5183 */
struct vnop_offtoblk_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  off_t a_offset;
  daddr64_t *a_lblkno;
};

/* 5184 */
struct vnop_blockmap_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  off_t a_foffset;
  size_t a_size;
  daddr64_t *a_bpn;
  size_t *a_run;
  void *a_poff;
  int a_flags;
  vfs_context_t a_context;
};

/* 5185 */
struct __attribute__((aligned(8))) _throttle_io_info_t
{
  lck_mtx_t throttle_lock;
  timeval throttle_last_write_timestamp;
  timeval throttle_min_timer_deadline;
  timeval throttle_window_start_timestamp[4];
  timeval throttle_last_IO_timestamp[4];
  pid_t throttle_last_IO_pid[4];
  timeval throttle_start_IO_period_timestamp[4];
  int32_t throttle_inflight_count[4];
  struct {uthread *tqh_first;uthread **tqh_last;}; throttle_uthlist[4];
  int throttle_next_wake_level;
  thread_call_t throttle_timer_call;
  int32_t throttle_timer_ref;
  int32_t throttle_timer_active;
  int32_t throttle_io_count;
  int32_t throttle_io_count_begin;
  int *throttle_io_periods;
  uint32_t throttle_io_period_num;
  int32_t throttle_refcnt;
  int32_t throttle_alloc;
  int32_t throttle_disabled;
  int32_t throttle_is_fusion_with_priority;
};

/* 5186 */
struct fdhashhead
{
  fdescnode *lh_first;
};

/* 5187 */
struct vnop_bwrite_args
{
  vnodeop_desc *a_desc;
  buf_t a_bp;
};

/* 5188 */
struct disk_conditioner_info
{
  int enabled;
  uint64_t access_time_usec;
  uint64_t read_throughput_mbps;
  uint64_t write_throughput_mbps;
  int is_ssd;
  uint32_t ioqueue_depth;
  uint32_t maxreadcnt;
  uint32_t maxwritecnt;
  uint32_t segreadcnt;
  uint32_t segwritecnt;
};

/* 5189 */
struct saved_mount_fields
{
  uint32_t mnt_maxreadcnt;
  uint32_t mnt_maxwritecnt;
  uint32_t mnt_segreadcnt;
  uint32_t mnt_segwritecnt;
  uint32_t mnt_ioqueue_depth;
  uint32_t mnt_ioscale;
};

/* 5190 */
struct _disk_conditioner_info_t
{
  disk_conditioner_info dcinfo;
  saved_mount_fields mnt_fields;
  daddr64_t last_blkno;
  timeval last_io_timestamp;
};

/* 5191 */
typedef int cp_key_store_action_t;

/* 5192 */
typedef unsigned __int8 cp_ep_state_t;

/* 5193 */
typedef unsigned __int8 cp_lock_state_t;

/* 5194 */
typedef unsigned __int8 cp_vfs_callback_arg_type_t;

/* 5195 */
struct cp_vfs_callback_arg
{
  cp_vfs_callback_arg_type_t type;
  union
  {
    cp_lock_state_t lock_state;
    cp_ep_state_t ep_state;
  };
  int valid_uuid;
  uuid_t_1 volume_uuid;
};

/* 5198 */
struct __attribute__((packed)) __attribute__((aligned(4))) fsevent_dev_filter_args64
{
  uint32_t num_devices;
  user64_addr_t devices;
};

/* 5199 */
struct fsevent_dev_filter_args32
{
  uint32_t num_devices;
  user32_addr_t devices;
};

/* 5200 */
struct fsevent_clone_args64
{
  user64_addr_t event_list;
  int32_t num_events;
  int32_t event_queue_depth;
  user64_addr_t fd;
};

/* 5201 */
struct fsevent_clone_args32
{
  user32_addr_t event_list;
  int32_t num_events;
  int32_t event_queue_depth;
  user32_addr_t fd;
};

/* 5202 */
struct fse_info
{
  ino64_t ino;
  dev_t dev;
  int32_t mode;
  uid_t uid;
  gid_t gid;
  uint64_t nlink;
};

/* 5204 */
struct fsevent_handle
{
  UInt32 flags;
  SInt32 active;
  fs_event_watcher *watcher;
  klist knotes;
  selinfo si;
};

/* 5205 */
struct __attribute__((aligned(4))) fs_event_watcher
{
  int8_t *event_list;
  int32_t num_events;
  dev_t *devices_not_to_watch;
  uint32_t num_devices;
  int32_t flags;
  kfs_event **event_queue;
  int32_t eventq_size;
  int32_t num_readers;
  int32_t rd;
  int32_t wr;
  int32_t blockers;
  int32_t my_id;
  uint32_t num_dropped;
  uint64_t max_event_id;
  fsevent_handle *fseh;
  pid_t pid;
  char proc_name[33];
};

/* 5206 */
struct __attribute__((aligned(8))) regular_event
{
  ino64_t ino;
  dev_t dev;
  int32_t mode;
  uid_t uid;
  gid_t gid;
  kfs_event *dest;
  const char *str;
  uint16_t len;
};

/* 5207 */
struct kfs_event
{
  struct
  {
    kfs_event *le_next;
    kfs_event **le_prev;
  } kevent_list;
  uint64_t abstime;
  int16_t type;
  uint16_t flags;
  int32_t refcount;
  pid_t pid;
  int32_t spare;
  union
  {
    regular_event regular_event;
    struct __attribute__((aligned(8)))
    {
      ino64_t src_ino;
      ino64_t dst_ino;
      uint64_t docid;
      dev_t dev;
    } docid_event;
    struct __attribute__((aligned(8)))
    {
      audit_token_t audit_token;
      const char *str;
      uint16_t len;
    } access_granted_event;
  };
};

/* 5208 */
typedef vfstable *vfstable_t;

/* 5209 */
struct vfsioattr
{
  u_int32_t io_maxreadcnt;
  u_int32_t io_maxwritecnt;
  u_int32_t io_segreadcnt;
  u_int32_t io_segwritecnt;
  u_int32_t io_maxsegreadsize;
  u_int32_t io_maxsegwritesize;
  u_int32_t io_devblocksize;
  u_int32_t io_flags;
  union
  {
    int64_t io_max_swappin_available;
    void *io_reserved[2];
  };
};

/* 5210 */
typedef kauth_acl *kauth_acl_t;

/* 5211 */
typedef kauth_filesec *kauth_filesec_t;

/* 5212 */
struct searchstate
{
  uint32_t ss_union_flags;
  uint32_t ss_union_layer;
  u_char ss_fsstate[548];
};

/* 5213 */
typedef uint32_t compound_vnop_id_t;

/* 5214 */
typedef int (*PFI)(void *);

/* 5215 */
struct vfs_fsentry
{
  vfsops *vfe_vfsops;
  int vfe_vopcnt;
  vnodeopv_desc **vfe_opvdescs;
  int vfe_fstypenum;
  char vfe_fsname[15];
  uint32_t vfe_flags;
  void *vfe_reserv[2];
};

/* 5216 */
typedef rsrcfork_header rsrcfork_header_t;

/* 8100 */
struct __attribute__((packed)) __attribute__((aligned(2))) rsrcfork_header
{
  u_int32_t fh_DataOffset;
  u_int32_t fh_MapOffset;
  u_int32_t fh_DataLength;
  u_int32_t fh_MapLength;
  u_int8_t systemData[112];
  u_int8_t appData[128];
  u_int32_t mh_DataOffset;
  u_int32_t mh_MapOffset;
  u_int32_t mh_DataLength;
  u_int32_t mh_MapLength;
  u_int32_t mh_Next;
  u_int16_t mh_RefNum;
  u_int8_t mh_Attr;
  u_int8_t mh_InMemoryAttr;
  u_int16_t mh_Types;
  u_int16_t mh_Names;
  u_int16_t typeCount;
};

/* 5217 */
typedef apple_double_entry apple_double_entry_t;

/* 8101 */
struct apple_double_entry
{
  u_int32_t type;
  u_int32_t offset;
  u_int32_t length;
};

/* 5218 */
typedef apple_double_header apple_double_header_t;

/* 9302 */
struct apple_double_header
{
  u_int32_t magic;
  u_int32_t version;
  u_int32_t filler[4];
  u_int16_t numEntries;
  __attribute__((packed)) __attribute__((aligned(1))) apple_double_entry_t entries[2];
  u_int8_t finfo[32];
  u_int8_t pad[2];
};

/* 5219 */
typedef attr_header attr_header_t;

/* 9303 */
struct attr_header
{
  apple_double_header_t appledouble;
  u_int32_t magic;
  u_int32_t debug_tag;
  u_int32_t total_size;
  u_int32_t data_start;
  u_int32_t data_length;
  u_int32_t reserved[3];
  u_int16_t flags;
  u_int16_t num_attrs;
};

/* 5220 */
typedef attr_entry attr_entry_t;

/* 8102 */
struct attr_entry
{
  u_int32_t offset;
  u_int32_t length;
  u_int16_t flags;
  u_int8_t namelen;
  u_int8_t name[1];
};

/* 5221 */
struct __attribute__((aligned(8))) vniodesc
{
  vnode_t vnio_vnode;
  int vnio_fflags;
};

/* 5225 */
typedef vniodesc *vniodesc_t;

/* 5226 */
struct unicode_mappings32
{
  u_int32_t _key;
  u_int32_t _value;
};

/* 5227 */
struct unicode_mappings16
{
  u_int16_t _key;
  u_int16_t _value;
};

/* 5228 */
struct vnop_copyfile_args
{
  vnodeop_desc *a_desc;
  vnode_t a_fvp;
  vnode_t a_tdvp;
  vnode_t a_tvp;
  componentname *a_tcnp;
  int a_mode;
  int a_flags;
  vfs_context_t a_context;
};

/* 5229 */
struct vnop_pageout_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  upl_t a_pl;
  upl_offset_t a_pl_offset;
  off_t a_f_offset;
  size_t a_size;
  int a_flags;
  vfs_context_t a_context;
};

/* 5230 */
struct vnop_remove_args
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t a_vp;
  componentname *a_cnp;
  int a_flags;
  vfs_context_t a_context;
};

/* 5231 */
struct vnop_exchange_args
{
  vnodeop_desc *a_desc;
  vnode_t a_fvp;
  vnode_t a_tvp;
  int a_options;
  vfs_context_t a_context;
};

/* 5232 */
struct vnop_access_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  int a_action;
  vfs_context_t a_context;
};

/* 5233 */
struct vnop_whiteout_args
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  componentname *a_cnp;
  int a_flags;
  vfs_context_t a_context;
};

/* 5234 */
struct vnop_create_args
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t *a_vpp;
  componentname *a_cnp;
  vnode_attr *a_vap;
  vfs_context_t a_context;
};

/* 5235 */
struct vnop_searchfs_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  void *a_searchparams1;
  void *a_searchparams2;
  attrlist *a_searchattrs;
  uint32_t a_maxmatches;
  timeval *a_timelimit;
  attrlist *a_returnattrs;
  uint32_t *a_nummatches;
  uint32_t a_scriptcode;
  uint32_t a_options;
  uio *a_uio;
  searchstate *a_searchstate;
  vfs_context_t a_context;
};

/* 5236 */
struct vnop_allocate_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  off_t a_length;
  u_int32_t a_flags;
  off_t *a_bytesallocated;
  off_t a_offset;
  vfs_context_t a_context;
};

/* 5237 */
struct vnop_readdirattr_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  attrlist *a_alist;
  uio *a_uio;
  uint32_t a_maxcount;
  uint32_t a_options;
  uint32_t *a_newstate;
  int *a_eofflag;
  uint32_t *a_actualcount;
  vfs_context_t a_context;
};

/* 5238 */
struct vnop_revoke_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  int a_flags;
  vfs_context_t a_context;
};

/* 5239 */
struct fs_snapshot_args
{
  uint32_t op;
  char op_r_[4];
  int dirfd;
  char dirfd_r_[4];
  user_addr_t_0 name1;
  user_addr_t_0 name2;
  user_addr_t_0 data;
  uint32_t flags;
  char flags_r_[4];
};

/* 5240 */
struct vfs_purge_args
{
  int32_t dummy;
};

/* 5241 */
struct fsgetpath_ext_args
{
  user_addr_t_0 buf;
  user_size_t bufsize;
  user_addr_t_0 fsid;
  uint64_t objid;
  uint32_t options;
  char options_r_[4];
};

/* 5242 */
struct fsgetpath_args
{
  user_addr_t_0 buf;
  user_size_t bufsize;
  user_addr_t_0 fsid;
  uint64_t objid;
  char objid_r_[];
};

/* 5243 */
struct flistxattr_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 namebuf;
  user_size_t bufsize;
  int options;
  char options_r_[4];
};

/* 5244 */
struct listxattr_args
{
  user_addr_t_0 path;
  user_addr_t_0 namebuf;
  user_size_t bufsize;
  int options;
  char options_r_[4];
};

/* 5245 */
struct fremovexattr_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 attrname;
  int options;
  char options_r_[4];
};

/* 5246 */
struct removexattr_args
{
  user_addr_t_0 path;
  user_addr_t_0 attrname;
  int options;
  char options_r_[4];
};

/* 5247 */
struct fsetxattr_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 attrname;
  user_addr_t_0 value;
  user_size_t size;
  uint32_t position;
  char position_r_[4];
  int options;
  char options_r_[4];
};

/* 5248 */
struct setxattr_args
{
  user_addr_t_0 path;
  user_addr_t_0 attrname;
  user_addr_t_0 value;
  user_size_t size;
  uint32_t position;
  char position_r_[4];
  int options;
  char options_r_[4];
};

/* 5249 */
struct fgetxattr_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 attrname;
  user_addr_t_0 value;
  user_size_t size;
  uint32_t position;
  char position_r_[4];
  int options;
  char options_r_[4];
};

/* 5250 */
struct getxattr_args
{
  user_addr_t_0 path;
  user_addr_t_0 attrname;
  user_addr_t_0 value;
  user_size_t size;
  uint32_t position;
  char position_r_[4];
  int options;
  char options_r_[4];
};

/* 5251 */
struct ffsctl_args
{
  int fd;
  char fd_r_[4];
  user_ulong_t cmd;
  user_addr_t_0 data;
  u_int options;
  char options_r_[4];
};

/* 5252 */
struct fsctl_args
{
  user_addr_t_0 path;
  user_ulong_t cmd;
  user_addr_t_0 data;
  u_int options;
  char options_r_[4];
};

/* 5253 */
struct searchfs_args
{
  user_addr_t_0 path;
  user_addr_t_0 searchblock;
  user_addr_t_0 nummatches;
  uint32_t scriptcode;
  char scriptcode_r_[4];
  uint32_t options;
  char options_r_[4];
  user_addr_t_0 state;
  char state_r_[];
};

/* 5254 */
struct exchangedata_args
{
  user_addr_t_0 path1;
  user_addr_t_0 path2;
  user_ulong_t options;
  char options_r_[];
};

/* 5255 */
struct getdirentriesattr_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 alist;
  user_addr_t_0 buffer;
  user_size_t buffersize;
  user_addr_t_0 count;
  user_addr_t_0 basep;
  user_addr_t_0 newstate;
  user_ulong_t options;
  char options_r_[];
};

/* 5256 */
struct revoke_args
{
  user_addr_t_0 path;
  char path_r_[];
};

/* 5257 */
struct umask_args
{
  int newmask;
  char newmask_r_[4];
};

/* 5258 */
struct umask_extended_args
{
  int newmask;
  char newmask_r_[4];
  user_addr_t_0 xsecurity;
  char xsecurity_r_[];
};

/* 5259 */
struct getdirentries64_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 buf;
  user_size_t bufsize;
  user_addr_t_0 position;
  char position_r_[];
};

/* 5260 */
struct getdirentries_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 buf;
  u_int count;
  char count_r_[4];
  user_addr_t_0 basep;
  char basep_r_[];
};

/* 5261 */
struct rmdir_args
{
  user_addr_t_0 path;
  char path_r_[];
};

/* 5262 */
struct mkdirat_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  int mode;
  char mode_r_[4];
};

/* 5263 */
struct mkdir_args
{
  user_addr_t_0 path;
  int mode;
  char mode_r_[4];
};

/* 5264 */
struct mkdir_extended_args
{
  user_addr_t_0 path;
  uid_t uid;
  char uid_r_[4];
  gid_t gid;
  char gid_r_[4];
  int mode;
  char mode_r_[4];
  user_addr_t_0 xsecurity;
  char xsecurity_r_[];
};

/* 5265 */
struct renameat_args
{
  int fromfd;
  char fromfd_r_[4];
  user_addr_t_0 from;
  int tofd;
  char tofd_r_[4];
  user_addr_t_0 to;
  char to_r_[];
};

/* 5266 */
struct renameatx_np_args
{
  int fromfd;
  char fromfd_r_[4];
  user_addr_t_0 from;
  int tofd;
  char tofd_r_[4];
  user_addr_t_0 to;
  u_int flags;
  char flags_r_[4];
};

/* 5267 */
struct rename_args
{
  user_addr_t_0 from;
  user_addr_t_0 to;
  char to_r_[];
};

/* 5268 */
struct fclonefileat_args
{
  int src_fd;
  char src_fd_r_[4];
  int dst_dirfd;
  char dst_dirfd_r_[4];
  user_addr_t_0 dst;
  uint32_t flags;
  char flags_r_[4];
};

/* 5269 */
struct clonefileat_args
{
  int src_dirfd;
  char src_dirfd_r_[4];
  user_addr_t_0 src;
  int dst_dirfd;
  char dst_dirfd_r_[4];
  user_addr_t_0 dst;
  uint32_t flags;
  char flags_r_[4];
};

/* 5270 */
struct copyfile_args
{
  user_addr_t_0 from;
  user_addr_t_0 to;
  int mode;
  char mode_r_[4];
  int flags;
  char flags_r_[4];
};

/* 5271 */
struct fdatasync_args
{
  int fd;
  char fd_r_[4];
};

/* 5272 */
struct fsync_nocancel_args
{
  int fd;
  char fd_r_[4];
};

/* 5273 */
struct ftruncate_args
{
  int fd;
  char fd_r_[4];
  off_t length;
  char length_r_[];
};

/* 5274 */
struct truncate_args
{
  user_addr_t_0 path;
  off_t length;
  char length_r_[];
};

/* 5275 */
struct futimes_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 tptr;
  char tptr_r_[];
};

/* 5276 */
struct utimes_args
{
  user_addr_t_0 path;
  user_addr_t_0 tptr;
  char tptr_r_[];
};

/* 5277 */
struct fchown_args
{
  int fd;
  char fd_r_[4];
  int uid;
  char uid_r_[4];
  int gid;
  char gid_r_[4];
};

/* 5278 */
struct fchownat_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  uid_t uid;
  char uid_r_[4];
  gid_t gid;
  char gid_r_[4];
  int flag;
  char flag_r_[4];
};

/* 5279 */
struct lchown_args
{
  user_addr_t_0 path;
  uid_t owner;
  char owner_r_[4];
  gid_t group;
  char group_r_[4];
};

/* 5280 */
struct chown_args
{
  user_addr_t_0 path;
  int uid;
  char uid_r_[4];
  int gid;
  char gid_r_[4];
};

/* 5281 */
struct fchmod_args
{
  int fd;
  char fd_r_[4];
  int mode;
  char mode_r_[4];
};

/* 5282 */
struct fchmod_extended_args
{
  int fd;
  char fd_r_[4];
  uid_t uid;
  char uid_r_[4];
  gid_t gid;
  char gid_r_[4];
  int mode;
  char mode_r_[4];
  user_addr_t_0 xsecurity;
  char xsecurity_r_[];
};

/* 5283 */
struct fchmodat_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  int mode;
  char mode_r_[4];
  int flag;
  char flag_r_[4];
};

/* 5284 */
struct chmod_args
{
  user_addr_t_0 path;
  int mode;
  char mode_r_[4];
};

/* 5285 */
struct chmod_extended_args
{
  user_addr_t_0 path;
  uid_t uid;
  char uid_r_[4];
  gid_t gid;
  char gid_r_[4];
  int mode;
  char mode_r_[4];
  user_addr_t_0 xsecurity;
  char xsecurity_r_[];
};

/* 5286 */
struct fchflags_args
{
  int fd;
  char fd_r_[4];
  int flags;
  char flags_r_[4];
};

/* 5287 */
struct chflags_args
{
  user_addr_t_0 path;
  int flags;
  char flags_r_[4];
};

/* 5288 */
struct readlinkat_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  user_addr_t_0 buf;
  user_size_t bufsize;
  char bufsize_r_[];
};

/* 5289 */
struct readlink_args
{
  user_addr_t_0 path;
  user_addr_t_0 buf;
  int count;
  char count_r_[4];
};

/* 5290 */
struct freadlink_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 buf;
  user_size_t bufsize;
  char bufsize_r_[];
};

/* 5291 */
struct pathconf_args
{
  user_addr_t_0 path;
  int name;
  char name_r_[4];
};

/* 5292 */
struct fstatat64_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  user_addr_t_0 ub;
  int flag;
  char flag_r_[4];
};

/* 5293 */
struct fstatat_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  user_addr_t_0 ub;
  int flag;
  char flag_r_[4];
};

/* 5294 */
struct lstat64_extended_args
{
  user_addr_t_0 path;
  user_addr_t_0 ub;
  user_addr_t_0 xsecurity;
  user_addr_t_0 xsecurity_size;
  char xsecurity_size_r_[];
};

/* 5295 */
struct lstat64_args
{
  user_addr_t_0 path;
  user_addr_t_0 ub;
  char ub_r_[];
};

/* 5296 */
struct lstat_args
{
  user_addr_t_0 path;
  user_addr_t_0 ub;
  char ub_r_[];
};

/* 5297 */
struct lstat_extended_args
{
  user_addr_t_0 path;
  user_addr_t_0 ub;
  user_addr_t_0 xsecurity;
  user_addr_t_0 xsecurity_size;
  char xsecurity_size_r_[];
};

/* 5298 */
struct stat64_extended_args
{
  user_addr_t_0 path;
  user_addr_t_0 ub;
  user_addr_t_0 xsecurity;
  user_addr_t_0 xsecurity_size;
  char xsecurity_size_r_[];
};

/* 5299 */
struct stat64_args
{
  user_addr_t_0 path;
  user_addr_t_0 ub;
  char ub_r_[];
};

/* 5300 */
struct stat_args
{
  user_addr_t_0 path;
  user_addr_t_0 ub;
  char ub_r_[];
};

/* 5301 */
struct stat_extended_args
{
  user_addr_t_0 path;
  user_addr_t_0 ub;
  user_addr_t_0 xsecurity;
  user_addr_t_0 xsecurity_size;
  char xsecurity_size_r_[];
};

/* 5302 */
struct faccessat_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  int amode;
  char amode_r_[4];
  int flag;
  char flag_r_[4];
};

/* 5303 */
struct access_args
{
  user_addr_t_0 path;
  int flags;
  char flags_r_[4];
};

/* 5304 */
struct access_extended_args
{
  user_addr_t_0 entries;
  user_size_t size;
  user_addr_t_0 results;
  uid_t uid;
  char uid_r_[4];
};

/* 5305 */
struct lseek_args
{
  int fd;
  char fd_r_[4];
  off_t offset;
  int whence;
  char whence_r_[4];
};

/* 5306 */
struct unlinkat_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  int flag;
  char flag_r_[4];
};

/* 5307 */
struct unlink_args
{
  user_addr_t_0 path;
  char path_r_[];
};

/* 5308 */
struct delete_args
{
  user_addr_t_0 path;
  char path_r_[];
};

/* 5309 */
struct undelete_args
{
  user_addr_t_0 path;
  char path_r_[];
};

/* 5310 */
struct symlinkat_args
{
  user_addr_t_0 path1;
  int fd;
  char fd_r_[4];
  user_addr_t_0 path2;
  char path2_r_[];
};

/* 5311 */
struct symlink_args
{
  user_addr_t_0 path;
  user_addr_t_0 link;
  char link_r_[];
};

/* 5312 */
struct linkat_args
{
  int fd1;
  char fd1_r_[4];
  user_addr_t_0 path;
  int fd2;
  char fd2_r_[4];
  user_addr_t_0 link;
  int flag;
  char flag_r_[4];
};

/* 5313 */
struct link_args
{
  user_addr_t_0 path;
  user_addr_t_0 link;
  char link_r_[];
};

/* 5314 */
struct mkfifoat_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  int mode;
  char mode_r_[4];
};

/* 5315 */
struct mkfifo_args
{
  user_addr_t_0 path;
  int mode;
  char mode_r_[4];
};

/* 5316 */
struct mkfifo_extended_args
{
  user_addr_t_0 path;
  uid_t uid;
  char uid_r_[4];
  gid_t gid;
  char gid_r_[4];
  int mode;
  char mode_r_[4];
  user_addr_t_0 xsecurity;
  char xsecurity_r_[];
};

/* 5317 */
struct mknodat_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  int mode;
  char mode_r_[4];
  int dev;
  char dev_r_[4];
};

/* 5318 */
struct mknod_args
{
  user_addr_t_0 path;
  int mode;
  char mode_r_[4];
  int dev;
  char dev_r_[4];
};

/* 5319 */
struct openbyid_np_args
{
  user_addr_t_0 fsid;
  user_addr_t_0 objid;
  int oflags;
  char oflags_r_[4];
};

/* 5320 */
struct openat_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  int flags;
  char flags_r_[4];
  int mode;
  char mode_r_[4];
};

/* 5321 */
struct open_args
{
  user_addr_t_0 path;
  int flags;
  char flags_r_[4];
  int mode;
  char mode_r_[4];
};

/* 5322 */
struct open_dprotected_np_args
{
  user_addr_t_0 path;
  int flags;
  char flags_r_[4];
  int class;
  char class_r_[4];
  int dpflags;
  char dpflags_r_[4];
  int mode;
  char mode_r_[4];
};

/* 5323 */
struct openat_dprotected_np_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  int flags;
  char flags_r_[4];
  int class;
  char class_r_[4];
  int dpflags;
  char dpflags_r_[4];
  int mode;
  char mode_r_[4];
  int authfd;
  char authfd_r_[4];
};

/* 5324 */
struct open_extended_args
{
  user_addr_t_0 path;
  int flags;
  char flags_r_[4];
  uid_t uid;
  char uid_r_[4];
  gid_t gid;
  char gid_r_[4];
  int mode;
  char mode_r_[4];
  user_addr_t_0 xsecurity;
  char xsecurity_r_[];
};

/* 5325 */
struct pivot_root_args
{
  user_addr_t_0 new_rootfs_path_before;
  user_addr_t_0 old_rootfs_path_after;
  char old_rootfs_path_after_r_[];
};

/* 5326 */
struct chroot_args
{
  user_addr_t_0 path;
  char path_r_[];
};

/* 5327 */
struct __pthread_chdir_args
{
  user_addr_t_0 path;
  char path_r_[];
};

/* 5328 */
struct __pthread_fchdir_args
{
  int fd;
  char fd_r_[4];
};

/* 5329 */
struct getfsstat64_args
{
  user_addr_t_0 buf;
  int bufsize;
  char bufsize_r_[4];
  int flags;
  char flags_r_[4];
};

/* 5330 */
struct getfsstat_args
{
  user_addr_t_0 buf;
  int bufsize;
  char bufsize_r_[4];
  int flags;
  char flags_r_[4];
};

/* 5331 */
struct fstatfs64_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 buf;
  char buf_r_[];
};

/* 5332 */
struct statfs64_args
{
  user_addr_t_0 path;
  user_addr_t_0 buf;
  char buf_r_[];
};

/* 5333 */
struct fstatfs_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 buf;
  char buf_r_[];
};

/* 5334 */
struct statfs_args
{
  user_addr_t_0 path;
  user_addr_t_0 buf;
  char buf_r_[];
};

/* 5335 */
struct quotactl_args
{
  user_addr_t_0 path;
  int cmd;
  char cmd_r_[4];
  int uid;
  char uid_r_[4];
  user_addr_t_0 arg;
  char arg_r_[];
};

/* 5336 */
struct unmount_args
{
  user_addr_t_0 path;
  int flags;
  char flags_r_[4];
};

/* 5337 */
struct ungraftdmg_args
{
  user_addr_t_0 mountdir;
  uint64_t flags;
  char flags_r_[];
};

/* 5338 */
struct graftdmg_args
{
  int dmg_fd;
  char dmg_fd_r_[4];
  user_addr_t_0 mountdir;
  uint32_t graft_type;
  char graft_type_r_[4];
  user_addr_t_0 gda;
  char gda_r_[];
};

/* 5339 */
struct fmount_args
{
  user_addr_t_0 type;
  int fd;
  char fd_r_[4];
  int flags;
  char flags_r_[4];
  user_addr_t_0 data;
  char data_r_[];
};

/* 5340 */
struct mount_args
{
  user_addr_t_0 type;
  user_addr_t_0 path;
  int flags;
  char flags_r_[4];
  user_addr_t_0 data;
  char data_r_[];
};

/* 5341 */
struct fchdir_args
{
  int fd;
  char fd_r_[4];
};

/* 5342 */
struct sync_args
{
  int32_t dummy;
};

/* 5343 */
struct chdir_args
{
  user_addr_t_0 path;
  char path_r_[];
};

/* 5344 */
typedef secure_boot_cryptex_args secure_boot_cryptex_args_t;

/* 8108 */
struct __attribute__((packed)) __attribute__((aligned(4))) secure_boot_cryptex_args
{
  u_int32_t sbc_version;
  u_int32_t sbc_4cc;
  int sbc_authentic_manifest_fd;
  int sbc_user_manifest_fd;
  int sbc_payload_fd;
  u_int64_t sbc_flags;
};

/* 5345 */
struct fsioc_cas_bsdflags
{
  uint32_t expected_flags;
  uint32_t new_flags;
  uint32_t actual_flags;
};

/* 5346 */
struct getfsstat_struct
{
  user_addr_t_0 sfsp;
  user_addr_t_0 *mp;
  int count;
  int maxcount;
  int flags;
  int error;
};

/* 5347 */
struct cdirargs
{
  vnode_t olddp;
  vnode_t newdp;
};

/* 5348 */
struct setxattr_ctx
{
  nameidata nd;
  char attrname[128];
  uio_stackbuf_t uio_buf[72];
};

/* 5349 */
typedef attrreference attrreference_t;

/* 8109 */
struct attrreference
{
  int32_t attr_dataoffset;
  u_int32_t attr_length;
};

/* 5350 */
struct __attribute__((aligned(4))) direntry
{
  __uint64_t d_ino;
  __uint64_t d_seekoff;
  __uint16_t d_reclen;
  __uint16_t d_namlen;
  __uint8_t d_type;
  char d_name[1024];
};

/* 5351 */
struct dirent
{
  ino_t d_ino;
  __uint16_t d_reclen;
  __uint8_t d_type;
  __uint8_t d_namlen;
  char d_name[256];
};

/* 5352 */
struct fsync_args
{
  int fd;
  char fd_r_[4];
};

/* 5354 */
struct accessx_descriptor
{
  unsigned int ad_name_offset;
  int ad_flags;
  int ad_pad[2];
};

/* 5355 */
struct openat_nocancel_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  int flags;
  char flags_r_[4];
  int mode;
  char mode_r_[4];
};

/* 5356 */
struct open_nocancel_args
{
  user_addr_t_0 path;
  int flags;
  char flags_r_[4];
  int mode;
  char mode_r_[4];
};

/* 5357 */
struct __attribute__((aligned(8))) nspace_resolver_request
{
  struct
  {
    nspace_resolver_request *le_next;
    nspace_resolver_request **le_prev;
  } r_hashlink;
  vnode_t r_vp;
  uint32_t r_req_id;
  int r_resolver_error;
  int r_flags;
};

/* 5358 */
struct nspace_resolver_requesthead
{
  nspace_resolver_request *lh_first;
};

/* 5359 */
struct statfs64
{
  uint32_t f_bsize;
  int32_t f_iosize;
  uint64_t f_blocks;
  uint64_t f_bfree;
  uint64_t f_bavail;
  uint64_t f_files;
  uint64_t f_ffree;
  fsid_t f_fsid;
  uid_t f_owner;
  uint32_t f_type;
  uint32_t f_flags;
  uint32_t f_fssubtype;
  char f_fstypename[16];
  char f_mntonname[1024];
  char f_mntfromname[1024];
  uint32_t f_flags_ext;
  uint32_t f_reserved[7];
};

/* 5360 */
struct __attribute__((aligned(8))) vnode_trigger_info
{
  trigger_vnode_resolve_callback_t vti_resolve_func;
  trigger_vnode_unresolve_callback_t vti_unresolve_func;
  trigger_vnode_rearm_callback_t vti_rearm_func;
  trigger_vnode_reclaim_callback_t vti_reclaim_func;
  void *vti_data;
  uint32_t vti_flags;
};

/* 5362 */
struct user_vfsidctl
{
  int vc_vers;
  fsid_t vc_fsid;
  user_addr_t_0 vc_ptr;
  user_size_t vc_len;
  u_int32_t vc_spare[12];
};

/* 5363 */
struct user32_vfsidctl
{
  int vc_vers;
  fsid_t vc_fsid;
  user32_addr_t vc_ptr;
  user32_size_t vc_len;
  u_int32_t vc_spare[12];
};

/* 8110 */
enum dir_clone_authorizer_op : __int32
{
  dir_clone_authorizer_op::OP_AUTHORIZE = 0x0,
  dir_clone_authorizer_op::OP_VATTR_SETUP = 0x1,
  dir_clone_authorizer_op::OP_VATTR_CLEANUP = 0x2,
};

/* 5364 */
typedef dir_clone_authorizer_op dir_clone_authorizer_op_t;

/* 5365 */
typedef uint32_t vfs_switch_root_flags_t;

/* 5366 */
typedef unsigned int vfs_rename_flags_t;

/* 5367 */
struct trigger_unmount_info
{
  vfs_context_t ctx;
  mount_t top_mp;
  vnode_t trigger_vp;
  mount_t trigger_mp;
  uint32_t trigger_vid;
  int flags;
};

/* 5369 */
struct __attribute__((aligned(8))) vnode_fsparam
{
  mount *vnfs_mp;
  vtype_0 vnfs_vtype;
  const char *vnfs_str;
  vnode *vnfs_dvp;
  void *vnfs_fsnode;
  int (**vnfs_vops)(void *);
  int vnfs_markroot;
  int vnfs_marksystem;
  dev_t vnfs_rdev;
  off_t vnfs_filesize;
  componentname *vnfs_cnp;
  uint32_t vnfs_flags;
};

/* 5368 */
struct __attribute__((aligned(8))) vnode_trigger_param
{
  vnode_fsparam vnt_params;
  trigger_vnode_resolve_callback_t vnt_resolve_func;
  trigger_vnode_unresolve_callback_t vnt_unresolve_func;
  trigger_vnode_rearm_callback_t vnt_rearm_func;
  trigger_vnode_reclaim_callback_t vnt_reclaim_func;
  void *vnt_data;
  uint32_t vnt_flags;
};

/* 5371 */
struct user32_statfs
{
  short f_otype;
  short f_oflags;
  user32_long_t f_bsize;
  user32_long_t f_iosize;
  user32_long_t f_blocks;
  user32_long_t f_bfree;
  user32_long_t f_bavail;
  user32_long_t f_files;
  user32_long_t f_ffree;
  fsid_t f_fsid;
  uid_t f_owner;
  short f_reserved1;
  short f_type;
  user32_long_t f_flags;
  user32_long_t f_reserved2[2];
  char f_fstypename[15];
  char f_mntonname[90];
  char f_mntfromname[90];
  char f_reserved3;
  user32_long_t f_reserved4[4];
};

/* 5372 */
struct user64_statfs
{
  short f_otype;
  short f_oflags;
  user64_long_t f_bsize;
  user64_long_t f_iosize;
  user64_long_t f_blocks;
  user64_long_t f_bfree;
  user64_long_t f_bavail;
  user64_long_t f_files;
  user64_long_t f_ffree;
  fsid_t f_fsid;
  uid_t f_owner;
  short f_reserved1;
  short f_type;
  user64_long_t f_flags;
  user64_long_t f_reserved2[2];
  char f_fstypename[15];
  char f_mntonname[90];
  char f_mntfromname[90];
  char f_reserved3;
  user64_long_t f_reserved4[4];
};

/* 5373 */
struct user_dqblk
{
  u_int64_t dqb_bhardlimit;
  u_int64_t dqb_bsoftlimit;
  u_int64_t dqb_curbytes;
  u_int32_t dqb_ihardlimit;
  u_int32_t dqb_isoftlimit;
  u_int32_t dqb_curinodes;
  u_int32_t dqb_btime;
  u_int32_t dqb_itime;
  u_int32_t dqb_id;
  u_int32_t dqb_spare[4];
};

/* 5374 */
struct __attribute__((aligned(8))) quotafile
{
  lck_mtx_t qf_lock;
  vnode *qf_vp;
  kauth_cred_t qf_cred;
  int qf_shift;
  int qf_maxentries;
  int qf_entrycnt;
  u_int32_t qf_btime;
  u_int32_t qf_itime;
  char qf_qflags;
  int qf_refcnt;
};

/* 5375 */
struct dqblk
{
  u_int64_t dqb_bhardlimit;
  u_int64_t dqb_bsoftlimit;
  u_int64_t dqb_curbytes;
  u_int32_t dqb_ihardlimit;
  u_int32_t dqb_isoftlimit;
  u_int32_t dqb_curinodes;
  u_int32_t dqb_btime;
  u_int32_t dqb_itime;
  u_int32_t dqb_id;
  u_int32_t dqb_spare[4];
};

/* 5376 */
struct __attribute__((aligned(8))) dquot
{
  struct
  {
    dquot *le_next;
    dquot **le_prev;
  } dq_hash;
  struct
  {
    dquot *tqe_next;
    dquot **tqe_prev;
  } dq_freelist;
  u_int16_t dq_flags;
  u_int16_t dq_cnt_unused;
  u_int16_t dq_lflags;
  u_int16_t dq_type;
  u_int32_t dq_id;
  u_int32_t dq_index;
  quotafile *dq_qfile;
  dqblk dq_dqb;
  uint32_t dq_cnt;
};

/* 5377 */
struct dqhash
{
  dquot *lh_first;
};

/* 5379 */
struct vfs_drt_hashentry
{
  u_int64_t dhe_control;
  u_int32_t dhe_bitvector[2];
};

/* 5380 */
struct vfs_drt_clustermap
{
  u_int32_t scm_magic;
  u_int32_t scm_modulus;
  u_int32_t scm_buckets;
  u_int32_t scm_lastclean;
  u_int32_t scm_iskips;
  vfs_drt_hashentry scm_hashtable[];
};

/* 5381 */
typedef cl_direct_read_lock cl_direct_read_lock_t;

/* 5383 */
struct cl_direct_read_lock
{
  struct
  {
    cl_direct_read_lock *le_next;
    cl_direct_read_lock **le_prev;
  } chain;
  int32_t ref_count;
  vnode_t vp;
  lck_rw_t rw_lock;
};

/* 5382 */
struct clios
{
  lck_mtx_t io_mtxp;
  u_int io_completed;
  u_int io_issued;
  int io_error;
  int io_wanted;
};

/* 5384 */
struct cl_direct_read_locks
{
  cl_direct_read_lock *lh_first;
};

/* 5385 */
typedef unsigned int lck_rw_type_t;

/* 5386 */
struct __attribute__((aligned(8))) nameidata_state
{
  u_long ni_loopcnt;
  char *ni_next;
  u_int ni_pathlen;
  int32_t ni_flag;
  char *cn_nameptr;
  int cn_namelen;
  int cn_flags;
  uint32_t cn_hash;
};

/* 5387 */
struct string_t
{
  struct
  {
    string_t *le_next;
    string_t **le_prev;
  } hash_chain;
  char *str;
  uint32_t strbuflen;
  uint32_t refcount;
};

/* 5388 */
struct stringhead
{
  string_t *lh_first;
};

/* 5389 */
struct smrq_list_head
{
  __smrq_link_t first;
};

/* 5390 */
struct buf_iterate_info_t
{
  int flag;
  buflists *listhead;
};

/* 5391 */
typedef cpx *cpx_t;

/* 5392 */
struct bqueues
{
  buf *tqh_first;
  buf **tqh_last;
};

/* 5394 */
struct bufhashhdr
{
  buf *lh_first;
};

/* 5395 */
typedef bufattr *bufattr_t;

/* 5396 */
struct fs_buffer_cache_gc_callout_t
{
  void (*callout)(int, void *);
  void *context;
};

/* 5397 */
struct fsetattrlist_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 alist;
  user_addr_t_0 attributeBuffer;
  user_size_t bufferSize;
  user_ulong_t options;
  char options_r_[];
};

/* 5398 */
struct setattrlistat_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  user_addr_t_0 alist;
  user_addr_t_0 attributeBuffer;
  user_size_t bufferSize;
  uint32_t options;
  char options_r_[4];
};

/* 5399 */
struct setattrlist_args
{
  user_addr_t_0 path;
  user_addr_t_0 alist;
  user_addr_t_0 attributeBuffer;
  user_size_t bufferSize;
  user_ulong_t options;
  char options_r_[];
};

/* 5400 */
struct getattrlistbulk_args
{
  int dirfd;
  char dirfd_r_[4];
  user_addr_t_0 alist;
  user_addr_t_0 attributeBuffer;
  user_size_t bufferSize;
  uint64_t options;
  char options_r_[];
};

/* 5401 */
struct getattrlistat_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 path;
  user_addr_t_0 alist;
  user_addr_t_0 attributeBuffer;
  user_size_t bufferSize;
  user_ulong_t options;
  char options_r_[];
};

/* 5402 */
struct getattrlist_args
{
  user_addr_t_0 path;
  user_addr_t_0 alist;
  user_addr_t_0 attributeBuffer;
  user_size_t bufferSize;
  user_ulong_t options;
  char options_r_[];
};

/* 5403 */
struct fgetattrlist_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 alist;
  user_addr_t_0 attributeBuffer;
  user_size_t bufferSize;
  user_ulong_t options;
  char options_r_[];
};

/* 5404 */
struct _attrlist_buf
{
  char *base;
  char *fixedcursor;
  char *varcursor;
  ssize_t allocated;
  ssize_t needed;
  attribute_set_t actual;
  attribute_set_t valid;
};

/* 5405 */
struct _attrlist_paths
{
  char *fullpathptr;
  ssize_t *fullpathlenp;
  char *relpathptr;
  ssize_t *relpathlenp;
  char *REALpathptr;
  ssize_t *REALpathlenp;
};

/* 5406 */
struct getvolattrlist_attrtab
{
  attrgroup_t attr;
  uint64_t bits;
  ssize_t size;
};

/* 5408 */
struct __attribute__((aligned(8))) getattrlist_attrtab
{
  attrgroup_t attr;
  uint64_t bits;
  ssize_t size;
  kauth_action_t action;
};

/* 5409 */
struct dk_memdev_info_t
{
  boolean_t mi_mdev;
  boolean_t mi_phys;
  uint32_t mi_base;
  uint64_t mi_size;
};

/* 5412 */
struct mdev
{
  uint64_t mdBase;
  uint32_t mdSize;
  int mdFlags;
  int mdSecsize;
  int mdBDev;
  int mdCDev;
  void *mdbdevb;
  void *mdcdevb;
};

/* 5413 */
struct getentropy_args
{
  user_addr_t_0 buffer;
  user_size_t size;
  char size_r_[];
};

/* 5414 */
struct __mac_getfsstat_args
{
  user_addr_t_0 buf;
  int bufsize;
  char bufsize_r_[4];
  user_addr_t_0 mac;
  int macsize;
  char macsize_r_[4];
  int flags;
  char flags_r_[4];
};

/* 5415 */
struct __mac_mount_args
{
  user_addr_t_0 type;
  user_addr_t_0 path;
  int flags;
  char flags_r_[4];
  user_addr_t_0 data;
  user_addr_t_0 mac_p;
  char mac_p_r_[];
};

/* 5416 */
struct kevent64_args
{
  int fd;
  char fd_r_[4];
  user_addr_t_0 changelist;
  int nchanges;
  char nchanges_r_[4];
  user_addr_t_0 eventlist;
  int nevents;
  char nevents_r_[4];
  unsigned int flags;
  char flags_r_[4];
  user_addr_t_0 timeout;
  char timeout_r_[];
};

/* 5418 */
struct cyc_list_head
{
  wrap_timer_call *lh_first;
};

/* 8129 */
typedef void (*cyc_func_t)(void *);

/* 5460 */
typedef uint16_t cyc_level_t;

/* 9311 */
struct __attribute__((aligned(8))) cyc_handler
{
  cyc_func_t cyh_func;
  void *cyh_arg;
  cyc_level_t cyh_level;
};

/* 5429 */
typedef cyc_handler cyc_handler_t;

/* 9310 */
struct cyc_time
{
  hrtime_t cyt_when;
  hrtime_t cyt_interval;
};

/* 5428 */
typedef cyc_time cyc_time_t;

/* 5461 */
struct __attribute__((aligned(4))) timer_call
{
  uint64_t tc_soft_deadline;
  simple_lock_data_t tc_lock;
  priority_queue_entry_deadline tc_pqlink;
  queue_head_t_0 *tc_queue;
  queue_chain_t_0 tc_qlink;
  timer_call_func_t tc_func;
  timer_call_param_t tc_param0;
  timer_call_param_t tc_param1;
  uint64_t tc_ttd;
  uint64_t tc_entry_time;
  uint32_t tc_flags;
  bool tc_async_dequeue;
};

/* 5462 */
struct wrap_timer_call
{
  cyc_handler_t hdlr;
  cyc_time_t when;
  uint64_t deadline;
  int cpuid;
  boolean_t suspended;
  timer_call call;
  struct
  {
    wrap_timer_call *le_next;
    wrap_timer_call **le_prev;
  } entries;
};

/* 5419 */
typedef dtrace_cpu dtrace_cpu_t;

/* 8123 */
struct dtrace_cpu
{
  processorid_t cpu_id;
  dtrace_cpu *cpu_next;
  lck_rw_t cpu_ft_lock;
  uintptr_t cpu_dtrace_caller;
  hrtime_t cpu_dtrace_chillmark;
  hrtime_t cpu_dtrace_chilled;
  boolean_t cpu_dtrace_invop_underway;
  cyc_list_head cpu_cyc_list;
};

/* 5420 */
typedef fasttrap_probe_spec fasttrap_probe_spec_t;

/* 9308 */
struct fasttrap_probe_spec
{
  pid_t ftps_pid;
  fasttrap_provider_type_t ftps_provider_type;
  fasttrap_probe_type_t ftps_probe_type;
  uint32_t ftps_arch_subinfo;
  char ftps_func[128];
  char ftps_mod[64];
  uint64_t ftps_pc;
  uint64_t ftps_size;
  uint64_t ftps_noffs;
  uint64_t ftps_offs[1];
};

/* 5423 */
typedef dtrace_helper_provdesc dtrace_helper_provdesc_t;

/* 9332 */
struct __attribute__((aligned(2))) dtrace_helper_provdesc
{
  char *dthpv_provname;
  dtrace_pattr_t dthpv_pattr;
};

/* 5424 */
typedef dtrace_helper_probedesc dtrace_helper_probedesc_t;

/* 8128 */
struct dtrace_helper_probedesc
{
  char *dthpb_mod;
  char *dthpb_func;
  char *dthpb_name;
  uint64_t dthpb_base;
  int32_t *dthpb_offs;
  int32_t *dthpb_enoffs;
  uint32_t dthpb_noffs;
  uint32_t dthpb_nenoffs;
  uint8_t *dthpb_args;
  uint8_t dthpb_xargc;
  uint8_t dthpb_nargc;
  char *dthpb_xtypes;
  char *dthpb_ntypes;
};

/* 5425 */
typedef fasttrap_tracepoint_spec fasttrap_tracepoint_spec_t;

/* 9309 */
struct fasttrap_tracepoint_spec
{
  pid_t fttps_pid;
  user_addr_t_0 fttps_pc;
};

/* 5426 */
typedef unsigned __int64 ulong_t;

/* 5427 */
struct fasttrap_hash
{
  ulong_t fth_nent;
  ulong_t fth_mask;
  fasttrap_bucket_t *fth_table;
};

/* 5430 */
typedef profile_probe profile_probe_t;

/* 9312 */
struct profile_probe
{
  char prof_name[15];
  dtrace_id_t prof_id;
  int prof_kind;
  hrtime_t prof_interval;
  cyclic_id_t prof_cyclic;
};

/* 5431 */
typedef profile_probe_percpu profile_probe_percpu_t;

/* 9313 */
struct profile_probe_percpu
{
  hrtime_t profc_expected;
  hrtime_t profc_interval;
  profile_probe_t *profc_probe;
};

/* 5435 */
typedef u_int64_t syscall_arg_t;

/* 5432 */
struct mach_call_args
{
  syscall_arg_t arg1;
  syscall_arg_t arg2;
  syscall_arg_t arg3;
  syscall_arg_t arg4;
  syscall_arg_t arg5;
  syscall_arg_t arg6;
  syscall_arg_t arg7;
  syscall_arg_t arg8;
  syscall_arg_t arg9;
};

/* 5433 */
typedef void mach_munge_t(void *);

/* 5434 */
struct mach_trap_t
{
  unsigned __int8 mach_trap_arg_count;
  unsigned __int8 mach_trap_u32_words;
  unsigned __int8 mach_trap_returns_port;
  unsigned __int8 __mach_trap_padding;
  kern_return_t (*mach_trap_function)(void *);
  mach_munge_t *mach_trap_arg_munge32;
};

/* 5436 */
typedef machtrace_sysent machtrace_sysent_t;

/* 9314 */
struct __attribute__((aligned(8))) machtrace_sysent
{
  dtrace_id_t stsy_entry;
  dtrace_id_t stsy_return;
  kern_return_t (*stsy_underlying)(void *);
  int32_t stsy_return_type;
};

/* 5437 */
typedef systrace_sysent systrace_sysent_t;

/* 9315 */
struct __attribute__((aligned(8))) systrace_sysent
{
  dtrace_id_t stsy_entry;
  dtrace_id_t stsy_return;
  int32_t (*stsy_underlying)(proc *, void *, int *);
  int32_t stsy_return_type;
};

/* 5438 */
typedef sdt_argdesc sdt_argdesc_t;

/* 8131 */
struct sdt_argdesc
{
  const char *sda_provider;
  const char *sda_name;
  const int sda_ndx;
  const int sda_mapping;
  const char *sda_native;
  const char *sda_xlate;
};

/* 5439 */
typedef dtrace_module_symbols dtrace_module_symbols_t;

/* 5440 */
typedef sdt_probedesc sdt_probedesc_t;

/* 8132 */
struct sdt_probedesc
{
  char *sdpd_name;
  int sdpd_namelen;
  char *sdpd_func;
  const char *sdpd_prov;
  unsigned __int64 sdpd_offset;
  sdt_probedesc *sdpd_next;
};

/* 5441 */
typedef dtrace_sdt_def dtrace_sdt_def_t;

/* 8133 */
struct dtrace_sdt_def
{
  uintptr_t dsd_addr;
  const char *dsd_prov;
  const char *dsd_name;
};

/* 5443 */
typedef uint32_t machine_inst_t;

/* 5444 */
typedef fbt_probe fbt_probe_t;

/* 8134 */
struct fbt_probe
{
  fbt_probe *fbtp_hashnext;
  machine_inst_t *fbtp_patchpoint;
  int8_t fbtp_rval;
  machine_inst_t fbtp_patchval;
  machine_inst_t fbtp_savedval;
  machine_inst_t fbtp_currentval;
  uintptr_t fbtp_roffset;
  dtrace_id_t fbtp_id;
  char fbtp_name[16];
  modctl *fbtp_ctl;
  int fbtp_loadcnt;
  fbt_probe *fbtp_next;
};

/* 5445 */
typedef unsigned int u_daddr_t;

/* 5446 */
typedef blmeta blmeta_t;

/* 9317 */
struct blmeta
{
  union
  {
    daddr_t bmu_avail;
    u_daddr_t bmu_bitmap;
  } u;
  daddr_t bm_bighint;
};

/* 5447 */
struct __attribute__((aligned(8))) blist
{
  daddr_t bl_blocks;
  daddr_t bl_radix;
  daddr_t bl_skip;
  daddr_t bl_free;
  blmeta_t *bl_root;
  daddr_t bl_rootblks;
};

/* 5448 */
struct dtrace_getstackdepth::frame;

/* 5450 */
typedef blist *blist_t;

/* 5451 */
struct blist_hdl
{
  blist_t blist;
};

/* 5452 */
typedef long __darwin_intptr_t;

/* 5453 */
typedef wrap_thread_call wrap_thread_call_t;

/* 9492 */
struct wrap_thread_call
{
  thread_call_t TChdl;
  cyc_handler_t hdlr;
  cyc_time_t when;
  uint64_t deadline;
};

/* 5454 */
typedef cyc_omni_handler cyc_omni_handler_t;

/* 8130 */
struct cyc_omni_handler
{
  void (*cyo_online)(void *, dtrace_cpu_t *, cyc_handler_t *, cyc_time_t *);
  void (*cyo_offline)(void *, dtrace_cpu_t *, void *);
  void *cyo_arg;
};

/* 5455 */
typedef cyc_list cyc_list_t;

/* 5456 */
typedef wrap_timer_call wrap_timer_call_t;

/* 9889 */
struct cyc_list
{
  cyc_omni_handler_t cyl_omni;
  wrap_timer_call_t cyl_wrap_by_cpus[];
};

/* 5457 */
typedef cpu_core cpu_core_t;

/* 9318 */
struct __attribute__((aligned(4))) cpu_core
{
  uint64_t cpuc_dtrace_illval;
  lck_mtx_t cpuc_pid_lock;
  uint16_t cpuc_dtrace_flags;
  uint64_t cpuc_missing_tos;
  uint8_t cpuc_pad[30];
};

/* 5463 */
typedef cyclic_id_t *cyclic_id_list_t;

/* 5465 */
typedef dtrace_procdesc dtrace_procdesc_t;

/* 5469 */
struct dtrace_procdesc
{
  char p_name[128];
  int p_name_length;
  pid_t p_pid;
};

/* 5466 */
typedef dtrace_invop_hdlr dtrace_invop_hdlr_t;

/* 8137 */
struct dtrace_invop_hdlr
{
  int (*dtih_func)(uintptr_t, uintptr_t *, uintptr_t);
  dtrace_invop_hdlr *dtih_next;
};

/* 5468 */
typedef uint_t_0 minor_t;

/* 5470 */
struct dtrace_proc_awaited_entry
{
  dtrace_procdesc *pdesc;
  struct
  {
    dtrace_proc_awaited_entry *le_next;
    dtrace_proc_awaited_entry **le_prev;
  } entries;
};

/* 5471 */
typedef lockstat_probe lockstat_probe_t;

/* 9319 */
struct lockstat_probe
{
  const char *lsp_func;
  const char *lsp_name;
  int lsp_probe;
  dtrace_id_t lsp_id;
  const char *lsp_args;
};

/* 5472 */
typedef dtrace_string dtrace_string_t;

/* 8139 */
struct __attribute__((aligned(8))) dtrace_string
{
  dtrace_string_t *dtst_next;
  dtrace_string_t *dtst_prev;
  uint32_t dtst_refcount;
};

/* 5473 */
typedef uint32_t dtrace_optid_t;

/* 5474 */
typedef dtrace_module_uuids_list dtrace_module_uuids_list_t;

/* 9493 */
struct dtrace_module_uuids_list
{
  uint64_t dtmul_count;
  UUID dtmul_uuid[1];
};

/* 5475 */
typedef int64_t dtrace_aggvarid_t;

/* 5476 */
typedef dof_ioctl_data dof_ioctl_data_t;

/* 5477 */
typedef int dtrace_probekey_f(const char *, const char *, int);

/* 5478 */
typedef dtrace_probekey dtrace_probekey_t;

/* 9322 */
struct __attribute__((aligned(8))) dtrace_probekey
{
  const char *dtpk_prov;
  dtrace_probekey_f *dtpk_pmatch;
  const char *dtpk_mod;
  dtrace_probekey_f *dtpk_mmatch;
  const char *dtpk_func;
  dtrace_probekey_f *dtpk_fmatch;
  const char *dtpk_name;
  dtrace_probekey_f *dtpk_nmatch;
  dtrace_id_t dtpk_id;
};

/* 5479 */
typedef dtrace_match_cond dtrace_match_cond_t;

/* 9323 */
struct dtrace_match_cond
{
  int (*dmc_func)(dtrace_probedesc_t *, void *);
  void *dmc_data;
};

/* 8141 */
enum dtrace_dynvar_op : __int32
{
  dtrace_dynvar_op::DTRACE_DYNVAR_ALLOC = 0x0,
  dtrace_dynvar_op::DTRACE_DYNVAR_NOALLOC = 0x1,
  dtrace_dynvar_op::DTRACE_DYNVAR_DEALLOC = 0x2,
};

/* 5480 */
typedef dtrace_dynvar_op dtrace_dynvar_op_t;

/* 5481 */
typedef __darwin_intptr_t intptr_t;

/* 5482 */
typedef uint8_t uchar_t;

/* 5483 */
typedef uintptr_t dtrace_icookie_t;

/* 5484 */
typedef dof_optdesc dof_optdesc_t;

/* 5491 */
typedef uint32_t dof_secidx_t;

/* 9324 */
struct dof_optdesc
{
  uint32_t dofo_option;
  dof_secidx_t dofo_strtab;
  uint64_t dofo_value;
};

/* 5486 */
typedef dof_actdesc dof_actdesc_t;

/* 9325 */
struct dof_actdesc
{
  dof_secidx_t dofa_difo;
  dof_secidx_t dofa_strtab;
  uint32_t dofa_kind;
  uint32_t dofa_ntuple;
  uint64_t dofa_arg;
  uint64_t dofa_uarg;
};

/* 5487 */
typedef dof_difohdr dof_difohdr_t;

/* 9326 */
struct dof_difohdr
{
  dtrace_diftype_t dofd_rtype;
  dof_secidx_t dofd_links[1];
};

/* 5488 */
typedef dof_probedesc dof_probedesc_t;

/* 5493 */
typedef uint32_t dof_stridx_t;

/* 9327 */
struct dof_probedesc
{
  dof_secidx_t dofp_strtab;
  dof_stridx_t dofp_provider;
  dof_stridx_t dofp_mod;
  dof_stridx_t dofp_func;
  dof_stridx_t dofp_name;
  uint32_t dofp_id;
};

/* 5489 */
typedef dof_ecbdesc dof_ecbdesc_t;

/* 9328 */
struct dof_ecbdesc
{
  dof_secidx_t dofe_probes;
  dof_secidx_t dofe_pred;
  dof_secidx_t dofe_actions;
  uint32_t dofe_pad;
  uint64_t dofe_uarg;
};

/* 5490 */
typedef dof_probe dof_probe_t;

/* 9329 */
struct dof_probe
{
  uint64_t dofpr_addr;
  dof_stridx_t dofpr_func;
  dof_stridx_t dofpr_name;
  dof_stridx_t dofpr_nargv;
  dof_stridx_t dofpr_xargv;
  uint32_t dofpr_argidx;
  uint32_t dofpr_offidx;
  uint8_t dofpr_nargc;
  uint8_t dofpr_xargc;
  uint16_t dofpr_noffs;
  uint32_t dofpr_enoffidx;
  uint16_t dofpr_nenoffs;
  uint16_t dofpr_pad1;
  uint32_t dofpr_pad2;
};

/* 5492 */
typedef uint32_t dof_attr_t;

/* 5494 */
typedef dof_provider dof_provider_t;

/* 8148 */
struct dof_provider
{
  dof_secidx_t dofpv_strtab;
  dof_secidx_t dofpv_probes;
  dof_secidx_t dofpv_prargs;
  dof_secidx_t dofpv_proffs;
  dof_stridx_t dofpv_name;
  dof_attr_t dofpv_provattr;
  dof_attr_t dofpv_modattr;
  dof_attr_t dofpv_funcattr;
  dof_attr_t dofpv_nameattr;
  dof_attr_t dofpv_argsattr;
  dof_secidx_t dofpv_prenoffs;
};

/* 5495 */
typedef dof_sec dof_sec_t;

/* 8149 */
struct dof_sec
{
  uint32_t dofs_type;
  uint32_t dofs_align;
  uint32_t dofs_flags;
  uint32_t dofs_entsize;
  uint64_t dofs_offset;
  uint64_t dofs_size;
};

/* 5496 */
typedef dof_hdr dof_hdr_t;

/* 9330 */
struct dof_hdr
{
  uint8_t dofh_ident[16];
  uint32_t dofh_flags;
  uint32_t dofh_hdrsize;
  uint32_t dofh_secsize;
  uint32_t dofh_secnum;
  uint64_t dofh_secoff;
  uint64_t dofh_loadsz;
  uint64_t dofh_filesz;
  uint64_t dofh_pad;
};

/* 5497 */
typedef dtrace_helptrace dtrace_helptrace_t;

/* 8150 */
struct dtrace_helptrace
{
  dtrace_helper_action_t *dtht_helper;
  int dtht_where;
  int dtht_nlocals;
  int dtht_fault;
  int dtht_fltoffs;
  uint64_t dtht_illval;
  uint64_t dtht_locals[1];
};

/* 5498 */
typedef dtrace_aggkey dtrace_aggkey_t;

/* 8151 */
struct dtrace_aggkey
{
  uint32_t dtak_hashval;
  caddr_t dtak_data;
  dtrace_aggkey *dtak_next;
};

/* 5499 */
typedef dtrace_aggbuffer dtrace_aggbuffer_t;

/* 8152 */
struct dtrace_aggbuffer
{
  uintptr_t dtagb_hashsize;
  uintptr_t dtagb_free;
  dtrace_aggkey_t **dtagb_hash;
};

/* 5500 */
typedef uintptr_t pc_t;

/* 5501 */
typedef dtrace_rechdr dtrace_rechdr_t;

/* 9331 */
struct dtrace_rechdr
{
  dtrace_epid_t dtrh_epid;
  uint32_t dtrh_timestamp_hi;
  uint32_t dtrh_timestamp_lo;
};

/* 5506 */
struct __dev_info;

/* 5507 */
typedef struct __dev_info *dev_info_t;

/* 5508 */
typedef void kthread_t;

/* 5509 */
typedef modctl modctl_t;

/* 5510 */
typedef dtrace_helpers dtrace_helpers_t;

/* 5511 */
typedef dtrace_actdesc dtrace_actdesc_t;

/* 8156 */
struct __attribute__((aligned(8))) dtrace_actdesc
{
  dtrace_difo_t *dtad_difo;
  dtrace_actdesc *dtad_next;
  dtrace_actkind_t dtad_kind;
  uint32_t dtad_ntuple;
  uint64_t dtad_arg;
  uint64_t dtad_uarg;
  int dtad_refcnt;
};

/* 5512 */
typedef dtrace_preddesc dtrace_preddesc_t;

/* 8155 */
struct dtrace_preddesc
{
  dtrace_difo_t *dtpdd_difo;
  dtrace_predicate *dtpdd_predicate;
};

/* 5513 */
typedef dtrace_ecbdesc dtrace_ecbdesc_t;

/* 9496 */
struct dtrace_ecbdesc
{
  dtrace_actdesc_t *dted_action;
  dtrace_preddesc_t dted_pred;
  dtrace_probedesc_t dted_probe;
  uint64_t dted_uarg;
  int dted_refcnt;
  uint64_t dted_probegen;
};

/* 5514 */
typedef dtrace_enabling dtrace_enabling_t;

/* 8153 */
struct dtrace_enabling
{
  dtrace_ecbdesc_t **dten_desc;
  int dten_ndesc;
  int dten_maxdesc;
  dtrace_vstate_t *dten_vstate;
  dtrace_genid_t dten_probegen;
  dtrace_ecbdesc_t *dten_current;
  int dten_error;
  int dten_primed;
  dtrace_enabling *dten_prev;
  dtrace_enabling *dten_next;
};

/* 5516 */
typedef dtrace_toxrange dtrace_toxrange_t;

/* 8158 */
struct dtrace_toxrange
{
  uintptr_t dtt_base;
  uintptr_t dtt_limit;
};

/* 5517 */
typedef const char *dtrace_strkey_f(void *, uintptr_t);

/* 5518 */
typedef dtrace_hashbucket dtrace_hashbucket_t;

/* 8159 */
struct __attribute__((aligned(8))) dtrace_hashbucket
{
  dtrace_hashbucket *dthb_next;
  void *dthb_chain;
  int dthb_len;
};

/* 5519 */
typedef dtrace_hash dtrace_hash_t;

/* 8160 */
struct dtrace_hash
{
  dtrace_hashbucket_t **dth_tab;
  int dth_size;
  int dth_mask;
  int dth_nbuckets;
  uintptr_t dth_nextoffs;
  uintptr_t dth_prevoffs;
  dtrace_strkey_f *dth_getstr;
  uintptr_t dth_stroffs;
};

/* 5520 */
typedef dtrace_mops dtrace_mops_t;

/* 8161 */
struct dtrace_mops
{
  void (*dtms_create_probe)(void *, void *, dtrace_helper_probedesc_t *);
  void *(*dtms_provide_proc)(void *, dtrace_helper_provdesc_t *, proc *);
  void (*dtms_remove_proc)(void *, dtrace_helper_provdesc_t *, proc *);
  char *(*dtms_provider_name)(void *);
};

/* 5521 */
typedef dtrace_meta dtrace_meta_t;

/* 8162 */
struct dtrace_meta
{
  dtrace_mops_t dtm_mops;
  char *dtm_name;
  void *dtm_arg;
  uint64_t dtm_count;
};

/* 5543 */
enum NetBootImageType : __int32
{
  kNetBootImageTypeUnknown = 0x0,
  kNetBootImageTypeNFS = 0x1,
  kNetBootImageTypeHTTP = 0x2,
};

/* 5544 */
struct netboot_info
{
  in_addr client_ip;
  in_addr server_ip;
  char *server_name;
  size_t server_name_length;
  char *mount_point;
  size_t mount_point_length;
  char *image_path;
  size_t image_path_length;
  NetBootImageType image_type;
  char *second_image_path;
  size_t second_image_path_length;
};

/* 5545 */
typedef uint32_t gss_qop_t;

/* 5546 */
typedef gss_cfx_mic_token_desc_struct *gss_cfx_mic_token;

/* 8174 */
struct gss_cfx_mic_token_desc_struct
{
  uint8_t TOK_ID[2];
  uint8_t Flags;
  uint8_t Filler[5];
  uint8_t SND_SEQ[8];
};

/* 5547 */
typedef crypto_ctx *crypto_ctx_t;

/* 5552 */
typedef lucid_context *lucid_context_t;

/* 8179 */
struct krb5_key
{
  void *key_val;
  size_t key_len;
};

/* 5550 */
typedef krb5_key krb5_key_t;

/* 5551 */
struct key_schedule
{
  cccbc_ctx *enc;
  cccbc_ctx *dec;
  krb5_key_t ikeys[2];
};

/* 5558 */
struct crypto_ctx
{
  uint32_t etype;
  uint32_t flags;
  size_t mpad;
  lck_mtx_t lock;
  lucid_context_t gss_ctx;
  void *key;
  const ccdigest_info_0 *di;
  const ccmode_cbc *enc_mode;
  const ccmode_cbc *dec_mode;
  key_schedule ks;
  uint32_t digest_size;
  uint32_t keylen;
  krb5_key_t ckeys[2];
};

/* 5555 */
struct key_data_1964
{
  uint32_t sign_alg;
  uint32_t seal_alg;
};

/* 5554 */
struct key_data_4121
{
  uint32_t acceptor_subkey;
};

/* 5556 */
struct lucid_protocol
{
  uint32_t proto;
  union
  {
    key_data_1964 data_1964;
    key_data_4121 data_4121;
  } lucid_protocol_u;
};

/* 5553 */
struct lucid_key
{
  uint32_t etype;
  struct
  {
    uint32_t key_len;
    uint8_t *key_val;
  } key;
};

/* 5557 */
struct lucid_context
{
  uint32_t vers;
  uint32_t initiate;
  uint32_t endtime;
  uint64_t send_seq;
  uint64_t recv_seq;
  lucid_protocol key_data;
  lucid_key ctx_key;
};

/* 5548 */
struct gss_buffer_desc_struct
{
  size_t length;
  void *value;
};

/* 5549 */
typedef gss_buffer_desc_struct *gss_buffer_t;

/* 5559 */
struct gss_ctx_id_desc
{
  lucid_context gss_lucid_ctx;
  crypto_ctx gss_cryptor;
};

/* 5560 */
struct hmac_walker_ctx
{
  const ccdigest_info_0 *di;
  cchmac_ctx *hmac_ctx;
};

/* 5561 */
struct crypt_walker_ctx
{
  size_t length;
  const ccmode_cbc *ccmode;
  cccbc_ctx *crypt_ctx;
  cccbc_iv *iv;
};

/* 5562 */
typedef gss_ctx_id_desc *gss_ctx_id_t;

/* 9337 */
struct gss_1964_mic_token_desc_struct
{
  uint8_t TOK_ID[2];
  uint8_t Sign_Alg[2];
  uint8_t Filler[4];
};

/* 8182 */
typedef gss_1964_mic_token_desc_struct gss_1964_mic_token_desc;

/* 9336 */
struct gss_1964_wrap_token_desc_struct
{
  uint8_t TOK_ID[2];
  uint8_t Sign_Alg[2];
  uint8_t Seal_Alg[2];
  uint8_t Filler[2];
};

/* 8181 */
typedef gss_1964_wrap_token_desc_struct gss_1964_wrap_token_desc;

/* 9335 */
struct gss_1964_delete_token_desc_struct
{
  uint8_t TOK_ID[2];
  uint8_t Sign_Alg[2];
  uint8_t Filler[4];
};

/* 8180 */
typedef gss_1964_delete_token_desc_struct gss_1964_delete_token_desc;

/* 5563 */
union gss_1964_tok_type
{
  gss_1964_mic_token_desc mic_tok;
  gss_1964_wrap_token_desc wrap_tok;
  gss_1964_delete_token_desc del_tok;
};

/* 5564 */
struct nfsrv_wg_delayhash
{
  nfsrv_descript *lh_first;
};

/* 5566 */
struct nfs_exphandle
{
  uint32_t nxh_version;
  uint32_t nxh_fsid;
  uint32_t nxh_expid;
  uint16_t nxh_flags;
  uint8_t nxh_reserved;
  uint32_t nxh_fidlen;
};

/* 5567 */
struct nfs_filehandle
{
  uint32_t nfh_len;
  nfs_exphandle nfh_xh;
  unsigned __int8 nfh_fid[108];
  unsigned __int8 *nfh_fhp;
};

/* 5569 */
struct nfsrv_descript
{
  time_t nd_time;
  off_t nd_off;
  off_t nd_eoff;
  struct
  {
    nfsrv_descript *le_next;
    nfsrv_descript **le_prev;
  } nd_hash;
  struct
  {
    nfsrv_descript *le_next;
    nfsrv_descript **le_prev;
  } nd_tq;
  struct
  {
    nfsrv_descript *lh_first;
  } nd_coalesce;
  nfsm_chain nd_nmreq;
  mbuf_t nd_mrep;
  mbuf_t nd_nam;
  mbuf_t nd_nam2;
  u_int32_t nd_procnum;
  int nd_stable;
  int nd_vers;
  int nd_len;
  int nd_repstat;
  u_int32_t nd_retxid;
  timeval nd_starttime;
  nfs_filehandle nd_fh;
  uint32_t nd_sec;
  nfs_gss_svc_ctx *nd_gss_context;
  uint32_t nd_gss_seqnum;
  mbuf_t nd_gss_mb;
  kauth_cred_t nd_cr;
};

/* 5568 */
struct __attribute__((aligned(8))) nfsm_chain
{
  mbuf_t nmc_mhead;
  mbuf_t nmc_mcur;
  caddr_t nmc_ptr;
  size_t nmc_left;
  uint32_t nmc_flags;
};

/* 5605 */
typedef uint64_t gssd_cred;

/* 5604 */
typedef uint64_t gssd_ctx;

/* 5565 */
struct __attribute__((aligned(8))) nfs_gss_svc_ctx
{
  lck_mtx_t gss_svc_mtx;
  struct
  {
    nfs_gss_svc_ctx *le_next;
    nfs_gss_svc_ctx **le_prev;
  } gss_svc_entries;
  uint32_t gss_svc_handle;
  uint32_t gss_svc_refcnt;
  uint32_t gss_svc_proc;
  uid_t gss_svc_uid;
  gid_t gss_svc_gids[16];
  uint32_t gss_svc_ngroups;
  uint64_t gss_svc_incarnation;
  uint32_t gss_svc_seqmax;
  uint32_t gss_svc_seqwin;
  uint32_t *gss_svc_seqbits;
  gssd_cred gss_svc_cred_handle;
  gssd_ctx gss_svc_context;
  gss_ctx_id_t gss_svc_ctx_id;
  u_char *gss_svc_token;
  uint32_t gss_svc_tokenlen;
  uint32_t gss_svc_major;
  uint32_t gss_svc_minor;
};

/* 5570 */
struct nfsrv_sock
{
  struct
  {
    nfsrv_sock *tqe_next;
    nfsrv_sock **tqe_prev;
  } ns_chain;
  struct
  {
    nfsrv_sock *tqe_next;
    nfsrv_sock **tqe_prev;
  } ns_svcq;
  struct
  {
    nfsrv_sock *tqe_next;
    nfsrv_sock **tqe_prev;
  } ns_wgq;
  nfsrv_uc_arg *ns_ua;
  lck_rw_t ns_rwlock;
  socket_t_0 ns_so;
  mbuf_t ns_nam;
  mbuf_t ns_raw;
  mbuf_t ns_rawend;
  mbuf_t ns_rec;
  mbuf_t ns_recend;
  mbuf_t ns_frag;
  int ns_flag;
  int ns_sotype;
  size_t ns_cc;
  size_t ns_reclen;
  int ns_reccnt;
  u_int32_t ns_sref;
  time_t ns_timestamp;
  lck_mtx_t ns_wgmutex;
  time_t ns_wgtime;
  struct
  {
    nfsrv_descript *lh_first;
  } ns_tq;
  nfsrv_wg_delayhash ns_wdelayhashtbl[16];
};

/* 5571 */
struct __attribute__((aligned(8))) nfsrv_uc_arg
{
  struct
  {
    nfsrv_uc_arg *tqe_next;
    nfsrv_uc_arg **tqe_prev;
  } nua_svcq;
  socket_t_0 nua_so;
  nfsrv_sock *nua_slp;
  int nua_waitflag;
  uint32_t nua_flags;
  uint32_t nua_qi;
};

/* 5572 */
struct nfsrv_uc_q
{
  nfsrv_uc_arg *tqh_first;
  nfsrv_uc_arg **tqh_last;
};

/* 5573 */
struct __attribute__((aligned(8))) nfsrv_uc_queue
{
  lck_mtx_t ucq_lock;
  nfsrv_uc_q ucq_queue[1];
  thread_t_0 ucq_thd;
  uint32_t ucq_flags;
};

/* 5574 */
struct user_nfs_export_args
{
  uint32_t nxa_fsid;
  uint32_t nxa_expid;
  user_addr_t_0 nxa_fspath;
  user_addr_t_0 nxa_exppath;
  uint32_t nxa_flags;
  uint32_t nxa_netcount;
  user_addr_t_0 nxa_nets;
};

/* 8184 */
enum xdrbuf_type : __int32
{
  xdrbuf_type::XDRBUF_NONE = 0x0,
  xdrbuf_type::XDRBUF_BUFFER = 0x1,
};

/* 5575 */
struct xdrbuf
{
  union
  {
    struct
    {
      char *xbb_base;
      size_t xbb_size;
      size_t xbb_len;
    } xb_buffer;
  } xb_u;
  char *xb_ptr;
  size_t xb_left;
  size_t xb_growsize;
  xdrbuf_type xb_type;
  uint32_t xb_flags;
};

/* 5576 */
enum nfstype : __int32
{
  NFNON = 0x0,
  NFREG = 0x1,
  NFDIR = 0x2,
  NFBLK = 0x3,
  NFCHR = 0x4,
  NFLNK = 0x5,
  NFSOCK = 0x6,
  NFFIFO = 0x7,
  NFATTRDIR = 0x8,
  NFNAMEDATTR = 0x9,
};

/* 5577 */
struct nfs_user_stat_hashtbl_head
{
  nfs_user_stat_node *lh_first;
};

/* 5578 */
struct nfs_user_stat_node
{
  struct
  {
    nfs_user_stat_node *tqe_next;
    nfs_user_stat_node **tqe_prev;
  } lru_link;
  struct
  {
    nfs_user_stat_node *le_next;
    nfs_user_stat_node **le_prev;
  } hash_link;
  uid_t uid;
  sockaddr_storage sock;
  uint64_t ops;
  uint64_t bytes_read;
  uint64_t bytes_written;
  time_t tm_start;
  time_t tm_last;
};

/* 5579 */
struct nfs_user_stat_lru_head
{
  nfs_user_stat_node *tqh_first;
  nfs_user_stat_node **tqh_last;
};

/* 5580 */
struct nfsstatcount64
{
  uint32_t hi;
  uint32_t lo;
};

/* 5581 */
struct nfs_exportfs
{
  struct
  {
    nfs_exportfs *le_next;
    nfs_exportfs **le_prev;
  } nxfs_next;
  uint32_t nxfs_id;
  char *nxfs_path;
  struct
  {
    nfs_export *lh_first;
  } nxfs_exports;
};

/* 5586 */
struct nfs_sec
{
  int count;
  uint32_t flavors[5];
};

/* 5587 */
struct nfs_export_options
{
  uint32_t nxo_flags;
  kauth_cred_t nxo_cred;
  nfs_sec nxo_sec;
};

/* 5583 */
struct nfs_export_stat_counters
{
  nfsstatcount64 ops;
  nfsstatcount64 bytes_read;
  nfsstatcount64 bytes_written;
};

/* 5582 */
struct nfs_active_user_list
{
  nfs_user_stat_lru_head user_lru;
  nfs_user_stat_hashtbl_head user_hashtbl[16];
  uint32_t node_count;
  lck_mtx_t user_mutex;
};

/* 5584 */
struct nfs_export
{
  struct
  {
    nfs_export *le_next;
    nfs_export **le_prev;
  } nx_next;
  struct
  {
    nfs_export *le_next;
    nfs_export **le_prev;
  } nx_hash;
  nfs_export *nx_parent;
  uint32_t nx_id;
  uint32_t nx_flags;
  nfs_exportfs *nx_fs;
  char *nx_path;
  nfs_filehandle nx_fh;
  nfs_export_options nx_defopt;
  uint32_t nx_expcnt;
  radix_node_head *nx_rtable[42];
  nfs_export_stat_counters nx_stats;
  nfs_active_user_list nx_user_list;
  timeval nx_exptime;
};

/* 5585 */
struct nfsrv_free_netopt_arg
{
  uint32_t *cnt;
  radix_node_head *rnh;
};

/* 5588 */
struct nfs_netopt
{
  radix_node no_rnodes[2];
  nfs_export_options no_opt;
  sockaddr *no_addr;
  sockaddr *no_mask;
};

/* 5589 */
union nethostaddr
{
  in_addr_t had_inetaddr;
  in6_addr_0 had_inet6addr;
  mbuf_t had_nam;
};

/* 5590 */
struct __attribute__((aligned(4))) nfsrvcache
{
  struct
  {
    nfsrvcache *tqe_next;
    nfsrvcache **tqe_prev;
  } rc_lru;
  struct
  {
    nfsrvcache *le_next;
    nfsrvcache **le_prev;
  } rc_hash;
  u_int32_t rc_xid;
  union
  {
    mbuf_t ru_repmb;
    int ru_repstat;
  } rc_un;
  sa_family_t rc_family;
  nethostaddr rc_haddr;
  u_int32_t rc_proc;
  u_char rc_state;
  u_char rc_flag;
};

/* 5591 */
struct nfsrv_reqcache_hash
{
  nfsrvcache *lh_first;
};

/* 5592 */
struct nfsd
{
  struct
  {
    nfsd *tqe_next;
    nfsd **tqe_prev;
  } nfsd_chain;
  struct
  {
    nfsd *tqe_next;
    nfsd **tqe_prev;
  } nfsd_queue;
  int nfsd_flag;
  nfsrv_sock *nfsd_slp;
  nfsrv_descript *nfsd_nd;
};

/* 5594 */
struct nfsrv_fmod
{
  struct
  {
    nfsrv_fmod *le_next;
    nfsrv_fmod **le_prev;
  } fm_link;
  vnode_t fm_vp;
  vfs_context fm_context;
  uint64_t fm_deadline;
};

/* 5595 */
struct nfsrv_fmod_hashhead
{
  nfsrv_fmod *lh_first;
};

/* 5596 */
typedef int (*nfsrv_proc_t)(nfsrv_descript *, nfsrv_sock *, vfs_context_t, mbuf_t *);

/* 5597 */
struct nfsrv_export_hashhead
{
  nfs_export *lh_first;
};

/* 5599 */
struct nfs_gss_svc_ctx_hashhead
{
  nfs_gss_svc_ctx *lh_first;
};

/* 5600 */
struct nfssvc_args
{
  int flag;
  char flag_r_[4];
  user_addr_t_0 argp;
  char argp_r_[];
};

/* 5601 */
struct fhopen_args
{
  user_addr_t_0 u_fhp;
  int flags;
  char flags_r_[4];
};

/* 5602 */
struct getfh_args
{
  user_addr_t_0 fname;
  user_addr_t_0 fhp;
  char fhp_r_[];
};

/* 5603 */
struct nfs_hooks_out
{
  void *(*f_get_bsdthreadtask_info)(thread_t_0);
};

/* 5628 */
struct t8020dart_ppl_tunable_t
{
  uint32_t offset;
  uint32_t mask;
  uint32_t value;
};

/* 8191 */
enum t8020dart_reg_lock : __int32
{
  t8020dart_reg_lock::DART_REG_LOCK_UNINITIALIZED = 0xFFFFFFFE,
  t8020dart_reg_lock::DART_REG_LOCK_NOT_SUPPORTED = 0xFFFFFFFF,
  t8020dart_reg_lock::DART_REG_LOCK_SUPPORTED_UNLOCKED = 0x0,
  t8020dart_reg_lock::DART_REG_LOCK_SUPPORTED_LOCKED = 0x1,
};

/* 5629 */
typedef t8020dart_reg_lock t8020dart_reg_lock_t;

/* 5626 */
struct t8020dart_smmu_data
{
  volatile uint32_t *registerBase;
  t8020dart_ppl_tunable_t smmuTunables[1];
  uint32_t numberOfSmmuTunables;
  uint32_t shadowPerfCtr;
  t8020dart_reg_lock_t regLock;
};

/* 5627 */
struct t8020dart_apf_init_data
{
  uint32_t apfConfig;
  uint32_t apfSid;
  uint32_t apfStartLsb;
  uint32_t apfStartMsb;
  uint32_t apfEndLsb;
  uint32_t apfEndMsb;
};

/* 5630 */
struct t8020dart_dart_data
{
  volatile uint32_t *registerBase;
  volatile uint32_t *apfRegisterBase;
  t8020dart_ppl_tunable_t dartTunables[21];
  t8020dart_apf_init_data apfInitData[16];
  uint32_t numberOfDartTunables;
  uint32_t numberOfApfs;
  uint32_t shadowSidValid;
  uint32_t shadowSidValidHi;
  uint32_t shadowPerfSidEnable;
  uint32_t shadowPerfSidEnableHi;
  uint32_t shadowTLBHitCtr;
  uint32_t shadowTLBMissCtr;
  uint32_t shadowSTHitCtr;
  uint32_t shadowSTMissCtr;
  uint32_t shadowSidConfig[64];
  t8020dart_reg_lock_t regLock;
};

/* 5634 */
typedef uint64_t t8020dart_tte_t;

/* 5631 */
struct t8020dart_mapper_data
{
  t8020dart_tte_t ttbrs[4];
  uint32_t npages;
  void *pagetableCarveout;
  pmap_paddr_t pagetableCarveoutStart;
  pmap_paddr_t pagetableCarveoutEnd;
  size_t pagetableCarveoutSize;
  size_t carveoutTTBOffset;
};

/* 5632 */
union t8020dart_remap_reg_t
{
  uint32_t reg[16];
  uint8_t sid[64];
};

/* 5633 */
struct __attribute__((aligned(4))) t8020dart_ppl
{
  ppl_iommu_state super;
  uint64_t version;
  t8020dart_mapper_data mapperData[64];
  t8020dart_dart_data darts[3];
  t8020dart_smmu_data smmus[2];
  t8020dart_remap_reg_t remap;
  const uint64_t *ttIndexMask;
  const uint32_t *ttIndexShift;
  pmap_paddr_t dummyPagetable;
  uint64_t maxDVA;
  uint64_t maxPA;
  uint64_t sidMask;
  uint64_t sidMaskRegOverride;
  uint64_t dartBypassMask;
  uint64_t apfBypassMask;
  uint32_t numDARTs;
  uint32_t numSMMUs;
  uint32_t maxSIDs;
  uint32_t dart_blk_sid_valid_offset;
  uint32_t dart_blk_tlb_config_offset;
  uint32_t dart_blk_ttbr_offset;
  uint32_t dart_blk_perf_status_offset;
  uint32_t pageShift;
  uint32_t pageSize;
  uint32_t pageMask;
  uint32_t pageRatio;
  uint32_t diagConfig;
  uint32_t smmuDiagConfig;
  uint32_t smmuPerfConfig;
  uint8_t bypassAddrs[64];
  uint8_t regionCheckShift;
  bool retention;
  bool perfCountersEnabled;
  bool negativeTlbCaching;
  bool flushPTE;
  bool rgnProtEnabled;
  bool dynamicSIDAssignment;
  bool persistentMappingsPresent;
  bool ignoreInconsistentHwLocks;
  bool remapSIDs;
  bool neverLock;
  bool realtime;
  bool allowPteRemap;
  uint8_t power_state;
};

/* 5636 */
typedef uint64_t kpc_config_t;

/* 5635 */
struct kpc_config_remote
{
  uint32_t classes;
  kpc_config_t *configv;
  uint64_t pmc_mask;
};

/* 5637 */
struct kpc_running_remote
{
  uint32_t classes;
  uint64_t cfg_target_mask;
  uint64_t cfg_state_mask;
};

/* 5638 */
typedef cpu_data cpu_data_t;

/* 7108 */
typedef uint32_t ast_t;

/* 6838 */
typedef void (*cache_dispatch_t)(cpu_id_t_0, unsigned int, unsigned int, unsigned int);

/* 9010 */
struct mpqueue_head
{
  queue_entry_0 head;
  priority_queue_deadline_min mpq_pqhead;
  uint64_t earliest_soft_deadline;
  uint64_t count;
  lck_ticket_t_0 lock_data;
};

/* 5645 */
typedef mpqueue_head mpqueue_head_t;

/* 9343 */
struct __attribute__((aligned(8))) rtclock_timer
{
  mpqueue_head_t queue;
  uint64_t deadline;
  _BYTE gap40[8];
};

/* 5711 */
typedef rtclock_timer rtclock_timer_t;

/* 5650 */
typedef arm_debug_aggregate_state arm_debug_state_t;

/* 5710 */
struct cpu_stat_t
{
  uint64_t irq_ex_cnt;
  uint64_t irq_ex_cnt_wake;
  uint64_t ipi_cnt;
  uint64_t ipi_cnt_wake;
  uint64_t timer_cnt;
  uint64_t undef_ex_cnt;
  uint64_t unaligned_cnt;
  uint64_t vfp_cnt;
  uint64_t data_ex_cnt;
  uint64_t instr_ex_cnt;
};

/* 5643 */
typedef pv_entry pv_entry_t;

/* 5644 */
struct __attribute__((aligned(8))) pv_free_list_t
{
  pv_entry_t *list;
  uint32_t count;
};

/* 5709 */
struct __attribute__((aligned(2))) pmap_cpu_data
{
  pmap_t cpu_nested_pmap;
  uint64_t commpage_page_shift;
  const page_table_attr *cpu_nested_pmap_attr;
  vm_map_address_t cpu_nested_region_addr;
  vm_map_offset_t cpu_nested_region_size;
  unsigned int cpu_number;
  bool copywindow_strong_sync[4];
  bool inflight_disconnect;
  pv_free_list_t pv_free;
  pv_entry_t *pv_free_spill_marker;
  uint8_t cpu_sw_asids[255];
};

/* 5708 */
typedef arm_thread_state64_t dbgwrap_thread_state_t;

/* 5825 */
struct __attribute__((aligned(16))) cpu_data
{
  short cpu_number;
  unsigned __int16 cpu_flags;
  int cpu_type;
  int cpu_subtype;
  int cpu_threadtype;
  vm_offset_t istackptr;
  vm_offset_t intstack_top;
  vm_offset_t excepstackptr;
  vm_offset_t excepstack_top;
  thread_t_0 cpu_active_thread;
  vm_offset_t cpu_active_stack;
  cpu_id_t_0 cpu_id;
  volatile unsigned int cpu_signal;
  ast_t cpu_pending_ast;
  cache_dispatch_t cpu_cache_dispatch;
  uint64_t cpu_base_timebase;
  uint64_t cpu_timebase;
  bool cpu_hibernate;
  bool cpu_running;
  bool cluster_master;
  bool sync_on_cswitch;
  bool in_state_transition;
  uint32_t cpu_decrementer;
  get_decrementer_t cpu_get_decrementer_func;
  set_decrementer_t cpu_set_decrementer_func;
  fiq_handler_t cpu_get_fiq_handler;
  void *cpu_tbd_hardware_addr;
  void *cpu_tbd_hardware_val;
  processor_idle_t_0 cpu_idle_notify;
  uint64_t cpu_idle_latency;
  uint64_t cpu_idle_pop;
  vm_offset_t cpu_reset_handler;
  uintptr_t cpu_reset_assist;
  uint32_t cpu_reset_type;
  unsigned int interrupt_source;
  void *cpu_int_state;
  IOInterruptHandler_0 interrupt_handler;
  void *interrupt_nub;
  void *interrupt_target;
  void *interrupt_refCon;
  idle_timer_t_0 idle_timer_notify;
  void *idle_timer_refcon;
  uint64_t idle_timer_deadline;
  uint64_t rtcPop;
  rtclock_timer_t rtclock_timer;
  _rtclock_data_ *rtclock_datap;
  arm_debug_state_t *cpu_user_debug;
  vm_offset_t cpu_debug_interface_map;
  volatile int debugger_active;
  volatile int PAB_active;
  void *cpu_xcall_p0;
  void *cpu_xcall_p1;
  void *cpu_imm_xcall_p0;
  void *cpu_imm_xcall_p1;
  vm_offset_t coresight_base[4];
  uint64_t cpu_regmap_paddr;
  uint32_t cpu_phys_id;
  uint32_t cpu_l2_access_penalty;
  platform_error_handler_t_0 platform_error_handler;
  int cpu_mcount_off;
  volatile unsigned int cpu_sleep_token;
  unsigned int cpu_sleep_token_last;
  cluster_type_t_0 cpu_cluster_type;
  uint32_t cpu_cluster_id;
  uint32_t cpu_l2_id;
  uint32_t cpu_l2_size;
  uint32_t cpu_l3_id;
  uint32_t cpu_l3_size;
  enum : __int32
  {
    CPU_NOT_HALTED = 0x0,
    CPU_HALTED = 0x1,
    CPU_HALTED_WITH_STATE = 0x2,
  } halt_status;
  uint64_t rop_key;
  uint64_t jop_key;
  uint64_t *cpu_kpc_buf[2];
  uint64_t *cpu_kpc_shadow;
  uint64_t *cpu_kpc_reload;
  cpu_stat_t cpu_stat;
  pmap_cpu_data cpu_pmap_cpu_data;
  dbgwrap_thread_state_t halt_state;
  uint64_t ipi_pc;
  uint64_t ipi_lr;
  uint64_t ipi_fp;
};

/* 8097 */
struct mach_timebase_info
{
  uint32_t numer;
  uint32_t denom;
};

/* 5740 */
typedef mach_timebase_info mach_timebase_info_data_t;

/* 7273 */
struct tbd_ops
{
  fiq_handler_t tbd_fiq_handler;
  get_decrementer_t tbd_get_decrementer;
  set_decrementer_t tbd_set_decrementer;
};

/* 5739 */
typedef tbd_ops tbd_ops_data_t;

/* 5741 */
struct _rtclock_data_
{
  uint32_t rtc_sec_divisor;
  uint32_t rtc_usec_divisor;
  mach_timebase_info_data_t rtc_timebase_const;
  union
  {
    uint64_t abstime;
    struct
    {
      uint32_t low;
      uint32_t high;
    } abstime_val;
  } rtc_base;
  union
  {
    uint64_t abstime;
    struct
    {
      uint32_t low;
      uint32_t high;
    } abstime_val;
  } rtc_adj;
  tbd_ops_data_t rtc_timebase_func;
  vm_offset_t rtc_timebase_addr;
  vm_offset_t rtc_timebase_val;
};

/* 7091 */
struct arm_debug_state32
{
  __uint32_t bvr[16];
  __uint32_t bcr[16];
  __uint32_t wvr[16];
  __uint32_t wcr[16];
  __uint64_t mdscr_el1;
};

/* 5649 */
typedef arm_debug_state32 arm_debug_state32_t;

/* 9130 */
struct arm_debug_state64
{
  __uint64_t bvr[16];
  __uint64_t bcr[16];
  __uint64_t wvr[16];
  __uint64_t wcr[16];
  __uint64_t mdscr_el1;
};

/* 5648 */
typedef arm_debug_state64 arm_debug_state64_t;

/* 9362 */
struct __attribute__((aligned(16))) arm_debug_aggregate_state
{
  arm_state_hdr_t dsh;
  union
  {
    arm_debug_state32_t ds32;
    arm_debug_state64_t ds64;
  } uds;
  os_refcnt_t ref;
};

/* 8194 */
struct pv_entry
{
  pv_entry *pve_next;
  pt_entry_t *pve_ptep[2];
};

/* 5639 */
typedef cpu_data_entry cpu_data_entry_t;

/* 9342 */
struct cpu_data_entry
{
  void *cpu_data_paddr;
  cpu_data *cpu_data_vaddr;
};

/* 5640 */
struct kdp_hdr_t
{
  _BYTE gap0[4];
  unsigned int key;
};

/* 5641 */
struct __attribute__((packed)) __attribute__((aligned(2))) kdp_readphysmem64_req_t
{
  kdp_hdr_t hdr;
  uint64_t address;
  uint32_t nbytes;
  uint16_t lcpu;
};

/* 5642 */
typedef arm_kernel_saved_state arm_kernel_saved_state_t;

/* 5744 */
struct __attribute__((aligned(8))) arm_kernel_saved_state
{
  uint64_t x[10];
  uint64_t fp;
  uint64_t lr;
  uint64_t sp;
  uint8_t pc_was_in_userspace;
  uint8_t ssbs;
  uint8_t dit;
  uint8_t uao;
};

/* 5646 */
struct thread_qos_override
{
  thread_qos_override *override_next;
  uint32_t override_contended_resource_count;
  int16_t override_qos;
  int16_t override_resource_type;
  user_addr_t_0 override_resource;
};

/* 5647 */
struct affinity_set
{
  affinity_space *aset_space;
  queue_chain_t_0 aset_affinities;
  queue_head_t_0 aset_threads;
  uint32_t aset_thread_count;
  uint32_t aset_tag;
  uint32_t aset_num;
  processor_set_t aset_pset;
};

/* 6841 */
struct affinity_space
{
  lck_mtx_t_0 aspc_lock;
  uint32_t aspc_task_count;
  queue_head_t_0 aspc_affinities;
};

/* 5651 */
typedef arm_neon_saved_state arm_neon_saved_state_t;

/* 5653 */
struct __attribute__((aligned(16))) arm_neon_saved_state32
{
  union
  {
    uint128_t q[16];
    uint64_t d[32];
    uint32_t s[32];
  } v;
  uint32_t fpsr;
  uint32_t fpcr;
};

/* 5654 */
struct arm_neon_saved_state
{
  arm_state_hdr_t nsh;
  union
  {
    arm_neon_saved_state32 ns_32;
    arm_neon_saved_state64 ns_64;
  } uns;
};

/* 5655 */
typedef arm_context arm_context_t;

/* 9344 */
struct arm_context
{
  arm_saved_state ss;
  arm_neon_saved_state ns;
};

/* 5656 */
struct perfcontrol_state
{
  uint64_t opaque[8];
};

/* 5657 */
struct waitq_set
{
  struct
  {
    _BYTE gap0[4];
  };
  hw_lck_ticket_t wqset_interlock;
  union
  {
    circle_queue_head_t wqset_queue;
    priority_queue_sched_max wqset_prio_queue;
    turnstile *wqset_ts;
  };
  union
  {
    circle_queue_head_t wqset_links;
    waitq_link_list_t wqset_sellinks;
    void *wqset_inheritor;
    mpsc_queue_chain wqset_defer;
  };
  circle_queue_head_t wqset_preposts;
};

/* 5661 */
struct io_stat_entry
{
  uint64_t count;
  uint64_t size;
};

/* 5662 */
struct io_stat_info
{
  io_stat_entry disk_reads;
  io_stat_entry io_priority[4];
  io_stat_entry paging;
  io_stat_entry metadata;
  io_stat_entry total_io;
};

/* 5663 */
struct proc_persona_info
{
  uint64_t unique_pid;
  int32_t pid;
  uint32_t flags;
  uint32_t pidversion;
  uint32_t persona_id;
  uint32_t uid;
  uint32_t gid;
  uint8_t macho_uuid[16];
};

/* 5664 */
struct bank_element
{
  _BYTE gap0[4];
  os_ref_atomic_t be_refs;
  unsigned int be_made;
};

/* 5665 */
struct bank_task
{
  bank_element bt_elem;
  proc_persona_info bt_proc_persona;
  ledger_t bt_ledger;
  queue_head_t_0 bt_accounts_to_pay;
  queue_head_t_0 bt_accounts_to_charge;
  lck_mtx_t_0 bt_acc_to_pay_lock;
  lck_mtx_t_0 bt_acc_to_charge_lock;
  uint32_t bt_persona_uid;
  uint64_t bt_rsrc_coal_id;
  thread_group *bt_thread_group;
};

/* 5668 */
struct __attribute__((aligned(8))) task_watchport_elem
{
  task_t_0 twe_task;
  ipc_port_t_1 twe_port;
  _BYTE gap10[8];
};

/* 5669 */
struct task_watchports
{
  os_refcnt_t tw_refcount;
  task_t_0 tw_task;
  thread_t_0 tw_thread;
  uint32_t tw_elem_array_count;
  task_watchport_elem tw_elem[];
};

/* 5671 */
typedef _vmobject_list_output_ *vmobject_list_output_t;

/* 5672 */
struct _cpu_time_qos_stats
{
  uint64_t cpu_time_qos_default;
  uint64_t cpu_time_qos_maintenance;
  uint64_t cpu_time_qos_background;
  uint64_t cpu_time_qos_utility;
  uint64_t cpu_time_qos_legacy;
  uint64_t cpu_time_qos_user_initiated;
  uint64_t cpu_time_qos_user_interactive;
};

/* 5673 */
struct task_writes_counters
{
  uint64_t task_immediate_writes;
  uint64_t task_deferred_writes;
  uint64_t task_invalidated_writes;
  uint64_t task_metadata_writes;
};

/* 5674 */
typedef io_stat_info *io_stat_info_t;

/* 5675 */
struct task_effective_policy
{
  _BYTE gap0[8];
};

/* 5676 */
struct task_requested_policy
{
  _BYTE gap0[8];
};

/* 5677 */
typedef vm_extmod_statistics vm_extmod_statistics_data_t;

/* 8199 */
struct vm_extmod_statistics
{
  int64_t task_for_pid_count;
  int64_t task_for_pid_caller_count;
  int64_t thread_creation_count;
  int64_t thread_creation_caller_count;
  int64_t thread_set_state_count;
  int64_t thread_set_state_caller_count;
};

/* 5678 */
struct arm64_uexc_region_t
{
  uint64_t start;
  uint64_t end;
  uint64_t handler;
  uint64_t refcon;
};

/* 5679 */
struct recount_task
{
  recount_track *rtk_lifetime;
  recount_usage *rtk_terminated;
};

/* 8263 */
typedef struct thread *thread_t_1;

/* 5682 */
struct ipc_mqueue
{
  circle_queue_head_t imq_messages;
  mach_port_seqno_t imq_seqno;
  mach_port_name_t_0 imq_receiver_name;
  uint16_t imq_msgcount;
  uint16_t imq_qlimit;
  uint32_t imq_context;
  union
  {
    klist imq_klist;
    knote *imq_inheritor_knote;
    turnstile *imq_inheritor_turnstile;
    thread_t_1 imq_inheritor_thread_ref;
    thread_t_1 imq_srp_owner_thread;
  };
};

/* 5697 */
typedef ipc_voucher *ipc_voucher_t;

/* 5698 */
struct thread_effective_policy
{
  _BYTE gap0[8];
};

/* 5699 */
struct thread_requested_policy
{
  _BYTE gap0[8];
};

/* 5700 */
typedef timer_call *timer_call_t;

/* 5701 */
typedef ipc_object *ipc_object_t;

/* 5702 */
typedef affinity_set *affinity_set_t;

/* 5703 */
struct recount_thread
{
  recount_track *rth_lifetime;
};

/* 5704 */
typedef timer timer_data_t;

/* 5705 */
struct machine_thread
{
  arm_context_t *contextData;
  _BYTE gap8[8];
  arm_neon_saved_state_t *uNeon;
  arm_saved_state_t *kpcb;
  long x86_64_compat;
  uint64_t recover_far;
  arm_debug_state_t *DebugData;
  vm_address_t_0 cthread_self;
  uint32_t recover_esr;
  uint32_t arm_machine_flags;
  vm_offset_t kstackptr;
  perfcontrol_state perfctrl_state;
  vm_offset_t pcpu_data_base;
  cpu_data *CpuDatap;
  unsigned int preemption_count;
  uint16_t exception_trace_code;
  uint64_t rop_pid;
  uint64_t jop_pid;
};

/* 5706 */
typedef thread_rr_state thread_rr_state_t;

/* 8195 */
union thread_rr_state
{
  uint32_t trr_value;
  struct
  {
    uint8_t trr_fault_state;
    uint8_t trr_sync_waiting;
    uint16_t trr_ipi_ack_pending;
  };
};

/* 5707 */
union waitq_t
{
  waitq *wq_q;
  waitq_set *wqs_set;
  select_set *wqs_sel;
};

/* 5713 */
struct kdp_hostinfo_t
{
  uint32_t cpus_mask;
  uint32_t cpu_type;
  uint32_t cpu_subtype;
};

/* 5714 */
struct kdp_exception_ack_t
{
  kdp_hdr_t hdr;
};

/* 5715 */
struct kdp_exc_info_t
{
  uint32_t cpu;
  uint32_t exception;
  uint32_t code;
  uint32_t subcode;
};

/* 5716 */
struct kdp_exception_t
{
  kdp_hdr_t hdr;
  uint32_t n_exc_info;
  kdp_exc_info_t exc_info[];
};

/* 5725 */
struct commpage_timeofday_data
{
  uint64_t TimeStamp_tick;
  uint64_t TimeStamp_sec;
  uint64_t TimeStamp_frac;
  uint64_t Ticks_scale;
  uint64_t Ticks_per_sec;
};

/* 5726 */
typedef volatile commpage_timeofday_data new_commpage_timeofday_data_t;

/* 5723 */
struct x86_64_commpage_t
{
  uint8_t signature[16];
  uint64_t cpu_capabilities64;
  uint8_t _unused[6];
  uint16_t version;
  uint32_t cpu_capabilities;
  uint8_t _unused0[2];
  uint16_t cache_linesize;
  volatile uint32_t sched_gen;
  volatile uint32_t memory_pressure;
  volatile uint32_t spin_count;
  volatile uint8_t active_cpus;
  uint8_t physical_cpus;
  uint8_t logical_cpus;
  uint8_t _unused1[1];
  uint64_t memory_size;
  uint32_t cpufamily;
  volatile uint32_t kdebug_enable;
  volatile uint32_t atm_diagnostic_config;
  uint8_t cp_dtrace_dof_enabled;
  uint8_t cp_kernel_page_shift;
  uint8_t cp_user_page_shift;
  uint8_t _unused2;
  volatile struct
  {
    uint64_t nt_tsc_base;
    uint32_t nt_scale;
    uint32_t nt_shift;
    uint64_t nt_ns_base;
    uint32_t nt_generation;
    uint32_t gtod_generation;
    uint64_t gtod_ns_base;
    uint64_t gtod_sec_base;
  } time_data;
  volatile union
  {
    struct
    {
      uint64_t time;
      uint64_t time_supported;
    } _;
    uint8_t _fill[64];
  } approx;
  volatile uint64_t cont_timebase;
  volatile uint64_t boottime_usec;
  new_commpage_timeofday_data_t new_time_data;
  uint64_t unused;
  uint64_t dyld_system_flags;
  uint8_t unused2[3792];
  uint64_t arm_cpu_capabilities;
  uint8_t cp_aprr_shadow_supported;
  uint8_t user_timebase_type;
  uint8_t unused3[6];
  uint64_t cp_aprr_shadow_jit_rw;
  uint64_t cp_aprr_shadow_jit_rx;
  uint32_t unused4;
  uint32_t arm_cpufamily;
  uint64_t cp_aprr_shadow_tpro_rw;
  uint64_t cp_aprr_shadow_tpro_ro;
};

/* 5724 */
struct bt_params
{
  double rate;
  uint64_t base_local_ts;
  uint64_t base_remote_ts;
};

/* 5727 */
typedef arm_thread_state arm_thread_state32_t;

/* 5728 */
struct _ca_event_pac_thread_state_sigreturn_event
{
  ca_sstr proc_name[17];
};

/* 5729 */
struct _ca_event_pac_thread_state_exception_event
{
  ca_sstr proc_name[17];
};

/* 5730 */
typedef arm_neon_saved_state32 arm_neon_saved_state32_t;

/* 5731 */
struct __arm_pagein_state
{
  int __pagein_error;
};

/* 5732 */
typedef __arm_pagein_state arm_pagein_state_t;

/* 5733 */
typedef arm_neon_state64 arm_neon_state64_t;

/* 5734 */
typedef arm_neon_state arm_neon_state_t;

/* 8206 */
struct __attribute__((aligned(16))) arm_neon_state
{
  __uint128_t_0 q[16];
  uint32_t fpsr;
  uint32_t fpcr;
};

/* 5735 */
typedef arm_legacy_debug_state arm_legacy_debug_state_t;

/* 8207 */
struct arm_legacy_debug_state
{
  __uint32_t bvr[16];
  __uint32_t bcr[16];
  __uint32_t wvr[16];
  __uint32_t wcr[16];
};

/* 5736 */
typedef arm_unified_thread_state arm_unified_thread_state_t;

/* 9497 */
struct arm_unified_thread_state
{
  arm_state_hdr_t ash;
  union
  {
    arm_thread_state32_t ts_32;
    arm_thread_state64_t ts_64;
  } uts;
};

/* 5738 */
typedef mach_timebase_info *mach_timebase_info_t;

/* 5742 */
struct arm_debug_info_t
{
  uint32_t num_watchpoint_pairs;
  uint32_t num_breakpoint_pairs;
};

/* 5743 */
struct __attribute__((aligned(8))) arm_kernel_neon_saved_state
{
  uint64_t d[8];
  uint32_t fpcr;
};

/* 5745 */
struct __attribute__((aligned(16))) ipc_kobject_label
{
  ipc_label_t ikol_label;
};

/* 5757 */
typedef tbd_ops *tbd_ops_t;

/* 5758 */
typedef kern_return_t (*dcs_error_inject_function_t)(void *, vm_offset_t, uint64_t, uint32_t);

/* 5759 */
typedef kern_return_t (*amcc_error_inject_function_t)(void *, vm_offset_t, uint64_t, uint32_t, uint32_t, uint32_t, uint32_t, uint32_t);

/* 5760 */
typedef void (*lockdown_handler_t)(void *);

/* 5761 */
struct vm_reserved_region
{
  const char *vmrr_name;
  vm_map_offset_t vmrr_addr;
  vm_map_size_t vmrr_size;
};

/* 5762 */
struct ex_cb_state_t
{
  vm_offset_t far;
};

/* 5763 */
enum ex_cb_class_t : __int32
{
  EXCB_CLASS_ILLEGAL_INSTR_SET = 0x0,
  EXCB_CLASS_MAX = 0x1,
};

/* 5764 */
enum ex_cb_action_t : __int32
{
  EXCB_ACTION_RERUN = 0x0,
  EXCB_ACTION_NONE = 0x1,
};

/* 5765 */
typedef ex_cb_action_t (*ex_cb_t)(ex_cb_class_t, void *, const ex_cb_state_t *);

/* 5766 */
struct ex_cb_info_t
{
  ex_cb_t cb;
  void *refcon;
};

/* 5767 */
typedef lck_tktlock_pv_info *lck_tktlock_pv_info_t;

/* 5768 */
struct __attribute__((aligned(8))) lck_tktlock_pv_info
{
  void *ltpi_lck;
  uint8_t ltpi_wt;
};

/* 5769 */
struct __attribute__((aligned(8))) kern_work_interval_args
{
  uint64_t work_interval_id;
  uint64_t start;
  uint64_t finish;
  uint64_t deadline;
  uint64_t next_start;
  uint32_t notify_flags;
  uint32_t create_flags;
  uint16_t urgency;
};

/* 5789 */
typedef perfcontrol_state *perfcontrol_state_t;

/* 5788 */
typedef going_off_core *going_off_core_t;

/* 8231 */
typedef void (*sched_perfcontrol_offcore_t)(perfcontrol_state_t, going_off_core_t, boolean_t);

/* 8230 */
typedef void (*sched_perfcontrol_context_switch_t)(perfcontrol_state_t, perfcontrol_state_t);

/* 5786 */
typedef going_on_core *going_on_core_t;

/* 8229 */
typedef void (*sched_perfcontrol_oncore_t)(perfcontrol_state_t, going_on_core_t);

/* 5782 */
typedef perfcontrol_max_runnable_latency *perfcontrol_max_runnable_latency_t;

/* 8228 */
typedef void (*sched_perfcontrol_max_runnable_latency_t)(perfcontrol_max_runnable_latency_t);

/* 5780 */
typedef perfcontrol_work_interval *perfcontrol_work_interval_t;

/* 8227 */
typedef void (*sched_perfcontrol_work_interval_notify_t)(perfcontrol_state_t, perfcontrol_work_interval_t);

/* 5784 */
typedef thread_group_data *thread_group_data_t;

/* 8226 */
typedef void (*sched_perfcontrol_thread_group_init_t)(thread_group_data_t);

/* 8225 */
typedef void (*sched_perfcontrol_thread_group_deinit_t)(thread_group_data_t);

/* 8224 */
typedef void (*sched_perfcontrol_deadline_passed_t)(uint64_t);

/* 8232 */
enum perfcontrol_event : __int32
{
  perfcontrol_event::QUANTUM_EXPIRY = 0x1,
  perfcontrol_event::THREAD_GROUP_UPDATE = 0x2,
  perfcontrol_event::PERFCONTROL_ATTR_UPDATE = 0x3,
  perfcontrol_event::CONTEXT_SWITCH = 0xA,
  perfcontrol_event::IDLE = 0xB,
};

/* 8223 */
typedef void (*sched_perfcontrol_csw_t)(perfcontrol_event, uint32_t, uint64_t, uint32_t, perfcontrol_thread_data *, perfcontrol_thread_data *, perfcontrol_cpu_counters *, void *);

/* 8222 */
typedef void (*sched_perfcontrol_state_update_t)(perfcontrol_event, uint32_t, uint64_t, uint32_t, perfcontrol_thread_data *, void *);

/* 8221 */
typedef void (*sched_perfcontrol_thread_group_flags_update_t)(thread_group_data_t);

/* 5778 */
typedef perfcontrol_work_interval_instance *perfcontrol_work_interval_instance_t;

/* 8220 */
typedef void (*sched_perfcontrol_work_interval_ctl_t)(perfcontrol_state_t, perfcontrol_work_interval_instance_t);

/* 8219 */
typedef void (*sched_perfcontrol_thread_group_blocked_t)(thread_group_data_t, thread_group_data_t, uint32_t, perfcontrol_state_t);

/* 8218 */
typedef void (*sched_perfcontrol_thread_group_unblocked_t)(thread_group_data_t, thread_group_data_t, uint32_t, perfcontrol_state_t);

/* 5770 */
struct sched_perfcontrol_callbacks
{
  unsigned __int64 version;
  sched_perfcontrol_offcore_t offcore;
  sched_perfcontrol_context_switch_t context_switch;
  sched_perfcontrol_oncore_t oncore;
  sched_perfcontrol_max_runnable_latency_t max_runnable_latency;
  sched_perfcontrol_work_interval_notify_t work_interval_notify;
  sched_perfcontrol_thread_group_init_t thread_group_init;
  sched_perfcontrol_thread_group_deinit_t thread_group_deinit;
  sched_perfcontrol_deadline_passed_t deadline_passed;
  sched_perfcontrol_csw_t csw;
  sched_perfcontrol_state_update_t state_update;
  sched_perfcontrol_thread_group_flags_update_t thread_group_flags_update;
  sched_perfcontrol_work_interval_ctl_t work_interval_ctl;
  sched_perfcontrol_thread_group_blocked_t thread_group_blocked;
  sched_perfcontrol_thread_group_unblocked_t thread_group_unblocked;
};

/* 5787 */
struct going_off_core
{
  uint64_t thread_id;
  uint32_t energy_estimate_nj;
  uint32_t reserved;
  uint64_t end_time;
  uint64_t thread_group_id;
  void *thread_group_data;
};

/* 5785 */
struct __attribute__((aligned(8))) going_on_core
{
  uint64_t thread_id;
  uint16_t qos_class;
  uint16_t urgency;
  uint64_t thread_group_id;
  void *thread_group_data;
  uint64_t scheduling_latency;
  uint64_t start_time;
  uint64_t scheduling_latency_at_same_basepri;
  uint32_t energy_estimate_nj;
};

/* 5781 */
struct perfcontrol_max_runnable_latency
{
  uint64_t max_scheduling_latencies[4];
};

/* 5779 */
struct __attribute__((aligned(8))) perfcontrol_work_interval
{
  uint64_t thread_id;
  uint16_t qos_class;
  uint16_t urgency;
  uint32_t flags;
  uint64_t work_interval_id;
  uint64_t start;
  uint64_t finish;
  uint64_t deadline;
  uint64_t next_start;
  uint64_t thread_group_id;
  void *thread_group_data;
  uint32_t create_flags;
};

/* 5783 */
struct thread_group_data
{
  uint64_t thread_group_id;
  void *thread_group_data;
  uint32_t thread_group_size;
  uint32_t thread_group_flags;
};

/* 5775 */
struct __attribute__((aligned(32))) perfcontrol_thread_data
{
  uint32_t energy_estimate_nj;
  perfcontrol_class_t perfctl_class;
  uint64_t thread_id;
  uint64_t thread_group_id;
  uint64_t scheduling_latency_at_same_basepri;
  void *thread_group_data;
  void *perfctl_state;
};

/* 5774 */
struct perfcontrol_cpu_counters
{
  uint64_t instructions;
  uint64_t cycles;
};

/* 5776 */
enum work_interval_ctl_t : __int32
{
  WORK_INTERVAL_START = 0x0,
  WORK_INTERVAL_UPDATE = 0x1,
  WORK_INTERVAL_FINISH = 0x2,
};

/* 5777 */
struct perfcontrol_work_interval_instance
{
  work_interval_ctl_t ctl;
  uint32_t create_flags;
  uint64_t complexity;
  uint64_t thread_id;
  uint64_t work_interval_id;
  uint64_t instance_id;
  uint64_t start;
  uint64_t finish;
  uint64_t deadline;
  uint64_t thread_group_id;
  void *thread_group_data;
};

/* 5771 */
typedef sched_perfcontrol_callbacks *sched_perfcontrol_callbacks_t;

/* 5810 */
enum cache_type_t : __int32
{
  CACHE_WRITE_THROUGH = 0x0,
  CACHE_WRITE_BACK = 0x1,
  CACHE_READ_ALLOCATION = 0x2,
  CACHE_WRITE_ALLOCATION = 0x3,
  CACHE_UNKNOWN = 0x4,
};

/* 5772 */
struct cache_info_t
{
  boolean_t c_valid;
  boolean_t c_unified;
  uint32_t c_isize;
  boolean_t c_i_ppage;
  uint32_t c_dsize;
  boolean_t c_d_ppage;
  cache_type_t c_type;
  uint32_t c_linesz;
  uint32_t c_assoc;
  uint32_t c_l2size;
  uint32_t c_bulksize_op;
  uint32_t c_inner_cache_size;
};

/* 5773 */
typedef ml_cpu_info ml_cpu_info_t;

/* 5790 */
enum csselr_cache_type : __int32
{
  CSSELR_DATA_UNIFIED = 0x0,
  CSSELR_INSTR = 0x1,
};

/* 5791 */
enum csselr_cache_level : __int32
{
  CSSELR_L1 = 0x0,
  CSSELR_L2 = 0x2,
  CSSELR_L3 = 0x4,
};

/* 5792 */
enum platform_error_source_t : __int32
{
  PLAT_ERR_SRC_ASYNC = 0x0,
  PLAT_ERR_SRC_SYNC = 0x1,
};

/* 5793 */
typedef uint32_t arm64_instr_t;

/* 5794 */
struct copyio_recovery_entry
{
  ptrdiff_t cre_start;
  ptrdiff_t cre_end;
  ptrdiff_t cre_recovery;
};

/* 5795 */
typedef bool (*expected_fault_handler_t)(arm_saved_state_t *);

/* 8233 */
enum fault_status_t : __int32
{
  FSC_TRANSLATION_FAULT_L0 = 0x4,
  FSC_TRANSLATION_FAULT_L1 = 0x5,
  FSC_TRANSLATION_FAULT_L2 = 0x6,
  FSC_TRANSLATION_FAULT_L3 = 0x7,
  FSC_ACCESS_FLAG_FAULT_L1 = 0x9,
  FSC_ACCESS_FLAG_FAULT_L2 = 0xA,
  FSC_ACCESS_FLAG_FAULT_L3 = 0xB,
  FSC_PERMISSION_FAULT_L1 = 0xD,
  FSC_PERMISSION_FAULT_L2 = 0xE,
  FSC_PERMISSION_FAULT_L3 = 0xF,
  FSC_SYNC_EXT_ABORT = 0x10,
  FSC_ASYNC_EXT_ABORT = 0x11,
  FSC_SYNC_EXT_ABORT_TT_L1 = 0x15,
  FSC_SYNC_EXT_ABORT_TT_L2 = 0x16,
  FSC_SYNC_EXT_ABORT_TT_L3 = 0x17,
  FSC_SYNC_PARITY = 0x18,
  FSC_ASYNC_PARITY = 0x19,
  FSC_SYNC_PARITY_TT_L1 = 0x1D,
  FSC_SYNC_PARITY_TT_L2 = 0x1E,
  FSC_SYNC_PARITY_TT_L3 = 0x1F,
  FSC_ALIGNMENT_FAULT = 0x21,
  FSC_DEBUG_FAULT = 0x22,
};

/* 5796 */
typedef void (*abort_handler_t)(arm_saved_state_t *, uint32_t, vm_offset_t, fault_status_t, vm_prot_t, expected_fault_handler_t);

/* 5797 */
typedef void (*abort_inspector_t)(uint32_t, fault_status_t *, vm_prot_t *);

/* 5798 */
struct lowglo_0
{
  unsigned __int8 lgVerCode[8];
  uint64_t lgZero;
  uint64_t lgStext;
  uint64_t lgVersion;
  uint64_t lgOSVersion;
  uint64_t lgKmodptr;
  uint64_t lgTransOff;
  uint64_t lgRebootFlag;
  uint64_t lgManualPktAddr;
  uint64_t lgAltDebugger;
  uint64_t lgPmapMemQ;
  uint64_t lgPmapMemPageOffset;
  uint64_t lgPmapMemChainOffset;
  uint64_t lgStaticAddr;
  uint64_t lgStaticSize;
  uint64_t lgLayoutMajorVersion;
  uint64_t lgLayoutMagic;
  uint64_t lgPmapMemStartAddr;
  uint64_t lgPmapMemEndAddr;
  uint64_t lgPmapMemPagesize;
  uint64_t lgPmapMemFromArrayMask;
  uint64_t lgPmapMemFirstppnum;
  uint64_t lgPmapMemPackedShift;
  uint64_t lgPmapMemPackedBaseAddr;
  uint64_t lgLayoutMinorVersion;
  uint64_t lgPageShift;
  uint64_t lgVmFirstPhys;
  uint64_t lgVmLastPhys;
  uint64_t lgPhysMapBase;
  uint64_t lgPhysMapEnd;
  uint64_t lgPmapIoRangePtr;
  uint64_t lgNumPmapIoRanges;
  uint64_t lgCompressorBufferAddr;
  uint64_t lgCompressorSizeAddr;
};

/* 5799 */
struct DTMemoryMapRange
{
  vm_offset_t paddr;
  size_t length;
};

/* 5800 */
struct ptov_table_entry
{
  pmap_paddr_t pa;
  vm_map_address_t va;
  vm_size_t_0 len;
};

/* 5802 */
struct dyld_chained_ptr_64_kernel_cache_rebase
{
  _BYTE gap0[8];
};

/* 5803 */
union ChainedFixupPointerOnDisk
{
  uint64_t raw64;
  dyld_chained_ptr_64_kernel_cache_rebase fixup64;
};

/* 5804 */
struct dyld_chained_starts_in_segment
{
  uint32_t size;
  uint16_t page_size;
  uint16_t pointer_format;
  uint64_t segment_offset;
  uint32_t max_valid_pointer;
  uint16_t page_count;
  uint16_t page_start[1];
};

/* 5805 */
struct dyld_chained_starts_in_image
{
  uint32_t seg_count;
  uint32_t seg_info_offset[1];
};

/* 5806 */
struct dyld_chained_fixups_header
{
  uint32_t fixups_version;
  uint32_t starts_offset;
  uint32_t imports_offset;
  uint32_t symbols_offset;
  uint32_t imports_count;
  uint32_t imports_format;
  uint32_t symbols_format;
};

/* 5807 */
typedef uint64_t dbgwrap_reg_t;

/* 5808 */
struct arm_cache_ccsidr_t
{
  _BYTE gap0[4];
};

/* 5809 */
struct arm_cache_clidr_t
{
  _BYTE gap0[4];
};

/* 5811 */
struct arm_cpuid_bits_t
{
  _BYTE gap0[4];
};

/* 5812 */
struct processor_cpu_stat64
{
  uint64_t irq_ex_cnt;
  uint64_t ipi_cnt;
  uint64_t timer_cnt;
  uint64_t undef_ex_cnt;
  uint64_t unaligned_cnt;
  uint64_t vfp_cnt;
  uint64_t vfp_shortv_cnt;
  uint64_t data_ex_cnt;
  uint64_t instr_ex_cnt;
  uint64_t pmi_cnt;
};

/* 5813 */
struct processor_cpu_stat
{
  uint32_t irq_ex_cnt;
  uint32_t ipi_cnt;
  uint32_t timer_cnt;
  uint32_t undef_ex_cnt;
  uint32_t unaligned_cnt;
  uint32_t vfp_cnt;
  uint32_t vfp_shortv_cnt;
  uint32_t data_ex_cnt;
  uint32_t instr_ex_cnt;
};

/* 5814 */
typedef pmap_cpu_data pmap_cpu_data_t;

/* 5815 */
union arm_cpu_info_t
{
  arm_cpuid_bits_t arm_info;
  uint32_t value;
};

/* 5816 */
typedef page_table_attr pt_attr_t;

/* 5817 */
struct ptd_info_t
{
  unsigned __int16 refcnt;
  unsigned __int16 wiredcnt;
};

/* 5818 */
typedef pt_desc pt_desc_t;

/* 9351 */
struct pt_desc
{
  queue_chain_t_0 pt_page;
  union
  {
    pmap *pmap;
    const ppl_iommu_state *iommu;
  };
  vm_offset_t va[4];
  ptd_info_t *ptd_info;
};

/* 5819 */
typedef page_free_entry page_free_entry_t;

/* 8239 */
struct page_free_entry
{
  page_free_entry *next;
};

/* 5820 */
typedef pmap_io_filter_entry pmap_io_filter_entry_t;

/* 8240 */
struct pmap_io_filter_entry
{
  uint32_t signature;
  uint16_t offset;
  uint16_t length;
};

/* 5821 */
typedef pmap_io_range pmap_io_range_t;

/* 8241 */
struct pmap_io_range
{
  uint64_t addr;
  uint64_t len;
  uint32_t wimg;
  uint32_t signature;
};

/* 5826 */
typedef lck_spin_t *usimple_lock_t_0;

/* 7783 */
typedef int64_t register_t;

/* 5827 */
struct pmap_begin_atomic_inout
{
  pmap_paddr_t pap1;
  pmap_paddr_t pap2;
  register_t *ovv;
  pmap_paddr_t ovp;
  register_t *nvv;
  pmap_paddr_t nvp;
};

/* 5828 */
struct batch_set_cache_attr_state_t
{
  _BYTE gap0[8];
};

/* 5829 */
typedef pmap_tlb_flush_range pmap_tlb_flush_range_t;

/* 9353 */
struct __attribute__((aligned(8))) pmap_tlb_flush_range
{
  pmap_t ptfr_pmap;
  vm_map_address_t ptfr_start;
  vm_map_address_t ptfr_end;
  bool ptfr_flush_needed;
};

/* 5830 */
typedef short SInt16;

/* 5831 */
typedef tt_free_entry tt_free_entry_t;

/* 8245 */
struct tt_free_entry
{
  tt_free_entry *next;
};

/* 5835 */
typedef pmap_reserved_page pmap_reserved_page_t;

/* 8247 */
struct pmap_reserved_page
{
  pmap_reserved_page *next;
};

/* 5840 */
struct fourk_pager_backing
{
  vm_object_t backing_object;
  vm_object_offset_t backing_offset;
};

/* 5841 */
struct fourk_pager
{
  memory_object fourk_pgr_hdr;
  queue_chain_t_0 pager_queue;
  bool is_ready;
  bool is_mapped;
  fourk_pager_backing slots[4];
};

/* 5842 */
typedef fourk_pager *fourk_pager_t;

/* 5843 */
struct __attribute__((aligned(8))) pager_crypt_info
{
  int (*page_decrypt)(const void *, void *, unsigned __int64, void *);
  void (*crypt_end)(void *);
  void *crypt_ops;
  volatile int crypt_refcnt;
};

/* 5844 */
struct apple_protect_pager
{
  memory_object ap_pgr_hdr;
  queue_chain_t_0 pager_queue;
  bool is_ready;
  bool is_mapped;
  bool is_cached;
  vm_object_t backing_object;
  vm_object_offset_t backing_offset;
  vm_object_offset_t crypto_backing_offset;
  vm_object_offset_t crypto_start;
  vm_object_offset_t crypto_end;
  pager_crypt_info *crypt_info;
};

/* 5845 */
typedef apple_protect_pager *apple_protect_pager_t;

/* 5846 */
typedef uint32_t entropy_sample_t;

/* 5847 */
typedef entropy_health_test entropy_health_test_t;

/* 8252 */
typedef entropy_health_stats entropy_health_stats_t;

/* 8253 */
struct entropy_health_test
{
  entropy_sample_t init_observation;
  uint64_t observation_count;
  entropy_health_stats_t *stats;
};

/* 8254 */
struct entropy_health_stats
{
  uint32_t reset_count;
  uint32_t failure_count;
  uint32_t max_observation_count;
};

/* 5848 */
struct __attribute__((aligned(8))) ccdrbg_nisthmac_custom
{
  const ccdigest_info_0 *di;
  int strictFIPS;
};

/* 9499 */
typedef int32_t (*ccrng_fortuna_getentropy)(size_t *, void *, void *);

/* 5849 */
typedef ccrng_fortuna_getentropy cckprng_getentropy;

/* 5850 */
struct ccrng_fortuna_pool_ctx
{
  uint8_t data[32];
  uint64_t nsamples;
  uint64_t ndrains;
  uint64_t nsamples_max;
};

/* 5851 */
struct __attribute__((aligned(8))) ccrng_fortuna_sched_ctx
{
  uint64_t reseed_sched;
  unsigned int pool_idx;
};

/* 5852 */
struct ccdrbg_state;

/* 5853 */
struct cc_lock_ctx
{
  lck_mtx_t *mutex;
  lck_grp_t *group;
};

/* 5858 */
typedef ccentropy_ctx ccentropy_ctx_t;

/* 5854 */
typedef int (*ccentropy_add_entropy_fn_t)(ccentropy_ctx_t *, uint32_t, size_t, const void *);

/* 5856 */
typedef ccentropy_info ccentropy_info_t;

/* 5857 */
struct ccentropy_ctx
{
  const ccentropy_info_t *info;
};

/* 5855 */
typedef int (*ccentropy_get_seed_fn_t)(ccentropy_ctx_t *, size_t, void *);

/* 9359 */
struct ccentropy_info
{
  ccentropy_get_seed_fn_t get_seed;
  ccentropy_add_entropy_fn_t add_entropy;
};

/* 5859 */
enum ccrng_schedule_result_t : __int32
{
  CCRNG_SCHEDULE_RESEED_SUCCEEDED = 0x1,
  CCRNG_SCHEDULE_RESEED_FAILED = 0x2,
};

/* 5860 */
typedef ccrng_schedule_info ccrng_schedule_info_t;

/* 5862 */
enum ccrng_schedule_action_t : __int32
{
  CCRNG_SCHEDULE_CONTINUE = 0x1,
  CCRNG_SCHEDULE_TRY_RESEED = 0x2,
  CCRNG_SCHEDULE_MUST_RESEED = 0x3,
};

/* 5863 */
typedef ccrng_schedule_ctx ccrng_schedule_ctx_t;

/* 9360 */
struct ccrng_schedule_info
{
  ccrng_schedule_action_t (*read)(ccrng_schedule_ctx_t *);
  void (*update)(ccrng_schedule_ctx_t *, ccrng_schedule_result_t);
};

/* 5861 */
struct ccrng_schedule_ctx
{
  const ccrng_schedule_info_t *info;
};

/* 5864 */
struct __attribute__((aligned(8))) ccrng_schedule_atomic_flag_ctx
{
  ccrng_schedule_ctx_t schedule_ctx;
  ccrng_schedule_action_t flag;
};

/* 5868 */
typedef cc_lock_ctx cc_lock_ctx_t;

/* 5865 */
struct ccrng_fortuna_ctx
{
  _BYTE gap0[8];
  uint8_t key[32];
  uint8_t ctr[16];
  ccrng_fortuna_sched_ctx sched;
  cc_lock_ctx_t lock;
  ccrng_fortuna_pool_ctx pools[32];
  _BYTE gap758[8];
  void *getentropy_arg;
  bool seeded;
  uint64_t nreseeds;
  uint64_t schedreseed_nsamples_max;
  uint64_t addentropy_nsamples_max;
};

/* 5866 */
typedef ccrng_crypto_ctx ccrng_crypto_ctx_t;

/* 9358 */
struct ccrng_crypto_ctx
{
  _BYTE gap0[8];
  ccentropy_ctx_t *entropy_ctx;
  ccrng_schedule_ctx_t *schedule_ctx;
  cc_lock_ctx_t *lock_ctx;
  const ccdrbg_info *drbg_info;
  ccdrbg_state *drbg_ctx;
  size_t generate_chunk_nbytes;
  size_t seed_nbytes;
  size_t cache_nbytes;
  uint8_t *cache;
  size_t cache_pos;
};

/* 5867 */
struct ccdrbg_info
{
  size_t size;
  _BYTE gap8[32];
  const void *custom;
};

/* 5869 */
typedef ccentropy_rng_ctx ccentropy_rng_ctx_t;

/* 8256 */
struct ccentropy_rng_ctx
{
  ccentropy_ctx_t entropy_ctx;
  ccrng_state *rng_ctx;
  size_t seed_max_nbytes;
};

/* 5870 */
typedef ccrng_schedule_atomic_flag_ctx ccrng_schedule_atomic_flag_ctx_t;

/* 5871 */
struct cckprng_ctx
{
  ccrng_schedule_atomic_flag_ctx_t schedule_ctx;
  ccentropy_rng_ctx_t entropy_ctx;
  cc_lock_ctx_t lock_ctx;
  ccdrbg_info drbg_info;
  uint8_t drbg_state[1280];
  uint8_t cache[256];
  ccrng_crypto_ctx_t rng_ctx;
  ccrng_fortuna_ctx fortuna_ctx;
};

/* 5873 */
struct ccdrbg_nisthmac_state
{
  const ccdrbg_nisthmac_custom *custom;
  uint8_t key[64];
  uint8_t V[64];
  uint64_t reseed_counter;
};

/* 5874 */
typedef uintptr_t telemetry_user_frame_t;

/* 5875 */
struct __attribute__((packed)) __attribute__((aligned(4))) thread_snapshot
{
  uint32_t snapshot_magic;
  uint32_t nkern_frames;
  uint32_t nuser_frames;
  uint64_t wait_event;
  uint64_t continuation;
  uint64_t thread_id;
  uint64_t user_time;
  uint64_t system_time;
  int32_t state;
  int32_t priority;
  int32_t sched_pri;
  int32_t sched_flags;
  char ss_flags;
  char ts_qos;
  char ts_rqos;
  char ts_rqos_override;
  char io_tier;
  char _reserved[3];
  uint64_t disk_reads_count;
  uint64_t disk_reads_size;
  uint64_t disk_writes_count;
  uint64_t disk_writes_size;
  uint64_t io_priority_count[4];
  uint64_t io_priority_size[4];
  uint64_t paging_count;
  uint64_t paging_size;
  uint64_t non_paging_count;
  uint64_t non_paging_size;
  uint64_t data_count;
  uint64_t data_size;
  uint64_t metadata_count;
  uint64_t metadata_size;
  uint64_t voucher_identifier;
  uint64_t total_syscalls;
  char pth_name[64];
};

/* 5876 */
struct __attribute__((packed)) __attribute__((aligned(1))) task_snapshot
{
  uint32_t snapshot_magic;
  int32_t pid;
  uint64_t uniqueid;
  uint64_t user_time_in_terminated_threads;
  uint64_t system_time_in_terminated_threads;
  uint8_t shared_cache_identifier[16];
  uint64_t shared_cache_slide;
  uint32_t nloadinfos;
  int suspend_count;
  int task_size;
  int faults;
  int pageins;
  int cow_faults;
  uint32_t ss_flags;
  uint64_t p_start_sec;
  uint64_t p_start_usec;
  char p_comm[17];
  uint32_t was_throttled;
  uint32_t did_throttle;
  uint32_t latency_qos;
  uint64_t disk_reads_count;
  uint64_t disk_reads_size;
  uint64_t disk_writes_count;
  uint64_t disk_writes_size;
  uint64_t io_priority_count[4];
  uint64_t io_priority_size[4];
  uint64_t paging_count;
  uint64_t paging_size;
  uint64_t non_paging_count;
  uint64_t non_paging_size;
  uint64_t data_count;
  uint64_t data_size;
  uint64_t metadata_count;
  uint64_t metadata_size;
  uint32_t donating_pid_count;
};

/* 5877 */
struct __attribute__((packed)) __attribute__((aligned(1))) micro_snapshot
{
  uint32_t snapshot_magic;
  uint32_t ms_cpu;
  uint64_t ms_time;
  uint64_t ms_time_microsecs;
  uint8_t ms_flags;
  uint16_t ms_opaque_flags;
};

/* 5878 */
struct vc_progress_user_options
{
  uint32_t options;
  uint32_t x_pos;
  uint32_t y_pos;
  uint32_t resv[8];
};

/* 5879 */
struct console_ops
{
  void (*putc)(char, bool);
  int (*getc)(bool);
};

/* 5880 */
struct console_printbuf_state
{
  int pos;
  int total;
  int flags;
  char str[256];
};

/* 5881 */
struct kperf_thread_dispatch
{
  uint64_t kpthdi_dq_serialno;
  char kpthdi_dq_label[64];
};

/* 5882 */
struct kperf_usample_min
{
  kperf_thread_dispatch th_dispatch;
};

/* 5883 */
struct kp_ucallstack
{
  uint32_t kpuc_flags;
  uint32_t kpuc_nframes;
  uint32_t kpuc_async_index;
  uint32_t kpuc_async_nframes;
  uintptr_t kpuc_frames[256];
};

/* 5884 */
struct kpcdata
{
  int curcpu;
  uint32_t running;
  uint32_t counterc;
  uint64_t counterv[4];
  uint32_t configc;
  uint64_t configv[3];
};

/* 5891 */
struct kperf_thread_info
{
  uint64_t kpthi_pid;
  uint64_t kpthi_tid;
  uint64_t kpthi_dq_addr;
  uint64_t kpthi_runmode;
};

/* 5885 */
struct kperf_usample
{
  kperf_usample_min *usample_min;
  kp_ucallstack ucallstack;
  kperf_thread_info th_info;
};

/* 5886 */
struct meminfo
{
  uint64_t phys_footprint;
  uint64_t purgeable_volatile;
  uint64_t purgeable_volatile_compressed;
};

/* 5887 */
struct kp_kcallstack
{
  uint32_t kpkc_flags;
  uint32_t kpkc_nframes;
  union
  {
    uintptr_t kpkc_word_frames[128];
    uint64_t kpkc_frames[128];
  };
};

/* 5888 */
struct kperf_task_snapshot
{
  uint64_t kptksn_flags;
  uint64_t kptksn_user_time_in_terminated_threads;
  uint64_t kptksn_system_time_in_terminated_threads;
  int kptksn_suspend_count;
  int kptksn_pageins;
};

/* 5889 */
struct __attribute__((aligned(8))) kperf_thread_snapshot
{
  uint64_t kpthsn_last_made_runnable_time;
  int16_t kpthsn_suspend_count;
  uint8_t kpthsn_io_tier;
  uint8_t kpthsn_flags;
};

/* 5890 */
struct __attribute__((aligned(8))) kperf_thread_scheduling
{
  uint64_t kpthsc_user_time;
  uint64_t kpthsc_system_time;
  uint64_t kpthsc_runnable_time;
  unsigned int kpthsc_state;
  uint16_t kpthsc_base_priority;
  uint16_t kpthsc_sched_priority;
  _BYTE gap20[8];
};

/* 5892 */
struct kperf_sample
{
  kperf_thread_info th_info;
  kperf_thread_scheduling th_scheduling;
  kperf_thread_snapshot th_snapshot;
  kperf_task_snapshot tk_snapshot;
  kp_kcallstack kcallstack;
  meminfo meminfo;
  kperf_usample usample;
  kpcdata kpcdata;
};

/* 5893 */
struct kptimer
{
  uint32_t kt_actionid;
  uint64_t kt_period_abs;
  lck_spin_t_0 kt_lock;
  uint64_t kt_cur_deadline;
};

/* 5894 */
struct kperf_context
{
  int cur_pid;
  thread_t_0 cur_thread;
  task_t_0 cur_task;
  uintptr_t *starting_fp;
  unsigned int trigger_type;
  unsigned int trigger_id;
};

/* 5895 */
struct action
{
  uint32_t sample;
  uint32_t ucallstack_depth;
  uint32_t kcallstack_depth;
  uint32_t userdata;
  int pid_filter;
};

/* 6822 */
typedef int clock_res_t;

/* 6823 */
struct mach_timespec
{
  unsigned int tv_sec;
  clock_res_t tv_nsec;
};

/* 5957 */
typedef mach_timespec mach_timespec_t;

/* 5990 */
struct mach_msg_trailer_t
{
  mach_msg_trailer_type_t msgh_trailer_type;
  mach_msg_trailer_size_t msgh_trailer_size;
};

/* 5898 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_service_wait_quiet_with_options::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_timespec_t wait_time;
  uint32_t options;
  mach_msg_trailer_t trailer;
};

/* 5899 */
typedef __Request__io_registry_entry_get_property_bin_buf_t __Request;

/* 8351 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_registry_entry_get_property_bin_buf_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  mach_msg_type_number_t property_nameOffset;
  mach_msg_type_number_t property_nameCnt;
  char property_name[128];
  uint32_t options;
  mach_vm_address_t_0 buf;
  mach_vm_size_t_0 bufsize;
};

/* 5900 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_registry_entry_get_property_bin_buf::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  mach_msg_type_number_t property_nameOffset;
  mach_msg_type_number_t property_nameCnt;
  char property_name[128];
  uint32_t options;
  mach_vm_address_t_0 buf;
  mach_vm_size_t_0 bufsize;
  mach_msg_trailer_t trailer;
};

/* 5901 */
struct _Xio_registry_entry_get_properties_bin_buf::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 buf;
  mach_vm_size_t_0 bufsize;
  mach_msg_trailer_t trailer;
};

/* 5902 */
struct _Xio_device_tree_entry_exists_with_name::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t nameOffset;
  mach_msg_type_number_t nameCnt;
  char name[128];
  mach_msg_trailer_t trailer;
};

/* 5903 */
struct _Xio_registry_entry_from_path_ool::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t path_ool;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t pathOffset;
  mach_msg_type_number_t pathCnt;
  char path[4096];
  mach_msg_type_number_t path_oolCnt;
  mach_msg_trailer_t trailer;
};

/* 5904 */
struct _Xio_registry_entry_get_path_ool::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  mach_msg_trailer_t trailer;
};

/* 5905 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_service_add_notification_bin_64::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t notification_typeOffset;
  mach_msg_type_number_t notification_typeCnt;
  char notification_type[128];
  mach_msg_type_number_t matchingCnt;
  char matching[4096];
  mach_msg_type_number_t referenceCnt;
  io_user_reference_t_0 reference[8];
  mach_msg_trailer_t trailer;
};

/* 5906 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_service_add_notification_bin::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t notification_typeOffset;
  mach_msg_type_number_t notification_typeCnt;
  char notification_type[128];
  mach_msg_type_number_t matchingCnt;
  char matching[4096];
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
  mach_msg_trailer_t trailer;
};

/* 5907 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_service_match_property_table_bin::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingCnt;
  char matching[4096];
  mach_msg_trailer_t trailer;
};

/* 5908 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_service_get_matching_services_bin::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingCnt;
  char matching[4096];
  mach_msg_trailer_t trailer;
};

/* 5909 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_service_get_matching_service_bin::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingCnt;
  char matching[4096];
  mach_msg_trailer_t trailer;
};

/* 5910 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_registry_entry_get_property_bin::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  mach_msg_type_number_t property_nameOffset;
  mach_msg_type_number_t property_nameCnt;
  char property_name[128];
  uint32_t options;
  mach_msg_trailer_t trailer;
};

/* 5911 */
struct _Xio_registry_entry_get_properties_bin::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5912 */
struct _Xio_server_version::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5913 */
struct _Xio_service_set_authorization_id::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint64_t authorization_id;
  mach_msg_trailer_t trailer;
};

/* 5914 */
struct _Xio_service_get_authorization_id::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5915 */
struct _Xio_service_get_matching_service_ool::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t matching;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingCnt;
  mach_msg_trailer_t trailer;
};

/* 5916 */
struct _Xio_service_get_matching_service::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingOffset;
  mach_msg_type_number_t matchingCnt;
  char matching[512];
  mach_msg_trailer_t trailer;
};

/* 5924 */
typedef uint64_t io_user_scalar_t;

/* 5917 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_connect_method_var_output::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t selector;
  mach_msg_type_number_t scalar_inputCnt;
  io_user_scalar_t scalar_input[16];
  mach_msg_type_number_t inband_inputCnt;
  char inband_input[4096];
  mach_vm_address_t_0 ool_input;
  mach_vm_size_t_0 ool_input_size;
  mach_msg_type_number_t inband_outputCnt;
  mach_msg_type_number_t scalar_outputCnt;
  mach_msg_trailer_t trailer;
};

/* 5918 */
struct _Xio_registry_entry_get_registry_entry_id::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5919 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_service_add_notification_ool_64::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t matching;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t notification_typeOffset;
  mach_msg_type_number_t notification_typeCnt;
  char notification_type[128];
  mach_msg_type_number_t matchingCnt;
  mach_msg_type_number_t referenceCnt;
  io_user_reference_t_0 reference[8];
  mach_msg_trailer_t trailer;
};

/* 5920 */
struct _Xio_service_add_interest_notification_64::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t type_of_interestOffset;
  mach_msg_type_number_t type_of_interestCnt;
  char type_of_interest[128];
  mach_msg_type_number_t referenceCnt;
  io_user_reference_t_0 reference[8];
  mach_msg_trailer_t trailer;
};

/* 5921 */
struct _Xio_service_add_notification_64::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t notification_typeOffset;
  mach_msg_type_number_t notification_typeCnt;
  char notification_type[128];
  mach_msg_type_number_t matchingOffset;
  mach_msg_type_number_t matchingCnt;
  char matching[512];
  mach_msg_type_number_t referenceCnt;
  io_user_reference_t_0 reference[8];
  mach_msg_trailer_t trailer;
};

/* 5922 */
struct _Xio_connect_set_notification_port_64::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t port;
  NDR_record_t_0 NDR;
  uint32_t notification_type;
  io_user_reference_t_0 reference;
  mach_msg_trailer_t trailer;
};

/* 5923 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_connect_async_method::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t referenceCnt;
  io_user_reference_t_0 reference[8];
  uint32_t selector;
  mach_msg_type_number_t scalar_inputCnt;
  io_user_scalar_t scalar_input[16];
  mach_msg_type_number_t inband_inputCnt;
  char inband_input[4096];
  mach_vm_address_t_0 ool_input;
  mach_vm_size_t_0 ool_input_size;
  mach_msg_type_number_t inband_outputCnt;
  mach_msg_type_number_t scalar_outputCnt;
  mach_vm_address_t_0 ool_output;
  mach_vm_size_t_0 ool_output_size;
  mach_msg_trailer_t trailer;
};

/* 5925 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_connect_method::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t selector;
  mach_msg_type_number_t scalar_inputCnt;
  io_user_scalar_t scalar_input[16];
  mach_msg_type_number_t inband_inputCnt;
  char inband_input[4096];
  mach_vm_address_t_0 ool_input;
  mach_vm_size_t_0 ool_input_size;
  mach_msg_type_number_t inband_outputCnt;
  mach_msg_type_number_t scalar_outputCnt;
  mach_vm_address_t_0 ool_output;
  mach_vm_size_t_0 ool_output_size;
  mach_msg_trailer_t trailer;
};

/* 5926 */
struct _Xio_connect_unmap_memory_from_task::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t from_task;
  NDR_record_t_0 NDR;
  uint32_t memory_type;
  mach_vm_address_t_0 address;
  mach_msg_trailer_t trailer;
};

/* 5927 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_connect_map_memory_into_task::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t into_task;
  NDR_record_t_0 NDR;
  uint32_t memory_type;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  uint32_t flags;
  mach_msg_trailer_t trailer;
};

/* 5928 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_service_open_extended::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t owningTask;
  mach_msg_ool_descriptor_t properties;
  NDR_record_t_0 NDR;
  uint32_t connect_type;
  NDR_record_t_0 ndr;
  mach_msg_type_number_t propertiesCnt;
  mach_msg_trailer_t trailer;
};

/* 5929 */
struct _Xio_object_get_bundle_identifier::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t obj_nameOffset;
  mach_msg_type_number_t obj_nameCnt;
  char obj_name[128];
  mach_msg_trailer_t trailer;
};

/* 5930 */
struct _Xio_object_get_superclass::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t obj_nameOffset;
  mach_msg_type_number_t obj_nameCnt;
  char obj_name[128];
  mach_msg_trailer_t trailer;
};

/* 5931 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_service_add_notification_ool::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t matching;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t notification_typeOffset;
  mach_msg_type_number_t notification_typeCnt;
  char notification_type[128];
  mach_msg_type_number_t matchingCnt;
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
  mach_msg_trailer_t trailer;
};

/* 5932 */
struct _Xio_service_match_property_table_ool::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t matching;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingCnt;
  mach_msg_trailer_t trailer;
};

/* 5933 */
struct _Xio_service_get_matching_services_ool::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t matching;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingCnt;
  mach_msg_trailer_t trailer;
};

/* 5934 */
struct _Xio_service_get_state::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5935 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_registry_entry_get_property_recursively::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  mach_msg_type_number_t property_nameOffset;
  mach_msg_type_number_t property_nameCnt;
  char property_name[128];
  uint32_t options;
  mach_msg_trailer_t trailer;
};

/* 5936 */
struct _Xio_registry_entry_get_location_in_plane::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  mach_msg_trailer_t trailer;
};

/* 5937 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_connect_unmap_memory::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t into_task;
  NDR_record_t_0 NDR;
  uint32_t memory_type;
  uint32_t address;
  mach_msg_trailer_t trailer;
};

/* 5938 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_connect_get_notification_semaphore::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  natural_t notification_type;
  mach_msg_trailer_t trailer;
};

/* 5939 */
struct _Xio_service_acknowledge_notification::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  natural_t notify_ref;
  natural_t response;
  mach_msg_trailer_t trailer;
};

/* 5940 */
struct _Xio_service_add_interest_notification::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t type_of_interestOffset;
  mach_msg_type_number_t type_of_interestCnt;
  char type_of_interest[128];
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
  mach_msg_trailer_t trailer;
};

/* 5941 */
struct _Xio_service_add_notification::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t notification_typeOffset;
  mach_msg_type_number_t notification_typeCnt;
  char notification_type[128];
  mach_msg_type_number_t matchingOffset;
  mach_msg_type_number_t matchingCnt;
  char matching[512];
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
  mach_msg_trailer_t trailer;
};

/* 5942 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_async_method_structureI_structureO::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  char input[4096];
  mach_msg_type_number_t outputCnt;
  mach_msg_trailer_t trailer;
};

/* 5943 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_async_method_scalarI_structureI::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  int input[16];
  mach_msg_type_number_t inputStructCnt;
  char inputStruct[4096];
  mach_msg_trailer_t trailer;
};

/* 5944 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_async_method_scalarI_structureO::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  int input[16];
  mach_msg_type_number_t outputCnt;
  mach_msg_trailer_t trailer;
};

/* 5945 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_async_method_scalarI_scalarO::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  int input[16];
  mach_msg_type_number_t outputCnt;
  mach_msg_trailer_t trailer;
};

/* 5946 */
struct _Xio_service_match_property_table::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingOffset;
  mach_msg_type_number_t matchingCnt;
  char matching[512];
  mach_msg_trailer_t trailer;
};

/* 5947 */
struct _Xio_registry_entry_get_name_in_plane::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  mach_msg_trailer_t trailer;
};

/* 5948 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_service_request_probe::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t options;
  mach_msg_trailer_t trailer;
};

/* 5949 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_catalog_reset::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t flag;
  mach_msg_trailer_t trailer;
};

/* 5950 */
struct _Xio_catalog_module_loaded::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t nameOffset;
  mach_msg_type_number_t nameCnt;
  char name[128];
  mach_msg_trailer_t trailer;
};

/* 5951 */
struct _Xio_catalog_get_gen_count::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5952 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_catalog_get_data::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t flag;
  mach_msg_trailer_t trailer;
};

/* 5953 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_catalog_terminate::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t flag;
  mach_msg_type_number_t nameOffset;
  mach_msg_type_number_t nameCnt;
  char name[128];
  mach_msg_trailer_t trailer;
};

/* 5954 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_catalog_send_data::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t inData;
  NDR_record_t_0 NDR;
  uint32_t flag;
  mach_msg_type_number_t inDataCnt;
  mach_msg_trailer_t trailer;
};

/* 5955 */
struct _Xio_iterator_is_valid::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5956 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_registry_entry_create_iterator::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  uint32_t options;
  mach_msg_trailer_t trailer;
};

/* 5958 */
struct _Xio_service_wait_quiet::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_timespec_t wait_time;
  mach_msg_trailer_t trailer;
};

/* 5959 */
struct _Xio_service_get_busy_state::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5960 */
struct _Xio_object_get_retain_count::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5961 */
struct _Xio_registry_entry_in_plane::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  mach_msg_trailer_t trailer;
};

/* 5962 */
struct _Xio_registry_entry_set_properties::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t properties;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t propertiesCnt;
  mach_msg_trailer_t trailer;
};

/* 5963 */
struct _Xio_registry_get_root_entry::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5964 */
struct _Xio_registry_entry_get_path::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  mach_msg_trailer_t trailer;
};

/* 5965 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_connect_method_structureI_structureO::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  char input[4096];
  mach_msg_type_number_t outputCnt;
  mach_msg_trailer_t trailer;
};

/* 5966 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_connect_method_scalarI_structureI::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  int input[16];
  mach_msg_type_number_t inputStructCnt;
  char inputStruct[4096];
  mach_msg_trailer_t trailer;
};

/* 5967 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_connect_method_scalarI_structureO::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  int input[16];
  mach_msg_type_number_t outputCnt;
  mach_msg_trailer_t trailer;
};

/* 5968 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_connect_method_scalarI_scalarO::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  int input[16];
  mach_msg_type_number_t outputCnt;
  mach_msg_trailer_t trailer;
};

/* 5969 */
struct _Xio_connect_set_properties::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t properties;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t propertiesCnt;
  mach_msg_trailer_t trailer;
};

/* 5970 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_connect_add_client::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t connect_to;
  mach_msg_trailer_t trailer;
};

/* 5971 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_connect_map_memory::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t into_task;
  NDR_record_t_0 NDR;
  uint32_t memory_type;
  uint32_t address;
  uint32_t size;
  uint32_t flags;
  mach_msg_trailer_t trailer;
};

/* 5972 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_connect_set_notification_port::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t port;
  NDR_record_t_0 NDR;
  uint32_t notification_type;
  uint32_t reference;
  mach_msg_trailer_t trailer;
};

/* 5973 */
struct _Xio_connect_get_service::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5974 */
struct _Xio_service_close::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5975 */
struct _Xio_registry_entry_get_parent_iterator::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  mach_msg_trailer_t trailer;
};

/* 5976 */
struct _Xio_registry_entry_get_child_iterator::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  mach_msg_trailer_t trailer;
};

/* 5977 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_registry_entry_get_property_bytes::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t property_nameOffset;
  mach_msg_type_number_t property_nameCnt;
  char property_name[128];
  mach_msg_type_number_t dataCnt;
  mach_msg_trailer_t trailer;
};

/* 5978 */
struct _Xio_registry_entry_get_properties::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5979 */
struct _Xio_registry_entry_get_name::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5980 */
struct _Xio_registry_entry_from_path::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t pathOffset;
  mach_msg_type_number_t pathCnt;
  char path[512];
  mach_msg_trailer_t trailer;
};

/* 5981 */
struct _Xio_registry_iterator_exit_entry::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5982 */
struct _Xio_registry_iterator_enter_entry::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5983 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xio_registry_create_iterator::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  uint32_t options;
  mach_msg_trailer_t trailer;
};

/* 5984 */
struct _Xio_registry_entry_get_property::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t property_nameOffset;
  mach_msg_type_number_t property_nameCnt;
  char property_name[128];
  mach_msg_trailer_t trailer;
};

/* 5985 */
struct _Xio_service_get_matching_services::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingOffset;
  mach_msg_type_number_t matchingCnt;
  char matching[512];
  mach_msg_trailer_t trailer;
};

/* 5986 */
struct _Xio_iterator_reset::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5988 */
struct _Xio_iterator_next::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5989 */
struct _Xio_object_conforms_to::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t classNameOffset;
  mach_msg_type_number_t classNameCnt;
  char className[128];
  mach_msg_trailer_t trailer;
};

/* 5991 */
struct _Xio_object_get_class::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 5992 */
typedef mach_msg_type_descriptor_t_0 *routine_arg_descriptor_t_0;

/* 7117 */
typedef kern_return_t (*mig_impl_routine_t_0)(void);

/* 5994 */
typedef void (*mig_stub_routine_t_0)(mach_msg_header_t_0 *, mach_msg_header_t_0 *);

/* 5993 */
struct __attribute__((aligned(8))) routine_descriptor_0
{
  mig_impl_routine_t_0 impl_routine;
  mig_stub_routine_t_0 stub_routine;
  unsigned int argc;
  unsigned int descr_count;
  routine_arg_descriptor_t_0 arg_descr;
  unsigned int max_reply_msg;
};

/* 5995 */
typedef mig_stub_routine_t_0 mig_routine_t_0;

/* 5996 */
typedef mig_routine_t_0 (*mig_server_routine_t_0)(mach_msg_header_t_0 *);

/* 5997 */
struct is_iokit_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[91];
};

/* 5998 */
struct pfc
{
  long pfc_cpus;
  long pfc_invalid_global;
};

/* 6137 */
typedef uint32_t vm32_address_t;

/* 6136 */
typedef uint32_t vm32_size_t;

/* 6000 */
struct vm32_read_entry
{
  vm32_address_t address;
  vm32_size_t size;
};

/* 6001 */
struct mach_vm_read_entry
{
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
};

/* 7695 */
typedef unsigned int vm_inherit_t;

/* 6002 */
struct __attribute__((aligned(4))) vm_region_submap_info
{
  vm_prot_t protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
  uint32_t offset;
  unsigned int user_tag;
  unsigned int pages_resident;
  unsigned int pages_shared_now_private;
  unsigned int pages_swapped_out;
  unsigned int pages_dirtied;
  unsigned int ref_count;
  unsigned __int16 shadow_depth;
  unsigned __int8 external_pager;
  unsigned __int8 share_mode;
  boolean_t is_submap;
  vm_behavior_t behavior;
  vm32_object_id_t object_id;
  unsigned __int16 user_wired_count;
};

/* 6003 */
struct vm_map_version
{
  unsigned int main_timestamp;
};

/* 6004 */
typedef int *vm_region_recurse_info_t;

/* 6005 */
typedef int *vm_region_info_t;

/* 6021 */
typedef vm_map_copy *vm_map_copy_t;

/* 6006 */
struct __attribute__((aligned(8))) vm_named_entry
{
  lck_mtx_t_0 Lock;
  union
  {
    vm_map_t_0 map;
    vm_map_copy_t copy;
  } backing;
  vm_object_offset_t offset;
  vm_object_size_t size;
  vm_object_offset_t data_offset;
  _BYTE gap30[8];
};

/* 6007 */
struct swapfile_pager
{
  memory_object swp_pgr_hdr;
  queue_chain_t_0 pager_queue;
  bool is_ready;
  bool is_mapped;
  vnode *swapfile_vnode;
};

/* 6008 */
typedef swapfile_pager *swapfile_pager_t;

/* 6009 */
struct dyld_pager
{
  memory_object dyld_header;
  bool dyld_is_mapped;
  bool dyld_is_ready;
  vm_object_t dyld_backing_object;
  void *dyld_link_info;
  uint32_t dyld_link_info_size;
  uint32_t dyld_num_range;
  memory_object_offset_t dyld_file_offset[5];
  mach_vm_address_t_0 dyld_address[5];
  mach_vm_size_t_0 dyld_size[5];
  uint64_t dyld_a_key;
};

/* 6010 */
typedef dyld_pager *dyld_pager_t;

/* 6011 */
struct shared_region_pager
{
  memory_object srp_header;
  queue_chain_t_0 srp_queue;
  bool srp_is_mapped;
  bool srp_is_ready;
  vm_object_t srp_backing_object;
  vm_object_offset_t srp_backing_offset;
  vm_shared_region_slide_info_t srp_slide_info;
  uint64_t srp_jop_key;
};

/* 6012 */
struct __attribute__((aligned(8))) shared_region_jop_key_map
{
  queue_chain_t_0 srk_queue;
  char *srk_shared_region_id;
  uint64_t srk_jop_key;
  os_refcnt_t srk_ref_count;
};

/* 6013 */
typedef shared_region_pager *shared_region_pager_t;

/* 6014 */
typedef vm_shared_region_slide_info_entry_v4 *vm_shared_region_slide_info_entry_v4_t;

/* 6015 */
typedef vm_shared_region_slide_info_entry_v3 *vm_shared_region_slide_info_entry_v3_t;

/* 6016 */
typedef vm_shared_region_slide_info_entry_v2 *vm_shared_region_slide_info_entry_v2_t;

/* 6017 */
typedef vm_shared_region_slide_info_entry_v1 *vm_shared_region_slide_info_entry_v1_t;

/* 6018 */
struct slide_info_entry_toc
{
  uint8_t entry[128];
};

/* 6019 */
struct _dyld_cache_image_text_info
{
  uuid_t_0 uuid;
  uint64_t loadAddress;
  uint32_t textSegmentSize;
  uint32_t pathOffset;
};

/* 6020 */
typedef vm_shared_region *vm_shared_region_t;

/* 6022 */
struct zone_security_flags
{
  _BYTE gap0[2];
};

/* 6023 */
struct __attribute__((aligned(8))) vm_page_delayed_work
{
  vm_page_t dw_m;
  int dw_mask;
};

/* 6024 */
typedef mach_memory_info mach_memory_info_t;

/* 9364 */
struct mach_memory_info
{
  uint64_t flags;
  uint64_t site;
  uint64_t size;
  uint64_t free;
  uint64_t largest;
  uint64_t collectable_bytes;
  uint64_t mapped;
  uint64_t peak;
  uint16_t tag;
  uint16_t zone;
  uint16_t _resvA[2];
  uint64_t _resv[3];
  char name[80];
};

/* 6025 */
typedef vm_page_packed_queue_entry *vm_page_queue_t;

/* 6026 */
struct vpl
{
  vm_page_queue_head_t vpl_queue;
  unsigned int vpl_count;
  unsigned int vpl_internal_count;
  unsigned int vpl_external_count;
  lck_spin_t_0 vpl_lock;
};

/* 6027 */
struct __attribute__((aligned(64))) vm_page_queue_free_head
{
  vm_page_queue_head_t qhead;
};

/* 6028 */
typedef vm_allocation_site vm_allocation_site_t;

/* 6029 */
struct vm_page_bucket_t
{
  vm_page_packed_t page_list;
};

/* 6030 */
struct __attribute__((aligned(64))) vm_speculative_age_q
{
  vm_page_queue_head_t age_q;
  mach_timespec_t age_ts;
};

/* 6031 */
typedef mach_vm_reclaim_entry_v1_s mach_vm_reclaim_entry_v1_t;

/* 9366 */
struct mach_vm_reclaim_entry_v1_s
{
  mach_vm_address_t_0 address;
  uint32_t size;
  uint16_t opcode;
  uint16_t flags;
};

/* 6032 */
typedef vm_deferred_reclamation_metadata_s *vm_deferred_reclamation_metadata_t;

/* 6033 */
struct vm_deferred_reclamation_metadata_s
{
  struct
  {
    vm_deferred_reclamation_metadata_s *tqe_next;
    vm_deferred_reclamation_metadata_s **tqe_prev;
  } vdrm_list;
  struct
  {
    vm_deferred_reclamation_metadata_s *tqe_next;
    vm_deferred_reclamation_metadata_s **tqe_prev;
  } vdrm_async_list;
  lck_mtx_t_0 vdrm_lock;
  task_t_0 vdrm_task;
  vm_map_t_0 vdrm_map;
  user_addr_t_0 vdrm_reclaim_buffer;
  mach_vm_size_t_0 vdrm_buffer_size;
  user_addr_t_0 vdrm_reclaim_indices;
  uint64_t vdrm_reclaimed_at;
  size_t vdrm_num_bytes_put_in_buffer;
  size_t vdrm_num_bytes_reclaimed;
};

/* 8452 */
struct vm_purgeable_stat
{
  uint64_t count;
  uint64_t size;
};

/* 6036 */
typedef vm_purgeable_stat vm_purgeable_stat_t;

/* 6034 */
struct vm_purgeable_info
{
  vm_purgeable_stat_t fifo_data[8];
  vm_purgeable_stat_t obsolete_data;
  vm_purgeable_stat_t lifo_data[8];
};

/* 6035 */
typedef vm_purgeable_info *vm_purgeable_info_t;

/* 6037 */
typedef purgeable_q *purgeable_q_t;

/* 6046 */
typedef uint32_t token_idx_t;

/* 8453 */
enum purgeable_q_type : __int32
{
  purgeable_q_type::PURGEABLE_Q_TYPE_OBSOLETE = 0x0,
  purgeable_q_type::PURGEABLE_Q_TYPE_FIFO = 0x1,
  purgeable_q_type::PURGEABLE_Q_TYPE_LIFO = 0x2,
  purgeable_q_type::PURGEABLE_Q_TYPE_MAX = 0x3,
};

/* 6038 */
struct __attribute__((aligned(8))) purgeable_q
{
  token_idx_t token_q_head;
  token_idx_t token_q_tail;
  token_idx_t token_q_unripe;
  int32_t new_pages;
  queue_head_t_0 objq[8];
  purgeable_q_type type;
};

/* 6039 */
typedef uint32_t token_cnt_t;

/* 6040 */
struct token
{
  token_cnt_t count;
  token_idx_t prev;
  token_idx_t next;
};

/* 6041 */
struct flow_control
{
  int state;
  mach_timespec_t ts;
};

/* 6042 */
struct vm_page_delayed_work_ctx
{
  vm_page_delayed_work dwp[32];
  thread_t_0 delayed_owner;
};

/* 6043 */
struct vm_pageout_stat
{
  unsigned __int64 vm_page_active_count;
  unsigned __int64 vm_page_speculative_count;
  unsigned __int64 vm_page_inactive_count;
  unsigned __int64 vm_page_anonymous_count;
  unsigned __int64 vm_page_free_count;
  unsigned __int64 vm_page_wire_count;
  unsigned __int64 vm_page_compressor_count;
  unsigned __int64 vm_page_pages_compressed;
  unsigned __int64 vm_page_pageable_internal_count;
  unsigned __int64 vm_page_pageable_external_count;
  unsigned __int64 vm_page_xpmapped_external_count;
  unsigned int pages_grabbed;
  unsigned int pages_freed;
  unsigned int pages_compressed;
  unsigned int pages_grabbed_by_compressor;
  unsigned int failed_compressions;
  unsigned int pages_evicted;
  unsigned int pages_purged;
  unsigned int considered;
  unsigned int considered_bq_internal;
  unsigned int considered_bq_external;
  unsigned int skipped_external;
  unsigned int skipped_internal;
  unsigned int filecache_min_reactivations;
  unsigned int freed_speculative;
  unsigned int freed_cleaned;
  unsigned int freed_internal;
  unsigned int freed_external;
  unsigned int cleaned_dirty_external;
  unsigned int cleaned_dirty_internal;
  unsigned int inactive_referenced;
  unsigned int inactive_nolock;
  unsigned int reactivation_limit_exceeded;
  unsigned int forced_inactive_reclaim;
  unsigned int throttled_internal_q;
  unsigned int throttled_external_q;
  unsigned int phantom_ghosts_found;
  unsigned int phantom_ghosts_added;
  unsigned int vm_page_realtime_count;
  unsigned int forcereclaimed_sharedcache;
  unsigned int forcereclaimed_realtime;
  unsigned int protected_sharedcache;
  unsigned int protected_realtime;
};

/* 6044 */
struct __attribute__((aligned(4))) vm_pageout_queue
{
  vm_page_queue_head_t pgo_pending;
  unsigned int pgo_laundry;
  unsigned int pgo_maxlaundry;
  _BYTE gap10[4];
};

/* 6045 */
struct __attribute__((aligned(16))) pgo_iothread_state
{
  vm_pageout_queue *q;
  void *current_early_swapout_chead;
  void *current_regular_swapout_chead;
  void *current_late_swapout_chead;
  char *scratch_buf;
  int id;
  thread_t_0 pgo_iothread;
};

/* 6047 */
typedef vm_object_fault_info *vm_object_fault_info_t;

/* 6075 */
struct vm_object_fault_info
{
  int interruptible;
  uint32_t user_tag;
  vm_size_t_0 cluster_size;
  vm_behavior_t behavior;
  vm_object_offset_t lo_offset;
  vm_object_offset_t hi_offset;
  _BYTE gap28[4];
  int pmap_options;
};

/* 6048 */
typedef pfc pmap_flush_context;

/* 6049 */
struct io_reprioritize_req
{
  uint64_t blkno;
  uint32_t len;
  int priority;
  vnode *devvp;
  queue_chain_t_0 io_reprioritize_list;
};

/* 6050 */
typedef void vm_map_kernel_flags_t;

/* 6051 */
struct __attribute__((packed)) __attribute__((aligned(4))) vm_region_submap_info_64
{
  vm_prot_t protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
  memory_object_offset_t offset;
  unsigned int user_tag;
  unsigned int pages_resident;
  unsigned int pages_shared_now_private;
  unsigned int pages_swapped_out;
  unsigned int pages_dirtied;
  unsigned int ref_count;
  unsigned __int16 shadow_depth;
  unsigned __int8 external_pager;
  unsigned __int8 share_mode;
  boolean_t is_submap;
  vm_behavior_t behavior;
  vm32_object_id_t object_id;
  unsigned __int16 user_wired_count;
  __attribute__((aligned(4))) unsigned int pages_reusable;
  vm_object_id_t object_id_full;
};

/* 6052 */
struct kmem_page_meta
{
  union
  {
    uint32_t km_bitmap;
    uint32_t km_free_chunks;
  };
  uint8_t km_page_marker;
  uint8_t km_sizeclass;
  union
  {
    uint16_t km_chunk_len;
    uint16_t km_page_idx;
  };
  struct
  {
    kmem_page_meta *le_next;
    kmem_page_meta **le_prev;
  } km_link;
};

/* 6053 */
typedef upl_page_info_array_t upl_page_list_ptr_t;

/* 6054 */
typedef vm_named_entry *vm_named_entry_t;

/* 6055 */
typedef vm_region_submap_info_64 *vm_region_submap_info_64_t;

/* 6056 */
struct __attribute__((aligned(8))) kmem_guard_t
{
  uint16_t kmg_tag;
  uint16_t kmg_type_hash;
};

/* 6057 */
struct vm_map_zap
{
  vm_map_entry_t vmz_head;
  vm_map_entry_t *vmz_tail;
};

/* 6058 */
typedef vm_map_zap *vm_map_zap_t;

/* 6059 */
typedef vm_map_version vm_map_version_t;

/* 6060 */
typedef _vm_map *vm_map_read_t;

/* 6061 */
typedef uint8_t cf_disp_t;

/* 6062 */
struct __attribute__((packed)) __attribute__((aligned(4))) vm_map_corpse_footprint_region
{
  vm_map_offset_t cfr_vaddr;
  uint32_t cfr_num_pages;
  cf_disp_t cfr_disposition[];
};

/* 6063 */
struct __attribute__((aligned(4))) vm_region_top_info
{
  unsigned int obj_id;
  unsigned int ref_count;
  unsigned int private_pages_resident;
  unsigned int shared_pages_resident;
  unsigned __int8 share_mode;
};

/* 6064 */
struct vm_region_extended_info
{
  vm_prot_t protection;
  unsigned int user_tag;
  unsigned int pages_resident;
  unsigned int pages_shared_now_private;
  unsigned int pages_swapped_out;
  unsigned int pages_dirtied;
  unsigned int ref_count;
  unsigned __int16 shadow_depth;
  unsigned __int8 external_pager;
  unsigned __int8 share_mode;
  unsigned int pages_reusable;
};

/* 6065 */
struct __attribute__((packed)) __attribute__((aligned(4))) vm_region_basic_info_64
{
  vm_prot_t protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
  boolean_t shared;
  boolean_t reserved;
  memory_object_offset_t offset;
  vm_behavior_t behavior;
  unsigned __int16 user_wired_count;
};

/* 6066 */
struct __attribute__((aligned(4))) vm_region_basic_info
{
  vm_prot_t protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
  boolean_t shared;
  boolean_t reserved;
  uint32_t offset;
  vm_behavior_t behavior;
  unsigned __int16 user_wired_count;
};

/* 6067 */
struct __attribute__((aligned(4))) vm_region_submap_short_info_64
{
  vm_prot_t protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
  __attribute__((packed)) __attribute__((aligned(1))) memory_object_offset_t offset;
  unsigned int user_tag;
  unsigned int ref_count;
  unsigned __int16 shadow_depth;
  unsigned __int8 external_pager;
  unsigned __int8 share_mode;
  boolean_t is_submap;
  vm_behavior_t behavior;
  vm32_object_id_t object_id;
  unsigned __int16 user_wired_count;
};

/* 6068 */
typedef submap_map submap_map_t;

/* 8458 */
struct submap_map
{
  vm_map_t_0 parent_map;
  vm_map_offset_t base_start;
  vm_map_offset_t base_end;
  vm_map_size_t base_len;
  submap_map *next;
};

/* 6070 */
typedef mach_vm_range *mach_vm_range_t;

/* 6071 */
typedef kmem_list_head kmem_list_head_t;

/* 8459 */
struct kmem_list_head
{
  kmem_page_meta *lh_first;
};

/* 6072 */
struct kmem_sizeclass
{
  vm_map_size_t ks_size;
  uint32_t ks_num_chunk;
  uint32_t ks_num_elem;
  crypto_random_ctx_t ks_rng_ctx;
  kmem_list_head_t ks_allfree_head[6];
  kmem_list_head_t ks_partial_head[6];
  kmem_list_head_t ks_full_head[6];
};

/* 6073 */
struct __attribute__((aligned(8))) kmem_range_startup_spec
{
  const char *kc_name;
  mach_vm_range *kc_range;
  vm_map_size_t kc_size;
  struct *kc_calculate_sz;
  _BYTE gap20[8];
};

/* 6074 */
struct __attribute__((packed)) __attribute__((aligned(2))) _ca_event_vmtc_telemetry
{
  unsigned __int64 vmtc_num_byte;
  bool vmtc_undiagnosed;
  bool vmtc_not_eligible;
  bool vmtc_copyin_fail;
  bool vmtc_not_found;
  bool vmtc_one_bit_flip;
  bool vmtc_testing;
};

/* 6076 */
struct __attribute__((packed)) __attribute__((aligned(4))) codesigning_exit_reason_info
{
  uint64_t ceri_virt_addr;
  uint64_t ceri_file_offset;
  char ceri_pathname[1024];
  char ceri_filename[1024];
  uint64_t ceri_codesig_modtime_secs;
  uint64_t ceri_codesig_modtime_nsecs;
  uint64_t ceri_page_modtime_secs;
  uint64_t ceri_page_modtime_nsecs;
  uint8_t ceri_path_truncated;
  uint8_t ceri_object_codesigned;
  uint8_t ceri_page_codesig_validated;
  uint8_t ceri_page_codesig_tainted;
  uint8_t ceri_page_codesig_nx;
  uint8_t ceri_page_wpmapped;
  uint8_t ceri_page_slid;
  uint8_t ceri_page_dirty;
  uint32_t ceri_page_shadow_depth;
};

/* 6077 */
struct vm_rtfault_record_t
{
  uint64_t rtfabstime;
  uint64_t rtfduration;
  uint64_t rtfaddr;
  uint64_t rtfpc;
  uint64_t rtftid;
  uint64_t rtfupid;
  uint64_t rtftype;
};

/* 6078 */
typedef int memory_object_flavor_t;

/* 6079 */
typedef int memory_object_return_t;

/* 6080 */
struct memory_object_attr_info
{
  memory_object_copy_strategy_t copy_strategy;
  memory_object_cluster_size_t cluster_size;
  boolean_t may_cache_object;
  boolean_t temporary;
};

/* 6081 */
struct old_memory_object_attr_info
{
  boolean_t object_ready;
  boolean_t may_cache;
  memory_object_copy_strategy_t copy_strategy;
};

/* 6082 */
struct memory_object_perf_info
{
  memory_object_cluster_size_t cluster_size;
  boolean_t may_cache;
};

/* 6083 */
struct memory_object_behave_info
{
  memory_object_copy_strategy_t copy_strategy;
  boolean_t temporary;
  boolean_t invalidate;
  boolean_t silent_overwrite;
  boolean_t advisory_pageout;
};

/* 6084 */
struct old_memory_object_behave_info
{
  memory_object_copy_strategy_t copy_strategy;
  boolean_t temporary;
  boolean_t invalidate;
};

/* 6085 */
typedef uintptr_t device_port_t;

/* 6086 */
struct device_pager
{
  memory_object dev_pgr_hdr;
  lck_mtx_t_0 lock;
  device_port_t device_handle;
  vm_size_t_0 size;
  int flags;
  boolean_t is_mapped;
};

/* 6087 */
struct lz4_hash_entry_t
{
  uint32_t offset;
  uint32_t word;
};

/* 6088 */
union compressor_encode_scratch_t
{
  uint8_t lz4state[8192];
  uint8_t wkscratch[];
};

/* 6089 */
union compressor_decode_scratch_t
{
  uint8_t lz4decodestate[8192];
  uint8_t wkdecompscratch[];
};

/* 6093 */
typedef c_segment *c_segment_t;

/* 6090 */
struct __attribute__((aligned(8))) swapfile
{
  queue_head_t_0 swp_queue;
  char *swp_path;
  vnode *swp_vp;
  uint64_t swp_size;
  uint8_t *swp_bitmap;
  unsigned int swp_pathlen;
  unsigned int swp_nsegs;
  unsigned int swp_nseginuse;
  unsigned int swp_index;
  unsigned int swp_flags;
  unsigned int swp_free_hint;
  unsigned int swp_io_count;
  c_segment_t *swp_csegs;
  trim_list *swp_delayed_trim_list_head;
  unsigned int swp_delayed_trim_count;
};

/* 6091 */
struct c_slot
{
  _BYTE gap0[8];
};

/* 6092 */
struct c_segment
{
  lck_mtx_t_0 c_lock;
  queue_chain_t_0 c_age_list;
  queue_chain_t_0 c_list;
  uint32_t c_mysegno;
  uint32_t c_creation_ts;
  uint64_t c_generation_id;
  int32_t c_bytes_used;
  int32_t c_bytes_unused;
  uint32_t c_slots_used;
  uint16_t c_firstemptyslot;
  uint16_t c_nextslot;
  uint32_t c_nextoffset;
  uint32_t c_populated_offset;
  union
  {
    int32_t *c_buffer;
    uint64_t c_swap_handle;
  } c_store;
  thread_t_0 c_busy_for_thread;
  uint32_t c_agedin_ts;
  uint32_t c_swappedin_ts;
  bool c_swappedin;
  __attribute__((aligned(8))) int c_slot_var_array_len;
  c_slot *c_slot_var_array;
  c_slot c_slot_fixed_array[];
};

/* 6094 */
struct swapout_io_completion
{
  int swp_io_busy;
  int swp_io_done;
  int swp_io_error;
  uint32_t swp_c_size;
  c_segment_t swp_c_seg;
  swapfile *swp_swf;
  uint64_t swp_f_offset;
  upl_io_completion swp_upl_ctx;
};

/* 6095 */
typedef int compressor_slot_t;

/* 6096 */
struct compressor_pager
{
  memory_object cpgr_hdr;
  lck_mtx_t_0 cpgr_lock;
  unsigned int cpgr_num_slots;
  unsigned int cpgr_num_slots_occupied;
  union
  {
    compressor_slot_t cpgr_eslots[2];
    compressor_slot_t *cpgr_dslots;
    compressor_slot_t **cpgr_islots;
  } cpgr_slots;
};

/* 6097 */
typedef c_slot *c_slot_t;

/* 6098 */
typedef unsigned int WK_word;

/* 6099 */
struct c_slot_mapping
{
  _BYTE gap0[4];
};

/* 6100 */
struct c_sv_hash_entry
{
  union
  {
    struct
    {
      uint32_t c_sv_he_ref;
      uint32_t c_sv_he_data;
    } c_sv_he;
    uint64_t c_sv_he_record;
  } c_sv_he_un;
};

/* 6101 */
union c_segu
{
  c_segment_t c_seg;
  uintptr_t c_segno;
};

/* 6102 */
struct proc_regioninfo_internal
{
  uint32_t pri_protection;
  uint32_t pri_max_protection;
  uint32_t pri_inheritance;
  uint32_t pri_flags;
  uint64_t pri_offset;
  uint32_t pri_behavior;
  uint32_t pri_user_wired_count;
  uint32_t pri_user_tag;
  uint32_t pri_pages_resident;
  uint32_t pri_pages_shared_now_private;
  uint32_t pri_pages_swapped_out;
  uint32_t pri_pages_dirtied;
  uint32_t pri_ref_count;
  uint32_t pri_shadow_depth;
  uint32_t pri_share_mode;
  uint32_t pri_private_pages_resident;
  uint32_t pri_shared_pages_resident;
  uint32_t pri_obj_id;
  uint32_t pri_depth;
  uint64_t pri_address;
  uint64_t pri_size;
};

/* 6103 */
struct vnode_pager
{
  memory_object vn_pgr_hdr;
  vnode *vnode_handle;
};

/* 6104 */
struct __attribute__((packed)) __attribute__((aligned(2))) _ca_event_mlock_failures
{
  unsigned __int64 over_global_limit;
  unsigned __int64 over_user_limit;
  unsigned __int64 trial_deployment_id;
  ca_sstr trial_treatment_id[37];
  ca_sstr trial_experiment_id[37];
};

/* 6105 */
struct __attribute__((packed)) __attribute__((aligned(2))) _ca_event_vm_swapusage
{
  unsigned __int64 max_alloced;
  unsigned __int64 max_used;
  unsigned __int64 trial_deployment_id;
  ca_sstr trial_treatment_id[37];
  ca_sstr trial_experiment_id[37];
};

/* 6106 */
struct _X_map_exec_lockdown::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 7488 */
typedef int vm_purgable_t;

/* 6107 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xpurgable_control::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm_purgable_t control;
  int state;
  mach_msg_trailer_t trailer;
};

/* 6108 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmap_64::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t object;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  vm32_address_t mask;
  int flags;
  memory_object_offset_t offset;
  boolean_t copy;
  vm_prot_t cur_protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
  mach_msg_trailer_t trailer;
};

/* 6109 */
struct _Xmake_memory_entry_64::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t parent_entry;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) memory_object_size_t size;
  __attribute__((packed)) __attribute__((aligned(1))) memory_object_offset_t offset;
  vm_prot_t permission;
  mach_msg_trailer_t trailer;
};

/* 6320 */
typedef int vm_region_flavor_t;

/* 6110 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xregion_64::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm_region_flavor_t flavor;
  mach_msg_type_number_t infoCnt;
  mach_msg_trailer_t trailer;
};

/* 6111 */
typedef vm_info_region_64 vm_info_region_64_t;

/* 8502 */
struct __attribute__((packed)) __attribute__((aligned(4))) vm_info_region_64
{
  natural_t vir_start;
  natural_t vir_end;
  natural_t vir_object;
  memory_object_offset_t vir_offset;
  boolean_t vir_needs_copy;
  vm_prot_t vir_protection;
  vm_prot_t vir_max_protection;
  vm_inherit_t vir_inheritance;
  natural_t vir_wired_count;
  natural_t vir_user_wired_count;
};

/* 6112 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xregion_info_64::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  mach_msg_trailer_t trailer;
};

/* 6113 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xregion_recurse_64::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  natural_t nesting_depth;
  mach_msg_type_number_t infoCnt;
  mach_msg_trailer_t trailer;
};

/* 6114 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xregion_recurse::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  natural_t nesting_depth;
  mach_msg_type_number_t infoCnt;
  mach_msg_trailer_t trailer;
};

/* 6115 */
struct _Xmapped_pages_info::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6116 */
typedef vm_info_region vm_info_region_t;

/* 8507 */
struct vm_info_region
{
  natural_t vir_start;
  natural_t vir_end;
  natural_t vir_object;
  natural_t vir_offset;
  boolean_t vir_needs_copy;
  vm_prot_t vir_protection;
  vm_prot_t vir_max_protection;
  vm_inherit_t vir_inheritance;
  natural_t vir_wired_count;
  natural_t vir_user_wired_count;
};

/* 6117 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xregion_info::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  mach_msg_trailer_t trailer;
};

/* 8445 */
typedef uint32_t vm32_offset_t;

/* 6118 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmap_page_query::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_offset_t offset;
  mach_msg_trailer_t trailer;
};

/* 6119 */
struct _Xmake_memory_entry::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t parent_entry;
  NDR_record_t_0 NDR;
  vm32_size_t size;
  vm32_offset_t offset;
  vm_prot_t permission;
  mach_msg_trailer_t trailer;
};

/* 6120 */
struct __attribute__((packed)) __attribute__((aligned(4))) _X_task_wire::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  boolean_t must_wire;
  mach_msg_trailer_t trailer;
};

/* 6121 */
struct _Xremap::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t src_task;
  NDR_record_t_0 NDR;
  vm32_address_t target_address;
  vm32_size_t size;
  vm32_address_t mask;
  boolean_t anywhere;
  vm32_address_t src_address;
  boolean_t copy;
  vm_inherit_t inheritance;
  mach_msg_trailer_t trailer;
};

/* 6326 */
typedef unsigned int vm_machine_attribute_t;

/* 6325 */
typedef int vm_machine_attribute_val_t;

/* 6122 */
struct _Xmachine_attribute::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  vm_machine_attribute_t attribute;
  vm_machine_attribute_val_t value;
  mach_msg_trailer_t trailer;
};

/* 6123 */
struct _Xmap::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t object;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  vm32_address_t mask;
  int flags;
  vm32_offset_t offset;
  boolean_t copy;
  vm_prot_t cur_protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
  mach_msg_trailer_t trailer;
};

/* 6124 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xbehavior_set::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  vm_behavior_t new_behavior;
  mach_msg_trailer_t trailer;
};

/* 6330 */
typedef unsigned int vm_sync_t;

/* 6125 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmsync::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  vm_sync_t sync_flags;
  mach_msg_trailer_t trailer;
};

/* 6126 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xread_overwrite::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  vm32_address_t data;
  mach_msg_trailer_t trailer;
};

/* 6127 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xcopy::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t source_address;
  vm32_size_t size;
  vm32_address_t dest_address;
  mach_msg_trailer_t trailer;
};

/* 6128 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xwrite::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t data;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  mach_msg_type_number_t dataCnt;
  mach_msg_trailer_t trailer;
};

/* 6129 */
typedef vm32_read_entry vm32_read_entry_t[256];

/* 6130 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xread_list::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_read_entry_t data_list;
  natural_t count;
  mach_msg_trailer_t trailer;
};

/* 6131 */
struct _Xread::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  mach_msg_trailer_t trailer;
};

/* 6132 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xinherit::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  vm_inherit_t new_inheritance;
  mach_msg_trailer_t trailer;
};

/* 6133 */
struct _Xprotect::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  boolean_t set_maximum;
  vm_prot_t new_protection;
  mach_msg_trailer_t trailer;
};

/* 6134 */
struct _Xdeallocate::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  mach_msg_trailer_t trailer;
};

/* 6135 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xallocate::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  int flags;
  mach_msg_trailer_t trailer;
};

/* 6138 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xregion::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm_region_flavor_t flavor;
  mach_msg_type_number_t infoCnt;
  mach_msg_trailer_t trailer;
};

/* 6139 */
struct vm32_map_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[32];
};

/* 6140 */
typedef mach_port_t_0 exception_handler_t;

/* 6766 */
typedef ipc_info_port ipc_info_port_t;

/* 6141 */
typedef ipc_info_port_t exception_handler_info_t;

/* 8553 */
struct ipc_info_port
{
  natural_t iip_port_object;
  natural_t iip_receiver_object;
};

/* 6142 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xthread_get_exception_ports_info::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  mach_msg_trailer_t trailer;
};

/* 6143 */
struct _Xthread_raise_exception::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int exception;
  natural_t code_count;
  int64_t code;
  int64_t sub_code;
  mach_msg_trailer_t trailer;
};

/* 6144 */
struct _Xthread_convert_thread_state::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int direction;
  thread_state_flavor_t flavor;
  mach_msg_type_number_t in_stateCnt;
  natural_t in_state[1296];
  mach_msg_type_number_t out_stateCnt;
  mach_msg_trailer_t trailer;
};

/* 6145 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xthread_swap_mach_voucher::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t new_voucher;
  mach_msg_port_descriptor_t old_voucher;
  mach_msg_trailer_t trailer;
};

/* 6146 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xthread_set_mach_voucher::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t voucher;
  mach_msg_trailer_t trailer;
};

/* 6199 */
typedef uint32_t mach_voucher_selector_t;

/* 6147 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xthread_get_mach_voucher::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_voucher_selector_t which;
  mach_msg_trailer_t trailer;
};

/* 6148 */
struct _Xthread_set_policy::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t pset;
  NDR_record_t_0 NDR;
  policy_t policy;
  mach_msg_type_number_t baseCnt;
  integer_t base[5];
  mach_msg_type_number_t limitCnt;
  integer_t limit[1];
  mach_msg_trailer_t trailer;
};

/* 6149 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xthread_policy_get::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_policy_flavor_t flavor;
  mach_msg_type_number_t policy_infoCnt;
  boolean_t get_default;
  mach_msg_trailer_t trailer;
};

/* 6150 */
struct _Xthread_policy_set::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_policy_flavor_t flavor;
  mach_msg_type_number_t policy_infoCnt;
  integer_t policy_info[16];
  mach_msg_trailer_t trailer;
};

/* 6151 */
struct _Xthread_policy::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  policy_t policy;
  mach_msg_type_number_t baseCnt;
  integer_t base[5];
  boolean_t set_limit;
  mach_msg_trailer_t trailer;
};

/* 6152 */
struct _Xthread_swap_exception_ports::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t new_port;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  exception_behavior_t behavior;
  thread_state_flavor_t new_flavor;
  mach_msg_trailer_t trailer;
};

/* 6153 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xthread_get_exception_ports_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  mach_msg_trailer_t trailer;
};

/* 6154 */
struct _Xthread_set_exception_ports::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t new_port;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  exception_behavior_t behavior;
  thread_state_flavor_t new_flavor;
  mach_msg_trailer_t trailer;
};

/* 6155 */
typedef natural_t thread_flavor_t;

/* 6156 */
struct _Xthread_info::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_flavor_t flavor;
  mach_msg_type_number_t thread_info_outCnt;
  mach_msg_trailer_t trailer;
};

/* 6157 */
struct _Xthread_set_special_port::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t special_port;
  NDR_record_t_0 NDR;
  int which_port;
  mach_msg_trailer_t trailer;
};

/* 6158 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xthread_get_special_port_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int which_port;
  mach_msg_trailer_t trailer;
};

/* 6159 */
struct _Xthread_depress_abort_from_user::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6160 */
struct _Xthread_abort_safely::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6161 */
struct _Xthread_abort::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6162 */
struct _Xthread_resume::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6163 */
struct _Xthread_suspend::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6164 */
struct _Xthread_set_state_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_state_flavor_t flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
  mach_msg_trailer_t trailer;
};

/* 6165 */
struct _Xthread_get_state_to_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_state_flavor_t flavor;
  mach_msg_type_number_t old_stateCnt;
  mach_msg_trailer_t trailer;
};

/* 6166 */
struct _Xact_set_state_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
  mach_msg_trailer_t trailer;
};

/* 6167 */
struct _Xact_get_state_to_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  mach_msg_trailer_t trailer;
};

/* 6168 */
struct _Xthread_terminate_from_user::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6169 */
struct thread_act_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[31];
};

/* 6170 */
struct kcdata_object
{
  kcdata_descriptor_t ko_data;
  __attribute__((aligned(16))) ipc_port_t_0 ko_port;
  uint32_t ko_alloc_size;
  os_refcnt_t ko_refs;
};

/* 6171 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_map_kcdata_object_64::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t kcdata_object;
  mach_msg_trailer_t trailer;
};

/* 6172 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_test_async_upcall_propagation::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t port;
  NDR_record_t_0 NDR;
  int qos;
  int iotier;
  mach_msg_trailer_t trailer;
};

/* 6173 */
typedef uint32_t task_corpse_forking_behavior_t;

/* 6174 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_set_corpse_forking_behavior::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_corpse_forking_behavior_t behavior;
  mach_msg_trailer_t trailer;
};

/* 6175 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_test_sync_upcall::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t port;
  mach_msg_trailer_t trailer;
};

/* 6176 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_get_exception_ports_info::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  mach_msg_trailer_t trailer;
};

/* 6177 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_dyld_process_info_notify_deregister::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 notify;
  mach_msg_trailer_t trailer;
};

/* 6223 */
typedef natural_t task_flavor_t;

/* 6178 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_identity_token_get_task_port::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_flavor_t flavor;
  mach_msg_trailer_t trailer;
};

/* 6179 */
struct _Xtask_create_identity_token::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6180 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_dyld_process_info_notify_register::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t notify;
  mach_msg_trailer_t trailer;
};

/* 6181 */
struct _Xmach_task_is_self::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 7086 */
typedef uint32_t task_exc_guard_behavior_t;

/* 6182 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_set_exc_guard_behavior::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_exc_guard_behavior_t behavior;
  mach_msg_trailer_t trailer;
};

/* 6183 */
struct _Xtask_get_exc_guard_behavior::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6184 */
typedef natural_t task_inspect_flavor_t;

/* 6185 */
struct _Xtask_inspect::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_inspect_flavor_t flavor;
  mach_msg_type_number_t info_outCnt;
  mach_msg_trailer_t trailer;
};

/* 6186 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_map_corpse_info_64::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t corspe_task;
  mach_msg_trailer_t trailer;
};

/* 6187 */
typedef dyld_kernel_process_info dyld_kernel_process_info_t;

/* 8122 */
struct fsobj_id
{
  u_int32_t fid_objno;
  u_int32_t fid_generation;
};

/* 6193 */
typedef fsobj_id fsobj_id_t;

/* 8644 */
struct dyld_kernel_image_info
{
  uuid_t_0 uuid;
  fsobj_id_t fsobjid;
  fsid_t fsid;
  uint64_t load_addr;
};

/* 9657 */
struct __attribute__((aligned(8))) dyld_kernel_process_info
{
  dyld_kernel_image_info cache_image_info;
  uint64_t timestamp;
  uint32_t imageCount;
  uint32_t initialImageCount;
  uint8_t dyldState;
  boolean_t no_cache;
  boolean_t private_cache;
};

/* 6188 */
struct _Xtask_register_dyld_get_process_state::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6189 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_register_dyld_set_dyld_state::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint8_t dyld_state;
  char dyld_statePad[3];
  mach_msg_trailer_t trailer;
};

/* 6624 */
typedef dyld_kernel_image_info dyld_kernel_image_info_t;

/* 6190 */
struct _Xtask_register_dyld_shared_cache_image_info::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  dyld_kernel_image_info_t dyld_cache_image;
  boolean_t no_cache;
  boolean_t private_cache;
  mach_msg_trailer_t trailer;
};

/* 6191 */
struct _Xtask_get_dyld_image_infos::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6192 */
struct _Xtask_unregister_dyld_image_infos::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t dyld_images;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t dyld_imagesCnt;
  mach_msg_trailer_t trailer;
};

/* 6194 */
struct _Xtask_register_dyld_image_infos::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t dyld_images;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t dyld_imagesCnt;
  mach_msg_trailer_t trailer;
};

/* 6195 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_map_corpse_info::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t corspe_task;
  mach_msg_trailer_t trailer;
};

/* 6196 */
struct _Xtask_generate_corpse::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6197 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_swap_mach_voucher::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t new_voucher;
  mach_msg_port_descriptor_t old_voucher;
  mach_msg_trailer_t trailer;
};

/* 6198 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_set_mach_voucher::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t voucher;
  mach_msg_trailer_t trailer;
};

/* 6200 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_get_mach_voucher::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_voucher_selector_t which;
  mach_msg_trailer_t trailer;
};

/* 6201 */
typedef vm_purgeable_info task_purgable_info_t;

/* 6202 */
struct _Xtask_purgable_info::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6203 */
struct _Xtask_resume2_mig::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6204 */
struct _Xtask_suspend2_mig::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6205 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_set_phys_footprint_limit::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int new_limit;
  mach_msg_trailer_t trailer;
};

/* 6206 */
struct _Xtask_set_state::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_state_flavor_t flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
  mach_msg_trailer_t trailer;
};

/* 6207 */
struct _Xtask_get_state::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_state_flavor_t flavor;
  mach_msg_type_number_t old_stateCnt;
  mach_msg_trailer_t trailer;
};

/* 6209 */
typedef natural_t task_policy_flavor_t;

/* 6208 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_policy_get::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_policy_flavor_t flavor;
  mach_msg_type_number_t policy_infoCnt;
  boolean_t get_default;
  mach_msg_trailer_t trailer;
};

/* 6210 */
struct _Xtask_policy_set::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_policy_flavor_t flavor;
  mach_msg_type_number_t policy_infoCnt;
  integer_t policy_info[16];
  mach_msg_trailer_t trailer;
};

/* 6211 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xsemaphore_destroy::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t semaphore;
  mach_msg_trailer_t trailer;
};

/* 6212 */
struct _Xsemaphore_create::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int policy;
  int value;
  mach_msg_trailer_t trailer;
};

/* 6213 */
struct _Xtask_swap_exception_ports::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t new_port;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  exception_behavior_t behavior;
  thread_state_flavor_t new_flavor;
  mach_msg_trailer_t trailer;
};

/* 6214 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_get_exception_ports_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  mach_msg_trailer_t trailer;
};

/* 6215 */
struct _Xtask_set_exception_ports::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t new_port;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  exception_behavior_t behavior;
  thread_state_flavor_t new_flavor;
  mach_msg_trailer_t trailer;
};

/* 6216 */
struct _Xthread_create_running_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_state_flavor_t flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
  mach_msg_trailer_t trailer;
};

/* 6217 */
struct _Xthread_create_from_user::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6218 */
struct _Xtask_set_special_port_from_user::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t special_port;
  NDR_record_t_0 NDR;
  int which_port;
  mach_msg_trailer_t trailer;
};

/* 6219 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_get_special_port_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int which_port;
  mach_msg_trailer_t trailer;
};

/* 6220 */
struct _Xtask_resume::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6221 */
struct _Xtask_suspend::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6222 */
struct _Xtask_set_info::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_flavor_t flavor;
  mach_msg_type_number_t task_info_inCnt;
  integer_t task_info_in[90];
  mach_msg_trailer_t trailer;
};

/* 6224 */
struct _Xtask_info_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_flavor_t flavor;
  mach_msg_type_number_t task_info_outCnt;
  mach_msg_trailer_t trailer;
};

/* 6225 */
struct _Xmach_ports_lookup::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6227 */
struct mach_msg_ool_ports_descriptor_t
{
  void *address;
  _BYTE gap8[4];
  mach_msg_size_t count;
};

/* 6226 */
struct _Xmach_ports_register::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_ports_descriptor_t init_port_set;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t init_port_setCnt;
  mach_msg_trailer_t trailer;
};

/* 6228 */
struct _Xtask_threads_from_user::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6229 */
struct _Xtask_terminate::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6230 */
struct task_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[65];
};

/* 6231 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xprocessor_set_tasks_with_flavor::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_task_flavor_t flavor;
  mach_msg_trailer_t trailer;
};

/* 6232 */
struct _Xprocessor_set_info::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int flavor;
  mach_msg_type_number_t info_outCnt;
  mach_msg_trailer_t trailer;
};

/* 6233 */
struct _Xprocessor_set_stack_usage::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6234 */
struct _Xprocessor_set_threads::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6235 */
struct _Xprocessor_set_tasks::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6236 */
typedef int processor_set_flavor_t;

/* 6237 */
struct _Xprocessor_set_statistics::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  processor_set_flavor_t flavor;
  mach_msg_type_number_t info_outCnt;
  mach_msg_trailer_t trailer;
};

/* 6238 */
struct processor_set_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[11];
};

/* 6239 */
struct _Xprocessor_get_assignment::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6240 */
struct _Xprocessor_assign::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t new_set;
  NDR_record_t_0 NDR;
  boolean_t wait;
  mach_msg_trailer_t trailer;
};

/* 6241 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xprocessor_control::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t processor_cmdCnt;
  integer_t processor_cmd[20];
  mach_msg_trailer_t trailer;
};

/* 6421 */
typedef int processor_flavor_t;

/* 6242 */
struct _Xprocessor_info::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  processor_flavor_t flavor;
  mach_msg_type_number_t processor_info_outCnt;
  mach_msg_trailer_t trailer;
};

/* 6243 */
struct _Xprocessor_exit_from_user::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6244 */
struct _Xprocessor_start_from_user::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6245 */
struct processor_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[6];
};

/* 6246 */
struct __attribute__((packed)) __attribute__((aligned(4))) Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t flags;
};

/* 6247 */
struct arcade_register_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[1];
};

/* 6248 */
struct arcade_upcall::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  boolean_t should_kill;
  mach_msg_trailer_t trailer;
};

/* 6249 */
struct arcade_upcall::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t path;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t pathCnt;
  uint64_t offset;
};

/* 6250 */
struct __Reply__arcade_upcall_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  boolean_t should_kill;
};

/* 6251 */
struct __attribute__((packed)) __attribute__((aligned(4))) fairplayd_arcade_request::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t arcade_reg_port;
};

/* 6252 */
struct __attribute__((packed)) __attribute__((aligned(4))) send_nspace_resolve_cancel::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_trailer_t trailer;
};

/* 6253 */
struct __attribute__((packed)) __attribute__((aligned(4))) send_nspace_resolve_cancel::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t req_id;
};

/* 6254 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__vfs_resolve_dir_with_audit_token_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 6255 */
struct __attribute__((packed)) __attribute__((aligned(4))) send_vfs_resolve_dir_with_audit_token::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_trailer_t trailer;
};

/* 8707 */
typedef char nspace_name_t[8192];

/* 6263 */
typedef char nspace_path_t[8192];

/* 6256 */
struct send_vfs_resolve_dir_with_audit_token::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t req_id;
  uint32_t op;
  nspace_name_t file_name;
  nspace_path_t path;
  audit_token_t req_atoken;
};

/* 6257 */
union send_vfs_resolve_dir_with_audit_token::vfs_resolve_dir_with_audit_tokenMessU
{
  send_vfs_resolve_dir_with_audit_token::Request In;
  send_vfs_resolve_dir_with_audit_token::Reply Out;
};

/* 6258 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__vfs_resolve_file_with_audit_token_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 6259 */
struct __attribute__((packed)) __attribute__((aligned(4))) send_vfs_resolve_file_with_audit_token::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_trailer_t trailer;
};

/* 6260 */
struct send_vfs_resolve_file_with_audit_token::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t req_id;
  uint32_t op;
  int64_t offset;
  int64_t size;
  nspace_path_t path;
  audit_token_t req_atoken;
};

/* 6261 */
union send_vfs_resolve_file_with_audit_token::vfs_resolve_file_with_audit_tokenMessU
{
  send_vfs_resolve_file_with_audit_token::Request In;
  send_vfs_resolve_file_with_audit_token::Reply Out;
};

/* 6262 */
struct __Reply__nspace_resolve_path_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int xxx_rdar44371223;
};

/* 6264 */
struct send_nspace_resolve_path::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int xxx_rdar44371223;
  mach_msg_trailer_t trailer;
};

/* 6265 */
struct __attribute__((packed)) __attribute__((aligned(4))) send_nspace_resolve_path::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t req_id;
  uint32_t pid;
  uint32_t op;
  nspace_path_t path;
};

/* 6266 */
union __attribute__((packed)) __attribute__((aligned(4))) send_nspace_resolve_path::nspace_resolve_pathMessU
{
  send_nspace_resolve_path::Request In;
  send_nspace_resolve_path::Reply Out;
};

/* 6267 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__nspace_resolve_cancel_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 6268 */
struct __attribute__((packed)) __attribute__((aligned(4))) send_sysdiagnose_notification_with_audit_token::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t flags;
};

/* 6269 */
struct __attribute__((packed)) __attribute__((aligned(4))) coalition_notification::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint64_t id;
  uint32_t flags;
};

/* 6270 */
typedef ivac_entry_s ivac_entry;

/* 6943 */
typedef uint64_t mach_voucher_attr_value_handle_t;

/* 6935 */
typedef mach_voucher_attr_value_handle_t iv_value_handle_t;

/* 6934 */
typedef mach_voucher_attr_value_reference_t iv_value_refs_t;

/* 9392 */
struct ivac_entry_s
{
  iv_value_handle_t ivace_value;
  _BYTE gap8[4];
  union
  {
    iv_value_refs_t ivaceu_made;
    iv_index_t ivaceu_layer;
  } ivace_u;
  iv_index_t ivace_next;
  iv_index_t ivace_index;
};

/* 6271 */
typedef ivac_entry *ivac_entry_t;

/* 6272 */
struct __attribute__((aligned(8))) ipc_voucher_attr_control
{
  boolean_t ivac_is_growing;
  ivac_entry_t ivac_table;
  iv_index_t ivac_table_size;
  iv_index_t ivac_init_table_size;
  iv_index_t ivac_freelist;
  lck_spin_t_0 ivac_lock_data;
  iv_index_t ivac_key_index;
};

/* 6273 */
typedef const ipc_voucher_attr_manager *ipc_voucher_attr_manager_t;

/* 6944 */
typedef uint32_t mach_voucher_attr_key_t;

/* 6277 */
typedef kern_return_t (*ipc_voucher_attr_manager_release_value_t)(ipc_voucher_attr_manager_t, mach_voucher_attr_key_t, mach_voucher_attr_value_handle_t, mach_voucher_attr_value_reference_t);

/* 6942 */
typedef uint32_t mach_voucher_attr_recipe_command_t;

/* 6941 */
typedef mach_voucher_attr_value_handle_t *mach_voucher_attr_value_handle_array_t;

/* 6940 */
typedef mach_msg_type_number_t mach_voucher_attr_value_handle_array_size_t;

/* 6939 */
typedef uint8_t *mach_voucher_attr_content_t;

/* 6938 */
typedef uint32_t mach_voucher_attr_content_size_t;

/* 6937 */
typedef uint32_t mach_voucher_attr_value_flags_t;

/* 9369 */
typedef kern_return_t (*ipc_voucher_attr_manager_get_value_t_0)(ipc_voucher_attr_manager_t, mach_voucher_attr_key_t, mach_voucher_attr_recipe_command_t, mach_voucher_attr_value_handle_array_t, mach_voucher_attr_value_handle_array_size_t, mach_voucher_attr_content_t, mach_voucher_attr_content_size_t, mach_voucher_attr_value_handle_t *, mach_voucher_attr_value_flags_t *, ipc_voucher_t *);

/* 9368 */
typedef kern_return_t (*ipc_voucher_attr_manager_extract_content_t_0)(ipc_voucher_attr_manager_t, mach_voucher_attr_key_t, mach_voucher_attr_value_handle_array_t, mach_voucher_attr_value_handle_array_size_t, mach_voucher_attr_recipe_command_t *, mach_voucher_attr_content_t, mach_voucher_attr_content_size_t *);

/* 6936 */
typedef uint32_t mach_voucher_attr_command_t;

/* 6274 */
typedef kern_return_t (*ipc_voucher_attr_manager_command_t)(ipc_voucher_attr_manager_t, mach_voucher_attr_key_t, mach_voucher_attr_value_handle_array_t, mach_voucher_attr_value_handle_array_size_t, mach_voucher_attr_command_t, mach_voucher_attr_content_t, mach_voucher_attr_content_size_t, mach_voucher_attr_content_t, mach_voucher_attr_content_size_t *);

/* 6945 */
typedef uint32_t ipc_voucher_attr_manager_flags;

/* 6278 */
struct __attribute__((aligned(8))) ipc_voucher_attr_manager
{
  ipc_voucher_attr_manager_release_value_t ivam_release_value;
  ipc_voucher_attr_manager_get_value_t_0 ivam_get_value;
  ipc_voucher_attr_manager_extract_content_t_0 ivam_extract_content;
  ipc_voucher_attr_manager_command_t ivam_command;
  ipc_voucher_attr_manager_flags ivam_flags;
};

/* 6275 */
typedef kern_return_t (*ipc_voucher_attr_manager_extract_content_t)(ipc_voucher_attr_manager_t, mach_voucher_attr_key_t, mach_voucher_attr_value_handle_array_t, mach_voucher_attr_value_handle_array_size_t, mach_voucher_attr_recipe_command_t *, mach_voucher_attr_content_t, mach_voucher_attr_content_size_t *);

/* 6276 */
typedef kern_return_t (*ipc_voucher_attr_manager_get_value_t)(ipc_voucher_attr_manager_t, mach_voucher_attr_key_t, mach_voucher_attr_recipe_command_t, mach_voucher_attr_value_handle_array_t, mach_voucher_attr_value_handle_array_size_t, mach_voucher_attr_content_t, mach_voucher_attr_content_size_t, mach_voucher_attr_value_handle_t *, mach_voucher_attr_value_flags_t *, ipc_voucher_t *);

/* 6279 */
struct persona_token
{
  proc_persona_info originator;
  proc_persona_info proximate;
};

/* 6280 */
struct bank_persona
{
  uint32_t persona_id;
  uint32_t persona_uid;
};

/* 8709 */
typedef bank_task *bank_task_t;

/* 6281 */
struct bank_account
{
  bank_element ba_elem;
  ledger_t ba_bill;
  bank_task_t ba_merchant;
  bank_task_t ba_holder;
  bank_task_t ba_secureoriginator;
  bank_task_t ba_proximateprocess;
  queue_chain_t_0 ba_next_acc_to_pay;
  queue_chain_t_0 ba_next_acc_to_charge;
  thread_group *ba_thread_group;
  bank_persona ba_so_persona;
};

/* 6282 */
struct __attribute__((packed)) __attribute__((aligned(4))) check_task_access_with_flavor::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_trailer_t trailer;
};

/* 6283 */
struct check_task_access_with_flavor::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int32_t calling_pid;
  uint32_t calling_gid;
  int32_t target_pid;
  mach_task_flavor_t flavor;
};

/* 6284 */
struct __attribute__((packed)) __attribute__((aligned(4))) find_code_signature::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_trailer_t trailer;
};

/* 6285 */
struct __attribute__((packed)) __attribute__((aligned(4))) find_code_signature::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int32_t new_pid;
};

/* 6286 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__check_task_access_with_flavor_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 6287 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__find_code_signature_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 6288 */
struct audit_analytics::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t caller_idOffset;
  mach_msg_type_number_t caller_idCnt;
  char caller_id[1024];
  mach_msg_type_number_t caller_nameOffset;
  mach_msg_type_number_t caller_nameCnt;
  char caller_name[1024];
};

/* 6289 */
union audit_analytics::audit_analyticsMessU
{
  audit_analytics::Request In;
};

/* 6290 */
struct _Xtask_restartable_ranges_synchronize::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6291 */
struct task_restartable_range_t
{
  mach_vm_address_t_0 location;
  unsigned __int16 length;
  unsigned __int16 recovery_offs;
  unsigned int flags;
};

/* 6292 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_restartable_ranges_register::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t rangesCnt;
  task_restartable_range_t ranges[64];
  mach_msg_trailer_t trailer;
};

/* 6293 */
struct task_restartable_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[2];
};

/* 6299 */
typedef char posix_path_t[1024];

/* 6298 */
typedef uint64_t resource_notify_flags_t;

/* 6294 */
struct send_disk_writes_violation::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  proc_name_t procname;
  char procnamePad[3];
  int pid;
  posix_path_t killed_proc_path;
  mach_timespec_t timestamp;
  int64_t observed_bytes_dirtied;
  int64_t observation_nsecs;
  int64_t bytes_dirtied_allowed;
  int64_t limit_window_nsecs;
  resource_notify_flags_t flags;
};

/* 6295 */
union send_disk_writes_violation::disk_writes_violationMessU
{
  send_disk_writes_violation::Request In;
};

/* 6296 */
struct send_cpu_wakes_violation::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  proc_name_t procname;
  char procnamePad[3];
  int pid;
  posix_path_t killed_proc_path;
  mach_timespec_t timestamp;
  int64_t observed_cpu_wakes;
  int64_t observation_nsecs;
  int64_t cpu_wakes_allowed;
  int64_t limit_window_nsecs;
  resource_notify_flags_t flags;
};

/* 6297 */
union send_cpu_wakes_violation::cpu_wakes_violationMessU
{
  send_cpu_wakes_violation::Request In;
};

/* 6300 */
struct send_cpu_usage_violation::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  proc_name_t procname;
  char procnamePad[3];
  int pid;
  posix_path_t killed_proc_path;
  mach_timespec_t timestamp;
  int64_t observed_cpu_nsecs;
  int64_t observation_nsecs;
  int64_t cpu_nsecs_allowed;
  int64_t limit_window_nsecs;
  resource_notify_flags_t flags;
};

/* 6301 */
union send_cpu_usage_violation::cpu_usage_violationMessU
{
  send_cpu_usage_violation::Request In;
};

/* 6302 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_memory_entry_ownership_from_user::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t owner;
  NDR_record_t_0 NDR;
  int ledger_tag;
  int ledger_flags;
  mach_msg_trailer_t trailer;
};

/* 6303 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_memory_entry_access_tracking::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int access_tracking;
  mach_msg_trailer_t trailer;
};

/* 6304 */
struct _Xmach_memory_entry_purgable_control::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm_purgable_t control;
  int state;
  mach_msg_trailer_t trailer;
};

/* 6305 */
struct memory_entry_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[3];
};

/* 6306 */
struct _Xmach_voucher_debug_info::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 voucher_name;
  mach_msg_type_number_t recipesCnt;
  mach_msg_trailer_t trailer;
};

/* 6307 */
struct _Xmach_voucher_attr_command::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_voucher_attr_key_t key;
  mach_voucher_attr_command_t command;
  mach_msg_type_number_t in_contentCnt;
  uint8_t in_content[4096];
  mach_msg_type_number_t out_contentCnt;
  mach_msg_trailer_t trailer;
};

/* 6308 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_voucher_extract_all_attr_recipes::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t recipesCnt;
  mach_msg_trailer_t trailer;
};

/* 6309 */
struct _Xmach_voucher_extract_attr_recipe::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_voucher_attr_key_t key;
  mach_msg_type_number_t recipeCnt;
  mach_msg_trailer_t trailer;
};

/* 6310 */
struct _Xmach_voucher_extract_attr_content::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_voucher_attr_key_t key;
  mach_msg_type_number_t contentCnt;
  mach_msg_trailer_t trailer;
};

/* 6311 */
struct mach_voucher_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[5];
};

/* 6312 */
struct _Xmach_vm_deferred_reclamation_buffer_update_reclaimable_bytes::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_size_t_0 reclaimable_bytes;
  mach_msg_trailer_t trailer;
};

/* 6313 */
struct _Xmach_vm_deferred_reclamation_buffer_synchronize::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_size_t_0 num_entries_to_reclaim;
  mach_msg_trailer_t trailer;
};

/* 6314 */
struct _Xmach_vm_deferred_reclamation_buffer_init::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_offset_t address;
  mach_vm_size_t_0 size;
  mach_vm_address_t_0 indices;
  mach_msg_trailer_t trailer;
};

/* 6315 */
struct _Xmach_vm_remap_new_external::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t src_tport;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 target_address;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_size_t_0 size;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_offset_t mask;
  int flags;
  mach_vm_address_t_0 src_address;
  boolean_t copy;
  vm_prot_t cur_protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
  mach_msg_trailer_t trailer;
};

/* 6316 */
struct _Xmach_vm_page_range_query::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_offset_t address;
  mach_vm_size_t_0 size;
  mach_vm_address_t_0 dispositions;
  mach_vm_size_t_0 dispositions_count;
  mach_msg_trailer_t trailer;
};

/* 6317 */
struct _Xmach_vm_page_info::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  vm_page_info_flavor_t flavor;
  mach_msg_type_number_t infoCnt;
  mach_msg_trailer_t trailer;
};

/* 6318 */
struct _Xmach_vm_purgable_control_external::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  vm_purgable_t control;
  int state;
  mach_msg_trailer_t trailer;
};

/* 6319 */
struct _X_mach_make_memory_entry::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t parent_handle;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) memory_object_size_t size;
  __attribute__((packed)) __attribute__((aligned(1))) memory_object_offset_t offset;
  vm_prot_t permission;
  mach_msg_trailer_t trailer;
};

/* 6321 */
struct _Xmach_vm_region::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  vm_region_flavor_t flavor;
  mach_msg_type_number_t infoCnt;
  mach_msg_trailer_t trailer;
};

/* 6322 */
struct _Xmach_vm_region_recurse::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  natural_t nesting_depth;
  mach_msg_type_number_t infoCnt;
  mach_msg_trailer_t trailer;
};

/* 6323 */
struct _Xmach_vm_page_query::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_offset_t offset;
  mach_msg_trailer_t trailer;
};

/* 6324 */
struct _Xmach_vm_remap_external::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t src_task;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 target_address;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_size_t_0 size;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_offset_t mask;
  int flags;
  mach_vm_address_t_0 src_address;
  boolean_t copy;
  vm_inherit_t inheritance;
  mach_msg_trailer_t trailer;
};

/* 6327 */
struct _Xmach_vm_machine_attribute::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  vm_machine_attribute_t attribute;
  vm_machine_attribute_val_t value;
  mach_msg_trailer_t trailer;
};

/* 6328 */
struct _Xmach_vm_map_external::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t object;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 address;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_size_t_0 size;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_offset_t mask;
  int flags;
  memory_object_offset_t offset;
  boolean_t copy;
  vm_prot_t cur_protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
  mach_msg_trailer_t trailer;
};

/* 6329 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_vm_behavior_set::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  vm_behavior_t new_behavior;
  mach_msg_trailer_t trailer;
};

/* 6331 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_vm_msync::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  vm_sync_t sync_flags;
  mach_msg_trailer_t trailer;
};

/* 6332 */
struct _Xmach_vm_read_overwrite::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  mach_vm_address_t_0 data;
  mach_msg_trailer_t trailer;
};

/* 6333 */
struct _Xmach_vm_copy::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 source_address;
  mach_vm_size_t_0 size;
  mach_vm_address_t_0 dest_address;
  mach_msg_trailer_t trailer;
};

/* 6334 */
struct _Xmach_vm_write::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t data;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 address;
  mach_msg_type_number_t dataCnt;
  mach_msg_trailer_t trailer;
};

/* 6335 */
typedef mach_vm_read_entry mach_vm_read_entry_t[256];

/* 6336 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_vm_read_list::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_read_entry_t data_list;
  natural_t count;
  mach_msg_trailer_t trailer;
};

/* 6337 */
struct _Xmach_vm_read::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  mach_msg_trailer_t trailer;
};

/* 6338 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_vm_inherit::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  vm_inherit_t new_inheritance;
  mach_msg_trailer_t trailer;
};

/* 6339 */
struct _Xmach_vm_protect::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  boolean_t set_maximum;
  vm_prot_t new_protection;
  mach_msg_trailer_t trailer;
};

/* 6340 */
struct _Xmach_vm_deallocate::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  mach_msg_trailer_t trailer;
};

/* 6341 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_vm_allocate_external::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  int flags;
  mach_msg_trailer_t trailer;
};

/* 6342 */
struct mach_vm_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[25];
};

/* 6371 */
typedef int mach_port_flavor_t;

/* 6343 */
struct _Xmach_port_assert_attributes::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_flavor_t flavor;
  mach_msg_type_number_t infoCnt;
  integer_t info[17];
  mach_msg_trailer_t trailer;
};

/* 6344 */
typedef mach_service_port_info mach_service_port_info_data_t;

/* 6863 */
struct mach_service_port_info
{
  char mspi_string_name[255];
  uint8_t mspi_domain_type;
};

/* 6345 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_get_service_port_info::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_trailer_t trailer;
};

/* 6346 */
struct _Xmach_port_is_connection_for_service::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 connection_port;
  mach_port_name_t_0 service_port;
  mach_msg_trailer_t trailer;
};

/* 6347 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_kobject_description_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_trailer_t trailer;
};

/* 6348 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_swap_guard::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  uint64_t old_guard;
  uint64_t new_guard;
  mach_msg_trailer_t trailer;
};

/* 6349 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_guard_with_flags::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  uint64_t guard;
  uint64_t flags;
  mach_msg_trailer_t trailer;
};

/* 6350 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_special_reply_port_reset_link::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_trailer_t trailer;
};

/* 6351 */
typedef ipc_info_space_basic ipc_info_space_basic_t;

/* 8830 */
struct ipc_info_space_basic
{
  natural_t iisb_genno_mask;
  natural_t iisb_table_size;
  natural_t iisb_table_next;
  natural_t iisb_table_inuse;
  natural_t iisb_reserved[2];
};

/* 6352 */
struct _Xmach_port_space_basic_info::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6353 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_unguard::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  uint64_t guard;
  mach_msg_trailer_t trailer;
};

/* 6354 */
struct _Xmach_port_guard::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t guard;
  boolean_t strict;
  mach_msg_trailer_t trailer;
};

/* 6355 */
struct _Xmach_port_destruct::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_delta_t srdelta;
  uint64_t guard;
  mach_msg_trailer_t trailer;
};

/* 6356 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_construct::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t options;
  NDR_record_t_0 NDR;
  uint64_t context;
  mach_msg_trailer_t trailer;
};

/* 6357 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_kobject_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_trailer_t trailer;
};

/* 6358 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_set_context::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_vm_address_t_0 context;
  mach_msg_trailer_t trailer;
};

/* 6359 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_get_context_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_trailer_t trailer;
};

/* 6360 */
struct _Xmach_port_extract_member::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_name_t_0 pset;
  mach_msg_trailer_t trailer;
};

/* 6361 */
struct _Xmach_port_insert_member::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_name_t_0 pset;
  mach_msg_trailer_t trailer;
};

/* 6362 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_dnrequest_info::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_trailer_t trailer;
};

/* 6363 */
typedef ipc_info_space ipc_info_space_t;

/* 8842 */
struct ipc_info_space
{
  natural_t iis_genno_mask;
  natural_t iis_table_size;
  natural_t iis_table_next;
  natural_t iis_tree_size;
  natural_t iis_tree_small;
  natural_t iis_tree_hash;
};

/* 6364 */
struct _Xmach_port_space_info_from_user::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6365 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_get_srights::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_trailer_t trailer;
};

/* 6366 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xtask_set_port_space::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int table_entries;
  mach_msg_trailer_t trailer;
};

/* 8846 */
typedef natural_t mach_port_right_t;

/* 8849 */
struct mach_port_qos
{
  _BYTE gap0[4];
  natural_t len;
};

/* 6368 */
typedef mach_port_qos mach_port_qos_t;

/* 6367 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_allocate_full::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t proto;
  NDR_record_t_0 NDR;
  mach_port_right_t right;
  mach_port_qos_t qos;
  mach_port_name_t_0 name;
  mach_msg_trailer_t trailer;
};

/* 6369 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_allocate_qos::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_right_t right;
  mach_port_qos_t qos;
  mach_msg_trailer_t trailer;
};

/* 6370 */
struct _Xmach_port_set_attributes::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_flavor_t flavor;
  mach_msg_type_number_t port_infoCnt;
  integer_t port_info[17];
  mach_msg_trailer_t trailer;
};

/* 6372 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_get_attributes_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_flavor_t flavor;
  mach_msg_type_number_t port_info_outCnt;
  mach_msg_trailer_t trailer;
};

/* 6373 */
struct _Xmach_port_set_seqno::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_seqno_t seqno;
  mach_msg_trailer_t trailer;
};

/* 8853 */
typedef unsigned int mach_msg_type_name_t;

/* 6374 */
struct _Xmach_port_extract_right::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_type_name_t msgt_name;
  mach_msg_trailer_t trailer;
};

/* 6375 */
struct _Xmach_port_insert_right::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t poly;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_trailer_t trailer;
};

/* 6376 */
struct _Xmach_port_request_notification::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t notify;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_id_t msgid;
  mach_port_mscount_t sync;
  mach_msg_trailer_t trailer;
};

/* 6377 */
struct _Xmach_port_move_member::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 member;
  mach_port_name_t_0 after;
  mach_msg_trailer_t trailer;
};

/* 6378 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_get_set_status_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_trailer_t trailer;
};

/* 6379 */
struct _Xmach_port_set_mscount::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_mscount_t mscount;
  mach_msg_trailer_t trailer;
};

/* 6380 */
struct _Xmach_port_peek::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_trailer_type_t trailer_type;
  mach_port_seqno_t request_seqnop;
  mach_msg_type_number_t trailer_infopCnt;
  mach_msg_trailer_t trailer;
};

/* 6381 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_mod_refs::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_right_t right;
  mach_port_delta_t delta;
  mach_msg_trailer_t trailer;
};

/* 6382 */
struct _Xmach_port_get_refs::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_right_t right;
  mach_msg_trailer_t trailer;
};

/* 6383 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_deallocate::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_trailer_t trailer;
};

/* 6384 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_destroy::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_trailer_t trailer;
};

/* 6385 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_allocate::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_right_t right;
  mach_msg_trailer_t trailer;
};

/* 6386 */
struct _Xmach_port_allocate_name::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_right_t right;
  mach_port_name_t_0 name;
  mach_msg_trailer_t trailer;
};

/* 6387 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_port_type::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_trailer_t trailer;
};

/* 6388 */
struct _Xmach_port_names::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6389 */
struct mach_port_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[43];
};

/* 6390 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_notify_dead_name::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 6391 */
struct mach_notify_send_once::Request
{
  mach_msg_header_t_0 Head;
};

/* 6392 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_notify_no_senders::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_mscount_t mscount;
};

/* 6393 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_notify_port_destroyed::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t rights;
};

/* 6394 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_notify_send_possible::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 6395 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_notify_port_deleted::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 6821 */
typedef int clock_flavor_t;

/* 6820 */
typedef int *clock_attr_t;

/* 6396 */
struct clock_ops
{
  int (*c_config)(void);
  int (*c_init)(void);
  kern_return_t (*c_gettime)(mach_timespec_t *);
  kern_return_t (*c_getattr)(clock_flavor_t, clock_attr_t, mach_msg_type_number_t *);
};

/* 6397 */
typedef const clock_ops *clock_ops_t;

/* 6398 */
struct clock
{
  clock_ops_t cl_ops;
  ipc_port *cl_service;
};

/* 8906 */
struct mach_zone_name
{
  char mzn_name[80];
};

/* 6515 */
typedef mach_zone_name mach_zone_name_t;

/* 6399 */
struct _Xmach_zone_get_btlog_records::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_zone_name_t name;
  mach_msg_trailer_t trailer;
};

/* 6400 */
struct _Xmach_zone_get_zlog_zones::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6401 */
struct _Xmach_zone_info_for_largest_zone::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6402 */
struct _Xmach_zone_info_for_zone::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_zone_name_t name;
  mach_msg_trailer_t trailer;
};

/* 6403 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xhost_set_multiuser_config_flags::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t multiuser_flags;
  mach_msg_trailer_t trailer;
};

/* 6404 */
struct _Xmach_memory_info::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6405 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xhost_set_atm_diagnostic_flag::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t diagnostic_flag;
  mach_msg_trailer_t trailer;
};

/* 6406 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xhost_create_mach_voucher::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t recipesCnt;
  uint8_t recipes[5120];
  mach_msg_trailer_t trailer;
};

/* 6407 */
struct _Xmach_zone_force_gc::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6408 */
struct _Xmach_zone_info::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6468 */
typedef integer_t host_flavor_t;

/* 6409 */
struct _Xhost_statistics64_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  host_flavor_t flavor;
  mach_msg_type_number_t host_info64_outCnt;
  mach_msg_trailer_t trailer;
};

/* 6410 */
struct _Xhost_lockgroup_info::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6411 */
struct _Xhost_request_notification::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t notify_port;
  NDR_record_t_0 NDR;
  host_flavor_t notify_type;
  mach_msg_trailer_t trailer;
};

/* 6412 */
struct _Xhost_statistics_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  host_flavor_t flavor;
  mach_msg_type_number_t host_info_outCnt;
  mach_msg_trailer_t trailer;
};

/* 6414 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_memory_object_memory_entry_64::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t pager;
  NDR_record_t_0 NDR;
  boolean_t internal;
  memory_object_size_t size;
  vm_prot_t permission;
  mach_msg_trailer_t trailer;
};

/* 6415 */
struct _Xprocessor_set_default::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6416 */
struct _Xhost_virtual_physical_table_info::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6417 */
struct _Xkmod_get_info::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6418 */
typedef int clock_id_t;

/* 6419 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xhost_get_clock_service::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  clock_id_t clock_id;
  mach_msg_trailer_t trailer;
};

/* 6420 */
struct _Xhost_get_io_main::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6422 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xhost_processor_info::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  processor_flavor_t flavor;
  mach_msg_trailer_t trailer;
};

/* 6423 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_memory_object_memory_entry::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t pager;
  NDR_record_t_0 NDR;
  boolean_t internal;
  vm_size_t_0 size;
  vm_prot_t permission;
  mach_msg_trailer_t trailer;
};

/* 6424 */
struct _Xhost_page_size::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6425 */
struct _Xhost_kernel_version::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6426 */
struct _Xhost_info::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  host_flavor_t flavor;
  mach_msg_type_number_t host_info_outCnt;
  mach_msg_trailer_t trailer;
};

/* 6427 */
struct mach_host_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[35];
};

/* 6428 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_exception_raise_backtrace::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t kcdata_object_t;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
  mach_msg_trailer_t trailer;
};

/* 6429 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_exception_raise_identity_protected::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t task_id_token_t;
  NDR_record_t_0 NDR;
  uint64_t thread_id;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
  mach_msg_trailer_t trailer;
};

/* 6430 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_exception_raise_state_identity::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
  mach_msg_trailer_t trailer;
};

/* 6431 */
struct _Xmach_exception_raise_state::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
  mach_msg_trailer_t trailer;
};

/* 6432 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_exception_raise::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
  mach_msg_trailer_t trailer;
};

/* 6433 */
struct catch_mach_exc_subsystem_0
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[5];
};

/* 6434 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_exception_raise_backtrace::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_trailer_t trailer;
};

/* 6435 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_exception_raise_backtrace::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t kcdata_object_t;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
};

/* 6436 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_exception_raise_identity_protected::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_trailer_t trailer;
};

/* 6437 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_exception_raise_identity_protected::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t task_id_token_t;
  NDR_record_t_0 NDR;
  uint64_t thread_id;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
};

/* 6438 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_exception_raise::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_trailer_t trailer;
};

/* 6439 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_exception_raise::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
};

/* 6440 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_exception_raise_backtrace_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 6441 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_exception_raise_identity_protected_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 6442 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_exception_raise_state_identity_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
};

/* 6443 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_exception_raise_state_identity::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
  mach_msg_trailer_t trailer;
};

/* 6444 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_exception_raise_state_identity::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
};

/* 6445 */
union mach_exception_raise_state_identity::mach_exception_raise_state_identityMessU
{
  mach_exception_raise_state_identity::Request In;
  mach_exception_raise_state_identity::Reply Out;
};

/* 6446 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_exception_raise_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
};

/* 6447 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_exception_raise_state::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
  mach_msg_trailer_t trailer;
};

/* 6448 */
struct mach_exception_raise_state::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
};

/* 6449 */
union mach_exception_raise_state::mach_exception_raise_stateMessU
{
  mach_exception_raise_state::Request In;
  mach_exception_raise_state::Reply Out;
};

/* 6450 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_exception_raise_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 6451 */
struct send_ktrace_background_available::Request
{
  mach_msg_header_t_0 Head;
};

/* 6452 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xkext_request::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t request_data;
  NDR_record_t_0 NDR;
  uint32_t user_log_flags;
  mach_msg_type_number_t request_dataCnt;
  mach_msg_trailer_t trailer;
};

/* 6453 */
struct _Xhost_get_UNDServer::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6454 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xhost_set_UNDServer::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t server;
  mach_msg_trailer_t trailer;
};

/* 6455 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xhost_processor_set_priv::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t set_name;
  mach_msg_trailer_t trailer;
};

/* 6456 */
struct _Xhost_processor_sets::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6457 */
struct _Xmach_vm_wire_external::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 address;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_size_t_0 size;
  vm_prot_t desired_access;
  mach_msg_trailer_t trailer;
};

/* 6458 */
struct _Xhost_swap_exception_ports::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t new_port;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  exception_behavior_t behavior;
  thread_state_flavor_t new_flavor;
  mach_msg_trailer_t trailer;
};

/* 6459 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xhost_get_exception_ports::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  mach_msg_trailer_t trailer;
};

/* 6460 */
struct _Xhost_set_exception_ports::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t new_port;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  exception_behavior_t behavior;
  thread_state_flavor_t new_flavor;
  mach_msg_trailer_t trailer;
};

/* 6461 */
struct _Xhost_set_special_port_from_user::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t port;
  NDR_record_t_0 NDR;
  int which;
  mach_msg_trailer_t trailer;
};

/* 6462 */
struct _Xhost_get_special_port_from_user::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int node;
  int which;
  mach_msg_trailer_t trailer;
};

/* 6463 */
struct _Xhost_processors::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6464 */
struct _Xvm_allocate_cpm::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) vm_address_t_0 address;
  __attribute__((packed)) __attribute__((aligned(1))) vm_size_t_0 size;
  int flags;
  mach_msg_trailer_t trailer;
};

/* 6465 */
struct _Xthread_wire::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t thread;
  NDR_record_t_0 NDR;
  boolean_t wired;
  mach_msg_trailer_t trailer;
};

/* 6466 */
struct _Xvm_wire::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) vm_address_t_0 address;
  __attribute__((packed)) __attribute__((aligned(1))) vm_size_t_0 size;
  vm_prot_t desired_access;
  mach_msg_trailer_t trailer;
};

/* 6467 */
struct _Xhost_default_memory_manager::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t default_manager;
  NDR_record_t_0 NDR;
  memory_object_cluster_size_t cluster_size;
  mach_msg_trailer_t trailer;
};

/* 6469 */
struct _Xhost_priv_statistics::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  host_flavor_t flavor;
  mach_msg_type_number_t host_info_outCnt;
  mach_msg_trailer_t trailer;
};

/* 6470 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xhost_reboot::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int options;
  mach_msg_trailer_t trailer;
};

/* 6471 */
struct _Xhost_get_boot_info::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6472 */
struct host_priv_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[26];
};

/* 6474 */
struct ipc_eventlink
{
  ipc_port_t_0 el_port;
  thread_t_1 el_thread;
  ipc_eventlink_base *el_base;
  uint64_t el_sync_counter;
  uint64_t el_wait_counter;
};

/* 9131 */
struct waitq_0
{
  struct
  {
    _BYTE gap0[4];
  };
  hw_lck_ticket_t waitq_interlock;
  union
  {
    circle_queue_head_t waitq_queue;
    priority_queue_sched_max waitq_prio_queue;
    turnstile *waitq_ts;
  };
  union
  {
    circle_queue_head_t waitq_links;
    waitq_link_list_t waitq_sellinks;
    void *waitq_inheritor;
    mpsc_queue_chain waitq_defer;
  };
};

/* 6473 */
struct __attribute__((aligned(4))) ipc_eventlink_base
{
  ipc_eventlink elb_eventlink[2];
  waitq_0 elb_waitq;
  os_refcnt_t elb_ref_count;
  uint8_t elb_type;
};

/* 6475 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_eventlink_disassociate::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  _BYTE gap28[4];
  mach_msg_trailer_t trailer;
};

/* 6476 */
struct _Xmach_eventlink_associate::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t thread;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 copyin_addr_wait;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t copyin_mask_wait;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 copyin_addr_signal;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t copyin_mask_signal;
  __attribute__((aligned(8))) mach_msg_trailer_t trailer;
};

/* 6477 */
struct _Xmach_eventlink_destroy::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6478 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xmach_eventlink_create::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  _BYTE gap28[4];
  mach_msg_trailer_t trailer;
};

/* 6479 */
struct mach_eventlink_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[4];
};

/* 6480 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xexception_raise_state_identity::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  integer_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
  mach_msg_trailer_t trailer;
};

/* 6481 */
struct _Xexception_raise_state::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  integer_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
  mach_msg_trailer_t trailer;
};

/* 6482 */
struct __attribute__((packed)) __attribute__((aligned(4))) _Xexception_raise::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  integer_t code[2];
  mach_msg_trailer_t trailer;
};

/* 6483 */
struct catch_exc_subsystem_0
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[3];
};

/* 6484 */
struct __attribute__((packed)) __attribute__((aligned(4))) exception_raise::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_trailer_t trailer;
};

/* 6485 */
struct __attribute__((packed)) __attribute__((aligned(4))) exception_raise::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  integer_t code[2];
};

/* 6486 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__exception_raise_state_identity_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
};

/* 6487 */
struct __attribute__((packed)) __attribute__((aligned(4))) exception_raise_state_identity::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
  mach_msg_trailer_t trailer;
};

/* 6488 */
struct __attribute__((packed)) __attribute__((aligned(4))) exception_raise_state_identity::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  integer_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
};

/* 6489 */
union exception_raise_state_identity::exception_raise_state_identityMessU
{
  exception_raise_state_identity::Request In;
  exception_raise_state_identity::Reply Out;
};

/* 6490 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__exception_raise_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
};

/* 6491 */
struct __attribute__((packed)) __attribute__((aligned(4))) exception_raise_state::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
  mach_msg_trailer_t trailer;
};

/* 6492 */
struct exception_raise_state::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  integer_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
};

/* 6493 */
union exception_raise_state::exception_raise_stateMessU
{
  exception_raise_state::Request In;
  exception_raise_state::Reply Out;
};

/* 6494 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__exception_raise_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 6497 */
typedef int alarm_type_t;

/* 6495 */
struct clock_alarm_reply::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t alarm_code;
  alarm_type_t alarm_type;
  mach_timespec_t alarm_time;
};

/* 6496 */
typedef mach_port_t_0 clock_reply_t;

/* 6498 */
struct _Xclock_alarm::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t alarm_port;
  NDR_record_t_0 NDR;
  alarm_type_t alarm_type;
  mach_timespec_t alarm_time;
  mach_msg_trailer_t trailer;
};

/* 6499 */
struct _Xclock_get_attributes::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  clock_flavor_t flavor;
  mach_msg_type_number_t clock_attrCnt;
  mach_msg_trailer_t trailer;
};

/* 6500 */
struct _Xclock_get_time::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_trailer_t trailer;
};

/* 6501 */
struct clock_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[3];
};

/* 6502 */
struct __attribute__((aligned(8))) task_id_token
{
  proc_ident ident;
  ipc_port_t_0 port;
  uint64_t task_uniqueid;
  os_refcnt_t tidt_refs;
};

/* 6503 */
struct proc_threadinfo_internal
{
  uint64_t pth_user_time;
  uint64_t pth_system_time;
  int32_t pth_cpu_usage;
  int32_t pth_policy;
  int32_t pth_run_state;
  int32_t pth_flags;
  int32_t pth_sleep_time;
  int32_t pth_curpri;
  int32_t pth_priority;
  int32_t pth_maxpriority;
  char pth_name[64];
};

/* 6504 */
struct proc_taskinfo_internal
{
  uint64_t pti_virtual_size;
  uint64_t pti_resident_size;
  uint64_t pti_total_user;
  uint64_t pti_total_system;
  uint64_t pti_threads_user;
  uint64_t pti_threads_system;
  int32_t pti_policy;
  int32_t pti_faults;
  int32_t pti_pageins;
  int32_t pti_cow_faults;
  int32_t pti_messages_sent;
  int32_t pti_messages_received;
  int32_t pti_syscalls_mach;
  int32_t pti_syscalls_unix;
  int32_t pti_csw;
  int32_t pti_threadnum;
  int32_t pti_numrunning;
  int32_t pti_priority;
};

/* 6505 */
struct proc_threadschedinfo_internal
{
  uint64_t int_time_ns;
};

/* 6506 */
struct zone_view_startup_spec
{
  zone_view_t zv_view;
  _BYTE gap8[8];
  vm_size_t_0 zv_size;
};

/* 6507 */
typedef mach_memory_info_t *mach_memory_info_array_t;

/* 6514 */
typedef mach_zone_info_data mach_zone_info_t;

/* 6508 */
typedef mach_zone_info_t *mach_zone_info_array_t;

/* 8905 */
struct mach_zone_info_data
{
  uint64_t mzi_count;
  uint64_t mzi_cur_size;
  uint64_t mzi_max_size;
  uint64_t mzi_elem_size;
  uint64_t mzi_alloc_size;
  uint64_t mzi_sum_size;
  uint64_t mzi_exhaustible;
  uint64_t mzi_collectable;
};

/* 6509 */
typedef mach_zone_name_t *mach_zone_name_array_t;

/* 6510 */
typedef kalloc_type_views kalloc_type_views_t;

/* 8997 */
union kalloc_type_views
{
  kalloc_type_view *ktv_fixed;
  kalloc_type_var_view *ktv_var;
};

/* 6512 */
struct zone_bits_head
{
  uint32_t zbh_next;
  uint32_t zbh_unused;
};

/* 6513 */
struct zone_bits_allocator_meta
{
  uint32_t zbam_left;
  uint32_t zbam_right;
  zone_bits_head zbam_lists[11];
  zone_bits_head zbam_lists_with_extra[11];
};

/* 6516 */
struct zone_bits_allocator_header
{
  uint64_t zbah_bits[32];
};

/* 6517 */
struct zone_bits_chain
{
  uint32_t zbc_next;
  uint32_t zbc_prev;
};

/* 6518 */
struct zone_bool_gen
{
  bool_gen zbg_bg;
  uint32_t zbg_entropy[2];
};

/* 6519 */
struct zone_cache_ops
{
  _BYTE gap0[8];
  void *(*zc_op_mark_valid)(zone_id_t, void *);
  void *(*zc_op_mark_invalid)(zone_id_t, void *);
  void (*zc_op_free)(zone_id_t, void *);
};

/* 6520 */
typedef const zone_cache_ops *zone_cache_ops_t;

/* 6521 */
struct zone_size_params
{
  uint32_t z_align_magic;
  uint32_t z_elem_size;
};

/* 6522 */
struct zone_page_metadata
{
  union
  {
    struct
    {
      _BYTE gap0[2];
    };
    uint16_t zm_bits;
  };
  union
  {
    uint16_t zm_alloc_size;
    struct
    {
      uint8_t zm_page_index;
      uint8_t zm_subchunk_len;
    };
    uint16_t zm_oob_offs;
  };
  union
  {
    uint32_t zm_bitmap;
    uint32_t zm_bump;
  };
  union
  {
    struct
    {
      zone_pva_t zm_page_next;
      zone_pva_t zm_page_prev;
    };
    vm_offset_t zm_pgz_orig_addr;
    zone_page_metadata *zm_pgz_slot_next;
  };
};

/* 6523 */
typedef zone_security_flags zone_security_flags_t;

/* 6527 */
typedef workload_config_entry workload_config_entry_t;

/* 6532 */
struct kern_work_interval_workload_id_args
{
  uint32_t wlida_flags;
  uint32_t wlida_wicreate_flags;
  char *wlida_name;
  uint64_t wlida_syscall_mask[2];
};

/* 6533 */
struct kern_work_interval_create_args
{
  uint64_t wica_id;
  mach_port_name_t wica_port;
  uint32_t wica_create_flags;
};

/* 6534 */
typedef uint32_t work_interval_auto_join_status_t;

/* 6535 */
struct work_interval_deferred_finish_state
{
  uint64_t instance_id;
  uint64_t start;
  uint64_t deadline;
  uint64_t complexity;
};

/* 6536 */
struct __attribute__((aligned(8))) work_interval_auto_join_info
{
  work_interval_deferred_finish_state deferred_finish_state;
  work_interval_auto_join_status_t status;
};

/* 6537 */
struct __attribute__((aligned(8))) work_interval
{
  uint64_t wi_id;
  os_refcnt wi_ref_count;
  uint32_t wi_create_flags;
  ipc_port_t_0 wi_port;
  uint64_t wi_creator_uniqueid;
  uint32_t wi_creator_pid;
  int wi_creator_pidversion;
  uint32_t wi_wlid_flags;
  uint32_t wi_group_flags;
  thread_group *wi_group;
  work_interval_auto_join_info wi_auto_join_info;
  mpsc_queue_chain wi_deallocate_link;
  _BYTE gap68;
  uint8_t wi_class_offset;
};

/* 6538 */
struct lck_spinlock_to_info
{
  void *lock;
  uintptr_t owner_thread_cur;
  int owner_cpu;
  uint32_t extra;
};

/* 7109 */
typedef uint64_t event64_t;

/* 6539 */
struct waitq_select_args
{
  event64_t event;
  wait_result_t result;
  __attribute__((aligned(8))) uint32_t max_threads;
  bool is_identified;
  uint32_t nthreads;
  circle_queue_head_t threadq;
};

/* 6540 */
typedef circle_queue_head *circle_queue_t;

/* 6541 */
struct hw_spin_state_t
{
  uint64_t hwss_start;
  uint64_t hwss_now;
  uint64_t hwss_deadline;
};

/* 6542 */
struct hw_spin_timeout_t
{
  uint64_t hwst_timeout;
};

/* 6749 */
enum hw_spin_timeout_status_t : __int8
{
  HW_LOCK_TIMEOUT_RETURN = 0x0,
  HW_LOCK_TIMEOUT_CONTINUE = 0x1,
};

/* 6543 */
typedef hw_spin_timeout_status_t hw_spin_timeout_fn_t(void *, hw_spin_timeout_t, hw_spin_state_t);

/* 6544 */
struct hw_spin_policy
{
  const char *hwsp_name;
  union
  {
    const uint64_t *hwsp_timeout;
    const uint64_t *hwsp_timeout_atomic;
  };
  uint16_t hwsp_timeout_shift;
  uint16_t hwsp_lock_offset;
  hw_spin_timeout_fn_t *hwsp_op_timeout;
};

/* 9000 */
typedef integer_t exception_data_type_t;

/* 6545 */
typedef exception_data_type_t *exception_data_t;

/* 6546 */
typedef stackshot_thread_turnstileinfo_v2 thread_turnstileinfo_v2_t;

/* 9001 */
struct __attribute__((packed)) __attribute__((aligned(4))) stackshot_thread_turnstileinfo_v2
{
  uint64_t waiter;
  uint64_t turnstile_context;
  uint8_t turnstile_priority;
  uint8_t number_of_hops;
  uint64_t turnstile_flags;
  int16_t portlabel_id;
};

/* 9006 */
enum turnstile_update_complete_flags : __int32
{
  turnstile_update_complete_flags::TURNSTILE_INTERLOCK_NOT_HELD = 0x1,
  turnstile_update_complete_flags::TURNSTILE_INTERLOCK_HELD = 0x2,
};

/* 6547 */
typedef turnstile_update_complete_flags turnstile_update_complete_flags_t;

/* 6548 */
enum turnstile_promote_policy : __int32
{
  turnstile_promote_policy::TURNSTILE_PROMOTE_NONE = 0x0,
  turnstile_promote_policy::TURNSTILE_KERNEL_PROMOTE = 0x1,
  turnstile_promote_policy::TURNSTILE_USER_PROMOTE = 0x2,
  turnstile_promote_policy::TURNSTILE_USER_IPC_PROMOTE = 0x4,
};

/* 6549 */
typedef turnstile_promote_policy turnstile_promote_policy_t;

/* 6550 */
struct turnstile_hashlist
{
  turnstile *slh_first;
};

/* 6551 */
struct turnstile_htable_bucket
{
  lck_spin_t_0 ts_ht_bucket_lock;
  turnstile_hashlist ts_ht_bucket_list;
};

/* 6552 */
typedef void (*mpsc_daemon_invoke_fn_t_0)(mpsc_queue_chain_t, mpsc_daemon_queue_t);

/* 6553 */
struct timer_coalescing_priority_params_ns_t
{
  uint32_t idle_entry_timer_processing_hdeadline_threshold_ns;
  uint32_t interrupt_timer_coalescing_ilat_threshold_ns;
  uint32_t timer_resort_threshold_ns;
  int32_t timer_coalesce_rt_shift;
  int32_t timer_coalesce_bg_shift;
  int32_t timer_coalesce_kt_shift;
  int32_t timer_coalesce_fp_shift;
  int32_t timer_coalesce_ts_shift;
  uint64_t timer_coalesce_rt_ns_max;
  uint64_t timer_coalesce_bg_ns_max;
  uint64_t timer_coalesce_kt_ns_max;
  uint64_t timer_coalesce_fp_ns_max;
  uint64_t timer_coalesce_ts_ns_max;
  uint32_t latency_qos_scale[6];
  uint64_t latency_qos_ns_max[6];
  boolean_t latency_tier_rate_limited[6];
};

/* 6554 */
typedef timer_call_0 timer_call_data_t;

/* 6555 */
struct threshold_t
{
  uint64_t interval;
  uint64_t margin;
  uint64_t deadline;
  uint64_t preempted;
  timer_call_t call;
  uint64_t deadline_set;
  timer_call_data_t timer;
  uint64_t scans;
  uint64_t preempts;
  uint64_t latency;
  uint64_t latency_min;
  uint64_t latency_max;
};

/* 6556 */
struct task_pend_token
{
  _BYTE gap0[4];
};

/* 6557 */
typedef task_pend_token *task_pend_token_t;

/* 6558 */
struct thread_requested_qos_policy
{
  integer_t thrq_base_qos;
  integer_t thrq_qos_relprio;
  integer_t thrq_qos_override;
  integer_t thrq_qos_promote;
  integer_t thrq_qos_kevent_override;
  integer_t thrq_qos_workq_override;
  integer_t thrq_qos_wlsvc_override;
};

/* 6559 */
struct thread_policy_state
{
  integer_t requested;
  integer_t effective;
  integer_t pending;
  integer_t flags;
  uint64_t thps_requested_policy;
  uint64_t thps_effective_policy;
  uint32_t thps_user_promotions;
  uint32_t thps_user_promotion_basepri;
  uint32_t thps_ipc_overrides;
  uint32_t reserved32;
  uint64_t reserved[2];
};

/* 6560 */
struct thread_qos_policy
{
  integer_t qos_tier;
  integer_t tier_importance;
};

/* 6561 */
typedef integer_t thread_latency_qos_t;

/* 6562 */
struct thread_latency_qos_policy
{
  thread_latency_qos_t thread_latency_qos_tier;
};

/* 6563 */
typedef integer_t thread_throughput_qos_t;

/* 6564 */
struct thread_throughput_qos_policy
{
  thread_throughput_qos_t thread_throughput_qos_tier;
};

/* 6565 */
struct thread_affinity_policy
{
  integer_t affinity_tag;
};

/* 6566 */
struct thread_precedence_policy
{
  integer_t importance;
};

/* 6567 */
struct thread_extended_policy
{
  boolean_t timeshare;
};

/* 6568 */
struct thread_time_constraint_with_priority_policy
{
  uint32_t period;
  uint32_t computation;
  uint32_t constraint;
  boolean_t preemptible;
  uint32_t priority;
};

/* 6569 */
struct qos_policy_params_t
{
  int16_t qos_pri[7];
  int16_t qos_iotier[7];
  uint32_t qos_through_qos[7];
  uint32_t qos_latency_qos[7];
};

/* 6570 */
union sched_clutch_edge
{
  struct
  {
    _BYTE gap0[4];
    uint32_t sce_migration_weight;
  };
  uint64_t sce_edge_packed;
};

/* 6571 */
typedef uint64_t sched_perfcontrol_preferred_cluster_options_t;

/* 6572 */
typedef void (*thread_group_iterate_fn_t)(void *, int, thread_group *);

/* 6578 */
struct thread_call_thread_state
{
  thread_call_group *thc_group;
  thread_call *thc_call;
  uint64_t thc_call_start;
  uint64_t thc_call_soft_deadline;
  uint64_t thc_call_hard_deadline;
  uint64_t thc_call_pending_timestamp;
  uint64_t thc_IOTES_invocation_timestamp;
  thread_call_func_t thc_func;
  thread_call_param_t thc_param0;
  thread_call_param_t thc_param1;
};

/* 6582 */
struct __attribute__((aligned(128))) thread_call_group
{
  lck_ticket_t_0 tcg_lock;
  const char *tcg_name;
  queue_head_t_0 pending_queue;
  uint32_t pending_count;
  queue_head_t_0 delayed_queues[2];
  priority_queue_deadline_min delayed_pqueues[2];
  timer_call_data_t delayed_timers[2];
  timer_call_data_t dealloc_timer;
  waitq_0 idle_waitq;
  uint64_t idle_timestamp;
  uint32_t idle_count;
  uint32_t active_count;
  uint32_t blocked_count;
  uint32_t tcg_thread_pri;
  uint32_t target_thread_count;
  waitq_0 waiters_waitq;
};

/* 6579 */
typedef uint32_t thread_call_options_t;

/* 6580 */
enum thread_call_priority_t : __int32
{
  THREAD_CALL_PRIORITY_HIGH = 0x0,
  THREAD_CALL_PRIORITY_KERNEL = 0x1,
  THREAD_CALL_PRIORITY_USER = 0x2,
  THREAD_CALL_PRIORITY_LOW = 0x3,
  THREAD_CALL_PRIORITY_KERNEL_HIGH = 0x4,
};

/* 6581 */
typedef thread_call thread_call_data_t;

/* 6583 */
struct _ca_event_thread_set_state
{
  ca_sstr current_proc[17];
};

/* 6584 */
typedef integer_t *thread_info_t;

/* 6585 */
struct thread_attr_for_ipc_propagation
{
  union
  {
    struct
    {
      _BYTE gap0[8];
    };
    uint64_t tafip_value;
  };
  uint64_t tafip_reserved;
};

/* 6586 */
typedef struct thread *thread_inspect_t;

/* 6587 */
typedef struct thread *thread_read_t;

/* 6588 */
typedef void (*sched_call_t)(int, thread_t_0);

/* 9374 */
typedef arm_kernel_context arm_kernel_context_t;

/* 6589 */
typedef arm_kernel_context_t machine_thread_kernel_state;

/* 8208 */
struct __attribute__((aligned(16))) arm_kernel_context
{
  arm_kernel_saved_state ss;
  arm_kernel_neon_saved_state ns;
};

/* 6590 */
struct __attribute__((aligned(16))) thread_kernel_state
{
  machine_thread_kernel_state machine;
  kern_allocation_name_t allocation_name;
};

/* 6591 */
struct thread_extended_info
{
  uint64_t pth_user_time;
  uint64_t pth_system_time;
  int32_t pth_cpu_usage;
  int32_t pth_policy;
  int32_t pth_run_state;
  int32_t pth_flags;
  int32_t pth_sleep_time;
  int32_t pth_curpri;
  int32_t pth_priority;
  int32_t pth_maxpriority;
  char pth_name[64];
};

/* 6592 */
struct policy_rr_info
{
  integer_t max_priority;
  integer_t base_priority;
  integer_t quantum;
  boolean_t depressed;
  integer_t depress_priority;
};

/* 6593 */
struct policy_timeshare_info
{
  integer_t max_priority;
  integer_t base_priority;
  integer_t cur_priority;
  boolean_t depressed;
  integer_t depress_priority;
};

/* 6594 */
struct thread_identifier_info
{
  uint64_t thread_id;
  uint64_t thread_handle;
  uint64_t dispatch_qaddr;
};

/* 6595 */
struct thread_basic_info
{
  time_value_t user_time;
  time_value_t system_time;
  integer_t cpu_usage;
  policy_t policy;
  integer_t run_state;
  integer_t flags;
  integer_t suspend_count;
  integer_t sleep_time;
};

/* 9375 */
typedef mach_port_t_1 exception_handler_t_0;

/* 6596 */
typedef exception_handler_t_0 exception_port_t;

/* 6597 */
typedef kcdata_object *kcdata_object_t;

/* 6598 */
struct thread_backtrace_elt
{
  mpsc_queue_chain link;
  exception_type_t exception_type;
  kcdata_object_t obj;
  exception_port_t exc_ports[3];
};

/* 6599 */
struct thread_exception_elt
{
  mpsc_queue_chain link;
  exception_type_t exception_type;
  task_t_0 exception_task;
  thread_t_1 exception_thread;
};

/* 6600 */
typedef integer_t *task_policy_t;

/* 6601 */
struct ledger_entry_info
{
  int64_t lei_balance;
  int64_t lei_credit;
  int64_t lei_debit;
  uint64_t lei_limit;
  uint64_t lei_refill_period;
  uint64_t lei_last_refill;
};

/* 6602 */
typedef thread_watchlist thread_watchlist_t;

/* 9018 */
struct __attribute__((aligned(8))) thread_watchlist
{
  thread_t_0 thread;
  int importance;
};

/* 6603 */
typedef task_watcher task_watch_t;

/* 9376 */
struct task_watcher
{
  queue_chain_t_0 tw_links;
  task_t_0 tw_task;
  thread_t_0 tw_thread;
  int tw_state;
  int tw_importance;
};

/* 6604 */
struct task_policy_state
{
  uint64_t requested;
  uint64_t effective;
  uint64_t pending;
  uint32_t imp_assertcnt;
  uint32_t imp_externcnt;
  uint64_t flags;
  uint64_t imp_transitions;
  uint64_t tps_requested_policy;
  uint64_t tps_effective_policy;
};

/* 6605 */
struct task_suppression_policy
{
  integer_t active;
  integer_t lowpri_cpu;
  integer_t timer_throttle;
  integer_t disk_throttle;
  integer_t cpu_limit;
  integer_t suspend;
  integer_t throughput_qos;
  integer_t suppressed_cpu;
  integer_t background_sockets;
  integer_t reserved[7];
};

/* 6606 */
typedef integer_t task_throughput_qos_t;

/* 6607 */
typedef integer_t task_latency_qos_t;

/* 6608 */
struct task_qos_policy
{
  task_latency_qos_t task_latency_qos_tier;
  task_throughput_qos_t task_throughput_qos_tier;
};

/* 6609 */
struct task_category_policy
{
  task_role_t role;
};

/* 6611 */
struct __attribute__((aligned(8))) ipc_importance_task
{
  ipc_importance_elem iit_elem;
  task_t_0 iit_task;
  queue_head_t_0 iit_inherits;
  queue_t iit_updateq;
  queue_chain_t_0 iit_updates;
  queue_chain_t_0 iit_props;
  uint64_t iit_updatetime;
  uint64_t iit_transitions;
  uint32_t iit_assertcnt;
  uint32_t iit_legacy_externcnt;
  uint32_t iit_legacy_externdrop;
};

/* 6612 */
typedef ipc_importance_task *ipc_importance_task_t;

/* 6613 */
struct task_power_info_extra
{
  uint64_t cycles;
  uint64_t instructions;
  uint64_t pcycles;
  uint64_t pinstructions;
  uint64_t user_ptime;
  uint64_t system_ptime;
  uint64_t runnable_time;
  uint64_t energy;
  uint64_t penergy;
};

/* 6948 */
typedef natural_t ipc_entry_bits_t;

/* 6947 */
typedef mach_port_name_t_0 mach_port_index_t;

/* 6946 */
typedef natural_t ipc_table_index_t;

/* 6614 */
struct ipc_entry
{
  _BYTE gap0[8];
  ipc_entry_bits_t ie_bits;
  __attribute__((aligned(8))) mach_port_index_t ie_index;
  union
  {
    mach_port_index_t ie_next;
    ipc_table_index_t ie_request;
  };
};

/* 6615 */
typedef thread_act_t *thread_act_array_t;

/* 6616 */
typedef struct task *task_policy_set_t;

/* 6617 */
typedef struct task *task_policy_get_t;

/* 6618 */
typedef struct task *task_inspect_t;

/* 6619 */
typedef struct task *task_name_t;

/* 6620 */
typedef struct task *task_read_t;

/* 6621 */
typedef gpu_energy_data *gpu_energy_data_t;

/* 6628 */
struct gpu_energy_data
{
  uint64_t task_gpu_utilisation;
  uint64_t task_gpu_stat_reserved0;
  uint64_t task_gpu_stat_reserved1;
  uint64_t task_gpu_stat_reserved2;
};

/* 6622 */
typedef _vm_object_query_data_ *vm_object_query_t;

/* 6623 */
typedef struct task *task_suspension_token_t;

/* 6625 */
struct task_flags_info
{
  uint32_t flags;
};

/* 6626 */
struct task_wait_state_info
{
  uint64_t total_wait_state_time;
  uint64_t total_wait_sfi_state_time;
  uint32_t _reserved[4];
};

/* 6627 */
struct __attribute__((packed)) __attribute__((aligned(4))) task_vm_info
{
  mach_vm_size_t_0 virtual_size;
  integer_t region_count;
  integer_t page_size;
  mach_vm_size_t_0 resident_size;
  mach_vm_size_t_0 resident_size_peak;
  mach_vm_size_t_0 device;
  mach_vm_size_t_0 device_peak;
  mach_vm_size_t_0 internal;
  mach_vm_size_t_0 internal_peak;
  mach_vm_size_t_0 external;
  mach_vm_size_t_0 external_peak;
  mach_vm_size_t_0 reusable;
  mach_vm_size_t_0 reusable_peak;
  mach_vm_size_t_0 purgeable_volatile_pmap;
  mach_vm_size_t_0 purgeable_volatile_resident;
  mach_vm_size_t_0 purgeable_volatile_virtual;
  mach_vm_size_t_0 compressed;
  mach_vm_size_t_0 compressed_peak;
  mach_vm_size_t_0 compressed_lifetime;
  mach_vm_size_t_0 phys_footprint;
  mach_vm_address_t_0 min_address;
  mach_vm_address_t_0 max_address;
  int64_t ledger_phys_footprint_peak;
  int64_t ledger_purgeable_nonvolatile;
  int64_t ledger_purgeable_novolatile_compressed;
  int64_t ledger_purgeable_volatile;
  int64_t ledger_purgeable_volatile_compressed;
  int64_t ledger_tag_network_nonvolatile;
  int64_t ledger_tag_network_nonvolatile_compressed;
  int64_t ledger_tag_network_volatile;
  int64_t ledger_tag_network_volatile_compressed;
  int64_t ledger_tag_media_footprint;
  int64_t ledger_tag_media_footprint_compressed;
  int64_t ledger_tag_media_nofootprint;
  int64_t ledger_tag_media_nofootprint_compressed;
  int64_t ledger_tag_graphics_footprint;
  int64_t ledger_tag_graphics_footprint_compressed;
  int64_t ledger_tag_graphics_nofootprint;
  int64_t ledger_tag_graphics_nofootprint_compressed;
  int64_t ledger_tag_neural_footprint;
  int64_t ledger_tag_neural_footprint_compressed;
  int64_t ledger_tag_neural_nofootprint;
  int64_t ledger_tag_neural_nofootprint_compressed;
  uint64_t limit_bytes_remaining;
  integer_t decompressions;
  int64_t ledger_swapins;
};

/* 6629 */
typedef task_power_info task_power_info_data_t;

/* 6631 */
struct task_power_info
{
  uint64_t total_user;
  uint64_t total_system;
  uint64_t task_interrupt_wakeups;
  uint64_t task_platform_idle_wakeups;
  uint64_t task_timer_wakeups_bin_1;
  uint64_t task_timer_wakeups_bin_2;
};

/* 6630 */
struct task_power_info_v2
{
  task_power_info_data_t cpu_energy;
  gpu_energy_data gpu_energy;
  uint64_t task_energy;
  uint64_t task_ptime;
  uint64_t task_pset_switches;
};

/* 6632 */
struct task_events_info
{
  integer_t faults;
  integer_t pageins;
  integer_t cow_faults;
  integer_t messages_sent;
  integer_t messages_received;
  integer_t syscalls_mach;
  integer_t syscalls_unix;
  integer_t csw;
};

/* 6633 */
struct policy_timeshare_base
{
  integer_t base_priority;
};

/* 6634 */
struct policy_rr_base
{
  integer_t base_priority;
  integer_t quantum;
};

/* 6635 */
struct task_kernelmemory_info
{
  uint64_t total_palloc;
  uint64_t total_pfree;
  uint64_t total_salloc;
  uint64_t total_sfree;
};

/* 6636 */
struct task_extmod_info
{
  unsigned __int8 task_uuid[16];
  vm_extmod_statistics_data_t extmod_statistics;
};

/* 6637 */
struct __attribute__((packed)) __attribute__((aligned(4))) task_dyld_info
{
  mach_vm_address_t_0 all_image_info_addr;
  mach_vm_size_t_0 all_image_info_size;
  integer_t all_image_info_format;
};

/* 6638 */
struct task_absolutetime_info
{
  uint64_t total_user;
  uint64_t total_system;
  uint64_t threads_user;
  uint64_t threads_system;
};

/* 6639 */
struct task_thread_times_info
{
  time_value_t user_time;
  time_value_t system_time;
};

/* 6640 */
struct mach_task_basic_info
{
  mach_vm_size_t_0 virtual_size;
  mach_vm_size_t_0 resident_size;
  mach_vm_size_t_0 resident_size_max;
  time_value_t user_time;
  time_value_t system_time;
  policy_t policy;
  integer_t suspend_count;
};

/* 6641 */
struct task_basic_info_64_2
{
  integer_t suspend_count;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_size_t_0 virtual_size;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_size_t_0 resident_size;
  time_value_t user_time;
  time_value_t system_time;
  policy_t policy;
};

/* 6642 */
struct task_basic_info_32
{
  integer_t suspend_count;
  natural_t virtual_size;
  natural_t resident_size;
  time_value_t user_time;
  time_value_t system_time;
  policy_t policy;
};

/* 6643 */
struct zinfo_usage_store_t
{
  uint64_t alloc;
  uint64_t free;
};

/* 6644 */
struct kern_invalid_args
{
  int32_t dummy;
};

/* 6912 */
typedef natural_t mach_msg_timeout_t;

/* 6645 */
struct thread_switch_args
{
  mach_port_name_t_0 thread_name;
  char thread_name_r_[4];
  int option;
  char option_r_[4];
  mach_msg_timeout_t option_time;
  char option_time_r_[4];
};

/* 6646 */
struct swtch_pri_args
{
  int pri;
  char pri_r_[4];
};

/* 6647 */
struct swtch_args
{
  int32_t dummy;
};

/* 6648 */
struct pfz_exit_args
{
  int32_t dummy;
};

/* 6649 */
struct semaphore_timedwait_signal_trap_args
{
  mach_port_name_t_0 wait_name;
  char wait_name_r_[4];
  mach_port_name_t_0 signal_name;
  char signal_name_r_[4];
  unsigned int sec;
  char sec_r_[4];
  clock_res_t nsec;
  char nsec_r_[4];
};

/* 6650 */
struct semaphore_wait_signal_trap_args
{
  mach_port_name_t_0 wait_name;
  char wait_name_r_[4];
  mach_port_name_t_0 signal_name;
  char signal_name_r_[4];
};

/* 6651 */
struct semaphore_timedwait_trap_args
{
  mach_port_name_t_0 wait_name;
  char wait_name_r_[4];
  unsigned int sec;
  char sec_r_[4];
  clock_res_t nsec;
  char nsec_r_[4];
};

/* 6652 */
struct semaphore_wait_trap_args
{
  mach_port_name_t_0 wait_name;
  char wait_name_r_[4];
};

/* 6653 */
struct semaphore_signal_all_trap_args
{
  mach_port_name_t_0 signal_name;
  char signal_name_r_[4];
};

/* 6654 */
struct semaphore_signal_trap_args
{
  mach_port_name_t_0 signal_name;
  char signal_name_r_[4];
};

/* 6655 */
struct semaphore_signal_thread_trap_args
{
  mach_port_name_t_0 signal_name;
  char signal_name_r_[4];
  mach_port_name_t_0 thread_name;
  char thread_name_r_[4];
};

/* 6656 */
struct __attribute__((aligned(4))) startup_tunable_dt_spec
{
  const char *dt_base;
  const char *dt_name;
  bool dt_chosen_override;
  const char *boot_arg_name;
  void *var_addr;
  int var_len;
  bool var_is_bool;
};

/* 6657 */
struct event_hdr
{
  event_hdr *next;
};

/* 6658 */
struct restartable_ranges
{
  queue_chain_t_0 rr_link;
  os_refcnt_t rr_ref;
  uint32_t rr_count;
  uint32_t rr_hash;
  task_restartable_range_t rr_ranges[64];
};

/* 6661 */
typedef hw_lck_ptr hw_lck_ptr_t;

/* 6659 */
struct smr_shash_mut_cursor_t
{
  hw_lck_ptr_t *head;
  __smrq_slink_t *prev;
};

/* 9033 */
union hw_lck_ptr
{
  struct
  {
    _BYTE gap0[6];
    uint16_t lck_ptr_mcs_tail;
  };
  uintptr_t lck_ptr_value;
};

/* 6903 */
struct smrsh_state_t
{
  uint8_t curidx;
  uint8_t curshift;
  uint8_t newidx;
  uint8_t newshift;
};

/* 9029 */
typedef uint64_t *scalable_counter_t;

/* 6660 */
struct smr_shash
{
  hw_lck_ptr_t *smrsh_array[2];
  uint32_t smrsh_seed[2];
  smrsh_state_t smrsh_state;
  _BYTE gap1C[12];
  scalable_counter_t smrsh_count;
  thread_call *smrsh_callout;
};

/* 6662 */
struct smr_record
{
  void *smrr_val;
  void (*smrr_dtor)(void *);
};

/* 6663 */
struct smr_bucket
{
  union
  {
    mpsc_queue_chain smrb_mplink;
    struct
    {
      smr_bucket *stqe_next;
    } smrb_stqlink;
  };
  uint32_t smrb_count;
  uint32_t smrb_size;
  smr_seq_t smrb_seq;
  smr_record smrb_recs[];
};

/* 9361 */
struct __attribute__((aligned(4))) timer_call_1
{
  uint64_t tc_soft_deadline;
  simple_lock_data_t_0 tc_lock;
  priority_queue_entry_deadline tc_pqlink;
  queue_head_t_0 *tc_queue;
  queue_chain_t_0 tc_qlink;
  timer_call_func_t tc_func;
  timer_call_param_t tc_param0;
  timer_call_param_t tc_param1;
  uint64_t tc_ttd;
  uint64_t tc_entry_time;
  uint32_t tc_flags;
  bool tc_async_dequeue;
};

/* 9839 */
typedef timer_call_1 timer_call_data_t_0;

/* 7107 */
typedef void (*thread_continue_t)(void *, wait_result_t);

/* 6664 */
struct sfi_class_state
{
  uint64_t off_time_usecs;
  uint64_t off_time_interval;
  timer_call_data_t_0 on_timer;
  uint64_t on_timer_deadline;
  boolean_t on_timer_programmed;
  boolean_t class_sfi_is_enabled;
  volatile boolean_t class_in_on_phase;
  waitq_0 waitq;
  thread_continue_t continuation;
  const char *class_name;
  const char *class_ledger_name;
};

/* 6665 */
struct sched_update_scan_context
{
  uint64_t earliest_bg_make_runnable_time;
  uint64_t earliest_normal_make_runnable_time;
  uint64_t earliest_rt_make_runnable_time;
  uint64_t sched_tick_last_abstime;
};

/* 6666 */
typedef sched_update_scan_context *sched_update_scan_context_t;

/* 6667 */
typedef int wait_timeout_urgency_t;

/* 6668 */
typedef rt_queue *rt_queue_t;

/* 6669 */
typedef run_queue *run_queue_t;

/* 6670 */
typedef sched_clutch_bucket *sched_clutch_bucket_t;

/* 6671 */
typedef sched_clutch_root *sched_clutch_root_t;

/* 6674 */
typedef void (*sched_avg_comp_t)(void *);

/* 6675 */
struct sched_average
{
  sched_avg_comp_t comp;
  void *param;
  int period;
  uint64_t deadline;
};

/* 6676 */
enum recount_cpu_kind_t : __int32
{
  RCT_CPU_EFFICIENCY = 0x0,
  RCT_CPU_PERFORMANCE = 0x1,
  RCT_CPU_KIND_COUNT = 0x2,
};

/* 6678 */
struct recount_times_mach
{
  uint64_t rtm_user;
  uint64_t rtm_system;
};

/* 6679 */
typedef const recount_plan *recount_plan_t;

/* 6680 */
enum recount_topo_t : __int32
{
  RCT_TOPO_SYSTEM = 0x0,
  RCT_TOPO_CPU = 0x1,
  RCT_TOPO_CPU_KIND = 0x2,
  RCT_TOPO_COUNT = 0x3,
};

/* 6681 */
struct __attribute__((aligned(8))) recount_plan
{
  const char *rpl_name;
  recount_topo_t rpl_topo;
};

/* 6682 */
typedef thread_t_0 *thread_array_t;

/* 6683 */
typedef integer_t *processor_set_info_t;

/* 6684 */
typedef task_t_0 *task_array_t;

/* 6685 */
struct processor_set_load_info
{
  int task_count;
  int thread_count;
  integer_t load_average;
  integer_t mach_factor;
};

/* 6686 */
struct processor_set_basic_info
{
  int processor_count;
  int default_policy;
};

/* 6687 */
struct processor_cpu_load_info
{
  unsigned int cpu_ticks[4];
};

/* 6688 */
struct processor_basic_info
{
  cpu_type_t_0 cpu_type;
  cpu_subtype_t_0 cpu_subtype;
  boolean_t running;
  int slot_num;
  union
  {
    boolean_t is_master;
    boolean_t is_main;
  };
};

/* 6689 */
struct shift_data
{
  int shift1;
  int shift2;
};

/* 6690 */
struct os_atomic_dependency_t
{
  unsigned __int64 __opaque_zero;
};

/* 6691 */
typedef mpsc_queue_head *mpsc_queue_head_t;

/* 9043 */
enum mpsc_queue_options : __int32
{
  mpsc_queue_options::MPSC_QUEUE_NONE = 0x0,
  mpsc_queue_options::MPSC_QUEUE_DISABLE_PREEMPTION = 0x1,
};

/* 6692 */
typedef mpsc_queue_options mpsc_queue_options_t;

/* 6693 */
struct mk_timer_cancel_trap_args
{
  mach_port_name_t_0 name;
  char name_r_[4];
  user_addr_t_0 result_time;
  char result_time_r_[];
};

/* 6694 */
struct mk_timer_arm_leeway_trap_args
{
  mach_port_name_t_0 name;
  char name_r_[4];
  uint64_t mk_timer_flags;
  uint64_t expire_time;
  uint64_t mk_leeway;
  char mk_leeway_r_[];
};

/* 6695 */
struct mk_timer_arm_trap_args
{
  mach_port_name_t_0 name;
  char name_r_[4];
  uint64_t expire_time;
  char expire_time_r_[];
};

/* 6696 */
struct mk_timer_destroy_trap_args
{
  mach_port_name_t_0 name;
  char name_r_[4];
};

/* 6697 */
struct mk_timer_create_trap_args
{
  int32_t dummy;
};

/* 6698 */
struct mk_timer
{
  simple_lock_data_t_0 lock;
  thread_call_data_t mkt_thread_call;
  _BYTE gap90[4];
  int active;
  ipc_port_t_0 port;
};

/* 6699 */
typedef integer_t *policy_base_t;

/* 6700 */
struct policy_timeshare_limit
{
  integer_t max_priority;
};

/* 6701 */
struct policy_fifo_limit
{
  integer_t max_priority;
};

/* 6702 */
struct policy_fifo_base
{
  integer_t base_priority;
};

/* 6703 */
struct policy_rr_limit
{
  integer_t max_priority;
};

/* 8193 */
enum cpu_event : __int32
{
  cpu_event::CPU_BOOT_REQUESTED = 0x0,
  cpu_event::CPU_BOOTED = 0x1,
  cpu_event::CPU_ACTIVE = 0x2,
  cpu_event::CLUSTER_ACTIVE = 0x3,
  cpu_event::CPU_EXIT_REQUESTED = 0x4,
  cpu_event::CPU_DOWN = 0x5,
  cpu_event::CLUSTER_EXIT_REQUESTED = 0x6,
  cpu_event::CPU_EXITED = 0x7,
};

/* 6704 */
typedef bool (*cpu_callback_t)(void *, cpu_event, unsigned int);

/* 6705 */
struct cpu_callback_chain_elem
{
  cpu_callback_t fn;
  void *param;
  cpu_callback_chain_elem *next;
};

/* 6706 */
struct __attribute__((aligned(8))) io_timeout_override_entry
{
  struct
  {
    io_timeout_override_entry *rbe_left;
    io_timeout_override_entry *rbe_right;
    io_timeout_override_entry *rbe_parent;
  } tree;
  uintptr_t iovaddr_base;
  unsigned int size;
  uint32_t read_timeout;
  uint32_t write_timeout;
};

/* 9048 */
typedef int mach_node_id_t;

/* 6707 */
struct mnl_node_info
{
  mach_node_id_t node_id;
  uint8_t datamodel;
  uint8_t byteorder;
  uint32_t proto_vers_min;
  uint32_t proto_vers_max;
};

/* 6708 */
typedef uint64_t mnl_name_t;

/* 6709 */
struct mnl_msg
{
  uint8_t sub;
  uint8_t cmd;
  uint8_t qos;
  uint8_t flags;
  uint32_t node_id;
  mnl_name_t object;
  uint32_t options;
  uint32_t size;
};

/* 6710 */
struct __block_literal_39
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
};

/* 6711 */
struct __block_literal_45
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_mtx_t *lock;
};

/* 6712 */
struct __block_literal_44
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_mtx_t *lock;
};

/* 6713 */
struct __block_literal_43
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_mtx_t *lock;
};

/* 6714 */
struct __block_literal_42
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_mtx_t *lock;
};

/* 6715 */
struct __block_literal_41
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_mtx_t *lock;
};

/* 6716 */
struct __block_literal_40
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_mtx_t *lock;
};

/* 6717 */
struct __block_literal_38
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_mtx_t *lock;
};

/* 6718 */
struct __block_literal_37
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_rw_t *lock;
};

/* 6719 */
struct __block_literal_36
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor_withcopydispose *__descriptor;
  struct *lck_rw_type;
  lck_rw_t *lock;
};

/* 6720 */
struct __block_literal_35
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_rw_t *lock;
};

/* 6721 */
struct __block_literal_34
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor_withcopydispose *__descriptor;
  struct *lck_rw_type;
  lck_rw_t *lock;
};

/* 6722 */
struct __block_literal_33
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor_withcopydispose *__descriptor;
  struct *lck_rw_type;
  lck_rw_t *lock;
};

/* 6723 */
typedef uint32_t ctid_t;

/* 6724 */
struct __block_literal_28
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor_withcopydispose *__descriptor;
  struct *lck_rw_type;
  lck_rw_t *lock;
};

/* 6725 */
struct __block_literal_27
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_rw_t *lock;
};

/* 6726 */
struct __attribute__((aligned(8))) usimple_lock_startup_spec
{
  usimple_lock_t lck;
  unsigned __int16 lck_init_arg;
};

/* 6727 */
struct lck_ticket_startup_spec
{
  lck_ticket_t *lck;
  lck_grp_t *lck_grp;
};

/* 6728 */
struct lck_spin_startup_spec
{
  lck_spin_t *lck;
  lck_grp_t *lck_grp;
  lck_attr_t *lck_attr;
};

/* 6729 */
struct lck_rw_startup_spec
{
  lck_rw_t *lck;
  lck_grp_t *lck_grp;
  lck_attr_t *lck_attr;
};

/* 6730 */
struct lck_mtx_startup_spec
{
  lck_mtx_t *lck;
  lck_grp_t *lck_grp;
  lck_attr_t *lck_attr;
};

/* 6731 */
enum lck_wake_action_t : __int32
{
  LCK_WAKE_DEFAULT = 0x0,
  LCK_WAKE_DO_NOT_TRANSFER_PUSH = 0x1,
};

/* 6732 */
enum gate_assert_flags_t : __int32
{
  GATE_ASSERT_CLOSED = 0x0,
  GATE_ASSERT_OPEN = 0x1,
  GATE_ASSERT_HELD = 0x2,
};

/* 6733 */
enum gate_handoff_flags_t : __int32
{
  GATE_HANDOFF_DEFAULT = 0x0,
  GATE_HANDOFF_OPEN_IF_NO_WAITERS = 0x1,
};

/* 9007 */
enum turnstile_type : __int8
{
  turnstile_type::TURNSTILE_NONE = 0x0,
  turnstile_type::TURNSTILE_KERNEL_MUTEX = 0x1,
  turnstile_type::TURNSTILE_ULOCK = 0x2,
  turnstile_type::TURNSTILE_PTHREAD_MUTEX = 0x3,
  turnstile_type::TURNSTILE_SYNC_IPC = 0x4,
  turnstile_type::TURNSTILE_WORKLOOPS = 0x5,
  turnstile_type::TURNSTILE_WORKQS = 0x6,
  turnstile_type::TURNSTILE_KNOTE = 0x7,
  turnstile_type::TURNSTILE_SLEEP_INHERITOR = 0x8,
  turnstile_type::TURNSTILE_TOTAL_TYPES = 0x9,
};

/* 6734 */
typedef turnstile_type turnstile_type_t;

/* 6735 */
typedef const hw_spin_policy *hw_spin_policy_t;

/* 6736 */
typedef cond_swi_var64 cond_swi_var64_s;

/* 9051 */
struct cond_swi_var64
{
  union
  {
    uint64_t cond64_data;
    struct
    {
      _BYTE gap0[4];
      uint32_t cond64_caller_extra;
    };
  };
};

/* 6737 */
typedef hslock *hw_lock_t;

/* 6738 */
typedef int wait_interrupt_t;

/* 6739 */
enum lck_sleep_action_t : __int32
{
  LCK_SLEEP_DEFAULT = 0x0,
  LCK_SLEEP_UNLOCK = 0x1,
  LCK_SLEEP_SHARED = 0x2,
  LCK_SLEEP_EXCLUSIVE = 0x4,
  LCK_SLEEP_SPIN = 0x8,
  LCK_SLEEP_PROMOTED_PRI = 0x10,
  LCK_SLEEP_SPIN_ALWAYS = 0x20,
};

/* 6740 */
typedef gate gate_t;

/* 9052 */
struct __attribute__((aligned(8))) gate
{
  uintptr_t gt_data;
  turnstile *gt_turnstile;
  union
  {
    struct
    {
      _BYTE gap0[4];
    };
    uint32_t gt_flags;
  };
};

/* 6741 */
typedef lck_spinlock_to_info *lck_spinlock_to_info_t;

/* 6742 */
struct lck_spin_mcs
{
  lck_spin_mcs *lsm_next;
  const void *lsm_lock;
  unsigned __int64 lsm_ready;
};

/* 6744 */
struct __attribute__((aligned(32))) lck_mtx_mcs
{
  _lck_mtx_ *lmm_ilk_current;
  lck_mtx_mcs *lmm_ilk_next;
  unsigned __int64 lmm_ilk_ready;
  lck_mtx_mcs *lmm_as_next;
  unsigned __int64 lmm_as_prev;
};

/* 6745 */
enum lck_rw_grab_flags_t : __int32
{
  LCK_RW_GRAB_F_SHARED = 0x0,
  LCK_RW_GRAB_F_WANT_EXCL = 0x1,
  LCK_RW_GRAB_F_WAIT = 0x2,
};

/* 6746 */
typedef uint32_t hw_lock_bit_t;

/* 6747 */
typedef lck_spin_mcs *lck_spin_mcs_t;

/* 6748 */
struct __attribute__((aligned(16))) lck_mcs
{
  lck_mtx_mcs mcs_mtx;
  volatile unsigned __int64 mcs_spin_rsv;
  lck_spin_mcs mcs_spin[2];
};

/* 6753 */
typedef lockgroup_info lockgroup_info_t;

/* 6750 */
typedef lockgroup_info_t *lockgroup_info_array_t;

/* 9058 */
struct lockgroup_info
{
  char lockgroup_name[64];
  uint64_t lockgroup_attr;
  uint64_t lock_spin_cnt;
  uint64_t lock_spin_util_cnt;
  uint64_t lock_spin_held_cnt;
  uint64_t lock_spin_miss_cnt;
  uint64_t lock_spin_held_max;
  uint64_t lock_spin_held_cum;
  uint64_t lock_mtx_cnt;
  uint64_t lock_mtx_util_cnt;
  uint64_t lock_mtx_held_cnt;
  uint64_t lock_mtx_miss_cnt;
  uint64_t lock_mtx_wait_cnt;
  uint64_t lock_mtx_held_max;
  uint64_t lock_mtx_held_cum;
  uint64_t lock_mtx_wait_max;
  uint64_t lock_mtx_wait_cum;
  uint64_t lock_rw_cnt;
  uint64_t lock_rw_util_cnt;
  uint64_t lock_rw_held_cnt;
  uint64_t lock_rw_miss_cnt;
  uint64_t lock_rw_wait_cnt;
  uint64_t lock_rw_held_max;
  uint64_t lock_rw_held_cum;
  uint64_t lock_rw_wait_max;
  uint64_t lock_rw_wait_cum;
};

/* 6751 */
struct __attribute__((aligned(16))) lck_grp_spec
{
  lck_grp_t *grp;
  char grp_name[64];
};

/* 6752 */
struct lck_attr_startup_spec
{
  lck_attr_t *lck_attr;
  uint32_t lck_attr_set_flags;
  uint32_t lck_attr_clear_flags;
};

/* 6754 */
typedef uint32_t compact_id_t;

/* 6755 */
struct ledger_info
{
  char li_name[32];
  int64_t li_id;
  int64_t li_entries;
};

/* 6756 */
struct ledger_template_info
{
  char lti_name[32];
  char lti_group[32];
  char lti_units[32];
};

/* 6757 */
struct ledger_entry
{
  volatile uint32_t le_flags;
  uint16_t le_warn_percent;
  ledger_amount_t le_limit;
  volatile ledger_amount_t le_credit;
  volatile ledger_amount_t le_debit;
  union
  {
    struct
    {
      uint64_t le_refill_period;
      uint64_t le_last_refill;
    } le_refill;
    struct
    {
      ledger_amount_t le_lifetime_max;
      ledger_amount_t le_interval_max;
    } _le_max;
  } _le;
};

/* 6762 */
typedef ledger_template *ledger_template_t;

/* 6763 */
struct kern_apfs_reflock
{
  union
  {
    cond_swi_var64_s kern_apfs_rl_data;
    struct
    {
      _BYTE gap0[8];
    };
  };
};

/* 6764 */
struct cond_swi_var;

/* 6765 */
struct kheap_info
{
  zone_id_t kh_zstart;
  union
  {
    kalloc_heap_t kh_views;
    kalloc_type_var_view_t kt_views;
  };
};

/* 6767 */
struct thread_get_special_reply_port_args
{
  int32_t dummy;
};

/* 6768 */
struct mach_reply_port_args
{
  int32_t dummy;
};

/* 6769 */
struct thread_self_trap_args
{
  int32_t dummy;
};

/* 6770 */
struct task_self_trap_args
{
  int32_t dummy;
};

/* 6771 */
typedef ipc_space *ipc_space_read_t;

/* 6772 */
typedef ipc_info_port_t *exception_port_info_array_t;

/* 6773 */
typedef thread_state_flavor_t *thread_state_flavor_array_t;

/* 6774 */
typedef exception_behavior_t *exception_behavior_array_t;

/* 6775 */
typedef mach_port_t_0 *exception_port_array_t;

/* 6776 */
typedef exception_mask_t *exception_mask_array_t;

/* 6777 */
typedef unsigned int mach_thread_flavor_t;

/* 6778 */
struct thread_init_exc_actions
{
  exception_action array[14];
};

/* 6779 */
typedef mach_port_t_0 *mach_port_array_t;

/* 6780 */
typedef mach_msg_security_trailer_t mach_msg_format_0_trailer_t;

/* 9379 */
struct mach_msg_security_trailer_t
{
  mach_msg_trailer_type_t msgh_trailer_type;
  mach_msg_trailer_size_t msgh_trailer_size;
  mach_port_seqno_t msgh_seqno;
  security_token_t msgh_sender;
};

/* 6781 */
struct mig_hash_t
{
  mach_msg_id_t num;
  mig_routine_t_0 routine;
  int size;
  int kobjidx;
};

/* 6782 */
typedef routine_descriptor_1 mig_routine_descriptor;

/* 9381 */
struct __attribute__((aligned(8))) routine_descriptor_1
{
  mig_impl_routine_t_0 impl_routine;
  mig_stub_routine_t_0 stub_routine;
  unsigned int argc;
  unsigned int descr_count;
  routine_arg_descriptor_t_0 arg_descr;
  unsigned int max_reply_msg;
};

/* 6783 */
struct mig_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  mach_msg_size_t maxsize;
  vm_address_t_0 reserved;
  mig_routine_descriptor routine[1];
};

/* 6784 */
struct host_self_trap_args
{
  int32_t dummy;
};

/* 6785 */
typedef processor_set_t processor_set_name_t;

/* 6909 */
typedef ipc_table_index_t ipc_port_request_index_t;

/* 6786 */
struct __attribute__((aligned(8))) host_notify_entry
{
  queue_chain_t_0 entries;
  ipc_port_t_0 port;
  ipc_port_request_index_t index;
};

/* 6787 */
typedef mach_port_t_1 io_main_t;

/* 6788 */
typedef processor_set_t *processor_set_name_array_t;

/* 6789 */
typedef integer_t *host_info64_t;

/* 6790 */
struct host_preferred_user_arch
{
  cpu_type_t_0 cpu_type;
  cpu_subtype_t_0 cpu_subtype;
};

/* 6791 */
struct host_can_has_debugger_info
{
  boolean_t can_has_debugger;
};

/* 6792 */
struct host_priority_info
{
  integer_t kernel_priority;
  integer_t system_priority;
  integer_t server_priority;
  integer_t user_priority;
  integer_t depress_priority;
  integer_t idle_priority;
  integer_t minimum_priority;
  integer_t maximum_priority;
};

/* 6793 */
struct host_sched_info
{
  integer_t min_timeout;
  integer_t min_quantum;
};

/* 6794 */
struct host_basic_info
{
  integer_t max_cpus;
  integer_t avail_cpus;
  natural_t memory_size;
  cpu_type_t cpu_type;
  cpu_subtype_t_0 cpu_subtype;
  cpu_threadtype_t cpu_threadtype;
  integer_t physical_cpu;
  integer_t physical_cpu_max;
  integer_t logical_cpu;
  integer_t logical_cpu_max;
  uint64_t max_mem;
};

/* 6795 */
struct __attribute__((aligned(8))) host_stats_cache
{
  uint64_t last_access;
  uint64_t current_requests;
  uint64_t max_requests;
  uintptr_t data;
  mach_msg_type_number_t count;
};

/* 6796 */
struct __attribute__((packed)) __attribute__((aligned(1))) _ca_event_pac_exception_event
{
  unsigned __int64 exception;
  unsigned __int64 exception_code_0;
  unsigned __int64 exception_code_1;
  ca_sstr proc_name[17];
};

/* 6797 */
struct gpu_descriptor
{
  uint32_t gpu_id;
  uint32_t gpu_max_domains;
};

/* 6798 */
typedef gpu_descriptor *gpu_descriptor_t;

/* 6799 */
enum mcc_ecc_version_t : __int32
{
  MCC_ECC_V1 = 0x0,
  MCC_ECC_NUM_VERSIONS = 0x1,
};

/* 6800 */
struct mcc_ecc_event_t
{
  mcc_ecc_version_t version;
  __attribute__((aligned(8))) uint32_t status;
  uint32_t amcc;
  uint32_t plane;
  uint32_t bank;
  uint32_t way;
  uint32_t index;
  uint32_t bit_off_cl;
  uint32_t bit_off_within_hcl;
};

/* 6801 */
struct ecc_event
{
  uint8_t id;
  uint8_t count;
  uint64_t data[8];
};

/* 6802 */
enum kdp_event_t : __int32
{
  KDP_EVENT_ENTER = 0x0,
  KDP_EVENT_EXIT = 0x1,
  KDP_EVENT_PANICLOG = 0x2,
};

/* 6803 */
typedef void (*kdp_callout_fn_t)(void *, kdp_event_t);

/* 6804 */
struct kdp_callout
{
  kdp_callout *callout_next;
  kdp_callout_fn_t callout_fn;
  boolean_t callout_in_progress;
  void *callout_arg;
};

/* 6805 */
struct __attribute__((aligned(8))) additional_panic_data_buffer
{
  const char *producer_name;
  void *buf;
  int len;
};

/* 6806 */
enum cpu_quiescent_state_t : __int32
{
  CPU_QUIESCE_COUNTER_NONE = 0x0,
  CPU_QUIESCE_COUNTER_PENDING_JOIN = 0x1,
  CPU_QUIESCE_COUNTER_JOINED = 0x2,
  CPU_QUIESCE_COUNTER_LEFT = 0x3,
};

/* 6807 */
struct __attribute__((aligned(8))) compact_id_table
{
  void **cidt_array[12];
  bitmap_t *cidt_bitmap[12];
  lck_mtx_t_0 cidt_lock;
  thread *cidt_allocator;
  bool cidt_waiters;
  uint32_t cidt_count;
  compact_id_t cidt_first_free;
};

/* 6808 */
typedef compact_id_table *compact_id_table_t;

/* 6809 */
struct coalition_resource_usage
{
  uint64_t tasks_started;
  uint64_t tasks_exited;
  uint64_t time_nonempty;
  uint64_t cpu_time;
  uint64_t interrupt_wakeups;
  uint64_t platform_idle_wakeups;
  uint64_t bytesread;
  uint64_t byteswritten;
  uint64_t gpu_time;
  uint64_t cpu_time_billed_to_me;
  uint64_t cpu_time_billed_to_others;
  uint64_t energy;
  uint64_t logical_immediate_writes;
  uint64_t logical_deferred_writes;
  uint64_t logical_invalidated_writes;
  uint64_t logical_metadata_writes;
  uint64_t logical_immediate_writes_to_external;
  uint64_t logical_deferred_writes_to_external;
  uint64_t logical_invalidated_writes_to_external;
  uint64_t logical_metadata_writes_to_external;
  uint64_t energy_billed_to_me;
  uint64_t energy_billed_to_others;
  uint64_t cpu_ptime;
  uint64_t cpu_time_eqos_len;
  uint64_t cpu_time_eqos[7];
  uint64_t cpu_instructions;
  uint64_t cpu_cycles;
  uint64_t fs_metadata_writes;
  uint64_t pm_writes;
  uint64_t cpu_pinstructions;
  uint64_t cpu_pcycles;
};

/* 6813 */
typedef coalition *coalition_t;

/* 6810 */
typedef void (*coalition_iterate_fn_t)(void *, int, coalition_t);

/* 6811 */
struct procinfo_coalinfo
{
  uint64_t coalition_id;
  uint32_t coalition_type;
  uint32_t coalition_tasks;
};

/* 6812 */
struct coalition_type
{
  int type;
  int has_default;
  kern_return_t (*init)(coalition_t, boolean_t, boolean_t);
  void (*dealloc)(coalition_t);
  kern_return_t (*adopt_task)(coalition_t, task_t_0);
  kern_return_t (*remove_task)(coalition_t, task_t_0);
  kern_return_t (*set_taskrole)(coalition_t, task_t_0, int);
  int (*get_taskrole)(coalition_t, task_t_0);
  void (*iterate_tasks)(coalition_t, void *, void (*)(coalition_t, void *, task_t_0));
};

/* 9030 */
struct smrh_key_t_0
{
  union
  {
    const char *smrk_string;
    const void *smrk_opaque;
    uint64_t smrk_u64;
  };
  size_t smrk_len;
};

/* 9382 */
struct smrh_traits_0
{
  unsigned __int64 link_offset;
  smr_t domain;
  uint32_t (*key_hash)(smrh_key_t_0, uint32_t);
  bool (*key_equ)(smrh_key_t, smrh_key_t);
  uint32_t (*obj_hash)(const smrq_slink *, uint32_t);
  bool (*obj_equ)(const smrq_slink *, smrh_key_t_0);
  bool (*obj_try_get)(void *);
};

/* 6816 */
struct coal_hash_traits
{
  smrh_traits_0 smrht;
};

/* 6818 */
typedef int sleep_type_t;

/* 6817 */
struct clock_sleep_trap_args
{
  mach_port_name_t_0 clock_name;
  char clock_name_r_[4];
  sleep_type_t sleep_type;
  char sleep_type_r_[4];
  int sleep_sec;
  char sleep_sec_r_[4];
  int sleep_nsec;
  char sleep_nsec_r_[4];
  user_addr_t_0 wakeup_time;
  char wakeup_time_r_[];
};

/* 6819 */
struct alarm
{
  alarm *al_next;
  alarm *al_prev;
  int al_status;
  mach_timespec_t al_time;
  struct
  {
    int type;
    ipc_port_t_1 port;
    mach_msg_type_name_t port_type;
    clock *clock;
    void *data;
  } al_alrm;
  long al_seqno;
};

/* 6824 */
struct mach_wait_until_trap_args
{
  uint64_t deadline;
  char deadline_r_[];
};

/* 6825 */
struct mach_timebase_info_trap_args
{
  user_addr_t_0 info;
  char info_r_[];
};

/* 6828 */
struct bintime
{
  time_t sec;
  uint64_t frac;
};

/* 9081 */
struct clock_calend
{
  uint64_t s_scale_ns;
  int64_t s_adj_nsx;
  uint64_t tick_scale_x;
  uint64_t offset_count;
  bintime offset;
  bintime bintime;
  bintime boottime;
  bintime basesleep;
};

/* 6826 */
struct __attribute__((aligned(8))) unlocked_clock_calend
{
  clock_calend calend;
  uint32_t gen;
};

/* 6829 */
typedef bt_library *bt_library_t;

/* 6834 */
typedef bt_hash *bt_hash_t;

/* 6831 */
typedef uint32_t btref_t;

/* 9083 */
struct bt_library
{
  lck_ticket_t_0 btl_lock;
  struct
  {
    volatile uint32_t __smr_ptr;
  } btl_param;
  bt_hash_t *btl_hash[2];
  thread_call_t btl_call;
  thread_t_0 btl_grower;
  btref_t *btl_free_tail;
  btref_t btl_free_head;
  btref_t btl_deferred_head;
  bool btl_waiters;
  bool btl_in_callout;
  bool btl_rehashing;
  uint8_t btl_slab_cur;
  uint32_t btl_alloc_pos;
  uint32_t btl_faulted_pos;
  uint32_t btl_max_pos;
  vm_address_t_0 btl_slabs[9];
};

/* 6832 */
struct btref_smr_t
{
  volatile btref_t __smr_ptr;
};

/* 6833 */
struct bt_hash
{
  btref_smr_t bth_array[256];
};

/* 6830 */
union bt_stack
{
  struct
  {
    btref_smr_t bts_next;
    uint32_t bts_ref_len;
    uint32_t bts_hash;
    uint32_t bts_frames[13];
  };
  struct
  {
    uint32_t bts_padding[13];
    uint32_t bts_free_next;
    smr_seq_t bts_free_seq;
  };
};

/* 6835 */
struct backtrace_user_info
{
  _BYTE gap0[4];
  errno_t btui_error;
  unsigned int btui_async_start_index;
  uintptr_t btui_async_frame_addr;
  uintptr_t btui_next_frame_addr;
};

/* 6839 */
struct backtrace_control
{
  _BYTE gap0[8];
  uintptr_t btc_frame_addr;
  void *btc_user_thread;
  backtrace_user_copy_fn btc_user_copy;
  void *btc_user_copy_context;
  int64_t btc_addr_offset;
};

/* 6840 */
typedef arcade_register *arcade_register_t;

/* 9084 */
struct arcade_register
{
  ipc_port_t_0 ar_port;
};

/* 6842 */
struct task_affinity_tag_info
{
  integer_t set_count;
  integer_t min;
  integer_t max;
  integer_t task_count;
};

/* 6843 */
typedef mach_port_options mach_port_options_t;

/* 6851 */
typedef natural_t mach_port_msgcount_t;

/* 9089 */
struct mach_port_limits
{
  mach_port_msgcount_t mpl_qlimit;
};

/* 6852 */
typedef mach_port_limits mach_port_limits_t;

/* 9383 */
struct mach_port_options
{
  uint32_t flags;
  mach_port_limits_t mpl;
  union
  {
    uint64_t reserved[2];
    mach_port_name_t_0 work_interval_port;
    uint32_t service_port_info32;
    uint64_t service_port_info64;
    mach_port_name_t_0 service_port_name;
  };
};

/* 6844 */
typedef mach_service_port_info *mach_service_port_info_t;

/* 6845 */
typedef char *mach_msg_trailer_info_t;

/* 6846 */
typedef ipc_entry *ipc_entry_t;

/* 6847 */
typedef mach_port_guard_info mach_port_guard_info_t;

/* 9088 */
struct mach_port_guard_info
{
  uint64_t mpgi_guard;
};

/* 6848 */
struct ipc_service_port_label
{
  _BYTE gap0[8];
  mach_port_context_t ispl_launchd_context;
  mach_port_name_t_0 ispl_launchd_name;
  _BYTE gap14[2];
  uint8_t ispl_domain;
  char *ispl_service_name;
};

/* 6849 */
typedef mach_port_info_ext mach_port_info_ext_t;

/* 7113 */
typedef natural_t mach_port_rights_t;

/* 9384 */
struct mach_port_status
{
  mach_port_rights_t mps_pset;
  mach_port_seqno_t mps_seqno;
  mach_port_mscount_t mps_mscount;
  mach_port_msgcount_t mps_qlimit;
  mach_port_msgcount_t mps_msgcount;
  mach_port_rights_t mps_sorights;
  boolean_t mps_srights;
  boolean_t mps_pdrequest;
  boolean_t mps_nsrequest;
  natural_t mps_flags;
};

/* 6850 */
typedef mach_port_status mach_port_status_t;

/* 9841 */
struct mach_port_info_ext
{
  mach_port_status_t mpie_status;
  mach_port_msgcount_t mpie_boost_cnt;
  uint32_t reserved[6];
};

/* 6853 */
struct ipc_pset
{
  ipc_object ips_object;
  waitq_set ips_wqset;
  klist ips_klist;
};

/* 6854 */
struct mach_msg2_trap_args
{
  mach_vm_address_t_0 data;
  __attribute__((aligned(16))) uint64_t msgh_bits_and_send_size;
  uint64_t msgh_remote_and_local_port;
  uint64_t msgh_voucher_and_id;
  uint64_t desc_count_and_rcv_name;
  uint64_t rcv_size_and_priority;
  uint64_t timeout;
  char timeout_r_[];
};

/* 6932 */
typedef integer_t mach_msg_option_t;

/* 9091 */
typedef unsigned int mach_msg_priority_t;

/* 6855 */
struct mach_msg_overwrite_trap_args
{
  user_addr_t_0 msg;
  mach_msg_option_t option;
  char option_r_[4];
  mach_msg_size_t send_size;
  char send_size_r_[4];
  mach_msg_size_t rcv_size;
  char rcv_size_r_[4];
  mach_port_name_t_0 rcv_name;
  char rcv_name_r_[4];
  mach_msg_timeout_t timeout;
  char timeout_r_[4];
  mach_msg_priority_t priority;
  char priority_r_[4];
  user_addr_t_0 rcv_msg;
  char rcv_msg_r_[];
};

/* 6856 */
struct __attribute__((packed)) __attribute__((aligned(1))) _ca_event_mach_msg_trap_event
{
  unsigned __int64 msgh_id;
  unsigned __int64 sw_platform;
  unsigned __int64 sdk;
  ca_sstr team_id[32];
  ca_sstr signing_id[128];
  ca_sstr proc_name[17];
};

/* 6857 */
struct mach_msg_user_header_t
{
  mach_msg_bits_t msgh_bits;
  mach_msg_size_t msgh_size;
  mach_port_name_t_0 msgh_remote_port;
  mach_port_name_t_0 msgh_local_port;
  mach_port_name_t_0 msgh_voucher_port;
  mach_msg_id_t msgh_id;
};

/* 6858 */
struct mach_msg_vector_t
{
  mach_vm_address_t_0 msgv_data;
  mach_vm_address_t_0 msgv_rcv_addr;
  mach_msg_size_t msgv_send_size;
  mach_msg_size_t msgv_rcv_size;
};

/* 6859 */
typedef void (*mach_msg_filter_retain_sblabel_cbfunc_t)(void *);

/* 6860 */
typedef kern_return_t (*mach_msg_filter_get_connection_port_filter_policy_cbfunc_t)(void *, void *, uint64_t *);

/* 6861 */
typedef void *(*mach_msg_filter_derive_sblabel_from_service_port_cbfunc_t)(void *, boolean_t *);

/* 6862 */
typedef void (*mach_msg_filter_dealloc_service_port_sblabel_cbfunc_t)(void *);

/* 6864 */
typedef kern_return_t (*mach_msg_filter_alloc_service_port_sblabel_cbfunc_t)(mach_service_port_info_t, void **);

/* 6865 */
typedef boolean_t (*mach_msg_fetch_filter_policy_cbfunc_t)(struct task *, void *, mach_msg_id_t, mach_msg_filter_id *);

/* 6866 */
struct task_dyld_process_info_notify_get_trap_args
{
  mach_vm_address_t_0 names_addr;
  mach_vm_address_t_0 names_count_addr;
  char names_count_addr_r_[];
};

/* 9092 */
typedef uint8_t *mach_voucher_attr_raw_recipe_t;

/* 6867 */
struct mach_voucher_extract_attr_recipe_args
{
  mach_port_name_t_0 voucher_name;
  char voucher_name_r_[4];
  mach_voucher_attr_key_t key;
  char key_r_[4];
  mach_voucher_attr_raw_recipe_t recipe;
  user_addr_t_0 recipe_size;
  char recipe_size_r_[];
};

/* 9093 */
typedef mach_voucher_attr_raw_recipe_t mach_voucher_attr_raw_recipe_array_t;

/* 6868 */
struct host_create_mach_voucher_args
{
  mach_port_name_t_0 host;
  char host_r_[4];
  mach_voucher_attr_raw_recipe_array_t recipes;
  int recipes_size;
  char recipes_size_r_[4];
  user_addr_t_0 voucher;
  char voucher_r_[];
};

/* 6869 */
struct _kernelrpc_mach_port_request_notification_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_port_name_t_0 name;
  char name_r_[4];
  mach_msg_id_t msgid;
  char msgid_r_[4];
  mach_port_mscount_t sync;
  char sync_r_[4];
  mach_port_name_t_0 notify;
  char notify_r_[4];
  mach_msg_type_name_t notifyPoly;
  char notifyPoly_r_[4];
  user_addr_t_0 previous;
  char previous_r_[];
};

/* 6870 */
struct _kernelrpc_mach_port_type_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_port_right_t name;
  char name_r_[4];
  user_addr_t_0 ptype;
  char ptype_r_[];
};

/* 6871 */
struct _kernelrpc_mach_port_unguard_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_port_name_t_0 name;
  char name_r_[4];
  uint64_t guard;
  char guard_r_[];
};

/* 6872 */
struct _kernelrpc_mach_port_guard_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_port_name_t_0 name;
  char name_r_[4];
  uint64_t guard;
  boolean_t strict;
  char strict_r_[4];
};

/* 6873 */
struct _kernelrpc_mach_port_destruct_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_port_name_t_0 name;
  char name_r_[4];
  mach_port_delta_t srdelta;
  char srdelta_r_[4];
  uint64_t guard;
  char guard_r_[];
};

/* 6874 */
struct _kernelrpc_mach_port_construct_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  user_addr_t_0 options;
  uint64_t context;
  user_addr_t_0 name;
  char name_r_[];
};

/* 6875 */
struct _kernelrpc_mach_port_extract_member_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_port_name_t_0 name;
  char name_r_[4];
  mach_port_name_t_0 pset;
  char pset_r_[4];
};

/* 6876 */
struct _kernelrpc_mach_port_insert_member_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_port_name_t_0 name;
  char name_r_[4];
  mach_port_name_t_0 pset;
  char pset_r_[4];
};

/* 6877 */
struct _kernelrpc_mach_port_get_attributes_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_port_name_t_0 name;
  char name_r_[4];
  mach_port_flavor_t flavor;
  char flavor_r_[4];
  user_addr_t_0 info;
  user_addr_t_0 count;
  char count_r_[];
};

/* 6878 */
struct _kernelrpc_mach_port_insert_right_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_port_name_t_0 name;
  char name_r_[4];
  mach_port_name_t_0 poly;
  char poly_r_[4];
  mach_msg_type_name_t polyPoly;
  char polyPoly_r_[4];
};

/* 6879 */
struct _kernelrpc_mach_port_move_member_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_port_name_t_0 member;
  char member_r_[4];
  mach_port_name_t_0 after;
  char after_r_[4];
};

/* 6880 */
struct _kernelrpc_mach_port_mod_refs_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_port_name_t_0 name;
  char name_r_[4];
  mach_port_right_t right;
  char right_r_[4];
  mach_port_delta_t delta;
  char delta_r_[4];
};

/* 6881 */
struct _kernelrpc_mach_port_deallocate_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_port_name_t_0 name;
  char name_r_[4];
};

/* 6882 */
struct _kernelrpc_mach_port_allocate_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_port_right_t right;
  char right_r_[4];
  user_addr_t_0 name;
  char name_r_[];
};

/* 6883 */
struct _kernelrpc_mach_vm_purgable_control_trap_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_vm_offset_t address;
  vm_purgable_t control;
  char control_r_[4];
  user_addr_t_0 state;
  char state_r_[];
};

/* 6884 */
struct _kernelrpc_mach_vm_map_trap_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  user_addr_t_0 addr;
  mach_vm_size_t_0 size;
  mach_vm_offset_t mask;
  int flags;
  char flags_r_[4];
  vm_prot_t cur_protection;
  char cur_protection_r_[4];
};

/* 6885 */
struct _kernelrpc_mach_vm_protect_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  boolean_t set_maximum;
  char set_maximum_r_[4];
  vm_prot_t new_protection;
  char new_protection_r_[4];
};

/* 6886 */
struct _kernelrpc_mach_vm_deallocate_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  char size_r_[];
};

/* 6887 */
struct _kernelrpc_mach_vm_allocate_trap_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  user_addr_t_0 addr;
  mach_vm_size_t_0 size;
  int flags;
  char flags_r_[4];
};

/* 6891 */
typedef ipc_info_tree_name ipc_info_tree_name_t;

/* 6888 */
typedef ipc_info_tree_name_t *ipc_info_tree_name_array_t;

/* 8868 */
typedef natural_t mach_port_type_t;

/* 8862 */
typedef natural_t mach_port_urefs_t;

/* 9385 */
struct ipc_info_name
{
  mach_port_name_t_0 iin_name;
  integer_t iin_collision;
  mach_port_type_t iin_type;
  mach_port_urefs_t iin_urefs;
  natural_t iin_object;
  natural_t iin_next;
  natural_t iin_hash;
};

/* 6892 */
typedef ipc_info_name ipc_info_name_t;

/* 9842 */
struct ipc_info_tree_name
{
  ipc_info_name_t iitn_name;
  mach_port_name_t_0 iitn_lchild;
  mach_port_name_t_0 iitn_rchild;
};

/* 6889 */
struct IOObject;

/* 6890 */
struct __attribute__((aligned(8))) ipc_port_request
{
  union
  {
    ipc_port *ipr_soright;
    host_notify_entry *ipr_hnotify;
  };
  union
  {
    mach_port_name_t_0 ipr_name;
    ipc_port_request_index_t ipr_next;
  };
};

/* 6893 */
struct mach_generate_activity_id_args
{
  mach_port_name_t_0 target;
  char target_r_[4];
  int count;
  char count_r_[4];
  user_addr_t_0 activity_id;
  char activity_id_r_[];
};

/* 6894 */
typedef uint32_t ipc_pthread_priority_value_t;

/* 6895 */
typedef mach_msg_type_number_t mach_voucher_attr_raw_recipe_array_size_t;

/* 6896 */
typedef mach_msg_type_number_t mach_voucher_attr_raw_recipe_size_t;

/* 6897 */
typedef mach_msg_type_number_t ipc_voucher_attr_raw_recipe_array_size_t;

/* 9097 */
typedef uint8_t *ipc_voucher_attr_raw_recipe_t;

/* 6898 */
typedef ipc_voucher_attr_raw_recipe_t ipc_voucher_attr_raw_recipe_array_t;

/* 6899 */
struct user_data_value_element
{
  mach_voucher_attr_value_reference_t e_made;
  mach_voucher_attr_content_size_t e_size;
  iv_index_t e_sum;
  iv_index_t e_hash;
  queue_chain_t_0 e_hash_link;
  uint8_t *e_data;
};

/* 6900 */
typedef ipc_voucher_attr_recipe_data ipc_voucher_attr_recipe_data_t;

/* 9386 */
struct __attribute__((packed)) __attribute__((aligned(4))) ipc_voucher_attr_recipe_data
{
  mach_voucher_attr_key_t key;
  mach_voucher_attr_recipe_command_t command;
  ipc_voucher_t previous_voucher;
  mach_voucher_attr_content_size_t content_size;
  uint8_t content[];
};

/* 6901 */
typedef mach_port_name_t_0 mach_voucher_name_t;

/* 6902 */
typedef mach_voucher_attr_recipe_data mach_voucher_attr_recipe_data_t;

/* 9387 */
struct mach_voucher_attr_recipe_data
{
  mach_voucher_attr_key_t key;
  mach_voucher_attr_recipe_command_t command;
  mach_voucher_name_t previous_voucher;
  mach_voucher_attr_content_size_t content_size;
  uint8_t content[];
};

/* 6904 */
typedef smr *smr_t_0;

/* 9388 */
struct smrh_traits_1
{
  unsigned __int64 link_offset;
  smr_t_0 domain;
  uint32_t (*key_hash)(smrh_key_t_0, uint32_t);
  bool (*key_equ)(smrh_key_t, smrh_key_t);
  uint32_t (*obj_hash)(const smrq_slink *, uint32_t);
  bool (*obj_equ)(const smrq_slink *, smrh_key_t_0);
  bool (*obj_try_get)(void *);
};

/* 6905 */
struct voucher_traits
{
  smrh_traits_1 smrht;
};

/* 6906 */
struct __attribute__((packed)) __attribute__((aligned(1))) portlabel_info
{
  int16_t portlabel_id;
  uint16_t portlabel_flags;
  uint8_t portlabel_domain;
};

/* 6907 */
typedef ipc_notify_nsenders ipc_notify_nsenders_t;

/* 9389 */
struct ipc_notify_nsenders
{
  ipc_port_t_1 ns_notify;
  mach_port_mscount_t ns_mscount;
  boolean_t ns_is_kobject;
};

/* 6908 */
typedef stackshot_thread_waitinfo_v2 thread_waitinfo_v2_t;

/* 9099 */
struct __attribute__((packed)) __attribute__((aligned(1))) stackshot_thread_waitinfo_v2
{
  uint64_t owner;
  uint64_t waiter;
  uint64_t context;
  uint8_t wait_type;
  int16_t portlabel_id;
  uint32_t wait_flags;
};

/* 6910 */
typedef natural_t ipc_object_type_t;

/* 6911 */
union waitq_link_t
{
  waitq_link_hdr *wqlh;
  waitq_sellink *wqls;
  waitq_link *wqll;
};

/* 6913 */
typedef ipc_pset *ipc_pset_t;

/* 6914 */
typedef ipc_mqueue *ipc_mqueue_t;

/* 6915 */
typedef circle_queue_t ipc_kmsg_queue_t;

/* 6917 */
struct _ca_event_reply_port_semantics_violations
{
  ca_sstr proc_name[17];
  ca_sstr service_name[86];
};

/* 6918 */
typedef uintptr_t ikm_sig_scratch_t;

/* 6919 */
typedef vm32_offset_t mach_port_context32_t;

/* 6920 */
typedef mach_msg_mac_trailer32_t mach_msg_max_trailer32_t;

/* 9843 */
struct mach_msg_mac_trailer32_t
{
  mach_msg_trailer_type_t msgh_trailer_type;
  mach_msg_trailer_size_t msgh_trailer_size;
  mach_port_seqno_t msgh_seqno;
  security_token_t msgh_sender;
  audit_token_t msgh_audit;
  mach_port_context32_t msgh_context;
  mach_msg_filter_id msgh_ad;
  msg_labels_t msgh_labels;
};

/* 6921 */
typedef mach_vm_offset_t mach_port_context64_t;

/* 6922 */
typedef mach_msg_mac_trailer64_t mach_msg_max_trailer64_t;

/* 9844 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_msg_mac_trailer64_t
{
  mach_msg_trailer_type_t msgh_trailer_type;
  mach_msg_trailer_size_t msgh_trailer_size;
  mach_port_seqno_t msgh_seqno;
  security_token_t msgh_sender;
  audit_token_t msgh_audit;
  mach_port_context64_t msgh_context;
  mach_msg_filter_id msgh_ad;
  msg_labels_t msgh_labels;
};

/* 6923 */
struct __attribute__((aligned(4))) mach_msg_user_port_descriptor_t
{
  mach_port_name_t_0 name;
  mach_msg_size_t pad1;
  _BYTE gap8[4];
};

/* 6924 */
struct mach_msg_guarded_port_descriptor64_t
{
  uint64_t context;
  _BYTE gap8[4];
  mach_port_name_t_0 name;
};

/* 6925 */
struct mach_msg_ool_ports_descriptor64_t
{
  uint64_t address;
  _BYTE gap8[4];
  mach_msg_size_t count;
};

/* 6926 */
struct mach_msg_ool_descriptor64_t
{
  uint64_t address;
  _BYTE gap8[4];
  mach_msg_size_t size;
};

/* 6927 */
struct mach_msg_aux_header_t
{
  mach_msg_size_t msgdh_size;
  uint32_t msgdh_reserved;
};

/* 6928 */
struct mach_msg_guarded_port_descriptor_t
{
  mach_port_t_0 name;
  _BYTE gap8[4];
  uint32_t pad_end;
};

/* 6929 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_msg_base_t
{
  mach_msg_header_t_0 header;
  mach_msg_body_t_0 body;
};

/* 6930 */
struct __attribute__((aligned(8))) ipc_kmsg_vector_t
{
  _BYTE gap0[8];
  mach_msg_size_t kmsgv_size;
};

/* 6931 */
struct reply_port_semantics_violations_rb_entry
{
  char proc_name[17];
  char service_name[86];
};

/* 9102 */
typedef ipc_importance_elem *ipc_importance_elem_t;

/* 6933 */
struct ipc_importance_inherit
{
  ipc_importance_elem iii_elem;
  boolean_t iii_donating;
  uint32_t iii_depth;
  ipc_importance_task_t iii_to_task;
  ipc_importance_elem_t iii_from_elem;
  queue_chain_t_0 iii_inheritance;
};

/* 6949 */
struct kdp_core_out_vars;

/* 6950 */
struct processor_core_context
{
  kdp_core_out_vars *core_outvars;
  kern_coredump_callback_config *core_config;
  void *core_refcon;
  boolean_t core_should_be_skipped;
  boolean_t core_is64bit;
  _BYTE gap20[4];
  uint32_t core_mh_magic;
  cpu_type_t_0 core_cpu_type;
  cpu_subtype_t_0 core_cpu_subtype;
  uint64_t core_file_length;
  uint64_t core_file_length_compressed;
  uint64_t core_segment_count;
  uint64_t core_segments_remaining;
  uint64_t core_segment_byte_total;
  uint64_t core_segment_bytes_remaining;
  uint64_t core_thread_count;
  uint64_t core_threads_remaining;
  uint64_t core_thread_state_size;
  uint64_t core_note_count;
  uint64_t core_notes_remaining;
  uint64_t core_note_bytes_total;
  uint64_t core_note_bytes_remaining;
  uint64_t core_cur_hoffset;
  uint64_t core_cur_foffset;
  uint64_t core_header_size;
  uint64_t core_total_bytes;
};

/* 6959 */
typedef kern_return_t (*core_save_summary_cb)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void *);

/* 6977 */
typedef kern_return_t (*core_save_segment_descriptions_cb)(uint64_t, uint64_t, void *);

/* 6958 */
typedef kern_return_t (*core_save_thread_state_cb)(void *, void *);

/* 6957 */
typedef kern_return_t (*core_save_sw_vers_cb)(void *, uint64_t, void *);

/* 6975 */
typedef kern_return_t (*core_save_segment_data_cb)(void *, uint64_t, void *);

/* 6956 */
typedef kern_return_t (*core_save_misc_data_cb)(void *, uint64_t, void *);

/* 6955 */
typedef kern_return_t (*core_save_note_summary_cb)(uint64_t, uint64_t, void *);

/* 6954 */
typedef kern_return_t (*core_save_note_descriptions_cb)(const char *, uint64_t, void *);

/* 6953 */
typedef kern_return_t (*core_save_note_data_cb)(void *, uint64_t, void *);

/* 6952 */
typedef kern_return_t (*core_save_sw_vers_detail_cb)(uint64_t, unsigned __int8 *, uint32_t, void *);

/* 6960 */
struct kern_coredump_callback_config
{
  kern_return_t (*kcc_coredump_init)(void *, void *);
  kern_return_t (*kcc_coredump_get_summary)(void *, core_save_summary_cb, void *);
  kern_return_t (*kcc_coredump_save_segment_descriptions)(void *, core_save_segment_descriptions_cb, void *);
  kern_return_t (*kcc_coredump_save_thread_state)(void *, void *, core_save_thread_state_cb, void *);
  kern_return_t (*kcc_coredump_save_sw_vers)(void *, core_save_sw_vers_cb, void *);
  kern_return_t (*kcc_coredump_save_segment_data)(void *, core_save_segment_data_cb, void *);
  kern_return_t (*kcc_coredump_save_misc_data)(void *, core_save_misc_data_cb, void *);
  kern_return_t (*kcc_coredump_save_note_summary)(void *, core_save_note_summary_cb, void *);
  kern_return_t (*kcc_coredump_save_note_descriptions)(void *, core_save_note_descriptions_cb, void *);
  kern_return_t (*kcc_coredump_save_note_data)(void *, core_save_note_data_cb, void *);
  kern_return_t (*kcc_coredump_save_sw_vers_detail)(void *, core_save_sw_vers_detail_cb, void *);
};

/* 6951 */
struct kern_userspace_coredump_context
{
  task_t_0 task;
};

/* 6961 */
struct kern_coredump_core
{
  kern_coredump_core *kcc_next;
  void *kcc_refcon;
  char kcc_corename[16];
  boolean_t kcc_is64bit;
  uint32_t kcc_mh_magic;
  cpu_type_t_0 kcc_cpu_type;
  cpu_subtype_t_0 kcc_cpu_subtype;
  kern_coredump_callback_config kcc_cb;
};

/* 6962 */
struct __attribute__((aligned(8))) kdp_core_out_state
{
  struct
  {
    kdp_output_stage *stqh_first;
    kdp_output_stage **stqh_last;
  } kcos_out_stage;
  kdp_output_stage *kcos_encryption_stage;
  bool kcos_enforce_encryption;
  uint64_t kcos_totalbytes;
  uint64_t kcos_bytes_written;
  uint64_t kcos_lastpercent;
  kern_return_t kcos_error;
};

/* 6963 */
struct kdp_output_stage_funcs
{
  void (*kosf_reset)(kdp_output_stage *);
  kern_return_t (*kosf_outproc)(kdp_output_stage *, unsigned int, char *, uint64_t, void *);
  void (*kosf_free)(kdp_output_stage *);
};

/* 6964 */
struct kdp_output_stage
{
  struct
  {
    kdp_output_stage *stqe_next;
  } kos_next;
  bool kos_initialized;
  kdp_core_out_state *kos_outstate;
  kdp_output_stage_funcs kos_funcs;
  uint64_t kos_bytes_written;
  bool kos_bypass;
  void *kos_data;
  size_t kos_data_size;
};

/* 6965 */
struct zlib_stage_data
{
  z_stream zs;
  size_t allocation_offset;
};

/* 6966 */
struct shmem_stage_data
{
  uint32_t seq_no;
  uint64_t contact_deadline;
  uint64_t contact_deadline_interval;
  kdp_hw_shmem_dbg_buf_elm *currently_filling_buf;
  kdp_hw_shmem_dbg_buf_elm *currently_flushing_buf;
};

/* 6967 */
struct kdp_hw_shmem_dbg_buf_elm
{
  vm_offset_t khsd_buf;
  uint32_t khsd_data_length;
  struct
  {
    kdp_hw_shmem_dbg_buf_elm *stqe_next;
  } khsd_elms;
};

/* 6968 */
struct xnu_hw_shmem_dbg_command_info
{
  volatile uint32_t xhsdci_status;
  uint32_t xhsdci_seq_no;
  volatile uint64_t xhsdci_buf_phys_addr;
  volatile uint32_t xhsdci_buf_data_length;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t xhsdci_coredump_total_size_uncomp;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t xhsdci_coredump_total_size_sent_uncomp;
  uint32_t xhsdci_page_size;
};

/* 6969 */
struct progress_notify_stage_data
{
  uint64_t notify_interval_matus;
  uint64_t last_notify_timestamp;
};

/* 6970 */
struct __attribute__((aligned(8))) lz4_stage_data
{
  compression_stream_t stream;
  compression_algorithm_t algorithm;
  uint8_t *dst_buf;
  const uint8_t *zero_buf;
  bool reset_failed;
};

/* 6971 */
struct disk_stage_data
{
  bool last_operation_was_write;
  uint64_t current_offset;
  uint64_t furthest_written_offset;
  size_t alignment;
};

/* 6972 */
struct buffer_stage_data
{
  size_t total_buffer_size;
  size_t current_size;
  char buffer[];
};

/* 6973 */
struct aea_stage_data
{
  bool encryption_open;
  uint64_t starting_corefile_offset;
  uint64_t current_corefile_offset;
  size_t state_size;
  char state[];
};

/* 6974 */
typedef int (*pmap_traverse_callback)(vm_map_offset_t, vm_map_offset_t, void *);

/* 6976 */
struct kern_dump_send_segdata_context
{
  core_save_segment_data_cb callback;
  void *context;
};

/* 6978 */
struct kern_dump_send_seg_desc_context
{
  core_save_segment_descriptions_cb callback;
  void *context;
};

/* 6979 */
struct kern_dump_preflight_context
{
  uint32_t region_count;
  uint64_t dumpable_bytes;
};

/* 6980 */
struct kdp_core_encryption_key_descriptor
{
  uint64_t kcekd_format;
  uint16_t kcekd_size;
  void *kcekd_key;
};

/* 6981 */
struct mach_core_details_v2
{
  uint64_t flags;
  uint64_t offset;
  uint64_t length;
  char core_name[16];
};

/* 6982 */
struct mach_core_fileheader_v2
{
  uint64_t signature;
  uint32_t version;
  uint64_t flags;
  uint64_t pub_key_offset;
  uint16_t pub_key_length;
  uint64_t log_offset;
  uint64_t log_length;
  uint64_t num_files;
  mach_core_details_v2 files[];
};

/* 6983 */
struct kdp_core_excluded_region
{
  kdp_core_excluded_region *next;
  vm_offset_t addr;
  vm_size_t_0 size;
};

/* 7021 */
enum kdp_dumpinfo_t : __int32
{
  KDP_DUMPINFO_GETINFO = 0x0,
  KDP_DUMPINFO_SETINFO = 0x1,
  KDP_DUMPINFO_CORE = 0x102,
  KDP_DUMPINFO_PANICLOG = 0x103,
  KDP_DUMPINFO_SYSTEMLOG = 0x104,
  KDP_DUMPINFO_DISABLE = 0x105,
  KDP_DUMPINFO_MASK = 0xFFF,
  KDP_DUMPINFO_DUMP = 0x100,
  KDP_DUMPINFO_REBOOT = 0x10000000,
  KDP_DUMPINFO_NORESUME = 0x20000000,
  KDP_DUMPINFO_RESUME = 0x0,
  KDP_DUMPINFO_NOINTR = 0x40000000,
  KDP_DUMPINFO_INTR = 0x0,
};

/* 6984 */
struct __attribute__((packed)) __attribute__((aligned(2))) kdp_dumpinfo_reply_t
{
  kdp_hdr_t hdr;
  char name[50];
  char destip[16];
  char routerip[16];
  uint32_t port;
  kdp_dumpinfo_t type;
};

/* 6985 */
struct kdp_udphdr
{
  u_short uh_sport;
  u_short uh_dport;
  short uh_ulen;
  u_short uh_sum;
};

/* 6993 */
struct kdp_in_addr
{
  uint32_t s_addr;
};

/* 6986 */
struct kdp_ipovly
{
  uint32_t ih_next;
  uint32_t ih_prev;
  u_char ih_x1;
  u_char ih_pr;
  short ih_len;
  kdp_in_addr ih_src;
  kdp_in_addr ih_dst;
};

/* 7023 */
enum kdp_error_t : __int32
{
  KDPERR_NO_ERROR = 0x0,
  KDPERR_ALREADY_CONNECTED = 0x1,
  KDPERR_BAD_NBYTES = 0x2,
  KDPERR_BADFLAVOR = 0x3,
  KDPERR_BAD_ACCESS = 0x4,
  KDPERR_MAX_BREAKPOINTS = 0x64,
  KDPERR_BREAKPOINT_NOT_FOUND = 0x65,
  KDPERR_BREAKPOINT_ALREADY_SET = 0x66,
};

/* 6987 */
struct kdp_connect_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
};

/* 6988 */
struct kdp_arphdr
{
  u_short ar_hrd;
  u_short ar_pro;
  u_char ar_hln;
  u_char ar_pln;
  u_short ar_op;
};

/* 6989 */
struct kdp_ether_arp
{
  kdp_arphdr ea_hdr;
  u_char arp_sha[6];
  u_char arp_spa[4];
  u_char arp_tha[6];
  u_char arp_tpa[4];
};

/* 6990 */
struct kdp_ether_header
{
  u_char ether_dhost[6];
  u_char ether_shost[6];
  u_short ether_type;
};

/* 6991 */
struct __attribute__((packed)) __attribute__((aligned(2))) corehdr
{
  short th_opcode;
  union
  {
    unsigned int tu_block;
    unsigned int tu_code;
    char tu_rpl[1];
  } th_u;
  char th_data[];
};

/* 6992 */
struct kdp_ether_addr
{
  u_char ether_addr_octet[6];
};

/* 6995 */
struct kdp_fault_result
{
  _BYTE gap0[8];
  uint64_t time_spent_faulting;
};

/* 6996 */
typedef int (*kdp_traverse_mappings_callback)(vm_offset_t, vm_offset_t, void *);

/* 6997 */
struct stackshot_cpu_times_v2
{
  uint64_t user_usec;
  uint64_t system_usec;
  uint64_t runnable_usec;
};

/* 6998 */
struct thread_snapshot_v4
{
  uint64_t ths_thread_id;
  uint64_t ths_wait_event;
  uint64_t ths_continuation;
  uint64_t ths_total_syscalls;
  uint64_t ths_voucher_identifier;
  uint64_t ths_dqserialnum;
  uint64_t ths_user_time;
  uint64_t ths_sys_time;
  uint64_t ths_ss_flags;
  uint64_t ths_last_run_time;
  uint64_t ths_last_made_runnable_time;
  uint32_t ths_state;
  uint32_t ths_sched_flags;
  int16_t ths_base_priority;
  int16_t ths_sched_priority;
  uint8_t ths_eqos;
  uint8_t ths_rqos;
  uint8_t ths_rqos_override;
  uint8_t ths_io_tier;
  uint64_t ths_thread_t;
  uint64_t ths_requested_policy;
  uint64_t ths_effective_policy;
};

/* 6999 */
struct __attribute__((packed)) __attribute__((aligned(4))) task_delta_snapshot_v2
{
  uint64_t tds_unique_pid;
  uint64_t tds_ss_flags;
  uint64_t tds_user_time_in_terminated_threads;
  uint64_t tds_system_time_in_terminated_threads;
  uint64_t tds_task_size;
  uint64_t tds_max_resident_size;
  uint32_t tds_suspend_count;
  uint32_t tds_faults;
  uint32_t tds_pageins;
  uint32_t tds_cow_faults;
  uint32_t tds_was_throttled;
  uint32_t tds_did_throttle;
  uint32_t tds_latency_qos;
};

/* 7000 */
struct __attribute__((packed)) __attribute__((aligned(4))) transitioning_task_snapshot
{
  uint64_t tts_unique_pid;
  uint64_t tts_ss_flags;
  uint64_t tts_transition_type;
  int32_t tts_pid;
  char tts_p_comm[32];
};

/* 7001 */
struct io_stats_snapshot
{
  uint64_t ss_disk_reads_count;
  uint64_t ss_disk_reads_size;
  uint64_t ss_disk_writes_count;
  uint64_t ss_disk_writes_size;
  uint64_t ss_io_priority_count[4];
  uint64_t ss_io_priority_size[4];
  uint64_t ss_paging_count;
  uint64_t ss_paging_size;
  uint64_t ss_non_paging_count;
  uint64_t ss_non_paging_size;
  uint64_t ss_data_count;
  uint64_t ss_data_size;
  uint64_t ss_metadata_count;
  uint64_t ss_metadata_size;
};

/* 7002 */
struct task_snapshot_v2
{
  uint64_t ts_unique_pid;
  uint64_t ts_ss_flags;
  uint64_t ts_user_time_in_terminated_threads;
  uint64_t ts_system_time_in_terminated_threads;
  uint64_t ts_p_start_sec;
  uint64_t ts_task_size;
  uint64_t ts_max_resident_size;
  uint32_t ts_suspend_count;
  uint32_t ts_faults;
  uint32_t ts_pageins;
  uint32_t ts_cow_faults;
  uint32_t ts_was_throttled;
  uint32_t ts_did_throttle;
  uint32_t ts_latency_qos;
  int32_t ts_pid;
  char ts_p_comm[32];
};

/* 7003 */
typedef user64_dyld_uuid_info kernel_uuid_info;

/* 7005 */
struct user64_dyld_uuid_info
{
  uint64_t imageLoadAddress;
  uuid_t_0 imageUUID;
};

/* 7004 */
struct user32_dyld_uuid_info
{
  uint32_t imageLoadAddress;
  uuid_t_0 imageUUID;
};

/* 7006 */
struct thread_delta_snapshot_v3
{
  uint64_t tds_thread_id;
  uint64_t tds_voucher_identifier;
  uint64_t tds_ss_flags;
  uint64_t tds_last_made_runnable_time;
  uint32_t tds_state;
  uint32_t tds_sched_flags;
  int16_t tds_base_priority;
  int16_t tds_sched_priority;
  uint8_t tds_eqos;
  uint8_t tds_rqos;
  uint8_t tds_rqos_override;
  uint8_t tds_io_tier;
  uint64_t tds_requested_policy;
  uint64_t tds_effective_policy;
};

/* 7007 */
struct jetsam_coalition_snapshot
{
  uint64_t jcs_id;
  uint64_t jcs_flags;
  uint64_t jcs_thread_group;
  uint64_t jcs_leader_task_uniqueid;
};

/* 7008 */
struct thread_group_snapshot_v3
{
  uint64_t tgs_id;
  char tgs_name[16];
  uint64_t tgs_flags;
  char tgs_name_cont[16];
};

/* 7012 */
typedef stackshot_config stackshot_config_t;

/* 7919 */
struct stackshot_config
{
  int sc_pid;
  uint64_t sc_flags;
  uint64_t sc_delta_timestamp;
  uint64_t sc_buffer;
  uint32_t sc_size;
  uint64_t sc_out_buffer_addr;
  uint64_t sc_out_size_addr;
  uint64_t sc_pagetable_mask;
};

/* 7013 */
struct kdp_breakpoint_record_t
{
  mach_vm_address_t_0 address;
  uint32_t bytesused;
  uint8_t oldbytes[4];
};

/* 7022 */
struct kdp_region_t
{
  uint32_t address;
  uint32_t nbytes;
  uint32_t protection;
};

/* 7024 */
struct __attribute__((packed)) __attribute__((aligned(2))) kdp_dumpinfo_req_t
{
  kdp_hdr_t hdr;
  char name[50];
  char destip[16];
  char routerip[16];
  uint32_t port;
  kdp_dumpinfo_t type;
};

/* 7025 */
struct kdp_writemsr64_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
};

/* 7026 */
struct __attribute__((packed)) __attribute__((aligned(2))) kdp_writemsr64_req_t
{
  kdp_hdr_t hdr;
  uint32_t address;
  uint16_t lcpu;
  char data[];
};

/* 7027 */
struct kdp_readmsr64_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
  char data[];
};

/* 7028 */
struct __attribute__((packed)) __attribute__((aligned(2))) kdp_readmsr64_req_t
{
  kdp_hdr_t hdr;
  uint32_t address;
  uint16_t lcpu;
};

/* 7029 */
struct kdp_writeioport_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
};

/* 7030 */
struct __attribute__((packed)) __attribute__((aligned(2))) kdp_writeioport_req_t
{
  kdp_hdr_t hdr;
  uint16_t lcpu;
  uint16_t address;
  uint16_t nbytes;
  char data[];
};

/* 7031 */
struct kdp_readioport_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
  char data[];
};

/* 7032 */
struct __attribute__((packed)) __attribute__((aligned(2))) kdp_readioport_req_t
{
  kdp_hdr_t hdr;
  uint16_t lcpu;
  uint16_t address;
  uint16_t nbytes;
};

/* 7033 */
struct kdp_kernelversion_reply_t
{
  kdp_hdr_t hdr;
  char version[];
};

/* 7034 */
struct kdp_kernelversion_req_t
{
  kdp_hdr_t hdr;
};

/* 7035 */
struct kdp_regions_reply_t
{
  kdp_hdr_t hdr;
  uint32_t nregions;
  kdp_region_t regions[];
};

/* 7036 */
struct kdp_regions_req_t
{
  kdp_hdr_t hdr;
};

/* 7037 */
struct __attribute__((packed)) __attribute__((aligned(2))) kdp_reattach_req_t
{
  kdp_hdr_t hdr;
  uint16_t req_reply_port;
};

/* 7038 */
struct kdp_breakpoint64_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
};

/* 7039 */
struct kdp_breakpoint64_req_t
{
  kdp_hdr_t hdr;
  uint64_t address;
};

/* 7040 */
struct kdp_breakpoint_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
};

/* 7041 */
struct kdp_breakpoint_req_t
{
  kdp_hdr_t hdr;
  uint32_t address;
};

/* 7042 */
struct kdp_termination_ack_t
{
  kdp_hdr_t hdr;
};

/* 7043 */
struct kdp_termination_t
{
  kdp_hdr_t hdr;
  uint32_t term_code;
  uint32_t exit_code;
};

/* 7044 */
struct kdp_resumecpus_reply_t
{
  kdp_hdr_t hdr;
};

/* 7045 */
struct kdp_resumecpus_req_t
{
  kdp_hdr_t hdr;
  uint32_t cpu_mask;
};

/* 7046 */
struct kdp_suspend_reply_t
{
  kdp_hdr_t hdr;
};

/* 7047 */
struct kdp_suspend_req_t
{
  kdp_hdr_t hdr;
};

/* 7048 */
struct kdp_imagepath_reply_t
{
  kdp_hdr_t hdr;
  char path[];
};

/* 7049 */
struct kdp_imagepath_req_t
{
  kdp_hdr_t hdr;
};

/* 7050 */
struct kdp_load_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
};

/* 7051 */
struct kdp_load_req_t
{
  kdp_hdr_t hdr;
  char file_args[];
};

/* 7052 */
struct kdp_writeregs_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
};

/* 7053 */
struct kdp_writeregs_req_t
{
  kdp_hdr_t hdr;
  uint32_t cpu;
  uint32_t flavor;
  char data[];
};

/* 7054 */
struct kdp_readregs_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
  char data[];
};

/* 7055 */
struct kdp_readregs_req_t
{
  kdp_hdr_t hdr;
  uint32_t cpu;
  uint32_t flavor;
};

/* 7056 */
struct kdp_writephysmem64_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
};

/* 7057 */
struct __attribute__((packed)) __attribute__((aligned(2))) kdp_writephysmem64_req_t
{
  kdp_hdr_t hdr;
  uint64_t address;
  uint32_t nbytes;
  uint16_t lcpu;
  char data[];
};

/* 7058 */
struct kdp_writemem64_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
};

/* 7059 */
struct __attribute__((packed)) __attribute__((aligned(4))) kdp_writemem64_req_t
{
  kdp_hdr_t hdr;
  uint64_t address;
  uint32_t nbytes;
  char data[];
};

/* 7060 */
struct kdp_writemem_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
};

/* 7061 */
struct kdp_writemem_req_t
{
  kdp_hdr_t hdr;
  uint32_t address;
  uint32_t nbytes;
  char data[];
};

/* 7062 */
struct kdp_readphysmem64_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
  char data[];
};

/* 7063 */
struct kdp_readmem64_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
  char data[];
};

/* 7064 */
struct __attribute__((packed)) __attribute__((aligned(4))) kdp_readmem64_req_t
{
  kdp_hdr_t hdr;
  uint64_t address;
  uint32_t nbytes;
};

/* 7065 */
struct kdp_readmem_reply_t
{
  kdp_hdr_t hdr;
  kdp_error_t error;
  char data[];
};

/* 7066 */
struct kdp_readmem_req_t
{
  kdp_hdr_t hdr;
  uint32_t address;
  uint32_t nbytes;
};

/* 7067 */
struct kdp_maxbytes_reply_t
{
  kdp_hdr_t hdr;
  uint32_t max_bytes;
};

/* 7068 */
struct kdp_maxbytes_req_t
{
  kdp_hdr_t hdr;
};

/* 7069 */
struct kdp_version_reply_t
{
  kdp_hdr_t hdr;
  uint32_t version;
  uint32_t feature;
  uint32_t pad0;
  uint32_t pad1;
};

/* 7070 */
struct kdp_version_req_t
{
  kdp_hdr_t hdr;
};

/* 7071 */
struct kdp_hostinfo_reply_t
{
  kdp_hdr_t hdr;
  kdp_hostinfo_t hostinfo;
};

/* 7072 */
struct kdp_hostinfo_req_t
{
  kdp_hdr_t hdr;
};

/* 7073 */
struct kdp_disconnect_reply_t
{
  kdp_hdr_t hdr;
};

/* 7074 */
struct kdp_disconnect_req_t
{
  kdp_hdr_t hdr;
};

/* 7075 */
struct kdp_connect_req_t
{
  kdp_hdr_t hdr;
  uint16_t req_reply_port;
  uint16_t exc_note_port;
  char greeting[];
};

/* 7076 */
union __attribute__((packed)) __attribute__((aligned(2))) kdp_pkt_t
{
  kdp_hdr_t hdr;
  kdp_connect_req_t connect_req;
  kdp_connect_reply_t connect_reply;
  kdp_disconnect_req_t disconnect_req;
  kdp_disconnect_reply_t disconnect_reply;
  kdp_hostinfo_req_t hostinfo_req;
  kdp_hostinfo_reply_t hostinfo_reply;
  kdp_version_req_t version_req;
  kdp_version_reply_t version_reply;
  kdp_maxbytes_req_t maxbytes_req;
  kdp_maxbytes_reply_t maxbytes_reply;
  kdp_readmem_req_t readmem_req;
  kdp_readmem_reply_t readmem_reply;
  kdp_readmem64_req_t readmem64_req;
  kdp_readmem64_reply_t readmem64_reply;
  kdp_readphysmem64_req_t readphysmem64_req;
  kdp_readphysmem64_reply_t readphysmem64_reply;
  kdp_writemem_req_t writemem_req;
  kdp_writemem_reply_t writemem_reply;
  kdp_writemem64_req_t writemem64_req;
  kdp_writemem64_reply_t writemem64_reply;
  kdp_writephysmem64_req_t writephysmem64_req;
  kdp_writephysmem64_reply_t writephysmem64_reply;
  kdp_readregs_req_t readregs_req;
  kdp_readregs_reply_t readregs_reply;
  kdp_writeregs_req_t writeregs_req;
  kdp_writeregs_reply_t writeregs_reply;
  kdp_load_req_t load_req;
  kdp_load_reply_t load_reply;
  kdp_imagepath_req_t imagepath_req;
  kdp_imagepath_reply_t imagepath_reply;
  kdp_suspend_req_t suspend_req;
  kdp_suspend_reply_t suspend_reply;
  kdp_resumecpus_req_t resumecpus_req;
  kdp_resumecpus_reply_t resumecpus_reply;
  kdp_exception_t exception;
  kdp_exception_ack_t exception_ack;
  kdp_termination_t termination;
  kdp_termination_ack_t termination_ack;
  kdp_breakpoint_req_t breakpoint_req;
  kdp_breakpoint_reply_t breakpoint_reply;
  kdp_breakpoint64_req_t breakpoint64_req;
  kdp_breakpoint64_reply_t breakpoint64_reply;
  kdp_reattach_req_t reattach_req;
  kdp_regions_req_t regions_req;
  kdp_regions_reply_t regions_reply;
  kdp_kernelversion_req_t kernelversion_req;
  kdp_kernelversion_reply_t kernelversion_reply;
  kdp_readioport_req_t readioport_req;
  kdp_readioport_reply_t readioport_reply;
  kdp_writeioport_req_t writeioport_req;
  kdp_writeioport_reply_t writeioport_reply;
  kdp_readmsr64_req_t readmsr64_req;
  kdp_readmsr64_reply_t readmsr64_reply;
  kdp_writemsr64_req_t writemsr64_req;
  kdp_writemsr64_reply_t writemsr64_reply;
  kdp_dumpinfo_req_t dumpinfo_req;
  kdp_dumpinfo_reply_t dumpinfo_reply;
};

/* 7077 */
typedef boolean_t (*kdp_dispatch_t)(kdp_pkt_t *, int *, unsigned __int16 *);

/* 7078 */
typedef void (*KUNCUserNotificationCallBack)(int, int, const void *);

/* 7079 */
struct UNDReply
{
  lck_mtx_t_0 lock;
  int userLandNotificationKey;
  KUNCUserNotificationCallBack callback;
  boolean_t inprogress;
  ipc_port_t_0 self_port;
};

/* 7080 */
struct ipc_port_request_table;

/* 7083 */
struct ipc_entry_table;

/* 7088 */
typedef scalable_counter_t counter_t;

/* 7090 */
struct sched_group;

/* 7103 */
typedef kern_return_t mach_msg_return_t;

/* 7102 */
typedef void (*mach_msg_continue_t)(mach_msg_return_t);

/* 7104 */
typedef struct sched_group *sched_group_t;

/* 7105 */
enum sched_bucket_t : __int32
{
  TH_BUCKET_FIXPRI = 0x0,
  TH_BUCKET_SHARE_FG = 0x1,
  TH_BUCKET_SHARE_IN = 0x2,
  TH_BUCKET_SHARE_DF = 0x3,
  TH_BUCKET_SHARE_UT = 0x4,
  TH_BUCKET_SHARE_BG = 0x5,
  TH_BUCKET_RUN = 0x6,
  TH_BUCKET_SCHED_MAX = 0x6,
  TH_BUCKET_MAX = 0x7,
};

/* 7106 */
enum sched_mode_t : __int32
{
  TH_MODE_NONE = 0x0,
  TH_MODE_REALTIME = 0x1,
  TH_MODE_FIXED = 0x2,
  TH_MODE_TIMESHARE = 0x3,
};

/* 7114 */
typedef unsigned int ipc_port_timestamp_t;

/* 7115 */
struct __attribute__((packed)) __attribute__((aligned(4))) _XUNDNotificationCreated_rpc::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int userLandNotificationKey;
  mach_msg_trailer_t trailer;
};

/* 7116 */
struct __attribute__((packed)) __attribute__((aligned(4))) _XUNDAlertCompletedWithResult_rpc::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t data;
  NDR_record_t_0 NDR;
  int result;
  mach_msg_type_number_t dataCnt;
  mach_msg_trailer_t trailer;
};

/* 7118 */
struct UNDReply_subsystem
{
  mig_server_routine_t_0 server;
  mach_msg_id_t start;
  mach_msg_id_t end;
  unsigned int maxsize;
  vm_address_t_0 reserved;
  routine_descriptor_0 routine[2];
};

/* 7119 */
struct __Reply__UNDDisplayAlertSimple_rpc_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  unsigned int response;
};

/* 7120 */
typedef char *UNDLabel;

/* 7121 */
typedef char *UNDMessage;

/* 7122 */
typedef mach_port_t_0 UNDServerRef;

/* 7123 */
struct UNDDisplayAlertSimple_rpc::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  unsigned int response;
  mach_msg_trailer_t trailer;
};

/* 7124 */
struct UNDDisplayAlertSimple_rpc::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int rpctimeout;
  unsigned int flags;
  mach_msg_type_number_t iconPathOffset;
  mach_msg_type_number_t iconPathCnt;
  char iconPath[128];
  mach_msg_type_number_t soundPathOffset;
  mach_msg_type_number_t soundPathCnt;
  char soundPath[128];
  mach_msg_type_number_t localizationPathOffset;
  mach_msg_type_number_t localizationPathCnt;
  char localizationPath[128];
  mach_msg_type_number_t headerOffset;
  mach_msg_type_number_t headerCnt;
  char header[128];
  mach_msg_type_number_t messageOffset;
  mach_msg_type_number_t messageCnt;
  char message[1024];
  mach_msg_type_number_t defaultButtonTitleOffset;
  mach_msg_type_number_t defaultButtonTitleCnt;
  char defaultButtonTitle[128];
  mach_msg_type_number_t alternateButtonTitleOffset;
  mach_msg_type_number_t alternateButtonTitleCnt;
  char alternateButtonTitle[128];
  mach_msg_type_number_t otherButtonTitleOffset;
  mach_msg_type_number_t otherButtonTitleCnt;
  char otherButtonTitle[128];
};

/* 7125 */
union UNDDisplayAlertSimple_rpc::UNDDisplayAlertSimple_rpcMessU
{
  UNDDisplayAlertSimple_rpc::Request In;
  UNDDisplayAlertSimple_rpc::Reply Out;
};

/* 7126 */
struct UNDDisplayNoticeSimple_rpc::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int rpctimeout;
  unsigned int flags;
  mach_msg_type_number_t iconPathOffset;
  mach_msg_type_number_t iconPathCnt;
  char iconPath[128];
  mach_msg_type_number_t soundPathOffset;
  mach_msg_type_number_t soundPathCnt;
  char soundPath[128];
  mach_msg_type_number_t localizationPathOffset;
  mach_msg_type_number_t localizationPathCnt;
  char localizationPath[128];
  mach_msg_type_number_t headerOffset;
  mach_msg_type_number_t headerCnt;
  char header[128];
  mach_msg_type_number_t messageOffset;
  mach_msg_type_number_t messageCnt;
  char message[1024];
  mach_msg_type_number_t defaultButtonTitleOffset;
  mach_msg_type_number_t defaultButtonTitleCnt;
  char defaultButtonTitle[128];
};

/* 7127 */
union UNDDisplayNoticeSimple_rpc::UNDDisplayNoticeSimple_rpcMessU
{
  UNDDisplayNoticeSimple_rpc::Request In;
};

/* 7128 */
typedef char *UNDPath;

/* 7129 */
typedef char *UNDKey;

/* 7130 */
struct __attribute__((packed)) __attribute__((aligned(4))) UNDDisplayCustomFromBundle_rpc::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t reply;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t bundlePathOffset;
  mach_msg_type_number_t bundlePathCnt;
  char bundlePath[1024];
  mach_msg_type_number_t fileNameOffset;
  mach_msg_type_number_t fileNameCnt;
  char fileName[128];
  mach_msg_type_number_t fileExtensionOffset;
  mach_msg_type_number_t fileExtensionCnt;
  char fileExtension[128];
  mach_msg_type_number_t messageKeyOffset;
  mach_msg_type_number_t messageKeyCnt;
  char messageKey[128];
  mach_msg_type_number_t tokenKeyOffset;
  mach_msg_type_number_t tokenKeyCnt;
  char tokenKey[1024];
};

/* 7131 */
union UNDDisplayCustomFromBundle_rpc::UNDDisplayCustomFromBundle_rpcMessU
{
  UNDDisplayCustomFromBundle_rpc::Request In;
};

/* 7132 */
struct UNDExecute_rpc::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t executionPathOffset;
  mach_msg_type_number_t executionPathCnt;
  char executionPath[1024];
  int uid;
  int gid;
};

/* 7133 */
union UNDExecute_rpc::UNDExecute_rpcMessU
{
  UNDExecute_rpc::Request In;
};

/* 7134 */
struct lockd_shutdown::Request
{
  mach_msg_header_t_0 Head;
};

/* 7135 */
typedef uint8_t nfs_handle[64];

/* 7136 */
typedef uint32_t xcred[19];

/* 7137 */
typedef uint32_t sock_storage[32];

/* 7138 */
struct __attribute__((packed)) __attribute__((aligned(4))) lockd_request::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t vers;
  uint32_t flags;
  uint64_t xid;
  int64_t flk_start;
  int64_t flk_len;
  int32_t flk_pid;
  int32_t flk_type;
  int32_t flk_whence;
  sock_storage sock_address;
  xcred cred;
  uint32_t fh_len;
  nfs_handle fh;
};

/* 7139 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_gss_lookup::Reply
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t gssd_session_port;
  mach_msg_trailer_t trailer;
};

/* 7140 */
struct mach_gss_lookup::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t uid;
  int32_t asid;
};

/* 7141 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_gss_unhold_cred::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  uint32_t major_stat;
  uint32_t minor_stat;
  mach_msg_trailer_t trailer;
};

/* 9137 */
enum gssd_mechtype : __int32
{
  gssd_mechtype::GSSD_NO_MECH = 0xFFFFFFFF,
  gssd_mechtype::GSSD_KRB5_MECH = 0x0,
  gssd_mechtype::GSSD_SPNEGO_MECH = 0x1,
  gssd_mechtype::GSSD_NTLM_MECH = 0x2,
  gssd_mechtype::GSSD_IAKERB_MECH = 0x3,
};

/* 9136 */
enum gssd_nametype : __int32
{
  gssd_nametype::GSSD_STRING_NAME = 0x0,
  gssd_nametype::GSSD_EXPORT = 0x1,
  gssd_nametype::GSSD_ANONYMOUS = 0x2,
  gssd_nametype::GSSD_HOSTBASED = 0x3,
  gssd_nametype::GSSD_USER = 0x4,
  gssd_nametype::GSSD_MACHINE_UID = 0x5,
  gssd_nametype::GSSD_STRING_UID = 0x6,
  gssd_nametype::GSSD_KRB5_PRINCIPAL = 0x7,
  gssd_nametype::GSSD_KRB5_REFERRAL = 0x8,
  gssd_nametype::GSSD_NTLM_PRINCIPAL = 0x9,
  gssd_nametype::GSSD_NTLM_BLOB = 0xA,
  gssd_nametype::GSSD_UUID = 0xB,
};

/* 7142 */
struct mach_gss_unhold_cred::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t princ;
  NDR_record_t_0 NDR;
  gssd_mechtype mech;
  gssd_nametype nt;
  mach_msg_type_number_t princCnt;
};

/* 7143 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_gss_hold_cred::Reply
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  uint32_t major_stat;
  uint32_t minor_stat;
  mach_msg_trailer_t trailer;
};

/* 7144 */
struct mach_gss_hold_cred::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t princ;
  NDR_record_t_0 NDR;
  gssd_mechtype mech;
  gssd_nametype nt;
  mach_msg_type_number_t princCnt;
};

/* 7145 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_gss_accept_sec_context_v2::Reply
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t key;
  mach_msg_ool_descriptor_t outtoken;
  NDR_record_t_0 NDR;
  uint32_t gssd_flags;
  gssd_ctx context;
  gssd_cred cred_handle;
  uint32_t flags;
  uint32_t uid;
  mach_msg_type_number_t gidsCnt;
  uint32_t gids[16];
  mach_msg_type_number_t keyCnt;
  mach_msg_type_number_t outtokenCnt;
  uint32_t major_stat;
  uint32_t minor_stat;
  mach_msg_trailer_t trailer;
};

/* 7146 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_gss_accept_sec_context_v2::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t intoken;
  mach_msg_ool_descriptor_t svc_princ;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t intokenCnt;
  gssd_nametype svc_nt;
  mach_msg_type_number_t svc_princCnt;
  uint32_t gssd_flags;
  gssd_ctx context;
  gssd_cred cred_handle;
};

/* 7147 */
typedef uint32_t *gssd_gid_list;

/* 7148 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_gss_init_sec_context_v2::Reply
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t key;
  mach_msg_ool_descriptor_t outtoken;
  NDR_record_t_0 NDR;
  uint32_t gssd_flags;
  gssd_ctx context;
  gssd_cred cred_handle;
  uint32_t ret_flags;
  mach_msg_type_number_t keyCnt;
  mach_msg_type_number_t outtokenCnt;
  mach_msg_type_number_t displaynameOffset;
  mach_msg_type_number_t displaynameCnt;
  char displayname[128];
  uint32_t major_stat;
  uint32_t minor_stat;
  mach_msg_trailer_t trailer;
};

/* 7149 */
struct mach_gss_init_sec_context_v2::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t intoken;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t clnt_princ;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t svc_princ;
  NDR_record_t_0 NDR;
  gssd_mechtype mech;
  mach_msg_type_number_t intokenCnt;
  uint32_t uid;
  gssd_nametype clnt_nt;
  mach_msg_type_number_t clnt_princCnt;
  gssd_nametype svc_nt;
  mach_msg_type_number_t svc_princCnt;
  uint32_t flags;
  uint32_t gssd_flags;
  gssd_ctx context;
  gssd_cred cred_handle;
};

/* 7150 */
typedef char *gssd_dstring;

/* 7151 */
typedef __Reply__mach_gss_init_sec_context_v3_t __Reply;

/* 7155 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_gss_init_sec_context_v3_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t key;
  mach_msg_ool_descriptor_t outtoken;
  NDR_record_t_0 NDR;
  uint32_t gssd_flags;
  gssd_ctx context;
  gssd_cred cred_handle;
  uint32_t ret_flags;
  mach_msg_type_number_t keyCnt;
  mach_msg_type_number_t outtokenCnt;
  mach_msg_type_number_t displaynameOffset;
  mach_msg_type_number_t displaynameCnt;
  char displayname[128];
  uint32_t major_stat;
  uint32_t minor_stat;
};

/* 7152 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_gss_lookup_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t gssd_session_port;
};

/* 7153 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_gss_unhold_cred_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  uint32_t major_stat;
  uint32_t minor_stat;
};

/* 7154 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_gss_hold_cred_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  uint32_t major_stat;
  uint32_t minor_stat;
};

/* 7156 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_gss_init_sec_context_v3::Reply
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t key;
  mach_msg_ool_descriptor_t outtoken;
  NDR_record_t_0 NDR;
  uint32_t gssd_flags;
  gssd_ctx context;
  gssd_cred cred_handle;
  uint32_t ret_flags;
  mach_msg_type_number_t keyCnt;
  mach_msg_type_number_t outtokenCnt;
  mach_msg_type_number_t displaynameOffset;
  mach_msg_type_number_t displaynameCnt;
  char displayname[128];
  uint32_t major_stat;
  uint32_t minor_stat;
  mach_msg_trailer_t trailer;
};

/* 7157 */
typedef int32_t *gssd_etype_list;

/* 7158 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_gss_init_sec_context_v3::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t intoken;
  mach_msg_ool_descriptor_t clnt_princ;
  mach_msg_ool_descriptor_t svc_princ;
  NDR_record_t_0 NDR;
  gssd_mechtype mech;
  mach_msg_type_number_t intokenCnt;
  uint32_t uid;
  gssd_nametype clnt_nt;
  mach_msg_type_number_t clnt_princCnt;
  gssd_nametype svc_nt;
  mach_msg_type_number_t svc_princCnt;
  uint32_t flags;
  mach_msg_type_number_t etypesCnt;
  int32_t etypes[64];
  uint32_t gssd_flags;
  gssd_ctx context;
  gssd_cred cred_handle;
};

/* 7159 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_gss_accept_sec_context_v2_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t key;
  mach_msg_ool_descriptor_t outtoken;
  NDR_record_t_0 NDR;
  uint32_t gssd_flags;
  gssd_ctx context;
  gssd_cred cred_handle;
  uint32_t flags;
  uint32_t uid;
  mach_msg_type_number_t gidsCnt;
  uint32_t gids[16];
  mach_msg_type_number_t keyCnt;
  mach_msg_type_number_t outtokenCnt;
  uint32_t major_stat;
  uint32_t minor_stat;
};

/* 7160 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_gss_init_sec_context_v2_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t key;
  mach_msg_ool_descriptor_t outtoken;
  NDR_record_t_0 NDR;
  uint32_t gssd_flags;
  gssd_ctx context;
  gssd_cred cred_handle;
  uint32_t ret_flags;
  mach_msg_type_number_t keyCnt;
  mach_msg_type_number_t outtokenCnt;
  mach_msg_type_number_t displaynameOffset;
  mach_msg_type_number_t displaynameCnt;
  char displayname[128];
  uint32_t major_stat;
  uint32_t minor_stat;
};

/* 7161 */
typedef char *gssd_string;

/* 7162 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_gss_log_error::Request
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t mntOffset;
  mach_msg_type_number_t mntCnt;
  char mnt[1024];
  uint32_t uid;
  mach_msg_type_number_t sourceOffset;
  mach_msg_type_number_t sourceCnt;
  char source[1024];
  uint32_t major_stat;
  uint32_t minor_stat;
};

/* 7163 */
union mach_gss_log_error::mach_gss_log_errorMessU
{
  mach_gss_log_error::Request In;
};

/* 7164 */
struct __Reply__mach_gss_accept_sec_context_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t key;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t outtoken;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) gssd_ctx context;
  __attribute__((packed)) __attribute__((aligned(1))) gssd_cred cred_handle;
  uint32_t flags;
  uint32_t uid;
  mach_msg_type_number_t gidsCnt;
  uint32_t gids[16];
  mach_msg_type_number_t keyCnt;
  mach_msg_type_number_t outtokenCnt;
  uint32_t major_stat;
  uint32_t minor_stat;
};

/* 7165 */
struct mach_gss_accept_sec_context::Reply
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t key;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t outtoken;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) gssd_ctx context;
  __attribute__((packed)) __attribute__((aligned(1))) gssd_cred cred_handle;
  uint32_t flags;
  uint32_t uid;
  mach_msg_type_number_t gidsCnt;
  uint32_t gids[16];
  mach_msg_type_number_t keyCnt;
  mach_msg_type_number_t outtokenCnt;
  uint32_t major_stat;
  uint32_t minor_stat;
  mach_msg_trailer_t trailer;
};

/* 7166 */
struct __attribute__((packed)) __attribute__((aligned(4))) mach_gss_accept_sec_context::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t intoken;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t intokenCnt;
  mach_msg_type_number_t svc_namestrOffset;
  mach_msg_type_number_t svc_namestrCnt;
  char svc_namestr[1024];
  uint32_t gssd_flags;
  gssd_ctx context;
  gssd_cred cred_handle;
};

/* 7167 */
union __attribute__((packed)) __attribute__((aligned(4))) mach_gss_accept_sec_context::mach_gss_accept_sec_contextMessU
{
  mach_gss_accept_sec_context::Request In;
  mach_gss_accept_sec_context::Reply Out;
};

/* 7168 */
struct __Reply__mach_gss_init_sec_context_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t key;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t outtoken;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) gssd_ctx context;
  __attribute__((packed)) __attribute__((aligned(1))) gssd_cred cred_handle;
  uint32_t ret_flags;
  mach_msg_type_number_t keyCnt;
  mach_msg_type_number_t outtokenCnt;
  uint32_t major_stat;
  uint32_t minor_stat;
};

/* 7171 */
typedef uint8_t *gssd_byte_buffer;

/* 7172 */
struct mach_gss_init_sec_context::Reply
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t key;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t outtoken;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) gssd_ctx context;
  __attribute__((packed)) __attribute__((aligned(1))) gssd_cred cred_handle;
  uint32_t ret_flags;
  mach_msg_type_number_t keyCnt;
  mach_msg_type_number_t outtokenCnt;
  uint32_t major_stat;
  uint32_t minor_stat;
  mach_msg_trailer_t trailer;
};

/* 7173 */
struct mach_gss_init_sec_context::Request
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t intoken;
  NDR_record_t_0 NDR;
  gssd_mechtype mech;
  mach_msg_type_number_t intokenCnt;
  uint32_t uid;
  mach_msg_type_number_t princ_namestrOffset;
  mach_msg_type_number_t princ_namestrCnt;
  char princ_namestr[1024];
  mach_msg_type_number_t svc_namestrOffset;
  mach_msg_type_number_t svc_namestrCnt;
  char svc_namestr[1024];
  uint32_t flags;
  uint32_t gssd_flags;
  gssd_ctx context;
  gssd_cred cred_handle;
};

/* 7174 */
union mach_gss_init_sec_context::mach_gss_init_sec_contextMessU
{
  mach_gss_init_sec_context::Request In;
  mach_gss_init_sec_context::Reply Out;
};

/* 7175 */
struct IOPMPowerState_0
{
  unsigned __int64 version;
  IOPMPowerFlags capabilityFlags;
  IOPMPowerFlags outputPowerCharacter;
  IOPMPowerFlags inputPowerRequirement;
  unsigned __int64 staticPower;
  unsigned __int64 stateOrder;
  unsigned __int64 powerToAttain;
  unsigned __int64 timeToAttain;
  unsigned __int64 settleUpTime;
  unsigned __int64 timeToLower;
  unsigned __int64 settleDownTime;
  unsigned __int64 powerDomainBudget;
};

/* 9896 */
struct __cppobj __attribute__((aligned(8))) IOMemoryDescriptor_1 : OSObject_0
{
  IOMemoryDescriptorReserved *reserved;
  OSPtr<OSSet>_0 _mappings;
  IOOptionBits _flags;
  IOMemoryReference *_memRef;
  vm_tag_t _kernelTag;
  vm_tag_t _userTag;
  int16_t _dmaReferences;
  uint16_t _internalFlags;
  kern_allocation_name_t _mapName;
  uint16_t _iomapperOptions;
  uint16_t __iomd_reserved3[3];
  uintptr_t __iomd_reserved4;
  IOByteCount _length;
  IOOptionBits _tag;
};

/* 7176 */
struct __cppobj __attribute__((aligned(8))) IODeviceMemory_0 : IOMemoryDescriptor_1
{
};

/* 7181 */
typedef kern_return_t (*IOMemoryMap::_CopyState_Handler)(OSMetaClassBase_0 *, _IOMemoryMapPrivateState *);

/* 7183 */
typedef kern_return_t (*IOMemoryDescriptor::CreateWithMemoryDescriptors_Handler)(uint64_t, uint32_t, IOMemoryDescriptor_0 **const, IOMemoryDescriptor_0 **);

/* 7184 */
typedef kern_return_t (*IOMemoryDescriptor::CreateSubMemoryDescriptor_Handler)(uint64_t, uint64_t, uint64_t, IOMemoryDescriptor_0 *, IOMemoryDescriptor_0 **);

/* 7185 */
typedef kern_return_t (*IOMemoryDescriptor::CreateMapping_Handler)(OSMetaClassBase_0 *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, IOMemoryMap_0 **);

/* 7186 */
typedef kern_return_t (*IOMemoryDescriptor::_CopyState_Handler)(OSMetaClassBase_0 *, _IOMDPrivateState *);

/* 7188 */
typedef UInt32 IOMessage;

/* 7189 */
typedef struct *IOServiceApplierBlock;

/* 7190 */
typedef void (*IOServiceApplierFunction_0)(IOService_0 *, void *);

/* 7191 */
typedef struct *IOServiceInterestHandlerBlock;

/* 7192 */
typedef struct *IOInterruptActionBlock;

/* 7193 */
typedef struct *IOServiceMatchingNotificationHandlerBlock;

/* 7194 */
typedef kern_return_t (*IOService::_NewUserClient_Handler)(OSMetaClassBase_0 *, uint32_t, OSDictionary_0 *, IOUserClient_0 **);

/* 7195 */
typedef void (*IOService::Stop_async_Handler)(OSMetaClassBase_0 *, IOService_0 *);

/* 7196 */
typedef kern_return_t (*IOService::StateNotificationItemCopy_Handler)(OSMetaClassBase_0 *, OSString_0 *, OSDictionary_0 **);

/* 7197 */
typedef kern_return_t (*IOService::StateNotificationItemSet_Handler)(OSMetaClassBase_0 *, OSString_0 *, OSDictionary_0 *);

/* 7198 */
typedef kern_return_t (*IOService::StateNotificationItemCreate_Handler)(OSMetaClassBase_0 *, OSString_0 *, OSDictionary_0 *);

/* 7199 */
typedef kern_return_t (*IOService::CopySystemStateNotificationService_Handler)(OSMetaClassBase_0 *, IOService_0 **);

/* 7200 */
typedef kern_return_t (*IOService::RemoveProperty_Handler)(OSMetaClassBase_0 *, OSString_0 *);

/* 7201 */
typedef kern_return_t (*IOService::SendIOMessageServicePropertyChange_Handler)(OSMetaClassBase_0 *);

/* 7202 */
typedef kern_return_t (*IOService::UserSetProperties_Handler)(OSMetaClassBase_0 *, OSContainer *);

/* 7203 */
typedef kern_return_t (*IOService::_ClaimSystemWakeEvent_Handler)(OSMetaClassBase_0 *, IOService_0 *, uint64_t, const char *, OSContainer *);

/* 7204 */
typedef kern_return_t (*IOService::StringFromReturn_Handler)(OSMetaClassBase_0 *, IOReturn_0, OSString_0 **);

/* 7205 */
typedef kern_return_t (*IOService::CopyName_Handler)(OSMetaClassBase_0 *, OSString_0 **);

/* 7206 */
typedef IOReturn_0 (*IOService::SetLegend_Handler)(OSMetaClassBase_0 *, OSArray_0 *, bool);

/* 7207 */
typedef IOReturn_0 (*IOService::ConfigureReport_Handler)(OSMetaClassBase_0 *, OSData_0 *, uint32_t, uint32_t *);

/* 7208 */
typedef IOReturn_0 (*IOService::UpdateReport_Handler)(OSMetaClassBase_0 *, OSData_0 *, uint32_t, uint32_t *, uint64_t, uint64_t, IOMemoryDescriptor_0 *);

/* 7209 */
typedef kern_return_t (*IOService::CoreAnalyticsSendEvent_Handler)(OSMetaClassBase_0 *, uint64_t, OSString_0 *, OSDictionary_0 *);

/* 7210 */
typedef kern_return_t (*IOService::GetBusyState_Handler)(OSMetaClassBase_0 *, uint32_t *);

/* 7211 */
typedef kern_return_t (*IOService::AdjustBusy_Handler)(OSMetaClassBase_0 *, int32_t);

/* 7212 */
typedef kern_return_t (*IOService::RequireMaxBusStall_Handler)(OSMetaClassBase_0 *, uint64_t);

/* 7213 */
typedef kern_return_t (*IOService::CopyProviderProperties_Handler)(OSMetaClassBase_0 *, OSArray_0 *, OSArray_0 **);

/* 7214 */
typedef kern_return_t (*IOService::Terminate_Handler)(OSMetaClassBase_0 *, uint64_t);

/* 7215 */
typedef kern_return_t (*IOService::Create_Handler)(OSMetaClassBase_0 *, IOService_0 *, const char *, IOService_0 **);

/* 7216 */
typedef kern_return_t (*IOService::NewUserClient_Handler)(OSMetaClassBase_0 *, uint32_t, IOUserClient_0 **);

/* 7217 */
typedef kern_return_t (*IOService::ChangePowerState_Handler)(OSMetaClassBase_0 *, uint32_t);

/* 7218 */
typedef kern_return_t (*IOService::SetPowerState_Handler)(OSMetaClassBase_0 *, uint32_t);

/* 7219 */
typedef kern_return_t (*IOService::JoinPMTree_Handler)(OSMetaClassBase_0 *);

/* 7220 */
typedef kern_return_t (*IOService::SetProperties_Handler)(OSMetaClassBase_0 *, OSDictionary_0 *);

/* 7221 */
typedef kern_return_t (*IOService::SearchProperty_Handler)(OSMetaClassBase_0 *, const char *, const char *, uint64_t, OSContainer **);

/* 7222 */
typedef kern_return_t (*IOService::CopyProperties_Handler)(OSMetaClassBase_0 *, OSDictionary_0 **);

/* 7223 */
typedef kern_return_t (*IOService::CreateDefaultDispatchQueue_Handler)(OSMetaClassBase_0 *, IODispatchQueue **);

/* 7224 */
typedef kern_return_t (*IOService::RegisterService_Handler)(OSMetaClassBase_0 *);

/* 7225 */
typedef kern_return_t (*IOService::SetName_Handler)(OSMetaClassBase_0 *, const char *);

/* 7226 */
typedef kern_return_t (*IOService::GetRegistryEntryID_Handler)(OSMetaClassBase_0 *, uint64_t *);

/* 7227 */
typedef kern_return_t (*IOService::ClientCrashed_Handler)(OSMetaClassBase_0 *, IOService_0 *, uint64_t);

/* 7228 */
typedef kern_return_t (*IOService::Stop_Handler)(OSMetaClassBase_0 *, IOService_0 *);

/* 7229 */
typedef kern_return_t (*IOService::Start_Handler)(OSMetaClassBase_0 *, IOService_0 *);

/* 7230 */
typedef struct *IORegistryEntry::ActionBlock;

/* 7231 */
typedef IOReturn_0 (*IORegistryEntry::Action_0)(OSObject_0 *, void *, void *, void *, void *);

/* 9198 */
typedef OSObject_0 *libkern::intrusive_shared_ptr<OSObject,intrusive_osobject_retainer>::pointer_0;

/* 9459 */
struct libkern::intrusive_shared_ptr<OSObject,intrusive_osobject_retainer>_0
{
  libkern::intrusive_shared_ptr<OSObject,intrusive_osobject_retainer>::pointer_0 ptr_;
};

/* 7234 */
struct __cppobj OSSharedPtr<OSObject> : libkern::intrusive_shared_ptr<OSObject,intrusive_osobject_retainer>_0
{
};

/* 7235 */
typedef uint32_t OSKextLogSpec_0;

/* 7239 */
typedef ccdigest_state_0 *ccdigest_state_t_1;

/* 7240 */
typedef firehose_buffer_bank_s *firehose_buffer_bank_t;

/* 7242 */
typedef firehose_tracepoint_s *firehose_tracepoint_t;

/* 7245 */
typedef host *host_t;

/* 7249 */
struct mac_policy_ops_0
{
  mpo_audit_check_postselect_t *mpo_audit_check_postselect;
  mpo_audit_check_preselect_t *mpo_audit_check_preselect;
  mpo_reserved_hook_t *mpo_reserved01;
  mpo_reserved_hook_t *mpo_reserved02;
  mpo_reserved_hook_t *mpo_reserved03;
  mpo_reserved_hook_t *mpo_reserved04;
  mpo_cred_check_label_update_execve_t *mpo_cred_check_label_update_execve;
  mpo_cred_check_label_update_t *mpo_cred_check_label_update;
  mpo_cred_check_visible_t *mpo_cred_check_visible;
  mpo_cred_label_associate_fork_t *mpo_cred_label_associate_fork;
  mpo_cred_label_associate_kernel_t *mpo_cred_label_associate_kernel;
  mpo_cred_label_associate_t *mpo_cred_label_associate;
  mpo_cred_label_associate_user_t *mpo_cred_label_associate_user;
  mpo_cred_label_destroy_t *mpo_cred_label_destroy;
  mpo_cred_label_externalize_audit_t *mpo_cred_label_externalize_audit;
  mpo_cred_label_externalize_t *mpo_cred_label_externalize;
  mpo_cred_label_init_t *mpo_cred_label_init;
  mpo_cred_label_internalize_t *mpo_cred_label_internalize;
  mpo_cred_label_update_execve_t *mpo_cred_label_update_execve;
  mpo_cred_label_update_t *mpo_cred_label_update;
  mpo_devfs_label_associate_device_t *mpo_devfs_label_associate_device;
  mpo_devfs_label_associate_directory_t *mpo_devfs_label_associate_directory;
  mpo_devfs_label_copy_t *mpo_devfs_label_copy;
  mpo_devfs_label_destroy_t *mpo_devfs_label_destroy;
  mpo_devfs_label_init_t *mpo_devfs_label_init;
  mpo_devfs_label_update_t *mpo_devfs_label_update;
  mpo_file_check_change_offset_t *mpo_file_check_change_offset;
  mpo_file_check_create_t *mpo_file_check_create;
  mpo_file_check_dup_t *mpo_file_check_dup;
  mpo_file_check_fcntl_t *mpo_file_check_fcntl;
  mpo_file_check_get_offset_t *mpo_file_check_get_offset;
  mpo_file_check_get_t *mpo_file_check_get;
  mpo_file_check_inherit_t *mpo_file_check_inherit;
  mpo_file_check_ioctl_t *mpo_file_check_ioctl;
  mpo_file_check_lock_t *mpo_file_check_lock;
  mpo_file_check_mmap_downgrade_t *mpo_file_check_mmap_downgrade;
  mpo_file_check_mmap_t *mpo_file_check_mmap;
  mpo_file_check_receive_t *mpo_file_check_receive;
  mpo_file_check_set_t *mpo_file_check_set;
  mpo_file_label_init_t *mpo_file_label_init;
  mpo_file_label_destroy_t *mpo_file_label_destroy;
  mpo_file_label_associate_t *mpo_file_label_associate;
  mpo_file_notify_close_t *mpo_file_notify_close;
  mpo_proc_check_launch_constraints_t *mpo_proc_check_launch_constraints;
  mpo_reserved_hook_t *mpo_reserved07;
  mpo_reserved_hook_t *mpo_reserved08;
  mpo_reserved_hook_t *mpo_reserved09;
  mpo_reserved_hook_t *mpo_reserved10;
  mpo_reserved_hook_t *mpo_reserved11;
  mpo_reserved_hook_t *mpo_reserved12;
  mpo_reserved_hook_t *mpo_reserved13;
  mpo_reserved_hook_t *mpo_reserved14;
  mpo_reserved_hook_t *mpo_reserved15;
  mpo_reserved_hook_t *mpo_reserved16;
  mpo_reserved_hook_t *mpo_reserved17;
  mpo_reserved_hook_t *mpo_reserved18;
  mpo_reserved_hook_t *mpo_reserved19;
  mpo_reserved_hook_t *mpo_reserved20;
  mpo_reserved_hook_t *mpo_reserved21;
  mpo_reserved_hook_t *mpo_reserved22;
  mpo_reserved_hook_t *mpo_reserved23;
  mpo_reserved_hook_t *mpo_reserved24;
  mpo_necp_check_open_t *mpo_necp_check_open;
  mpo_necp_check_client_action_t *mpo_necp_check_client_action;
  mpo_file_check_library_validation_t *mpo_file_check_library_validation;
  mpo_vnode_notify_setacl_t *mpo_vnode_notify_setacl;
  mpo_vnode_notify_setattrlist_t *mpo_vnode_notify_setattrlist;
  mpo_vnode_notify_setextattr_t *mpo_vnode_notify_setextattr;
  mpo_vnode_notify_setflags_t *mpo_vnode_notify_setflags;
  mpo_vnode_notify_setmode_t *mpo_vnode_notify_setmode;
  mpo_vnode_notify_setowner_t *mpo_vnode_notify_setowner;
  mpo_vnode_notify_setutimes_t *mpo_vnode_notify_setutimes;
  mpo_vnode_notify_truncate_t *mpo_vnode_notify_truncate;
  mpo_vnode_check_getattrlistbulk_t *mpo_vnode_check_getattrlistbulk;
  mpo_proc_check_get_task_special_port_t *mpo_proc_check_get_task_special_port;
  mpo_proc_check_set_task_special_port_t *mpo_proc_check_set_task_special_port;
  mpo_vnode_notify_swap_t *mpo_vnode_notify_swap;
  mpo_vnode_notify_unlink_t *mpo_vnode_notify_unlink;
  mpo_reserved_hook_t *mpo_reserved32;
  mpo_reserved_hook_t *mpo_reserved33;
  mpo_reserved_hook_t *mpo_reserved34;
  mpo_reserved_hook_t *mpo_reserved35;
  mpo_vnode_check_copyfile_t *mpo_vnode_check_copyfile;
  mpo_mount_check_quotactl_t *mpo_mount_check_quotactl;
  mpo_mount_check_fsctl_t *mpo_mount_check_fsctl;
  mpo_mount_check_getattr_t *mpo_mount_check_getattr;
  mpo_mount_check_label_update_t *mpo_mount_check_label_update;
  mpo_mount_check_mount_t *mpo_mount_check_mount;
  mpo_mount_check_remount_t *mpo_mount_check_remount;
  mpo_mount_check_setattr_t *mpo_mount_check_setattr;
  mpo_mount_check_stat_t *mpo_mount_check_stat;
  mpo_mount_check_umount_t *mpo_mount_check_umount;
  mpo_mount_label_associate_t *mpo_mount_label_associate;
  mpo_mount_label_destroy_t *mpo_mount_label_destroy;
  mpo_mount_label_externalize_t *mpo_mount_label_externalize;
  mpo_mount_label_init_t *mpo_mount_label_init;
  mpo_mount_label_internalize_t *mpo_mount_label_internalize;
  mpo_proc_check_expose_task_with_flavor_t *mpo_proc_check_expose_task_with_flavor;
  mpo_proc_check_get_task_with_flavor_t *mpo_proc_check_get_task_with_flavor;
  mpo_proc_check_task_id_token_get_task_t *mpo_proc_check_task_id_token_get_task;
  mpo_pipe_check_ioctl_t *mpo_pipe_check_ioctl;
  mpo_pipe_check_kqfilter_t *mpo_pipe_check_kqfilter;
  mpo_reserved_hook_t *mpo_reserved41;
  mpo_pipe_check_read_t *mpo_pipe_check_read;
  mpo_pipe_check_select_t *mpo_pipe_check_select;
  mpo_pipe_check_stat_t *mpo_pipe_check_stat;
  mpo_pipe_check_write_t *mpo_pipe_check_write;
  mpo_pipe_label_associate_t *mpo_pipe_label_associate;
  mpo_reserved_hook_t *mpo_reserved42;
  mpo_pipe_label_destroy_t *mpo_pipe_label_destroy;
  mpo_reserved_hook_t *mpo_reserved43;
  mpo_pipe_label_init_t *mpo_pipe_label_init;
  mpo_reserved_hook_t *mpo_reserved44;
  mpo_proc_check_syscall_mac_t *mpo_proc_check_syscall_mac;
  mpo_policy_destroy_t *mpo_policy_destroy;
  mpo_policy_init_t *mpo_policy_init;
  mpo_policy_initbsd_t *mpo_policy_initbsd;
  mpo_policy_syscall_t *mpo_policy_syscall;
  mpo_system_check_sysctlbyname_t *mpo_system_check_sysctlbyname;
  mpo_proc_check_inherit_ipc_ports_t *mpo_proc_check_inherit_ipc_ports;
  mpo_vnode_check_rename_t *mpo_vnode_check_rename;
  mpo_kext_check_query_t *mpo_kext_check_query;
  mpo_proc_notify_exec_complete_t *mpo_proc_notify_exec_complete;
  mpo_proc_notify_cs_invalidated_t *mpo_proc_notify_cs_invalidated;
  mpo_proc_check_syscall_unix_t *mpo_proc_check_syscall_unix;
  mpo_reserved_hook_t *mpo_reserved45;
  mpo_proc_check_set_host_special_port_t *mpo_proc_check_set_host_special_port;
  mpo_proc_check_set_host_exception_port_t *mpo_proc_check_set_host_exception_port;
  mpo_exc_action_check_exception_send_t *mpo_exc_action_check_exception_send;
  mpo_exc_action_label_associate_t *mpo_exc_action_label_associate;
  mpo_exc_action_label_populate_t *mpo_exc_action_label_populate;
  mpo_exc_action_label_destroy_t *mpo_exc_action_label_destroy;
  mpo_exc_action_label_init_t *mpo_exc_action_label_init;
  mpo_exc_action_label_update_t *mpo_exc_action_label_update;
  mpo_vnode_check_trigger_resolve_t *mpo_vnode_check_trigger_resolve;
  mpo_mount_check_mount_late_t *mpo_mount_check_mount_late;
  mpo_mount_check_snapshot_mount_t *mpo_mount_check_snapshot_mount;
  mpo_vnode_notify_reclaim_t *mpo_vnode_notify_reclaim;
  mpo_skywalk_flow_check_connect_t *mpo_skywalk_flow_check_connect;
  mpo_skywalk_flow_check_listen_t *mpo_skywalk_flow_check_listen;
  mpo_posixsem_check_create_t *mpo_posixsem_check_create;
  mpo_posixsem_check_open_t *mpo_posixsem_check_open;
  mpo_posixsem_check_post_t *mpo_posixsem_check_post;
  mpo_posixsem_check_unlink_t *mpo_posixsem_check_unlink;
  mpo_posixsem_check_wait_t *mpo_posixsem_check_wait;
  mpo_posixsem_label_associate_t *mpo_posixsem_label_associate;
  mpo_posixsem_label_destroy_t *mpo_posixsem_label_destroy;
  mpo_posixsem_label_init_t *mpo_posixsem_label_init;
  mpo_posixshm_check_create_t *mpo_posixshm_check_create;
  mpo_posixshm_check_mmap_t *mpo_posixshm_check_mmap;
  mpo_posixshm_check_open_t *mpo_posixshm_check_open;
  mpo_posixshm_check_stat_t *mpo_posixshm_check_stat;
  mpo_posixshm_check_truncate_t *mpo_posixshm_check_truncate;
  mpo_posixshm_check_unlink_t *mpo_posixshm_check_unlink;
  mpo_posixshm_label_associate_t *mpo_posixshm_label_associate;
  mpo_posixshm_label_destroy_t *mpo_posixshm_label_destroy;
  mpo_posixshm_label_init_t *mpo_posixshm_label_init;
  mpo_proc_check_debug_t *mpo_proc_check_debug;
  mpo_proc_check_fork_t *mpo_proc_check_fork;
  mpo_reserved_hook_t *mpo_reserved61;
  mpo_reserved_hook_t *mpo_reserved62;
  mpo_proc_check_getaudit_t *mpo_proc_check_getaudit;
  mpo_proc_check_getauid_t *mpo_proc_check_getauid;
  mpo_proc_check_getlcid_t *mpo_proc_check_getlcid;
  mpo_proc_check_mprotect_t *mpo_proc_check_mprotect;
  mpo_proc_check_sched_t *mpo_proc_check_sched;
  mpo_proc_check_setaudit_t *mpo_proc_check_setaudit;
  mpo_proc_check_setauid_t *mpo_proc_check_setauid;
  mpo_proc_check_setlcid_t *mpo_proc_check_setlcid;
  mpo_proc_check_signal_t *mpo_proc_check_signal;
  mpo_proc_check_wait_t *mpo_proc_check_wait;
  mpo_proc_check_dump_core_t *mpo_proc_check_dump_core;
  mpo_proc_check_remote_thread_create_t *mpo_proc_check_remote_thread_create;
  mpo_socket_check_accept_t *mpo_socket_check_accept;
  mpo_socket_check_accepted_t *mpo_socket_check_accepted;
  mpo_socket_check_bind_t *mpo_socket_check_bind;
  mpo_socket_check_connect_t *mpo_socket_check_connect;
  mpo_socket_check_create_t *mpo_socket_check_create;
  mpo_reserved_hook_t *mpo_reserved46;
  mpo_reserved_hook_t *mpo_reserved47;
  mpo_reserved_hook_t *mpo_reserved48;
  mpo_socket_check_listen_t *mpo_socket_check_listen;
  mpo_socket_check_receive_t *mpo_socket_check_receive;
  mpo_socket_check_received_t *mpo_socket_check_received;
  mpo_reserved_hook_t *mpo_reserved49;
  mpo_socket_check_send_t *mpo_socket_check_send;
  mpo_socket_check_stat_t *mpo_socket_check_stat;
  mpo_socket_check_setsockopt_t *mpo_socket_check_setsockopt;
  mpo_socket_check_getsockopt_t *mpo_socket_check_getsockopt;
  mpo_proc_check_get_movable_control_port_t *mpo_proc_check_get_movable_control_port;
  mpo_proc_check_dyld_process_info_notify_register_t *mpo_proc_check_dyld_process_info_notify_register;
  mpo_proc_check_setuid_t *mpo_proc_check_setuid;
  mpo_proc_check_seteuid_t *mpo_proc_check_seteuid;
  mpo_proc_check_setreuid_t *mpo_proc_check_setreuid;
  mpo_proc_check_setgid_t *mpo_proc_check_setgid;
  mpo_proc_check_setegid_t *mpo_proc_check_setegid;
  mpo_proc_check_setregid_t *mpo_proc_check_setregid;
  mpo_proc_check_settid_t *mpo_proc_check_settid;
  mpo_proc_check_memorystatus_control_t *mpo_proc_check_memorystatus_control;
  mpo_reserved_hook_t *mpo_reserved60;
  mpo_thread_telemetry_t *mpo_thread_telemetry;
  mpo_iokit_check_open_service_t *mpo_iokit_check_open_service;
  mpo_system_check_acct_t *mpo_system_check_acct;
  mpo_system_check_audit_t *mpo_system_check_audit;
  mpo_system_check_auditctl_t *mpo_system_check_auditctl;
  mpo_system_check_auditon_t *mpo_system_check_auditon;
  mpo_system_check_host_priv_t *mpo_system_check_host_priv;
  mpo_system_check_nfsd_t *mpo_system_check_nfsd;
  mpo_system_check_reboot_t *mpo_system_check_reboot;
  mpo_system_check_settime_t *mpo_system_check_settime;
  mpo_system_check_swapoff_t *mpo_system_check_swapoff;
  mpo_system_check_swapon_t *mpo_system_check_swapon;
  mpo_socket_check_ioctl_t *mpo_socket_check_ioctl;
  mpo_sysvmsg_label_associate_t *mpo_sysvmsg_label_associate;
  mpo_sysvmsg_label_destroy_t *mpo_sysvmsg_label_destroy;
  mpo_sysvmsg_label_init_t *mpo_sysvmsg_label_init;
  mpo_sysvmsg_label_recycle_t *mpo_sysvmsg_label_recycle;
  mpo_sysvmsq_check_enqueue_t *mpo_sysvmsq_check_enqueue;
  mpo_sysvmsq_check_msgrcv_t *mpo_sysvmsq_check_msgrcv;
  mpo_sysvmsq_check_msgrmid_t *mpo_sysvmsq_check_msgrmid;
  mpo_sysvmsq_check_msqctl_t *mpo_sysvmsq_check_msqctl;
  mpo_sysvmsq_check_msqget_t *mpo_sysvmsq_check_msqget;
  mpo_sysvmsq_check_msqrcv_t *mpo_sysvmsq_check_msqrcv;
  mpo_sysvmsq_check_msqsnd_t *mpo_sysvmsq_check_msqsnd;
  mpo_sysvmsq_label_associate_t *mpo_sysvmsq_label_associate;
  mpo_sysvmsq_label_destroy_t *mpo_sysvmsq_label_destroy;
  mpo_sysvmsq_label_init_t *mpo_sysvmsq_label_init;
  mpo_sysvmsq_label_recycle_t *mpo_sysvmsq_label_recycle;
  mpo_sysvsem_check_semctl_t *mpo_sysvsem_check_semctl;
  mpo_sysvsem_check_semget_t *mpo_sysvsem_check_semget;
  mpo_sysvsem_check_semop_t *mpo_sysvsem_check_semop;
  mpo_sysvsem_label_associate_t *mpo_sysvsem_label_associate;
  mpo_sysvsem_label_destroy_t *mpo_sysvsem_label_destroy;
  mpo_sysvsem_label_init_t *mpo_sysvsem_label_init;
  mpo_sysvsem_label_recycle_t *mpo_sysvsem_label_recycle;
  mpo_sysvshm_check_shmat_t *mpo_sysvshm_check_shmat;
  mpo_sysvshm_check_shmctl_t *mpo_sysvshm_check_shmctl;
  mpo_sysvshm_check_shmdt_t *mpo_sysvshm_check_shmdt;
  mpo_sysvshm_check_shmget_t *mpo_sysvshm_check_shmget;
  mpo_sysvshm_label_associate_t *mpo_sysvshm_label_associate;
  mpo_sysvshm_label_destroy_t *mpo_sysvshm_label_destroy;
  mpo_sysvshm_label_init_t *mpo_sysvshm_label_init;
  mpo_sysvshm_label_recycle_t *mpo_sysvshm_label_recycle;
  mpo_proc_notify_exit_t *mpo_proc_notify_exit;
  mpo_mount_check_snapshot_revert_t *mpo_mount_check_snapshot_revert;
  mpo_vnode_check_getattr_t *mpo_vnode_check_getattr;
  mpo_mount_check_snapshot_create_t *mpo_mount_check_snapshot_create;
  mpo_mount_check_snapshot_delete_t *mpo_mount_check_snapshot_delete;
  mpo_vnode_check_clone_t *mpo_vnode_check_clone;
  mpo_proc_check_get_cs_info_t *mpo_proc_check_get_cs_info;
  mpo_proc_check_set_cs_info_t *mpo_proc_check_set_cs_info;
  mpo_iokit_check_hid_control_t *mpo_iokit_check_hid_control;
  mpo_vnode_check_access_t *mpo_vnode_check_access;
  mpo_vnode_check_chdir_t *mpo_vnode_check_chdir;
  mpo_vnode_check_chroot_t *mpo_vnode_check_chroot;
  mpo_vnode_check_create_t *mpo_vnode_check_create;
  mpo_vnode_check_deleteextattr_t *mpo_vnode_check_deleteextattr;
  mpo_vnode_check_exchangedata_t *mpo_vnode_check_exchangedata;
  mpo_vnode_check_exec_t *mpo_vnode_check_exec;
  mpo_vnode_check_getattrlist_t *mpo_vnode_check_getattrlist;
  mpo_vnode_check_getextattr_t *mpo_vnode_check_getextattr;
  mpo_vnode_check_ioctl_t *mpo_vnode_check_ioctl;
  mpo_vnode_check_kqfilter_t *mpo_vnode_check_kqfilter;
  mpo_vnode_check_label_update_t *mpo_vnode_check_label_update;
  mpo_vnode_check_link_t *mpo_vnode_check_link;
  mpo_vnode_check_listextattr_t *mpo_vnode_check_listextattr;
  mpo_vnode_check_lookup_t *mpo_vnode_check_lookup;
  mpo_vnode_check_open_t *mpo_vnode_check_open;
  mpo_vnode_check_read_t *mpo_vnode_check_read;
  mpo_vnode_check_readdir_t *mpo_vnode_check_readdir;
  mpo_vnode_check_readlink_t *mpo_vnode_check_readlink;
  mpo_vnode_check_rename_from_t *mpo_vnode_check_rename_from;
  mpo_vnode_check_rename_to_t *mpo_vnode_check_rename_to;
  mpo_vnode_check_revoke_t *mpo_vnode_check_revoke;
  mpo_vnode_check_select_t *mpo_vnode_check_select;
  mpo_vnode_check_setattrlist_t *mpo_vnode_check_setattrlist;
  mpo_vnode_check_setextattr_t *mpo_vnode_check_setextattr;
  mpo_vnode_check_setflags_t *mpo_vnode_check_setflags;
  mpo_vnode_check_setmode_t *mpo_vnode_check_setmode;
  mpo_vnode_check_setowner_t *mpo_vnode_check_setowner;
  mpo_vnode_check_setutimes_t *mpo_vnode_check_setutimes;
  mpo_vnode_check_stat_t *mpo_vnode_check_stat;
  mpo_vnode_check_truncate_t *mpo_vnode_check_truncate;
  mpo_vnode_check_unlink_t *mpo_vnode_check_unlink;
  mpo_vnode_check_write_t *mpo_vnode_check_write;
  mpo_vnode_label_associate_devfs_t *mpo_vnode_label_associate_devfs;
  mpo_vnode_label_associate_extattr_t *mpo_vnode_label_associate_extattr;
  mpo_vnode_label_associate_file_t *mpo_vnode_label_associate_file;
  mpo_vnode_label_associate_pipe_t *mpo_vnode_label_associate_pipe;
  mpo_vnode_label_associate_posixsem_t *mpo_vnode_label_associate_posixsem;
  mpo_vnode_label_associate_posixshm_t *mpo_vnode_label_associate_posixshm;
  mpo_vnode_label_associate_singlelabel_t *mpo_vnode_label_associate_singlelabel;
  mpo_vnode_label_associate_socket_t *mpo_vnode_label_associate_socket;
  mpo_vnode_label_copy_t *mpo_vnode_label_copy;
  mpo_vnode_label_destroy_t *mpo_vnode_label_destroy;
  mpo_vnode_label_externalize_audit_t *mpo_vnode_label_externalize_audit;
  mpo_vnode_label_externalize_t *mpo_vnode_label_externalize;
  mpo_vnode_label_init_t *mpo_vnode_label_init;
  mpo_vnode_label_internalize_t *mpo_vnode_label_internalize;
  mpo_vnode_label_recycle_t *mpo_vnode_label_recycle;
  mpo_vnode_label_store_t *mpo_vnode_label_store;
  mpo_vnode_label_update_extattr_t *mpo_vnode_label_update_extattr;
  mpo_vnode_label_update_t *mpo_vnode_label_update;
  mpo_vnode_notify_create_t *mpo_vnode_notify_create;
  mpo_vnode_check_signature_t *mpo_vnode_check_signature;
  mpo_vnode_check_uipc_bind_t *mpo_vnode_check_uipc_bind;
  mpo_vnode_check_uipc_connect_t *mpo_vnode_check_uipc_connect;
  mpo_proc_check_run_cs_invalid_t *mpo_proc_check_run_cs_invalid;
  mpo_proc_check_suspend_resume_t *mpo_proc_check_suspend_resume;
  mpo_thread_userret_t *mpo_thread_userret;
  mpo_iokit_check_set_properties_t *mpo_iokit_check_set_properties;
  mpo_vnode_check_supplemental_signature_t *mpo_vnode_check_supplemental_signature;
  mpo_vnode_check_searchfs_t *mpo_vnode_check_searchfs;
  mpo_priv_check_t *mpo_priv_check;
  mpo_priv_grant_t *mpo_priv_grant;
  mpo_proc_check_map_anon_t *mpo_proc_check_map_anon;
  mpo_vnode_check_fsgetpath_t *mpo_vnode_check_fsgetpath;
  mpo_iokit_check_open_t *mpo_iokit_check_open;
  mpo_proc_check_ledger_t *mpo_proc_check_ledger;
  mpo_vnode_notify_rename_t *mpo_vnode_notify_rename;
  mpo_vnode_check_setacl_t *mpo_vnode_check_setacl;
  mpo_vnode_notify_deleteextattr_t *mpo_vnode_notify_deleteextattr;
  mpo_system_check_kas_info_t *mpo_system_check_kas_info;
  mpo_vnode_check_lookup_preflight_t *mpo_vnode_check_lookup_preflight;
  mpo_vnode_notify_open_t *mpo_vnode_notify_open;
  mpo_system_check_info_t *mpo_system_check_info;
  mpo_pty_notify_grant_t *mpo_pty_notify_grant;
  mpo_pty_notify_close_t *mpo_pty_notify_close;
  mpo_vnode_find_sigs_t *mpo_vnode_find_sigs;
  mpo_kext_check_load_t *mpo_kext_check_load;
  mpo_kext_check_unload_t *mpo_kext_check_unload;
  mpo_proc_check_proc_info_t *mpo_proc_check_proc_info;
  mpo_vnode_notify_link_t *mpo_vnode_notify_link;
  mpo_iokit_check_filter_properties_t *mpo_iokit_check_filter_properties;
  mpo_iokit_check_get_property_t *mpo_iokit_check_get_property;
};

/* 7250 */
typedef void (*trigger_vnode_reclaim_callback_t_0)(vnode_t, void *);

/* 7251 */
typedef resolver_result_t (*trigger_vnode_unresolve_callback_t_0)(vnode_t, int, void *, vfs_context_t);

/* 7252 */
typedef resolver_result_t (*trigger_vnode_resolve_callback_t_0)(vnode_t, const componentname *, path_operation, int, void *, vfs_context_t);

/* 7255 */
typedef resolver_result_t (*trigger_vnode_resolve_callback_t_1)(vnode_t, const componentname *, path_operation, int, void *, vfs_context_t);

/* 7257 */
struct mac_label_element_list_t
{
  mac_label_element *slh_first;
};

/* 7258 */
struct mac_policy_list
{
  u_int numloaded;
  u_int max;
  u_int maxindex;
  u_int staticmax;
  u_int chunks;
  u_int freehint;
  mac_policy_list_element *entries;
};

/* 7270 */
struct pe_serial_functions
{
  void (*init)(void);
  unsigned int (*transmit_ready)(void);
  void (*transmit_data)(uint8_t);
  unsigned int (*receive_ready)(void);
  uint8_t (*receive_data)(void);
  void (*enable_irq)(void);
  bool (*disable_irq)(void);
  bool (*acknowledge_irq)(void);
  bool has_irq;
  serial_device_t device;
  pe_serial_functions *next;
};

/* 7271 */
typedef void (*timebase_callback_func)(timebase_freq_t *);

/* 7272 */
typedef PE_Video_0 PE_Video_1;

/* 7274 */
struct machine_timeout_spec
{
  void *ptr;
  uint64_t default_value;
  uint64_t unit_scale;
  char name[26];
  bool (*skip_predicate)(const machine_timeout_spec *);
};

/* 7275 */
enum kc_index : __int32
{
  kc_index::primary_kc_index = 0x0,
  kc_index::pageable_kc_index = 0x1,
  kc_index::auxiliary_kc_index = 0x3,
};

/* 7277 */
typedef kc_kind_0 kc_kind_t_1;

/* 7278 */
typedef OpaqueDTEntry DeviceTreeNode_0;

/* 7279 */
struct ml_topology_cpu
{
  unsigned int cpu_id;
  uint32_t phys_id;
  unsigned int cluster_id;
  unsigned int die_id;
  _BYTE gap10[4];
  uint32_t l2_access_penalty;
  uint32_t l2_cache_size;
  uint32_t l2_cache_id;
  uint32_t l3_cache_size;
  uint32_t l3_cache_id;
  vm_offset_t cpu_IMPL_regs;
  uint64_t cpu_IMPL_pa;
  uint64_t cpu_IMPL_len;
  vm_offset_t cpu_UTTDBG_regs;
  uint64_t cpu_UTTDBG_pa;
  uint64_t cpu_UTTDBG_len;
  vm_offset_t coresight_regs;
  uint64_t coresight_pa;
  uint64_t coresight_len;
  unsigned int die_cluster_id;
  unsigned int cluster_core_id;
};

/* 9166 */
typedef void (*IOInterruptHandler_1)(void *, void *, void *, int);

/* 7280 */
struct __cppobj PassthruInterruptController_0 : IOInterruptController_0
{
  IOInterruptHandler_1 child_handler;
  void *child_target;
  void *child_refCon;
  IOService_0 *child_nub;
  semaphore_t_0 child_sentinel;
};

/* 7281 */
struct __cppobj IOPMGR_0 : IOService_0
{
};

/* 7282 */
struct ml_topology_cluster
{
  unsigned int cluster_id;
  __attribute__((aligned(8))) unsigned int num_cpus;
  unsigned int first_cpu_id;
  uint64_t cpu_mask;
  vm_offset_t acc_IMPL_regs;
  uint64_t acc_IMPL_pa;
  uint64_t acc_IMPL_len;
  vm_offset_t cpm_IMPL_regs;
  uint64_t cpm_IMPL_pa;
  uint64_t cpm_IMPL_len;
};

/* 7284 */
struct __cppobj OSSharedPtr<OSCollection> : libkern::intrusive_shared_ptr<OSCollection,intrusive_osobject_retainer>
{
};

/* 7286 */
struct __cppobj OSSharedPtr<OSValueObject<PMAssertStruct> > : libkern::intrusive_shared_ptr<OSValueObject<PMAssertStruct>,intrusive_osobject_retainer>
{
};

/* 7288 */
struct __cppobj OSValueObject<PMAssertStruct>::MetaClass : OSMetaClass_0
{
};

/* 7289 */
struct __cppobj IORootParent::MetaClass : OSMetaClass_0
{
};

/* 7290 */
struct __cppobj PMSettingObject::MetaClass : OSMetaClass_0
{
};

/* 7774 */
typedef libkern::detail::copy_cv<unsigned int,char>::type libkern::detail::copy_cv_t<unsigned int,char>;

/* 7757 */
typedef libkern::detail::copy_cv_t<unsigned int,char> libkern::bounded_ptr<unsigned int,os_detail::panic_trapping_policy>::CharType;

/* 7291 */
struct libkern::bounded_ptr<unsigned int,os_detail::panic_trapping_policy>
{
  libkern::bounded_ptr<unsigned int,os_detail::panic_trapping_policy>::CharType *base_;
  uint32_t count_;
  int32_t offset_;
};

/* 7293 */
struct __cppobj PMSettingHandle::MetaClass : OSMetaClass_0
{
};

/* 7294 */
struct __cppobj PMTraceWorker::MetaClass : OSMetaClass_0
{
};

/* 7295 */
struct __cppobj IOPMServiceInterestNotifier::MetaClass : OSMetaClass_0
{
};

/* 7296 */
struct __cppobj IOPMrootDomain::MetaClass : OSMetaClass_0
{
};

/* 7298 */
struct libkern::intrusive_shared_ptr<IONotifier,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IONotifier,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7297 */
struct __cppobj OSSharedPtr<IONotifier> : libkern::intrusive_shared_ptr<IONotifier,intrusive_osobject_retainer>
{
};

/* 7300 */
struct libkern::intrusive_shared_ptr<IOTimerEventSource,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOTimerEventSource,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7299 */
struct __cppobj OSSharedPtr<IOTimerEventSource> : libkern::intrusive_shared_ptr<IOTimerEventSource,intrusive_osobject_retainer>
{
};

/* 7302 */
struct libkern::intrusive_shared_ptr<PMTraceWorker,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<PMTraceWorker,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7301 */
struct __cppobj OSSharedPtr<PMTraceWorker> : libkern::intrusive_shared_ptr<PMTraceWorker,intrusive_osobject_retainer>
{
};

/* 7304 */
struct libkern::intrusive_shared_ptr<IORegistryIterator,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IORegistryIterator,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7303 */
struct __cppobj OSSharedPtr<IORegistryIterator> : libkern::intrusive_shared_ptr<IORegistryIterator,intrusive_osobject_retainer>
{
};

/* 7306 */
struct __cppobj PMHaltWorker::MetaClass : OSMetaClass_0
{
};

/* 7307 */
struct __cppobj PMAssertionsTracker::MetaClass : OSMetaClass_0
{
};

/* 9194 */
typedef IOReturn_0 (*IOServiceInterestHandler_1)(void *, void *, UInt32, IOService_0 *, void *, vm_size_t_0);

/* 7309 */
struct HaltRestartApplierContext
{
  IOPMrootDomain_0 *RootDomain;
  unsigned __int64 PowerState;
  IOPMPowerFlags PowerFlags;
  UInt32 MessageType;
  UInt32 Counter;
  const char *LogString;
  shutdownPhase_t phase;
  IOServiceInterestHandler_1 handler;
};

/* 7314 */
struct __cppobj __attribute__((aligned(8))) _IOServiceInterestNotifier : IONotifier_0
{
  queue_chain_t_0 chain;
  IOServiceInterestHandler_1 handler;
  void *target;
  void *ref;
  queue_head_t_0 handlerInvocations;
  IOOptionBits_0 state;
};

/* 7310 */
struct __cppobj IOPMServiceInterestNotifier : _IOServiceInterestNotifier
{
  uint32_t ackTimeoutCnt;
  uint32_t msgType;
  uint32_t lastSleepWakeMsgType;
  uint32_t msgIndex;
  uint32_t maxMsgDelayMS;
  uint32_t maxAckDelayMS;
  uint64_t msgAbsTime;
  uint64_t uuid0;
  uint64_t uuid1;
  OSSharedPtr<const OSSymbol> identifier;
  OSSharedPtr<const OSSymbol> clientName;
};

/* 7311 */
struct __cppobj IOPlatformDevice_0 : IOService_0
{
  IOPlatformDevice::ExpansionData_0 *iopd_reserved;
};

/* 7471 */
struct IOPlatformDevice::ExpansionData_0
{
  _BYTE gap0;
};

/* 7313 */
struct __cppobj IORootParent : IOService_0
{
};

/* 7315 */
struct __cppobj __attribute__((aligned(8))) PMHaltWorker : OSObject_1
{
  IOService_0 *service;
  AbsoluteTime_0 startTime;
  int depth;
  int visits;
  IOLock_0 *lock;
  bool timeout;
};

/* 7316 */
struct PMAssertStruct
{
  IOPMDriverAssertionID id;
  IOPMDriverAssertionType assertionBits;
  uint64_t createdTime;
  uint64_t modifiedTime;
  const OSSymbol_0 *ownerString;
  IOService_0 *ownerService;
  uint64_t registryEntryID;
  IOPMDriverAssertionLevel level;
  uint64_t assertCPUStartTime;
  uint64_t assertCPUDuration;
};

/* 7318 */
struct __cppobj IOUnifiedAddressTranslator::MetaClass : OSMetaClass_0
{
};

/* 7319 */
struct __cppobj __attribute__((aligned(8))) IOUnifiedAddressTranslator : OSObject_1
{
  task_t_0 fOwningTask;
  IOService_0 *fDriverService;
  ppl_iommu_state *fPPLState;
  IOLock_0 *fTTBR0Lock;
  bool fUseRestrictedAperture;
  IORangeAllocator_0 *fCodeRangeAllocator;
  uint32_t fDebugEnable;
  ppl_iommu_seg fUnmapList[32];
  uint32_t fUnmapListCount;
  IORecursiveLock_0 *fUnmapListLock;
  OSArray_0 *fReleaseArray;
  IOLock_0 *fReleaseThreadLock;
  thread_call_t fReleaseThread;
  bool fReleaseThreadActive;
  atomic_bool fReleaseThreadTerminate;
};

/* 7320 */
struct __cppobj IONVRAMController::MetaClass : OSMetaClass_0
{
};

/* 7321 */
struct __cppobj IOSKMemoryBuffer::MetaClass : OSMetaClass_0
{
};

/* 7322 */
struct __cppobj IOSKMemoryArray::MetaClass : OSMetaClass_0
{
};

/* 7323 */
struct __cppobj IOSKRegion::MetaClass : OSMetaClass_0
{
};

/* 7324 */
struct __cppobj IOSKArena::MetaClass : OSMetaClass_0
{
};

/* 7325 */
struct __cppobj IOSKMapper::MetaClass : OSMetaClass_0
{
};

/* 7326 */
struct __cppobj IOSKRegionMapper::MetaClass : OSMetaClass_0
{
};

/* 7327 */
typedef IOSKRegion *IOSKRegionRef_0;

/* 7328 */
typedef IOSKArena *IOSKArenaRef_0;

/* 7329 */
struct __cppobj __attribute__((aligned(4))) IOSKMemoryArray : IOMultiMemoryDescriptor_0
{
};

/* 7330 */
struct __cppobj IOSKRegionMapper : OSObject_1
{
  IOSKMapper *fMapper;
  IOSKRegion *fRegion;
  IOMemoryMap_0 **fMemoryMaps;
  IOSKCount fMemoryMapCount;
  IOSKOffset fRegionOffset;
};

/* 7336 */
struct __cppobj IOPerfControlWorkContext::MetaClass : OSMetaClass_0
{
};

/* 7337 */
struct __cppobj IOPerfControlClient::MetaClass : OSMetaClass_0
{
};

/* 7338 */
struct __attribute__((aligned(8))) IOPerfControlClient::WorkTableEntry
{
  thread_group *thread_group;
  bool started;
  uint8_t perfcontrol_data[32];
};

/* 7339 */
struct __cppobj __attribute__((aligned(8))) IOPerfControlWorkContext : OSObject_1
{
  uint64_t id;
  thread_group *thread_group;
  bool started;
  uint8_t perfcontrol_data[32];
};

/* 7340 */
struct __cppobj IOPerfControlClient : OSObject_1
{
  uint8_t driverIndex;
  IOPerfControlClient::IOPerfControlClientShared *shared;
  IOPerfControlClient::WorkTableEntry *workTable;
  size_t workTableLength;
  size_t workTableNextIndex;
  IOSimpleLock_0 *workTableLock;
  IOPerfControlClient::IOPerfControlClientData clientData;
};

/* 7348 */
struct IOPerfControlClient::IOPerfControlClientShared
{
  atomic_uint_fast8_t maxDriverIndex;
  IOPerfControlClient::PerfControllerInterface interface;
  IOLock_0 *interfaceLock;
  OSSet_0 *deviceRegistrationList;
};

/* 7349 */
struct __cppobj IOWatchDogTimer::MetaClass : OSMetaClass_0
{
};

/* 7350 */
struct __cppobj IOWatchDogTimer_0 : IOService_0
{
  IONotifier_0 *notifier;
  IOWatchDogTimer::ExpansionData_0 *reserved;
};

/* 7351 */
struct IOWatchDogTimer::ExpansionData_0
{
  _BYTE gap0;
};

/* 7352 */
struct __cppobj IOPowerConnection::MetaClass : OSMetaClass_0
{
};

/* 7353 */
struct __cppobj RootDomainUserClient::MetaClass : OSMetaClass_0
{
};

/* 7354 */
struct __cppobj RootDomainUserClient : IOUserClient2022
{
  IOPMrootDomain_0 *fOwner;
  task_t_0 fOwningTask;
};

/* 7355 */
enum IOPolledCoreFileMode_t : __int32
{
  kIOPolledCoreFileModeNotInitialized = 0x0,
  kIOPolledCoreFileModeDisabled = 0x1,
  kIOPolledCoreFileModeClosed = 0x2,
  kIOPolledCoreFileModeUnlinked = 0x3,
  kIOPolledCoreFileModeStackshot = 0x4,
  kIOPolledCoreFileModeCoredump = 0x5,
};

/* 7356 */
typedef libkern::sa_detail::remove_const<char>::type libkern::sa_detail::remove_const_t<char>;

/* 7625 */
typedef libkern::detail::copy_cv_t<OSArray *,char> libkern::bounded_ptr<OSArray *,os_detail::panic_trapping_policy>::CharType;

/* 7357 */
struct libkern::bounded_ptr<OSArray *,os_detail::panic_trapping_policy>
{
  libkern::bounded_ptr<OSArray *,os_detail::panic_trapping_policy>::CharType *base_;
  uint32_t count_;
  int32_t offset_;
};

/* 7359 */
struct __attribute__((aligned(8))) libkern::safe_allocation<unsigned char,os_detail::IOKit_typed_allocator<unsigned char,true>,os_detail::panic_trapping_policy>
{
  unsigned __int8 *data_;
  uint32_t size_;
};

/* 7360 */
struct __cppobj IOStateNotificationListener::MetaClass : OSMetaClass_0
{
};

/* 7361 */
struct __cppobj IOStateNotificationItem::MetaClass : OSMetaClass_0
{
};

/* 7362 */
struct __cppobj IOSystemStateNotification::MetaClass : OSMetaClass_0
{
};

/* 7363 */
struct __cppobj IOServiceStateNotificationEventSource::MetaClass : OSMetaClass_0
{
};

/* 7364 */
struct __cppobj IOUserUserClient::MetaClass : OSMetaClass_0
{
};

/* 7365 */
struct __cppobj IOUserServer::MetaClass : OSMetaClass_0
{
};

/* 7381 */
typedef const char libkern::detail::copy_cv<const IOExternalTrap,char>::type;

/* 7382 */
typedef libkern::detail::copy_cv<const IOExternalTrap,char>::type libkern::detail::copy_cv_t<const IOExternalTrap,char>;

/* 7380 */
typedef libkern::detail::copy_cv_t<const IOExternalTrap,char> libkern::bounded_ptr<const IOExternalTrap,os_detail::panic_trapping_policy>::CharType;

/* 7366 */
struct libkern::bounded_ptr<const IOExternalTrap,os_detail::panic_trapping_policy>
{
  libkern::bounded_ptr<const IOExternalTrap,os_detail::panic_trapping_policy>::CharType *base_;
  uint32_t count_;
  int32_t offset_;
};

/* 7603 */
typedef const char libkern::detail::copy_cv<const char,char>::type;

/* 7604 */
typedef libkern::detail::copy_cv<const char,char>::type libkern::detail::copy_cv_t<const char,char>;

/* 7598 */
typedef libkern::detail::copy_cv_t<const char,char> libkern::bounded_ptr<const char,os_detail::panic_trapping_policy>::CharType;

/* 7367 */
struct libkern::bounded_ptr<const char,os_detail::panic_trapping_policy>
{
  libkern::bounded_ptr<const char,os_detail::panic_trapping_policy>::CharType *base_;
  uint32_t count_;
  int32_t offset_;
};

/* 7368 */
struct __cppobj _IOUserServerCheckInCancellationHandler::MetaClass : OSMetaClass_0
{
};

/* 7369 */
struct __cppobj IOUserServerCheckInToken::MetaClass : OSMetaClass_0
{
};

/* 7370 */
struct __cppobj IOUserService::MetaClass : OSMetaClass_0
{
};

/* 7371 */
struct __cppobj IOUserService : IOService_0
{
};

/* 7372 */
struct __cppobj OSUserMetaClass::MetaClass : OSMetaClass_0
{
};

/* 7373 */
typedef libkern::sa_detail::remove_const<unsigned char>::type libkern::sa_detail::remove_const_t<unsigned char>;

/* 7375 */
struct __cppobj IOSystemStateNotification : IOService_0
{
};

/* 7376 */
typedef IOPMPowerState_0 IOPMPowerState_1;

/* 7377 */
struct __cppobj IOServiceStateNotificationEventSource : IOEventSource_0
{
  IOService_0 *fStateNotification;
  IOStateNotificationListenerRef fListener;
  bool fEnable;
  bool fArmed;
  IOEventSource::ExpansionData_0 *reserved;
};

/* 7383 */
struct __cppobj IORTC_0 : IOService_0
{
  IORTC::ExpansionData_0 *iortc_reserved;
};

/* 7385 */
struct IORTC::ExpansionData_0
{
  _BYTE gap0;
};

/* 7384 */
struct __cppobj IORTC::MetaClass : OSMetaClass_0
{
};

/* 7387 */
struct libkern::intrusive_shared_ptr<IOReportLegend,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOReportLegend,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7386 */
struct __cppobj OSSharedPtr<IOReportLegend> : libkern::intrusive_shared_ptr<IOReportLegend,intrusive_osobject_retainer>
{
};

/* 7389 */
struct __cppobj IOReportLegend::MetaClass : OSMetaClass_0
{
};

/* 7390 */
struct __cppobj OSSharedPtr<IOHistogramReporter> : libkern::intrusive_shared_ptr<IOHistogramReporter,intrusive_osobject_retainer>
{
};

/* 7391 */
struct __cppobj IOHistogramReporter::MetaClass : OSMetaClass_0
{
};

/* 7393 */
struct __cppobj OSSharedPtr<IOStateReporter> : libkern::intrusive_shared_ptr<IOStateReporter,intrusive_osobject_retainer>
{
};

/* 7394 */
struct __cppobj IOStateReporter::MetaClass : OSMetaClass_0
{
};

/* 7396 */
struct __cppobj IOSimpleReporter::MetaClass : OSMetaClass_0
{
};

/* 7398 */
struct libkern::intrusive_shared_ptr<IOSimpleReporter,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOSimpleReporter,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7397 */
struct __cppobj OSSharedPtr<IOSimpleReporter> : libkern::intrusive_shared_ptr<IOSimpleReporter,intrusive_osobject_retainer>
{
};

/* 7399 */
struct __cppobj IOReporter::MetaClass : OSMetaClass_0
{
};

/* 7400 */
struct IOStatistics::ClassTree
{
  ClassNode *rbh_root;
};

/* 7401 */
struct IOStatistics::KextAddressTree
{
  KextNode *rbh_root;
};

/* 7402 */
struct IOStatistics::KextTree
{
  KextNode *rbh_root;
};

/* 7403 */
struct __cppobj OSSharedPtr<IOSharedDataQueue> : libkern::intrusive_shared_ptr<IOSharedDataQueue,intrusive_osobject_retainer>
{
};

/* 7404 */
struct __cppobj IOSharedDataQueue::MetaClass : OSMetaClass_0
{
};

/* 7408 */
struct __cppobj OSSharedPtr<IODataQueue> : libkern::intrusive_shared_ptr<IODataQueue,intrusive_osobject_retainer>
{
};

/* 7409 */
struct __cppobj IODataQueue::MetaClass : OSMetaClass_0
{
};

/* 7410 */
struct __cppobj IOKitDiagnosticsClient::MetaClass : OSMetaClass_0
{
};

/* 7411 */
struct __cppobj IOKitDiagnosticsClient_0 : IOUserClient2022
{
};

/* 7412 */
struct __cppobj IOKitDiagnostics::MetaClass : OSMetaClass_0
{
};

/* 7413 */
struct __cppobj __attribute__((aligned(8))) IOKitDiagnostics_0 : OSObject_1
{
};

/* 7414 */
struct libkern::bounded_array<unsigned long long,16UL,os_detail::panic_trapping_policy>
{
  unsigned __int64 data_[16];
};

/* 7429 */
typedef libkern::detail::copy_cv<unsigned long long,char>::type libkern::detail::copy_cv_t<unsigned long long,char>;

/* 7423 */
typedef libkern::detail::copy_cv_t<unsigned long long,char> libkern::bounded_ptr<unsigned long long,os_detail::panic_trapping_policy>::CharType;

/* 7415 */
struct libkern::bounded_ptr<unsigned long long,os_detail::panic_trapping_policy>
{
  libkern::bounded_ptr<unsigned long long,os_detail::panic_trapping_policy>::CharType *base_;
  uint32_t count_;
  int32_t offset_;
};

/* 7416 */
struct __cppobj IOUserClient2022::MetaClass : OSMetaClass_0
{
};

/* 7417 */
struct __cppobj IOUserClient::MetaClass : OSMetaClass_0
{
};

/* 7418 */
struct __cppobj IOServiceMessageUserNotification::MetaClass : OSMetaClass_0
{
};

/* 7419 */
struct __cppobj IOServiceUserNotification::MetaClass : OSMetaClass_0
{
};

/* 7420 */
struct __cppobj IOUserNotification::MetaClass : OSMetaClass_0
{
};

/* 7421 */
struct __cppobj IOUserIterator::MetaClass : OSMetaClass_0
{
};

/* 7422 */
struct __cppobj IOMachPort::MetaClass : OSMetaClass_0
{
};

/* 7424 */
struct IOServiceMessageUserNotification::PingMsgUdata
{
  OSNotificationHeader64 notifyHeader;
};

/* 7430 */
struct __cppobj IOUserIterator : OSIterator_1
{
  OSObject_1 *userIteratorObject;
  IOLock_0 lock;
};

/* 7428 */
struct __cppobj IOUserNotification : IOUserIterator
{
};

/* 7425 */
struct __cppobj __attribute__((aligned(4))) IOServiceMessageUserNotification : IOUserNotification
{
  ipc_port_t_0 remotePort;
  void *msgReference;
  mach_msg_size_t msgReferenceSize;
  mach_msg_size_t msgExtraSize;
  natural_t msgType;
  uint8_t clientIs64;
  int owningPID;
  bool ipcLogged;
};

/* 7426 */
struct IOServiceUserNotification::PingMsgUdata
{
  OSNotificationHeader64 notifyHeader;
};

/* 7427 */
struct __cppobj __attribute__((aligned(8))) IOServiceUserNotification : IOUserNotification
{
  ipc_port_t_0 remotePort;
  void *msgReference;
  mach_msg_size_t msgReferenceSize;
  natural_t msgType;
  OSArray_1 *newSet;
  bool armed;
  bool ipcLogged;
};

/* 9903 */
struct __cppobj OSArray_1 : OSCollection_1
{
  unsigned int count;
  unsigned int capacity;
  unsigned int capacityIncrement;
};

/* 7432 */
struct __cppobj PassthruInterruptController::MetaClass : OSMetaClass_0
{
};

/* 7433 */
struct __cppobj IOSharedInterruptController::MetaClass : OSMetaClass_0
{
};

/* 7434 */
struct __cppobj IOInterruptController::MetaClass : OSMetaClass_0
{
};

/* 7435 */
struct __cppobj IODMAController::MetaClass : OSMetaClass_0
{
};

/* 7436 */
typedef chrp_nvram_header chrp_nvram_header_t;

/* 7437 */
struct __cppobj IODTNVRAMVariables::MetaClass : OSMetaClass_0
{
};

/* 7438 */
struct __cppobj IODTNVRAMDiags::MetaClass : OSMetaClass_0
{
};

/* 7439 */
struct __cppobj IODTNVRAMPlatformNotifier::MetaClass : OSMetaClass_0
{
};

/* 7440 */
struct __cppobj IODTNVRAM::MetaClass : OSMetaClass_0
{
};

/* 7441 */
struct __cppobj OSSharedPtr<OSSerializer> : libkern::intrusive_shared_ptr<OSSerializer,intrusive_osobject_retainer>
{
};

/* 7443 */
struct libkern::intrusive_shared_ptr<const OSString,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<const OSString,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7442 */
struct __cppobj OSSharedPtr<const OSString> : libkern::intrusive_shared_ptr<const OSString,intrusive_osobject_retainer>
{
};

/* 7453 */
typedef const char libkern::detail::copy_cv<const unsigned char,char>::type;

/* 9167 */
typedef libkern::detail::copy_cv<const unsigned char,char>::type libkern::detail::copy_cv_t<const unsigned char,char>;

/* 7450 */
typedef libkern::detail::copy_cv_t<const unsigned char,char> libkern::bounded_ptr<const unsigned char,os_detail::panic_trapping_policy>::CharType;

/* 7444 */
struct libkern::bounded_ptr<const unsigned char,os_detail::panic_trapping_policy>
{
  libkern::bounded_ptr<const unsigned char,os_detail::panic_trapping_policy>::CharType *base_;
  uint32_t count_;
  int32_t offset_;
};

/* 7447 */
struct libkern::intrusive_shared_ptr<OSBoolean,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSBoolean,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7446 */
struct __cppobj OSSharedPtr<OSBoolean> : libkern::intrusive_shared_ptr<OSBoolean,intrusive_osobject_retainer>
{
};

/* 7449 */
struct libkern::intrusive_shared_ptr<IORegistryEntry,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IORegistryEntry,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7448 */
struct __cppobj OSSharedPtr<IORegistryEntry> : libkern::intrusive_shared_ptr<IORegistryEntry,intrusive_osobject_retainer>
{
};

/* 7451 */
struct __cppobj IONVRAMV3Handler : IODTNVRAMFormatHandler
{
  IONVRAMController_0 *_nvramController;
  IODTNVRAM_0 *_provider;
  bool _newData;
  bool _resetData;
  bool _reload;
  bool _rawController;
  uint32_t _generation;
  uint8_t *_nvramImage;
  OSSharedPtr<OSDictionary> *_varDict;
  uint32_t _commonSize;
  uint32_t _systemSize;
  uint32_t _commonUsed;
  uint32_t _systemUsed;
  uint32_t _currentOffset;
  OSSharedPtr<OSArray> _varEntries;
};

/* 7452 */
struct IOTypedOperatorsMixin<IONVRAMV3Handler>
{
  _BYTE gap0;
};

/* 7454 */
struct __cppobj IONVRAMCHRPHandler : IODTNVRAMFormatHandler
{
  bool _newData;
  bool _reload;
  IONVRAMController_0 *_nvramController;
  IODTNVRAM_0 *_provider;
  NVRAMVersion _version;
  uint32_t _generation;
  uint8_t *_nvramImage;
  uint32_t _commonPartitionOffset;
  uint32_t _commonPartitionSize;
  uint32_t _systemPartitionOffset;
  uint32_t _systemPartitionSize;
  OSSharedPtr<OSDictionary> *_varDict;
  uint32_t _commonUsed;
  uint32_t _systemUsed;
};

/* 7456 */
struct __cppobj IOCPUInterruptController::MetaClass : OSMetaClass_0
{
};

/* 7457 */
struct __cppobj IOCPUInterruptController : IOInterruptController_0
{
  int enabledCPUs;
  int numCPUs;
  int numSources;
  IOCPUInterruptController::ExpansionData *iocpuic_reserved;
};

/* 7459 */
struct IOCPUInterruptController::ExpansionData
{
  _BYTE gap0;
};

/* 7458 */
struct __cppobj IOCPU::MetaClass : OSMetaClass_0
{
};

/* 7460 */
struct __cppobj IOCPU : IOService_0
{
  OSPtr<OSArray>_0 _cpuGroup;
  UInt32 _cpuNumber;
  UInt32 _cpuState;
  IOService_0 *cpuNub;
  processor_t machProcessor;
  ipi_handler_t ipi_handler;
  IOCPU::ExpansionData *iocpu_reserved;
};

/* 7461 */
struct IOCPU::ExpansionData
{
  _BYTE gap0;
};

/* 7462 */
struct __cppobj IOPlatformIO::MetaClass : OSMetaClass_0
{
};

/* 7463 */
struct __cppobj IOPlatformIO_0 : IOService_0
{
};

/* 7464 */
struct __cppobj IODTPlatformExpert_0 : IOPlatformExpert_0
{
  IODTNVRAM_0 *dtNVRAM;
  IODTPlatformExpert::ExpansionData_0 *iodtpe_reserved;
};

/* 7472 */
struct IODTPlatformExpert::ExpansionData_0
{
  _BYTE gap0;
};

/* 7465 */
struct __cppobj IOPanicPlatform::MetaClass : OSMetaClass_0
{
};

/* 7466 */
struct __cppobj IOPanicPlatform : IOPlatformExpert_0
{
};

/* 7467 */
struct __cppobj IOPlatformDevice::MetaClass : OSMetaClass_0
{
};

/* 7468 */
struct __cppobj IOPlatformExpertDevice::MetaClass : OSMetaClass_0
{
};

/* 7469 */
struct __cppobj IODTPlatformExpert::MetaClass : OSMetaClass_0
{
};

/* 7470 */
struct __cppobj IOPlatformExpert::MetaClass : OSMetaClass_0
{
};

/* 7474 */
struct __cppobj IOGuardPageMemoryDescriptor::MetaClass : OSMetaClass_0
{
};

/* 7476 */
struct __cppobj OSSharedPtr<IOGuardPageMemoryDescriptor> : libkern::intrusive_shared_ptr<IOGuardPageMemoryDescriptor,intrusive_osobject_retainer>
{
};

/* 7477 */
struct __cppobj IOSubMemoryDescriptor::MetaClass : OSMetaClass_0
{
};

/* 7478 */
struct __cppobj IORangeAllocator::MetaClass : OSMetaClass_0
{
};

/* 7479 */
struct __cppobj IOMultiMemoryDescriptor::MetaClass : OSMetaClass_0
{
};

/* 7480 */
typedef uint64_t addr64_t_0;

/* 7481 */
struct __cppobj _IOMemoryDescriptorMixedData::MetaClass : OSMetaClass_0
{
};

/* 9147 */
struct __cppobj OSMetaClass_1 : OSMetaClassBase_0
{
  ExpansionData *reserved;
  const OSMetaClass_0 *superClassLink;
  const OSSymbol_0 *className;
  unsigned int classSize;
  unsigned int instanceCount;
};

/* 7482 */
struct __cppobj IOMemoryMap::MetaClass : OSMetaClass_1
{
};

/* 7483 */
struct __cppobj IOGeneralMemoryDescriptor::MetaClass : OSMetaClass_0
{
};

/* 7497 */
typedef libkern::detail::copy_cv<SerData,char>::type libkern::detail::copy_cv_t<SerData,char>;

/* 7495 */
typedef libkern::detail::copy_cv_t<SerData,char> libkern::bounded_ptr<SerData,os_detail::panic_trapping_policy>::CharType;

/* 7484 */
struct libkern::bounded_ptr<SerData,os_detail::panic_trapping_policy>
{
  libkern::bounded_ptr<SerData,os_detail::panic_trapping_policy>::CharType *base_;
  uint32_t count_;
  int32_t offset_;
};

/* 7485 */
struct __attribute__((aligned(8))) libkern::safe_allocation<SerData,os_detail::IOKit_typed_allocator<SerData,true>,os_detail::panic_trapping_policy>
{
  IOGeneralMemoryDescriptor::serialize::SerData *data_;
  uint32_t size_;
};

/* 7494 */
struct IOGeneralMemoryDescriptor::serialize::SerData
{
  user_addr_t_0 address;
  user_size_t length;
};

/* 7486 */
struct __cppobj OSSharedPtr<_IOMemoryDescriptorMixedData> : libkern::intrusive_shared_ptr<_IOMemoryDescriptorMixedData,intrusive_osobject_retainer>
{
};

/* 7487 */
struct __cppobj IOMemoryDescriptor::MetaClass : OSMetaClass_1
{
};

/* 7489 */
struct __cppobj IOTimeStampIntervalConstantFiltered
{
  unsigned int _csc;
  uintptr_t _endArg1;
  uintptr_t _endArg2;
  uintptr_t _endArg3;
  uintptr_t _endArg4;
};

/* 7493 */
struct libkern::intrusive_shared_ptr<IOGeneralMemoryDescriptor,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOGeneralMemoryDescriptor,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7492 */
struct __cppobj OSSharedPtr<IOGeneralMemoryDescriptor> : libkern::intrusive_shared_ptr<IOGeneralMemoryDescriptor,intrusive_osobject_retainer>
{
};

/* 7499 */
struct libkern::intrusive_shared_ptr<IOLittleMemoryCursor,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOLittleMemoryCursor,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7498 */
struct __cppobj OSSharedPtr<IOLittleMemoryCursor> : libkern::intrusive_shared_ptr<IOLittleMemoryCursor,intrusive_osobject_retainer>
{
};

/* 7501 */
struct libkern::intrusive_shared_ptr<IOBigMemoryCursor,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOBigMemoryCursor,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7500 */
struct __cppobj OSSharedPtr<IOBigMemoryCursor> : libkern::intrusive_shared_ptr<IOBigMemoryCursor,intrusive_osobject_retainer>
{
};

/* 7503 */
struct libkern::intrusive_shared_ptr<IONaturalMemoryCursor,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IONaturalMemoryCursor,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7502 */
struct __cppobj OSSharedPtr<IONaturalMemoryCursor> : libkern::intrusive_shared_ptr<IONaturalMemoryCursor,intrusive_osobject_retainer>
{
};

/* 7504 */
struct __cppobj OSSharedPtr<IOMemoryCursor> : libkern::intrusive_shared_ptr<IOMemoryCursor,intrusive_osobject_retainer>
{
};

/* 7505 */
struct __cppobj IOLittleMemoryCursor::MetaClass : OSMetaClass_0
{
};

/* 7507 */
struct __cppobj IOBigMemoryCursor::MetaClass : OSMetaClass_0
{
};

/* 7508 */
struct __cppobj IONaturalMemoryCursor::MetaClass : OSMetaClass_0
{
};

/* 7509 */
struct __cppobj IOMemoryCursor::MetaClass : OSMetaClass_0
{
};

/* 7514 */
struct __cppobj IOMapper::MetaClass : OSMetaClass_0
{
};

/* 7515 */
struct __cppobj IOMapperLock
{
  IOLock_0 *fWaitLock;
};

/* 7516 */
struct __cppobj IOInterleavedMemoryDescriptor::MetaClass : OSMetaClass_0
{
};

/* 7517 */
struct __cppobj __attribute__((aligned(8))) IOInterleavedMemoryDescriptor_0 : IOMemoryDescriptor_0
{
  IOByteCount_0 _descriptorCapacity;
  UInt32 _descriptorCount;
  IOMemoryDescriptor_0 **_descriptors;
  IOByteCount_0 *_descriptorOffsets;
  IOByteCount_0 *_descriptorLengths;
  bool _descriptorPrepared;
};

/* 7519 */
struct __cppobj IODMACommand::MetaClass : OSMetaClass_0
{
};

/* 7521 */
struct libkern::intrusive_shared_ptr<IOMapper,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOMapper,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7520 */
struct __cppobj OSSharedPtr<IOMapper> : libkern::intrusive_shared_ptr<IOMapper,intrusive_osobject_retainer>
{
};

/* 7523 */
struct libkern::intrusive_shared_ptr<IODMACommand,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IODMACommand,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7522 */
struct __cppobj OSSharedPtr<IODMACommand> : libkern::intrusive_shared_ptr<IODMACommand,intrusive_osobject_retainer>
{
};

/* 7528 */
struct libkern::intrusive_shared_ptr<IOBufferMemoryDescriptor,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOBufferMemoryDescriptor,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7526 */
struct __cppobj OSSharedPtr<IOBufferMemoryDescriptor> : libkern::intrusive_shared_ptr<IOBufferMemoryDescriptor,intrusive_osobject_retainer>
{
};

/* 7527 */
struct __cppobj IOBufferMemoryDescriptor::MetaClass : OSMetaClass_0
{
};

/* 7529 */
struct __cppobj IOTimerEventSource::MetaClass : OSMetaClass_0
{
};

/* 7531 */
struct libkern::intrusive_shared_ptr<IOFilterInterruptEventSource,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOFilterInterruptEventSource,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7530 */
struct __cppobj OSSharedPtr<IOFilterInterruptEventSource> : libkern::intrusive_shared_ptr<IOFilterInterruptEventSource,intrusive_osobject_retainer>
{
};

/* 7532 */
struct __cppobj IOFilterInterruptEventSource::MetaClass : OSMetaClass_0
{
};

/* 7536 */
struct libkern::intrusive_shared_ptr<IODMAEventSource,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IODMAEventSource,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7535 */
struct __cppobj OSSharedPtr<IODMAEventSource> : libkern::intrusive_shared_ptr<IODMAEventSource,intrusive_osobject_retainer>
{
};

/* 7537 */
struct __cppobj IODMAEventSource::MetaClass : OSMetaClass_0
{
};

/* 7541 */
struct libkern::intrusive_shared_ptr<IOCommand,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOCommand,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7543 */
struct libkern::intrusive_shared_ptr<IOCommandPool,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<IOCommandPool,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7542 */
struct __cppobj OSSharedPtr<IOCommandPool> : libkern::intrusive_shared_ptr<IOCommandPool,intrusive_osobject_retainer>
{
};

/* 7544 */
struct __cppobj IOCommandPool::MetaClass : OSMetaClass_0
{
};

/* 7545 */
struct __cppobj IOCommand::MetaClass : OSMetaClass_0
{
};

/* 7546 */
struct __cppobj OSSharedPtr<IOCommandGate> : libkern::intrusive_shared_ptr<IOCommandGate,intrusive_osobject_retainer>
{
};

/* 7547 */
struct __cppobj IOCommandGate::MetaClass : OSMetaClass_0
{
};

/* 7548 */
struct __cppobj IOInterruptEventSource::MetaClass : OSMetaClass_0
{
};

/* 7549 */
struct __cppobj IOEventSource::MetaClass : OSMetaClass_0
{
};

/* 7550 */
struct __cppobj IOWorkLoop::MetaClass : OSMetaClass_0
{
};

/* 7554 */
struct __cppobj IOPolledFilePollers::MetaClass : OSMetaClass_0
{
};

/* 7555 */
struct __cppobj IOPolledInterface::MetaClass : OSMetaClass_0
{
};

/* 7556 */
struct __cppobj IOPolledInterface : OSObject_1
{
  IOPolledInterface::ExpansionData *reserved;
};

/* 7558 */
struct IOPolledInterface::ExpansionData
{
  _BYTE gap0;
};

/* 7559 */
struct __cppobj IOPMGR::MetaClass : OSMetaClass_0
{
};

/* 7560 */
struct __cppobj IOPMPowerSourceList::MetaClass : OSMetaClass_0
{
};

/* 7561 */
struct __cppobj IOPMPowerSourceList_0 : OSObject_1
{
  IOPMPowerSource_0 *firstItem;
  unsigned __int64 length;
};

/* 7563 */
struct __cppobj IOPMPowerSource_0 : IOService_0
{
  bool settingsChangedSinceUpdate;
  OSDictionary_0 *properties;
  const OSSymbol_1 *externalConnectedKey;
  const OSSymbol_1 *externalChargeCapableKey;
  const OSSymbol_1 *batteryInstalledKey;
  const OSSymbol_1 *chargingKey;
  const OSSymbol_1 *warnLevelKey;
  const OSSymbol_1 *criticalLevelKey;
  const OSSymbol_1 *currentCapacityKey;
  const OSSymbol_1 *maxCapacityKey;
  const OSSymbol_1 *timeRemainingKey;
  const OSSymbol_1 *amperageKey;
  const OSSymbol_1 *voltageKey;
  const OSSymbol_1 *cycleCountKey;
  const OSSymbol_1 *adapterInfoKey;
  const OSSymbol_1 *locationKey;
  const OSSymbol_1 *errorConditionKey;
  const OSSymbol_1 *manufacturerKey;
  const OSSymbol_1 *modelKey;
  const OSSymbol_1 *serialKey;
  const OSSymbol_1 *batteryInfoKey;
  IOPMPowerSource_0 *nextInList;
};

/* 9464 */
struct __cppobj __attribute__((aligned(8))) OSString_1 : OSObject_1
{
  _BYTE gapC[8];
  _BYTE gap14[4];
};

/* 9465 */
struct __cppobj OSSymbol_1 : OSString_1
{
  smrq_slink hashlink;
};

/* 7562 */
struct __cppobj IOPMPowerSource::MetaClass : OSMetaClass_0
{
};

/* 7565 */
struct libkern::intrusive_shared_ptr<OSIterator,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSIterator,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7564 */
struct __cppobj OSSharedPtr<OSIterator> : libkern::intrusive_shared_ptr<OSIterator,intrusive_osobject_retainer>
{
};

/* 7567 */
struct __cppobj OSSharedPtr<IOCatalogue> : libkern::intrusive_shared_ptr<IOCatalogue,intrusive_osobject_retainer>
{
};

/* 7568 */
struct __cppobj IOCatalogue::MetaClass : OSMetaClass_1
{
};

/* 7570 */
struct __cppobj IOPMPowerStateQueue::MetaClass : OSMetaClass_0
{
};

/* 7571 */
struct IOPMPowerStateQueue::PowerEventEntry
{
  queue_chain_t_0 chain;
  uint32_t eventType;
  void *arg0;
  uint64_t arg1;
};

/* 7572 */
struct __cppobj IOPMinformeeList::MetaClass : OSMetaClass_0
{
};

/* 7573 */
struct __cppobj IOPMinformee::MetaClass : OSMetaClass_0
{
};

/* 7574 */
struct __cppobj IOServicePM::MetaClass : OSMetaClass_0
{
};

/* 7575 */
struct __cppobj IOPMCompletionQueue::MetaClass : OSMetaClass_0
{
};

/* 7576 */
struct __cppobj IOPMWorkQueue::MetaClass : OSMetaClass_0
{
};

/* 7577 */
struct __cppobj IOPMRequestQueue::MetaClass : OSMetaClass_0
{
};

/* 7578 */
struct __cppobj IOPMRequest::MetaClass : OSMetaClass_0
{
};

/* 7581 */
typedef kern_return_t (*IOCoreAnalyticsSendEventProc)(uint64_t, OSString_0 *, OSDictionary_0 *);

/* 7582 */
struct __cppobj IOServiceCompatibility::MetaClass : OSMetaClass_0
{
};

/* 7583 */
struct __cppobj IOServiceCompatibility : IOService_0
{
};

/* 7584 */
struct __cppobj IONotifier::MetaClass : OSMetaClass_1
{
};

/* 7585 */
struct __cppobj _IOServiceStateNotification::MetaClass : OSMetaClass_0
{
};

/* 7586 */
struct __cppobj _IOServiceStateNotification : IOService_0
{
  IOLock_0 *fLock;
  OSDictionary_0 *fItems;
};

/* 7587 */
struct __cppobj _IOOpenServiceIterator::MetaClass : OSMetaClass_0
{
};

/* 7588 */
struct __cppobj IOUserResources::MetaClass : OSMetaClass_0
{
};

/* 7589 */
struct __cppobj IOResources::MetaClass : OSMetaClass_0
{
};

/* 7590 */
struct __cppobj _IOServiceJob::MetaClass : OSMetaClass_0
{
};

/* 7591 */
struct __cppobj _IOConfigThread::MetaClass : OSMetaClass_0
{
};

/* 7592 */
struct __cppobj _IOServiceInterestNotifier::MetaClass : OSMetaClass_0
{
};

/* 7593 */
struct __cppobj _IOServiceNullNotifier::MetaClass : OSMetaClass_0
{
};

/* 7594 */
struct __cppobj _IOServiceNotifier::MetaClass : OSMetaClass_0
{
};

/* 7595 */
struct __cppobj IOService::MetaClass : OSMetaClass_1
{
};

/* 7596 */
struct __attribute__((aligned(8))) libkern::safe_allocation<char,os_detail::IOKit_typed_allocator<char,true>,os_detail::panic_trapping_policy>
{
  char *data_;
  uint32_t size_;
};

/* 7597 */
struct __cppobj _IOOpenServiceIterator : OSIterator_1
{
  OSIterator_0 *iter;
  const IOService_0 *client;
  const IOService_0 *provider;
  IOService_0 *last;
};

/* 7599 */
struct __cppobj IOUserResources : IOService_0
{
};

/* 7600 */
struct __cppobj IOResources : IOService_0
{
};

/* 7601 */
struct __cppobj __attribute__((aligned(8))) _IOConfigThread : OSObject_1
{
};

/* 7602 */
struct __cppobj __attribute__((aligned(8))) _IOServiceNullNotifier : IONotifier_0
{
};

/* 7605 */
struct __cppobj _IOServiceJob : OSObject_1
{
  int type;
  IOService_0 *nub;
  IOOptionBits_0 options;
};

/* 7606 */
struct __cppobj IORegistryIterator::MetaClass : OSMetaClass_0
{
};

/* 7607 */
struct __cppobj IORegistryPlane::MetaClass : OSMetaClass_0
{
};

/* 7608 */
struct __cppobj IORegistryEntry::MetaClass : OSMetaClass_1
{
};

/* 7611 */
typedef libkern::detail::copy_cv<char,char>::type libkern::detail::copy_cv_t<char,char>;

/* 7610 */
typedef libkern::detail::copy_cv_t<char,char> libkern::bounded_ptr<char,os_detail::panic_trapping_policy>::CharType;

/* 7609 */
struct libkern::bounded_ptr<char,os_detail::panic_trapping_policy>
{
  libkern::bounded_ptr<char,os_detail::panic_trapping_policy>::CharType *base_;
  uint32_t count_;
  int32_t offset_;
};

/* 7613 */
struct __cppobj IOConditionLock::MetaClass : OSMetaClass_0
{
};

/* 7614 */
struct __cppobj __attribute__((aligned(8))) IOConditionLock_0 : OSObject_1
{
  IOLock_0 *cond_interlock;
  volatile int condition;
  IOLock_0 *sleep_interlock;
  unsigned __int8 interruptible;
  volatile bool want_lock;
  volatile bool waiting;
};

/* 7615 */
typedef unsigned int IOAlignment;

/* 7616 */
struct __cppobj IOWorkGroup::MetaClass : OSMetaClass_0
{
};

/* 7618 */
struct __cppobj IOEventLink::MetaClass : OSMetaClass_0
{
};

/* 7620 */
struct __cppobj IOServiceStateNotificationDispatchSource::MetaClass : OSMetaClass_0
{
};

/* 7623 */
struct __cppobj IOServiceNotificationDispatchSource::MetaClass : OSMetaClass_0
{
};

/* 7626 */
struct __cppobj IODataQueueDispatchSource::MetaClass : OSMetaClass_0
{
};

/* 7630 */
struct __cppobj IOInterruptDispatchSource::MetaClass : OSMetaClass_0
{
};

/* 7632 */
struct __cppobj IODispatchQueue::MetaClass : OSMetaClass_0
{
};

/* 7633 */
struct __cppobj IODispatchSource::MetaClass : OSMetaClass_0
{
};

/* 7634 */
struct __cppobj OSAction_IOUserClient_KernelCompletion::MetaClass : OSMetaClass_0
{
};

/* 7635 */
struct __cppobj OSAction_IOUserClient_KernelCompletion : OSAction_0
{
  union
  {
    OSAction_IOUserClient_KernelCompletion_IVars *ivars;
    OSAction_IOUserClient_KernelCompletion_LocalIVars *lvars;
  };
};

/* 7636 */
struct __cppobj OSAction::MetaClass : OSMetaClass_0
{
};

/* 7637 */
typedef void (*registration_callback_t)(void);

/* 7643 */
typedef uintptr_t ptrauth_generic_signature_t;

/* 7658 */
typedef kern_return_t (*InKernelPerformSHA1Func)(void *, const void *, size_t, u_int32_t *, u_int32_t, u_int32_t *, Boolean);

/* 7660 */
typedef ccdigest_ctx_0 *ccdigest_ctx_t_1;

/* 7661 */
typedef crypto_functions *crypto_functions_t;

/* 7667 */
typedef unsigned int u4;

/* 7669 */
enum memory_order : __int32
{
  memory_order::memory_order_relaxed = 0x0,
  memory_order::memory_order_consume = 0x1,
  memory_order::memory_order_acquire = 0x2,
  memory_order::memory_order_release = 0x3,
  memory_order::memory_order_acq_rel = 0x4,
  memory_order::memory_order_seq_cst = 0x5,
};

/* 7670 */
struct segment_command_64_1
{
  uint32_t cmd;
  uint32_t cmdsize;
  char segname[16];
  uint64_t vmaddr;
  uint64_t vmsize;
  uint64_t fileoff;
  uint64_t filesize;
  vm_prot_t maxprot;
  vm_prot_t initprot;
  uint32_t nsects;
  uint32_t flags;
};

/* 7671 */
typedef struct *log_queue_t;

/* 7672 */
struct log_queue_s
{
  log_queue_list_s lq_log_list;
  log_queue_list_s lq_dispatch_list;
  logmem_t lq_mem[8];
  size_t lq_mem_set;
  size_t lq_mem_size;
  size_t lq_mem_size_order;
  __attribute__((aligned(16))) thread_call_t lq_mem_handler;
  size_t lq_cnt_mem_active;
  size_t lq_cnt_mem_avail;
  __attribute__((aligned(16))) void *lq_req_mem;
};

/* 7673 */
typedef os_log_fmt_range_s *os_log_fmt_range_t;

/* 7678 */
struct smr_hash_iterator
{
  smrq_slist_head *hd_next;
  smrq_slist_head *hd_last;
  __smrq_slink_t *prev;
  smrq_slink *link;
};

/* 7679 */
struct __cppobj OSSymbol::MetaClass : OSMetaClass_0
{
};

/* 7680 */
struct __attribute__((aligned(8))) smr_hash_array
{
  smrq_slist_head *smrh_array;
  uint16_t smrh_order;
};

/* 7681 */
struct __cppobj __attribute__((aligned(4))) OSSymbolPool
{
  lck_mtx_t _mutex;
  smr_hash _hash;
  smrq_slist_head _huge_head;
  thread_call_t _tcall;
  uint32_t _hugeCount;
  bool _tcallScheduled;
};

/* 7682 */
struct OSSymbolPool::hash_traits
{
  smrh_traits smrht;
};

/* 7683 */
struct __cppobj OSString::MetaClass : OSMetaClass_0
{
};

/* 7685 */
struct __cppobj OSSet::MetaClass : OSMetaClass_0
{
};

/* 7687 */
struct __cppobj OSSerializer::MetaClass : OSMetaClass_0
{
};

/* 7688 */
struct __cppobj OSSerialize::MetaClass : OSMetaClass_1
{
};

/* 7690 */
struct libkern::intrusive_shared_ptr<OSSerialize,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSSerialize,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7689 */
struct __cppobj OSSharedPtr<OSSerialize> : libkern::intrusive_shared_ptr<OSSerialize,intrusive_osobject_retainer>
{
};

/* 7692 */
struct __cppobj OSOrderedSet::MetaClass : OSMetaClass_0
{
};

/* 7693 */
struct __cppobj OSSharedPtr<OSNumber> : libkern::intrusive_shared_ptr<OSNumber,intrusive_osobject_retainer>
{
};

/* 7694 */
struct __cppobj OSNumber::MetaClass : OSMetaClass_0
{
};

/* 7697 */
struct libkern::intrusive_shared_ptr<OSDextCrash,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSDextCrash,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7696 */
struct __cppobj OSSharedPtr<OSDextCrash> : libkern::intrusive_shared_ptr<OSDextCrash,intrusive_osobject_retainer>
{
};

/* 7711 */
struct libkern::intrusive_shared_ptr<OSDextStatistics,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSDextStatistics,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7698 */
struct __cppobj OSSharedPtr<OSDextStatistics> : libkern::intrusive_shared_ptr<OSDextStatistics,intrusive_osobject_retainer>
{
};

/* 7700 */
struct libkern::intrusive_shared_ptr<OSValueObject<void (*)(unsigned int,int,const void *,unsigned int,void *)>,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSValueObject<void (*)(unsigned int,int,const void *,unsigned int,void *)>,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7699 */
struct __cppobj OSSharedPtr<OSValueObject<void (*)(unsigned int,int,const void *,unsigned int,void *)> > : libkern::intrusive_shared_ptr<OSValueObject<void (*)(unsigned int,int,const void *,unsigned int,void *)>,intrusive_osobject_retainer>
{
};

/* 7702 */
struct libkern::intrusive_shared_ptr<OSValueObject<void *>,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSValueObject<void *>,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7701 */
struct __cppobj OSSharedPtr<OSValueObject<void *> > : libkern::intrusive_shared_ptr<OSValueObject<void *>,intrusive_osobject_retainer>
{
};

/* 7703 */
struct __cppobj OSValueObject<void *>::MetaClass : OSMetaClass_0
{
};

/* 7704 */
struct __cppobj OSValueObject<void (*)(unsigned int,int,const void *,unsigned int,void *)>::MetaClass : OSMetaClass_0
{
};

/* 7705 */
struct __cppobj OSDextCrash::MetaClass : OSMetaClass_0
{
};

/* 7706 */
struct __cppobj OSDextStatistics::MetaClass : OSMetaClass_0
{
};

/* 7707 */
struct __cppobj OSKextSavedMutableSegment::MetaClass : OSMetaClass_0
{
};

/* 7708 */
struct __cppobj OSKext::MetaClass : OSMetaClass_0
{
};

/* 7709 */
struct libkern::intrusive_shared_ptr<OSObject,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSObject,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7710 */
struct __cppobj OSSharedPtr<OSKextSavedMutableSegment> : libkern::intrusive_shared_ptr<OSKextSavedMutableSegment,intrusive_osobject_retainer>
{
};

/* 7714 */
struct libkern::intrusive_shared_ptr<OSKext,intrusive_osobject_retainer>
{
  libkern::intrusive_shared_ptr<OSKext,intrusive_osobject_retainer>::pointer ptr_;
};

/* 7713 */
struct __cppobj OSSharedPtr<OSKext> : libkern::intrusive_shared_ptr<OSKext,intrusive_osobject_retainer>
{
};

/* 7715 */
struct kaslrPackedOffsets
{
  uint32_t count;
  uint32_t offsetsArray[];
};

/* 7720 */
struct __cppobj OSIterator::MetaClass : OSMetaClass_0
{
};

/* 7721 */
struct __cppobj OSDictionary::MetaClass : OSMetaClass_0
{
};

/* 7723 */
struct libkern::intrusive_shared_ptr<OSCollection,intrusive_tagged_osobject_retainer<OSCollection> >
{
  libkern::intrusive_shared_ptr<OSCollection,intrusive_tagged_osobject_retainer<OSCollection> >::pointer ptr_;
};

/* 7722 */
struct __cppobj OSTaggedSharedPtr<OSCollection,OSCollection> : libkern::intrusive_shared_ptr<OSCollection,intrusive_tagged_osobject_retainer<OSCollection> >
{
};

/* 7725 */
struct libkern::intrusive_shared_ptr<const OSSymbol,intrusive_tagged_osobject_retainer<OSCollection> >
{
  libkern::intrusive_shared_ptr<const OSSymbol,intrusive_tagged_osobject_retainer<OSCollection> >::pointer ptr_;
};

/* 7724 */
struct __cppobj OSTaggedSharedPtr<const OSSymbol,OSCollection> : libkern::intrusive_shared_ptr<const OSSymbol,intrusive_tagged_osobject_retainer<OSCollection> >
{
};

/* 7727 */
struct OSDictionary::dictEntry_0
{
  OSTaggedPtr<const OSSymbol> key;
  OSTaggedPtr<const OSMetaClassBase> value;
};

/* 7729 */
struct __cppobj OSData::MetaClass : OSMetaClass_1
{
};

/* 7730 */
struct __cppobj OSSharedPtr<OSCollectionIterator> : libkern::intrusive_shared_ptr<OSCollectionIterator,intrusive_osobject_retainer>
{
};

/* 7731 */
struct __cppobj OSCollectionIterator::MetaClass : OSMetaClass_0
{
};

/* 7734 */
struct __cppobj OSCollection::MetaClass : OSMetaClass_0
{
};

/* 7735 */
struct __cppobj OSBoolean::MetaClass : OSMetaClass_0
{
};

/* 7736 */
typedef OSTaggedSharedPtr<const OSMetaClassBase,OSCollection>_0 OSArray::ArraySharedPtrType;

/* 9197 */
typedef const OSMetaClassBase_0 *libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_tagged_osobject_retainer<OSCollection> >::pointer_0;

/* 9456 */
struct libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_tagged_osobject_retainer<OSCollection> >_0
{
  libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_tagged_osobject_retainer<OSCollection> >::pointer_0 ptr_;
};

/* 9457 */
struct __cppobj OSTaggedSharedPtr<const OSMetaClassBase,OSCollection>_0 : libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_tagged_osobject_retainer<OSCollection> >_0
{
};

/* 7738 */
struct __cppobj OSArray::MetaClass : OSMetaClass_0
{
};

/* 7740 */
struct libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_tagged_osobject_retainer<OSCollection> >
{
  libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_tagged_osobject_retainer<OSCollection> >::pointer ptr_;
};

/* 7739 */
struct __cppobj OSTaggedSharedPtr<const OSMetaClassBase,OSCollection> : libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_tagged_osobject_retainer<OSCollection> >
{
};

/* 9458 */
typedef OSTaggedSharedPtr<const OSMetaClassBase,OSCollection>_0 OSTaggedPtr<const OSMetaClassBase>_1;

/* 7741 */
typedef OSTaggedPtr<const OSMetaClassBase>_1 OSArray::ArrayPtrType_0;

/* 7742 */
struct __cppobj OSObject::MetaClass : OSMetaClass_1
{
};

/* 7744 */
struct __cppobj OSMetaClassMeta : OSMetaClass_0
{
};

/* 7746 */
typedef struct *OSActionAbortedHandler_0;

/* 7749 */
struct __attribute__((aligned(8))) IODeviceMemory::InitElement
{
  IOPhysicalAddress_0 start;
  IOPhysicalLength_0 length;
  IOOptionBits tag;
};

/* 7750 */
struct __cppobj IODeviceMemory::MetaClass : OSMetaClass_1
{
};

/* 7752 */
struct __attribute__((aligned(8))) componentname_0
{
  uint32_t cn_nameiop;
  uint32_t cn_flags;
  void *cn_reserved1;
  void *cn_reserved2;
  char *cn_pnbuf;
  int cn_pnlen;
  char *cn_nameptr;
  int cn_namelen;
  uint32_t cn_hash;
  uint32_t cn_consume;
};

/* 7753 */
typedef resolver_result_t (*trigger_vnode_resolve_callback_t_2)(vnode_t, const componentname_0 *, path_operation, int, void *, vfs_context_t);

/* 7769 */
struct IODMACommand::Segment32
{
  UInt32 fIOVMAddr;
  UInt32 fLength;
};

/* 7770 */
struct __attribute__((aligned(8))) IODMACommand::SegmentOptions_0
{
  uint8_t fStructSize;
  uint8_t fNumAddressBits;
  uint64_t fMaxSegmentSize;
  uint64_t fMaxTransferSize;
  uint32_t fAlignment;
  uint32_t fAlignmentLength;
  uint32_t fAlignmentInternalSegments;
};

/* 7775 */
typedef void (*OSData::DeallocFunction_1)(void *, unsigned int);

/* 7777 */
typedef IORPC_0 IORPC_1;

/* 7779 */
typedef SInt32 OSSpinLock;

/* 7780 */
typedef char SInt8;

/* 7806 */
struct user_sigframe64
{
  user64_siginfo_t sinfo;
  user_ucontext64 uctx;
  mcontext64_t mctx;
};

/* 7807 */
struct user_sigframe32
{
  user32_addr_t puctx;
  user32_addr_t token;
  user32_siginfo_t sinfo;
  user_ucontext32 uctx;
  mcontext32_t mctx;
};

/* 7813 */
struct __attribute__((aligned(8))) cdevsw_0
{
  open_close_fcn_t *d_open;
  open_close_fcn_t *d_close;
  read_write_fcn_t *d_read;
  read_write_fcn_t *d_write;
  ioctl_fcn_t *d_ioctl;
  stop_fcn_t *d_stop;
  reset_fcn_t *d_reset;
  tty **d_ttys;
  select_fcn_t *d_select;
  mmap_fcn_t *d_mmap;
  strategy_fcn_t *d_strategy;
  rsvd_fcn_t *d_reserved_1;
  rsvd_fcn_t *d_reserved_2;
  int d_type;
};

/* 7816 */
typedef uint32_t packet_csum_flags_t;

/* 7818 */
typedef uint32_t packet_flowid_t;

/* 7820 */
typedef errno_t (*nxprov_ring_init_fn_t_0)(kern_nexus_provider_t, kern_nexus_t, kern_channel_t, kern_channel_ring_t, boolean_t, void **);

/* 7821 */
typedef void (*nxprov_pre_disconnect_fn_t_0)(kern_nexus_provider_t, kern_nexus_t, kern_channel_t);

/* 7822 */
typedef errno_t (*nxprov_connected_fn_t_0)(kern_nexus_provider_t, kern_nexus_t, kern_channel_t);

/* 7823 */
typedef errno_t (*dlil_output_func_0)(ifnet_t, mbuf_t);

/* 7825 */
typedef const sk_protect *sk_protect_t;

/* 7826 */
typedef void (*nxprov_slot_fini_fn_t_0)(kern_nexus_provider_t, kern_nexus_t, kern_channel_ring_t, kern_channel_slot_t, uint32_t);

/* 7827 */
enum _netif_stats : __int32
{
  _netif_stats::NETIF_STATS_RX_PACKETS = 0x0,
  _netif_stats::NETIF_STATS_RX_IRQ = 0x1,
  _netif_stats::NETIF_STATS_RX_IRQ_MIT = 0x2,
  _netif_stats::NETIF_STATS_RX_IRQ_BUSY = 0x3,
  _netif_stats::NETIF_STATS_RX_IRQ_AGAIN = 0x4,
  _netif_stats::NETIF_STATS_RX_IRQ_ERR = 0x5,
  _netif_stats::NETIF_STATS_RX_COPY_SUM = 0x6,
  _netif_stats::NETIF_STATS_RX_COPY_DIRECT = 0x7,
  _netif_stats::NETIF_STATS_RX_COPY_MBUF = 0x8,
  _netif_stats::NETIF_STATS_RX_COPY_ATTACH = 0x9,
  _netif_stats::NETIF_STATS_RX_SYNC = 0xA,
  _netif_stats::NETIF_STATS_TX_PACKETS = 0xB,
  _netif_stats::NETIF_STATS_TX_IRQ = 0xC,
  _netif_stats::NETIF_STATS_TX_IRQ_MIT = 0xD,
  _netif_stats::NETIF_STATS_TX_IRQ_BUSY = 0xE,
  _netif_stats::NETIF_STATS_TX_IRQ_AGAIN = 0xF,
  _netif_stats::NETIF_STATS_TX_IRQ_ERR = 0x10,
  _netif_stats::NETIF_STATS_TX_COPY_SUM = 0x11,
  _netif_stats::NETIF_STATS_TX_COPY_DIRECT = 0x12,
  _netif_stats::NETIF_STATS_TX_COPY_MBUF = 0x13,
  _netif_stats::NETIF_STATS_TX_SYNC = 0x14,
  _netif_stats::NETIF_STATS_TX_REPL = 0x15,
  _netif_stats::NETIF_STATS_TX_DROP_ENQ_AQM = 0x16,
  _netif_stats::NETIF_STATS_GSO_SEG = 0x17,
  _netif_stats::NETIF_STATS_GSO_PKT = 0x18,
  _netif_stats::NETIF_STATS_GSO_PKT_DROP_NOMEM = 0x19,
  _netif_stats::NETIF_STATS_GSO_PKT_DROP_NA_INACTIVE = 0x1A,
  _netif_stats::NETIF_STATS_GSO_PKT_DROP_BADLEN = 0x1B,
  _netif_stats::NETIF_STATS_GSO_PKT_DROP_NONTCP = 0x1C,
  _netif_stats::NETIF_STATS_DROP = 0x1D,
  _netif_stats::NETIF_STATS_DROP_NOMEM_BUF = 0x1E,
  _netif_stats::NETIF_STATS_DROP_NOMEM_PKT = 0x1F,
  _netif_stats::NETIF_STATS_DROP_NOMEM_MBUF = 0x20,
  _netif_stats::NETIF_STATS_DROP_BADLEN = 0x21,
  _netif_stats::NETIF_STATS_DROP_NA_INACTIVE = 0x22,
  _netif_stats::NETIF_STATS_DROP_KRDROP_MODE = 0x23,
  _netif_stats::NETIF_STATS_DROP_RXQ_OVFL = 0x24,
  _netif_stats::NETIF_STATS_DROP_NO_RX_CB = 0x25,
  _netif_stats::NETIF_STATS_EV_SENT = 0x26,
  _netif_stats::NETIF_STATS_EV_DROP = 0x27,
  _netif_stats::NETIF_STATS_EV_DROP_NOMEM_PKT = 0x28,
  _netif_stats::NETIF_STATS_EV_DROP_NA_INACTIVE = 0x29,
  _netif_stats::NETIF_STATS_EV_DROP_NA_DEFUNCT = 0x2A,
  _netif_stats::NETIF_STATS_EV_DROP_KRDROP_MODE = 0x2B,
  _netif_stats::NETIF_STATS_EV_DROP_KEVENT_INACTIVE = 0x2C,
  _netif_stats::NETIF_STATS_EV_DROP_KRSPACE = 0x2D,
  _netif_stats::NETIF_STATS_EV_DROP_DEMUX_ERR = 0x2E,
  _netif_stats::NETIF_STATS_EV_DROP_EV_VPNA_NOTSUP = 0x2F,
  _netif_stats::NETIF_STATS_EV_DROP_NO_VPNA = 0x30,
  _netif_stats::NETIF_STATS_IF_ADV_UPD_RECV = 0x31,
  _netif_stats::NETIF_STATS_IF_ADV_UPD_SENT = 0x32,
  _netif_stats::NETIF_STATS_IF_ADV_UPD_DROP = 0x33,
  _netif_stats::NETIF_STATS_FILTER_DROP_NO_RX_CB = 0x34,
  _netif_stats::NETIF_STATS_FILTER_DROP_DISABLED = 0x35,
  _netif_stats::NETIF_STATS_FILTER_DROP_REMOVED = 0x36,
  _netif_stats::NETIF_STATS_FILTER_DROP_PKTQ_FULL = 0x37,
  _netif_stats::NETIF_STATS_FILTER_DROP_MBQ_FULL = 0x38,
  _netif_stats::NETIF_STATS_FILTER_DROP_DISABLED_RING = 0x39,
  _netif_stats::NETIF_STATS_FILTER_DROP_NO_SPACE = 0x3A,
  _netif_stats::NETIF_STATS_FILTER_DROP_INTERNALIZE = 0x3B,
  _netif_stats::NETIF_STATS_FILTER_DROP_PKT_ALLOC_FAIL = 0x3C,
  _netif_stats::NETIF_STATS_FILTER_DROP_DEFAULT = 0x3D,
  _netif_stats::NETIF_STATS_FILTER_PKT_TRUNCATED = 0x3E,
  _netif_stats::NETIF_STATS_FILTER_TX_DELIVER = 0x3F,
  _netif_stats::NETIF_STATS_FILTER_RX_DELIVER = 0x40,
  _netif_stats::NETIF_STATS_FILTER_TX_INJECT = 0x41,
  _netif_stats::NETIF_STATS_FILTER_RX_INJECT = 0x42,
  _netif_stats::NETIF_STATS_FILTER_TX_ENTER = 0x43,
  _netif_stats::NETIF_STATS_FILTER_RX_ENTER = 0x44,
  _netif_stats::NETIF_STATS_FILTER_TX_EXIT = 0x45,
  _netif_stats::NETIF_STATS_FILTER_RX_EXIT = 0x46,
  _netif_stats::NETIF_STATS_FILTER_SYNC_NO_PKTS = 0x47,
  _netif_stats::NETIF_STATS_FILTER_ADD = 0x48,
  _netif_stats::NETIF_STATS_FILTER_REMOVE = 0x49,
  _netif_stats::NETIF_STATS_FILTER_TX_FLUSH = 0x4A,
  _netif_stats::NETIF_STATS_FILTER_RX_NOT_FILTERABLE = 0x4B,
  _netif_stats::NETIF_STATS_FILTER_BAD_PKT_LEN = 0x4C,
  _netif_stats::NETIF_STATS_VP_DROP_USER_RING_DISABLED = 0x4D,
  _netif_stats::NETIF_STATS_VP_DROP_DEV_RING_DISABLED = 0x4E,
  _netif_stats::NETIF_STATS_VP_DROP_USER_RING_NO_SPACE = 0x4F,
  _netif_stats::NETIF_STATS_VP_DROP_DEV_RING_NO_SPACE = 0x50,
  _netif_stats::NETIF_STATS_VP_DROP_RX_ALLOC_FAIL = 0x51,
  _netif_stats::NETIF_STATS_VP_DROP_TX_ALLOC_FAIL = 0x52,
  _netif_stats::NETIF_STATS_VP_DROP_PKT_TOO_BIG = 0x53,
  _netif_stats::NETIF_STATS_VP_DROP_INTERNALIZE_FAIL = 0x54,
  _netif_stats::NETIF_STATS_VP_DROP_UNEXPECTED_ERR = 0x55,
  _netif_stats::NETIF_STATS_VP_BAD_MADDR_LEN = 0x56,
  _netif_stats::NETIF_STATS_VP_BAD_MADDR = 0x57,
  _netif_stats::NETIF_STATS_VP_BAD_PKT_LEN = 0x58,
  _netif_stats::NETIF_STATS_VP_FLOW_INFO_ERR = 0x59,
  _netif_stats::NETIF_STATS_VP_FLOW_NOT_MATCH = 0x5A,
  _netif_stats::NETIF_STATS_VP_KR_ENTER_FAIL = 0x5B,
  _netif_stats::NETIF_STATS_VP_DEV_RING_DISABLED = 0x5C,
  _netif_stats::NETIF_STATS_VP_SYNC_UNKNOWN_ERR = 0x5D,
  _netif_stats::NETIF_STATS_VP_SYNC_NO_PKTS = 0x5E,
  _netif_stats::NETIF_STATS_VP_SPURIOUS_NOTIFY = 0x5F,
  _netif_stats::NETIF_STATS_VP_ENQUEUE_FAILED = 0x60,
  _netif_stats::NETIF_STATS_VP_ENQUEUED = 0x61,
  _netif_stats::NETIF_STATS_VP_LL_ENQUEUED = 0x62,
  _netif_stats::NETIF_STATS_VP_LL_SENT = 0x63,
  _netif_stats::NETIF_STATS_VP_LL_DELIVERED = 0x64,
  _netif_stats::NETIF_STATS_VP_DELIVERED = 0x65,
  _netif_stats::NETIF_STATS_VP_FLOW_FOUND = 0x66,
  _netif_stats::NETIF_STATS_VP_FLOW_NOT_FOUND = 0x67,
  _netif_stats::NETIF_STATS_VP_FLOW_DISABLED = 0x68,
  _netif_stats::NETIF_STATS_VP_FLOW_EMPTY_TABLE = 0x69,
  _netif_stats::NETIF_STATS_VP_FLOW_TABLE_INIT_FAIL = 0x6A,
  _netif_stats::NETIF_STATS_VP_FLOW_INSERT_FAIL = 0x6B,
  _netif_stats::NETIF_STATS_VP_FLOW_ADD = 0x6C,
  _netif_stats::NETIF_STATS_VP_FLOW_REMOVE = 0x6D,
  _netif_stats::NETIF_STATS_AGENT_BAD_ETHERTYPE = 0x6E,
  _netif_stats::NETIF_STATS_AGENT_BAD_IPV6_ADDR = 0x6F,
  _netif_stats::NETIF_STATS_AGENT_DUP_FLOW = 0x70,
  _netif_stats::NETIF_STATS_LLINK_ADD = 0x71,
  _netif_stats::NETIF_STATS_LLINK_REMOVE = 0x72,
  _netif_stats::NETIF_STATS_LLINK_DEF_QSET_USED = 0x73,
  _netif_stats::NETIF_STATS_LLINK_NONDEF_QSET_USED = 0x74,
  _netif_stats::NETIF_STATS_LLINK_HINT_NOT_USEFUL = 0x75,
  _netif_stats::NETIF_STATS_LLINK_DUP_INT_ID_GENERATED = 0x76,
  _netif_stats::NETIF_STATS_LLINK_DUP_ID_GIVEN = 0x77,
  _netif_stats::NETIF_STATS_LLINK_QSET_INIT_FAIL = 0x78,
  _netif_stats::NETIF_STATS_LLINK_RXQ_INIT_FAIL = 0x79,
  _netif_stats::NETIF_STATS_LLINK_TXQ_INIT_FAIL = 0x7A,
  _netif_stats::NETIF_STATS_LLINK_NOT_FOUND_REMOVE = 0x7B,
  _netif_stats::NETIF_STATS_LLINK_TX_DROP_BAD_STATE = 0x7C,
  _netif_stats::NETIF_STATS_LLINK_RX_DROP_BAD_STATE = 0x7D,
  _netif_stats::NETIF_STATS_LLINK_AQM_QFULL = 0x7E,
  _netif_stats::NETIF_STATS_LLINK_AQM_DROPPED = 0x7F,
  _netif_stats::NETIF_STATS_LLINK_AQM_DEQ_BAD_STATE = 0x80,
  _netif_stats::NETIF_STATS_LLINK_QSET_BAD_STATE = 0x81,
  _netif_stats::NETIF_STATS_LLINK_ADD_BAD_PARAMS = 0x82,
  _netif_stats::__NETIF_STATS_MAX = 0x83,
};

/* 7829 */
typedef errno_t (*nxdom_prov_init_fn_t_0)(kern_nexus_domain_provider_t);

/* 7830 */
struct kern_nexus_domain_provider_init_0
{
  uint32_t nxdpi_version;
  uint32_t nxdpi_flags;
  nxdom_prov_init_fn_t_0 nxdpi_init;
  nxdom_prov_fini_fn_t nxdpi_fini;
};

/* 7831 */
struct flow_mgr_tree
{
  flow_mgr *rbh_root;
};

/* 7832 */
typedef errno_t (*nxprov_pre_connect_fn_t_0)(kern_nexus_provider_t, proc_t, kern_nexus_t, nexus_port_t, kern_channel_t, void **);

/* 7833 */
struct kern_nexus_tree
{
  kern_nexus *rbh_root;
};

/* 7837 */
struct ch_event_result
{
  uint32_t tx_data;
  uint32_t rx_data;
};

/* 7838 */
struct sk_tag_spec
{
  kern_allocation_name_t *skt_var;
  const char *skt_name;
};

/* 7839 */
struct protons_token_tree
{
  protons_token *rbh_root;
};

/* 7840 */
struct netns_namespaces_tree
{
  ns *rbh_root;
};

/* 7841 */
typedef void (*ifnet_start_func_0)(ifnet_t);

/* 7842 */
typedef errno_t (*dlil_output_func_1)(ifnet_t, mbuf_t);

/* 7843 */
typedef errno_t (*ifnet_del_proto_func_0)(ifnet_t, protocol_family_t);

/* 7844 */
typedef errno_t (*ifnet_add_proto_func_0)(ifnet_t, protocol_family_t, const ifnet_demux_desc *, u_int32_t);

/* 7845 */
typedef void (*ifnet_event_func_0)(ifnet_t, const kev_msg *);

/* 7846 */
typedef errno_t (*ifnet_demux_func_1)(ifnet_t, mbuf_t, char *, protocol_family_t *);

/* 7847 */
typedef errno_t (*ifnet_set_bpf_tap_0)(ifnet_t, bpf_tap_mode, bpf_packet_func);

/* 7848 */
typedef errno_t (*ifnet_ioctl_func_0)(ifnet_t, unsigned __int64, void *);

/* 7849 */
typedef errno_t (*ifnet_ctl_func_0)(ifnet_t, ifnet_ctl_cmd_t, u_int32_t, void *);

/* 7851 */
typedef resolver_result_t (*trigger_vnode_unresolve_callback_t_1)(vnode_t, int, void *, vfs_context_t);

/* 7852 */
typedef resolver_result_t (*trigger_vnode_resolve_callback_t_3)(vnode_t, const componentname *, path_operation, int, void *, vfs_context_t);

/* 7854 */
typedef resolver_result_t (*trigger_vnode_resolve_callback_t_4)(vnode_t, const componentname *, path_operation, int, void *, vfs_context_t);

/* 7857 */
struct _dk_cs_unmap
{
  dk_extent_t *extents;
  uint32_t extentsCount;
  uint32_t options;
};

/* 7858 */
typedef void (*ifnet_event_func_1)(ifnet_t, const kev_msg *);

/* 7859 */
typedef bool (*soflow_feat_detach_db_func)(socket *, soflow_db *);

/* 7860 */
typedef bool (*soflow_feat_detach_entry_func)(socket *, soflow_hash_entry *);

/* 7861 */
typedef bool (*soflow_feat_gc_perform_func)(socket *, soflow_hash_entry *);

/* 7862 */
typedef bool (*soflow_feat_gc_needed_func)(socket *, soflow_hash_entry *, u_int64_t);

/* 7864 */
struct __attribute__((aligned(8))) tracker_db
{
  trackerhashhead *tracker_hashbase;
  u_long tracker_hashmask;
  uint32_t tracker_count;
  uint32_t tracker_count_short;
  uint32_t max_link_count;
};

/* 7867 */
struct proc_policy_cpuusage_attr
{
  uint32_t ppattr_cpu_attr;
  uint32_t ppattr_cpu_percentage;
  uint64_t ppattr_cpu_attr_interval;
  uint64_t ppattr_cpu_attr_deadline;
};

/* 7868 */
struct proc_threadschedinfo
{
  uint64_t int_time_ns;
};

/* 7869 */
struct proc_ipctableinfo
{
  uint32_t table_size;
  uint32_t table_free;
};

/* 7870 */
struct proc_exitreasonbasicinfo
{
  uint32_t beri_namespace;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t beri_code;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t beri_flags;
  uint32_t beri_reason_buf_size;
};

/* 7871 */
struct proc_exitreasoninfo
{
  uint32_t eri_namespace;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t eri_code;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t eri_flags;
  uint32_t eri_reason_buf_size;
  uint64_t eri_kcd_buf;
};

/* 7872 */
struct proc_pidcoalitioninfo
{
  uint64_t coalition_id[2];
  uint64_t reserved1;
  uint64_t reserved2;
  uint64_t reserved3;
};

/* 7873 */
struct proc_archinfo
{
  cpu_type_t p_cputype;
  cpu_subtype_t_0 p_cpusubtype;
};

/* 7876 */
struct proc_threadinfo
{
  uint64_t pth_user_time;
  uint64_t pth_system_time;
  int32_t pth_cpu_usage;
  int32_t pth_policy;
  int32_t pth_run_state;
  int32_t pth_flags;
  int32_t pth_sleep_time;
  int32_t pth_curpri;
  int32_t pth_priority;
  int32_t pth_maxpriority;
  char pth_name[64];
};

/* 7874 */
struct proc_threadwithpathinfo
{
  proc_threadinfo pt;
  vnode_info_path pvip;
};

/* 7875 */
struct proc_regioninfo
{
  uint32_t pri_protection;
  uint32_t pri_max_protection;
  uint32_t pri_inheritance;
  uint32_t pri_flags;
  uint64_t pri_offset;
  uint32_t pri_behavior;
  uint32_t pri_user_wired_count;
  uint32_t pri_user_tag;
  uint32_t pri_pages_resident;
  uint32_t pri_pages_shared_now_private;
  uint32_t pri_pages_swapped_out;
  uint32_t pri_pages_dirtied;
  uint32_t pri_ref_count;
  uint32_t pri_shadow_depth;
  uint32_t pri_share_mode;
  uint32_t pri_private_pages_resident;
  uint32_t pri_shared_pages_resident;
  uint32_t pri_obj_id;
  uint32_t pri_depth;
  uint64_t pri_address;
  uint64_t pri_size;
};

/* 7877 */
struct proc_taskinfo
{
  uint64_t pti_virtual_size;
  uint64_t pti_resident_size;
  uint64_t pti_total_user;
  uint64_t pti_total_system;
  uint64_t pti_threads_user;
  uint64_t pti_threads_system;
  int32_t pti_policy;
  int32_t pti_faults;
  int32_t pti_pageins;
  int32_t pti_cow_faults;
  int32_t pti_messages_sent;
  int32_t pti_messages_received;
  int32_t pti_syscalls_mach;
  int32_t pti_syscalls_unix;
  int32_t pti_csw;
  int32_t pti_threadnum;
  int32_t pti_numrunning;
  int32_t pti_priority;
};

/* 7878 */
struct proc_bsdshortinfo
{
  uint32_t pbsi_pid;
  uint32_t pbsi_ppid;
  uint32_t pbsi_pgid;
  uint32_t pbsi_status;
  char pbsi_comm[16];
  uint32_t pbsi_flags;
  uid_t pbsi_uid;
  gid_t pbsi_gid;
  uid_t pbsi_ruid;
  gid_t pbsi_rgid;
  uid_t pbsi_svuid;
  gid_t pbsi_svgid;
  uint32_t pbsi_rfu;
};

/* 7879 */
struct proc_bsdinfo
{
  uint32_t pbi_flags;
  uint32_t pbi_status;
  uint32_t pbi_xstatus;
  uint32_t pbi_pid;
  uint32_t pbi_ppid;
  uid_t pbi_uid;
  gid_t pbi_gid;
  uid_t pbi_ruid;
  gid_t pbi_rgid;
  uid_t pbi_svuid;
  gid_t pbi_svgid;
  uint32_t rfu_1;
  char pbi_comm[16];
  char pbi_name[32];
  uint32_t pbi_nfiles;
  uint32_t pbi_pgid;
  uint32_t pbi_pjobc;
  uint32_t e_tdev;
  uint32_t e_tpgid;
  int32_t pbi_nice;
  uint64_t pbi_start_tvsec;
  uint64_t pbi_start_tvusec;
};

/* 7880 */
struct proc_uniqidentifierinfo
{
  uint8_t p_uuid[16];
  uint64_t p_uniqueid;
  uint64_t p_puniqueid;
  int32_t p_idversion;
  uint32_t p_reserve2;
  uint64_t p_reserve3;
  uint64_t p_reserve4;
};

/* 7881 */
struct fileport_info_args
{
  int fia_flavor;
  user_addr_t_0 fia_buffer;
  uint32_t fia_buffersize;
  int32_t *fia_retval;
};

/* 7882 */
struct proc_terminate_all_rsr_struct
{
  int ptss_sig;
  int32_t *ptss_retval;
};

/* 7883 */
struct pshmhead
{
  internal_pshminfo *rbh_root;
};

/* 7884 */
struct section_64_1
{
  char sectname[16];
  char segname[16];
  uint64_t addr;
  uint64_t size;
  uint32_t offset;
  uint32_t align;
  uint32_t reloff;
  uint32_t nreloc;
  uint32_t flags;
  uint32_t reserved1;
  uint32_t reserved2;
  uint32_t reserved3;
};

/* 7885 */
typedef user_msghdr_x *user_msghdr_x_ptr_t;

/* 7886 */
typedef void *void_ptr_t;

/* 7888 */
typedef recv_msg_elem *recv_msg_elem_ptr_t;

/* 7889 */
typedef sockaddr *sockaddr_ref_t;

/* 7890 */
typedef uio **uio_ref_ptr_t;

/* 7891 */
enum mbuf_traffic_class_t : __int32
{
  MBUF_TC_UNSPEC = 0xFFFFFFFF,
  MBUF_TC_BE = 0x0,
  MBUF_TC_BK = 0x1,
  MBUF_TC_VI = 0x2,
  MBUF_TC_VO = 0x3,
  MBUF_TC_MAX = 0x4,
};

/* 7893 */
struct mbuf_mtypes_t
{
  unsigned int cpu_mtypes[32];
};

/* 7902 */
typedef const domain_unguard *domain_unguard_t;

/* 7903 */
typedef const domain_guard *domain_guard_t;

/* 7907 */
typedef uint32_t uint_fast32_t;

/* 7910 */
struct ulock_wait2_args
{
  uint32_t operation;
  char operation_r_[4];
  user_addr_t_0 addr;
  uint64_t value;
  uint64_t timeout;
  uint64_t value2;
  char value2_r_[];
};

/* 7911 */
struct kpersona_info
{
  uint32_t persona_info_version;
  uid_t persona_id;
  int persona_type;
  gid_t persona_gid;
  uint32_t persona_ngroups;
  gid_t persona_groups[16];
  uid_t persona_gmuid;
  char persona_name[256];
  uid_t persona_uid;
};

/* 7912 */
struct snprintf_arg
{
  char *str;
  size_t remain;
};

/* 7913 */
struct __attribute__((aligned(8))) putchar_args
{
  int flags;
  tty *tty;
  bool last_char_was_cr;
};

/* 7914 */
struct log_cache_t
{
  uint8_t *lc_buf;
  uint8_t *lc_blk;
  size_t lc_blk_count;
  size_t lc_blk_pos;
  log_stream_t *lc_stream;
  size_t lc_stream_pos;
};

/* 7915 */
struct log_stream_si_t
{
  lck_spin_t lsi_lock;
  _BYTE gap10[8];
  selinfo lsi_selinfo;
  void *lsi_channel;
};

/* 7920 */
struct stackshot_stats
{
  uint64_t ss_last_start;
  uint64_t ss_last_end;
  uint64_t ss_count;
  uint64_t ss_duration;
};

/* 7921 */
enum stackshot_progress : __int32
{
  stackshot_progress::STACKSHOT_NOT_ROOT = 0x52,
  stackshot_progress::STACKSHOT_NOT_ENTITLED = 0x45,
  stackshot_progress::STACKSHOT_PERMITTED = 0x50,
  stackshot_progress::STACKSHOT_ATTEMPTED = 0x41,
  stackshot_progress::STACKSHOT_SUCCEEDED = 0x53,
};

/* 7922 */
struct _img4_cstr_0
{
  size_t i4cs_len;
  char i4cs_cstr[64];
};

/* 7923 */
typedef void *(*img4_runtime_alloc_t_0)(const img4_runtime_t *, size_t);

/* 7924 */
typedef void (*img4_runtime_dealloc_t_0)(const img4_runtime_t *, void *, size_t);

/* 7925 */
typedef uint32_t code_signing_config_t;

/* 7926 */
typedef uint32_t code_signing_monitor_type_t;

/* 7930 */
enum vm_pressure_level : __int32
{
  vm_pressure_level::kVMPressureNormal = 0x0,
  vm_pressure_level::kVMPressureWarning = 0x1,
  vm_pressure_level::kVMPressureUrgent = 0x2,
  vm_pressure_level::kVMPressureCritical = 0x3,
  vm_pressure_level::kVMPressureJetsam = 0x4,
};

/* 7928 */
typedef vm_pressure_level vm_pressure_level_t;

/* 7929 */
struct _ca_event_memorystatus_pressure_interval
{
  unsigned __int64 num_processes_registered;
  unsigned __int64 num_notifications_sent;
  unsigned __int64 max_level;
  unsigned __int64 num_transitions;
  unsigned __int64 num_kills;
  unsigned __int64 duration;
};

/* 7931 */
struct memorystatus_priority_properties
{
  int32_t priority;
  uint64_t user_data;
};

/* 7932 */
struct vm_statistics64
{
  natural_t free_count;
  natural_t active_count;
  natural_t inactive_count;
  natural_t wire_count;
  uint64_t zero_fill_count;
  uint64_t reactivations;
  uint64_t pageins;
  uint64_t pageouts;
  uint64_t faults;
  uint64_t cow_faults;
  uint64_t lookups;
  uint64_t hits;
  uint64_t purges;
  natural_t purgeable_count;
  natural_t speculative_count;
  uint64_t decompressions;
  uint64_t compressions;
  uint64_t swapins;
  uint64_t swapouts;
  natural_t compressor_page_count;
  natural_t throttled_count;
  natural_t external_page_count;
  natural_t internal_page_count;
  uint64_t total_uncompressed_pages_in_compressor;
};

/* 7934 */
typedef memorystatus_internal_properties memorystatus_internal_properties_t;

/* 7935 */
struct __attribute__((aligned(8))) memorystatus_internal_properties
{
  proc_t proc;
  int32_t priority;
};

/* 7938 */
struct sysctl_oid_iterator
{
  sysctl_oid_0 *a;
  sysctl_oid_0 *b;
};

/* 7939 */
struct sysdoproc_args
{
  size_t buflen;
  void *kprocp;
  boolean_t is_64_bit;
  user_addr_t_0 dp;
  size_t needed;
  unsigned int sizeof_kproc;
  int *errorp;
  int uidcheck;
  int ruidcheck;
  int ttycheck;
  int uidval;
};

/* 7940 */
typedef void *event_t;

/* 7943 */
typedef kcdata_iter kcdata_iter_t;

/* 7944 */
struct __mac_execve_args
{
  user_addr_t_0 fname;
  user_addr_t_0 argp;
  user_addr_t_0 envp;
  user_addr_t_0 mac_p;
  char mac_p_r_[];
};

/* 7945 */
struct user__posix_spawn_args_desc
{
  user_size_t attr_size;
  user_addr_t_0 attrp;
  user_size_t file_actions_size;
  user_addr_t_0 file_actions;
  user_size_t port_actions_size;
  user_addr_t_0 port_actions;
  user_size_t mac_extensions_size;
  user_addr_t_0 mac_extensions;
  user_size_t coal_info_size;
  user_addr_t_0 coal_info;
  user_size_t persona_info_size;
  user_addr_t_0 persona_info;
  user_size_t posix_cred_info_size;
  user_addr_t_0 posix_cred_info;
  user_size_t subsystem_root_path_size;
  user_addr_t_0 subsystem_root_path;
};

/* 7946 */
struct __attribute__((aligned(8))) exec_copyout_strings::copyout_desc
{
  char *start_string;
  int count;
  user_addr_t_0 *dtrace_cookie;
  boolean_t null_term;
};

/* 7947 */
struct execve_args
{
  user_addr_t_0 fname;
  user_addr_t_0 argp;
  user_addr_t_0 envp;
  char envp_r_[];
};

/* 7951 */
enum kqwl_unbind_locked_mode : __int32
{
  kqwl_unbind_locked_mode::KQWL_OVERRIDE_DROP_IMMEDIATELY = 0x0,
  kqwl_unbind_locked_mode::KQWL_OVERRIDE_DROP_DELAYED = 0x1,
};

/* 7952 */
typedef workq_threadreq_param_s workq_threadreq_param_t;

/* 7954 */
union workq_threadreq_param_s
{
  struct __attribute__((aligned(8)))
  {
    uint16_t trp_flags;
    uint8_t trp_pri;
    uint8_t trp_pol;
  };
  uint64_t trp_value;
};

/* 7953 */
enum kqlocking : __int32
{
  kqlocking::KNOTE_KQ_LOCK_ALWAYS = 0x0,
  kqlocking::KNOTE_KQ_LOCK_ON_SUCCESS = 0x1,
  kqlocking::KNOTE_KQ_LOCK_ON_FAILURE = 0x2,
  kqlocking::KNOTE_KQ_UNLOCK = 0x3,
};

/* 7955 */
struct __attribute__((aligned(8))) gfp_crarg
{
  guardid_t gca_guard;
  uint16_t gca_attrs;
};

/* 7956 */
struct cp_key
{
  uint8_t len;
  void *key;
};

/* 7957 */
struct fgetsigsinfo
{
  off_t fg_file_start;
  int fg_info_request;
  int fg_sig_is_platform;
};

/* 7958 */
struct fchecklv
{
  off_t lv_file_start;
  size_t lv_error_message_size;
  void *lv_error_message;
};

/* 7959 */
struct fspecread
{
  unsigned int fsr_flags;
  unsigned int reserved;
  off_t fsr_offset;
  off_t fsr_length;
};

/* 7960 */
struct ftrimactivefile
{
  off_t fta_offset;
  off_t fta_length;
};

/* 7961 */
struct fpunchhole
{
  unsigned int fp_flags;
  unsigned int reserved;
  off_t fp_offset;
  off_t fp_length;
};

/* 7962 */
struct fstore
{
  unsigned int fst_flags;
  int fst_posmode;
  off_t fst_offset;
  off_t fst_length;
  off_t fst_bytesalloc;
};

/* 7963 */
struct _dk_cs_pin
{
  dk_extent_t cp_extent;
  int64_t cp_flags;
};

/* 7964 */
typedef uint32_t csr_config_t;

/* 7965 */
struct addrable_bits_note
{
  uint32_t version;
  uint32_t addressing_bits;
  uint64_t unused;
};

/* 7966 */
typedef aio_workq *aio_workq_t;

/* 7967 */
typedef u_int16_t comp_t;

/* 7968 */
struct kd_resolver
{
  kd_threadmap *krs_map;
  vm_size_t_0 krs_count;
  vm_size_t_0 krs_maxcount;
};

/* 7969 */
struct kd_regtype
{
  unsigned int type;
  unsigned int value1;
  unsigned int value2;
  unsigned int value3;
  unsigned int value4;
};

/* 7970 */
typedef uint8_t *typefilter_t;

/* 7971 */
enum kdebug_opts : __int32
{
  kdebug_opts::KDOPT_WRAPPING = 0x1,
  kdebug_opts::KDOPT_ATBOOT = 0x2,
};

/* 7974 */
typedef resolver_result_t (*trigger_vnode_unresolve_callback_t_2)(vnode_t, int, void *, vfs_context_t);

/* 7975 */
typedef resolver_result_t (*trigger_vnode_resolve_callback_t_5)(vnode_t, const componentname *, path_operation, int, void *, vfs_context_t);

/* 7976 */
struct workq_usec_var
{
  uint32_t usecs;
  uint64_t abstime;
};

/* 7977 */
typedef thread_qos_policy thread_qos_policy_data_t;

/* 7978 */
enum workq_set_self_flags : __int32
{
  workq_set_self_flags::WORKQ_SET_SELF_QOS_FLAG = 0x1,
  workq_set_self_flags::WORKQ_SET_SELF_VOUCHER_FLAG = 0x2,
  workq_set_self_flags::WORKQ_SET_SELF_FIXEDPRIORITY_FLAG = 0x4,
  workq_set_self_flags::WORKQ_SET_SELF_TIMESHARE_FLAG = 0x8,
  workq_set_self_flags::WORKQ_SET_SELF_WQ_KEVENT_UNBIND = 0x10,
  workq_set_self_flags::WORKQ_SET_SELF_ALTERNATE_AMX = 0x20,
  workq_set_self_flags::WORKQ_SET_SELF_QOS_OVERRIDE_FLAG = 0x40,
};

/* 7979 */
typedef const pthread_callbacks_s *pthread_callbacks_t;

/* 7980 */
typedef const pthread_functions_s *pthread_functions_t;

/* 7982 */
typedef resolver_result_t (*trigger_vnode_unresolve_callback_t_3)(vnode_t, int, void *, vfs_context_t);

/* 7983 */
typedef resolver_result_t (*trigger_vnode_resolve_callback_t_6)(vnode_t, const componentname *, path_operation, int, void *, vfs_context_t);

/* 7984 */
struct fileops_0
{
  file_type_t fo_type;
  int (*fo_read)(fileproc *, uio *, int, vfs_context_t);
  int (*fo_write)(fileproc *, uio *, int, vfs_context_t);
  int (*fo_ioctl)(fileproc *, u_long, caddr_t, vfs_context_t);
  int (*fo_select)(fileproc *, int, void *, vfs_context_t);
  int (*fo_close)(fileglob *, vfs_context_t);
  int (*fo_kqfilter)(fileproc *, knote *, kevent_qos_s *);
  int (*fo_drain)(fileproc *, vfs_context_t);
};

/* 7985 */
typedef au_sentry au_sentry_t;

/* 7988 */
struct randomtab
{
  const int ru_bits;
  const long ru_out;
  const u_int32_t ru_max;
  const u_int32_t ru_gen;
  const u_int32_t ru_n;
  const u_int32_t ru_agen;
  const u_int32_t ru_m;
  const u_int32_t pfacts[4];
  u_int32_t ru_counter;
  u_int32_t ru_msb;
  u_int32_t ru_x;
  u_int32_t ru_seed;
  u_int32_t ru_seed2;
  u_int32_t ru_a;
  u_int32_t ru_b;
  u_int32_t ru_g;
  long ru_reseed;
};

/* 7989 */
struct udp6_ctlinput::udp_portonly
{
  u_int16_t uh_sport;
  u_int16_t uh_dport;
};

/* 7991 */
struct rtqk_arg
{
  radix_node_head *rnh;
  int updating;
  int draining;
  uint32_t killed;
  uint32_t found;
  uint64_t nextstop;
};

/* 7992 */
struct ip_mreq
{
  in_addr imr_multiaddr;
  in_addr imr_interface;
};

/* 7993 */
struct ipv6_mreq
{
  in6_addr_0 ipv6mr_multiaddr;
  unsigned int ipv6mr_interface;
};

/* 7994 */
enum ip6_check_if_result : __int32
{
  ip6_check_if_result::IP6_CHECK_IF_NONE = 0x0,
  ip6_check_if_result::IP6_CHECK_IF_OURS = 0x1,
  ip6_check_if_result::IP6_CHECK_IF_DROP = 0x2,
  ip6_check_if_result::IP6_CHECK_IF_FORWARD = 0x3,
};

/* 7995 */
struct __attribute__((aligned(8))) ip6q
{
  ip6asfrag *ip6q_down;
  ip6asfrag *ip6q_up;
  u_int32_t ip6q_ident;
  u_int8_t ip6q_nxt;
  u_int8_t ip6q_ecn;
  u_int8_t ip6q_ttl;
  in6_addr_0 ip6q_src;
  in6_addr_0 ip6q_dst;
  ip6q *ip6q_next;
  ip6q *ip6q_prev;
  int ip6q_unfrglen;
  int ip6q_nfrag;
  uint32_t ip6q_csum_flags;
  uint32_t ip6q_csum;
  uint32_t ip6q_flags;
  uint32_t ip6q_dst_ifscope;
  uint32_t ip6q_src_ifscope;
};

/* 7997 */
typedef symptoms_advisory symptoms_advisory_t;

/* 7998 */
struct symptoms_advisory
{
  union
  {
    uint32_t sa_nwk_status_int;
    struct
    {
      union
      {
        uint16_t sa_nwk_status;
        struct
        {
          uint8_t sa_wifi_status;
          uint8_t sa_cell_status;
        };
      };
      uint16_t sa_unused;
    };
  };
};

/* 7999 */
typedef errno_t (*ctl_send_func_0)(kern_ctl_ref, u_int32_t, void *, mbuf_t, int);

/* 8000 */
enum mptcp_wifi_quality : __int32
{
  mptcp_wifi_quality::MPTCP_WIFI_QUALITY_GOOD = 0x0,
  mptcp_wifi_quality::MPTCP_WIFI_QUALITY_BAD = 0x1,
  mptcp_wifi_quality::MPTCP_WIFI_QUALITY_UNSURE = 0x2,
};

/* 8001 */
typedef struct opaque_ipfilter *ipfilter_t;

/* 8002 */
typedef errno_t (*dlil_input_func_0)(ifnet_t, mbuf_t, mbuf_t, const ifnet_stat_increment_param *, boolean_t, struct thread *);

/* 8003 */
struct __attribute__((packed)) __attribute__((aligned(1))) udp_ip6
{
  ip6_hdr uip6_ip6;
  _BYTE gap28;
};

/* 8004 */
struct __attribute__((aligned(8))) udp_in6
{
  sockaddr_in6 uin6_sin;
};

/* 8005 */
struct tcp_connection_info
{
  u_int8_t tcpi_state;
  u_int8_t tcpi_snd_wscale;
  u_int8_t tcpi_rcv_wscale;
  u_int8_t __pad1;
  u_int32_t tcpi_options;
  u_int32_t tcpi_flags;
  u_int32_t tcpi_rto;
  u_int32_t tcpi_maxseg;
  u_int32_t tcpi_snd_ssthresh;
  u_int32_t tcpi_snd_cwnd;
  u_int32_t tcpi_snd_wnd;
  u_int32_t tcpi_snd_sbbytes;
  u_int32_t tcpi_rcv_wnd;
  u_int32_t tcpi_rttcur;
  u_int32_t tcpi_srtt;
  u_int32_t tcpi_rttvar;
  u_int64_t tcpi_txpackets;
  u_int64_t tcpi_txbytes;
  u_int64_t tcpi_txretransmitbytes;
  u_int64_t tcpi_rxpackets;
  u_int64_t tcpi_rxbytes;
  u_int64_t tcpi_rxoutoforderbytes;
  u_int64_t tcpi_txretransmitpackets;
};

/* 8006 */
struct __attribute__((aligned(8))) tcptimerlist
{
  timerlisthead lhead;
  lck_mtx_t mtx;
  lck_grp_t *mtx_grp;
  thread_call_t call;
  uint32_t runtime;
  uint32_t schedtime;
  uint32_t entries;
  uint32_t maxentries;
  boolean_t running;
  boolean_t scheduled;
  uint32_t mode;
  uint32_t pref_mode;
  uint32_t pref_offset;
  uint32_t idleruns;
  tcptimerentry *next_te;
  u_int16_t probe_if_index;
};

/* 8007 */
struct tcpstat
{
  u_int32_t tcps_connattempt;
  u_int32_t tcps_accepts;
  u_int32_t tcps_connects;
  u_int32_t tcps_drops;
  u_int32_t tcps_conndrops;
  u_int32_t tcps_closed;
  u_int32_t tcps_segstimed;
  u_int32_t tcps_rttupdated;
  u_int32_t tcps_delack;
  u_int32_t tcps_timeoutdrop;
  u_int32_t tcps_rexmttimeo;
  u_int32_t tcps_persisttimeo;
  u_int32_t tcps_keeptimeo;
  u_int32_t tcps_keepprobe;
  u_int32_t tcps_keepdrops;
  u_int32_t tcps_sndtotal;
  u_int32_t tcps_sndpack;
  u_int32_t tcps_sndbyte;
  u_int32_t tcps_sndrexmitpack;
  u_int32_t tcps_sndrexmitbyte;
  u_int32_t tcps_sndacks;
  u_int32_t tcps_sndprobe;
  u_int32_t tcps_sndurg;
  u_int32_t tcps_sndwinup;
  u_int32_t tcps_sndctrl;
  u_int32_t tcps_rcvtotal;
  u_int32_t tcps_rcvpack;
  u_int32_t tcps_rcvbyte;
  u_int32_t tcps_rcvbadsum;
  u_int32_t tcps_rcvbadoff;
  u_int32_t tcps_rcvmemdrop;
  u_int32_t tcps_rcvshort;
  u_int32_t tcps_rcvduppack;
  u_int32_t tcps_rcvdupbyte;
  u_int32_t tcps_rcvpartduppack;
  u_int32_t tcps_rcvpartdupbyte;
  u_int32_t tcps_rcvoopack;
  u_int32_t tcps_rcvoobyte;
  u_int32_t tcps_rcvpackafterwin;
  u_int32_t tcps_rcvbyteafterwin;
  u_int32_t tcps_rcvafterclose;
  u_int32_t tcps_rcvwinprobe;
  u_int32_t tcps_rcvdupack;
  u_int32_t tcps_rcvacktoomuch;
  u_int32_t tcps_rcvackpack;
  u_int32_t tcps_rcvackbyte;
  u_int32_t tcps_rcvwinupd;
  u_int32_t tcps_pawsdrop;
  u_int32_t tcps_predack;
  u_int32_t tcps_preddat;
  u_int32_t tcps_pcbcachemiss;
  u_int32_t tcps_cachedrtt;
  u_int32_t tcps_cachedrttvar;
  u_int32_t tcps_cachedssthresh;
  u_int32_t tcps_usedrtt;
  u_int32_t tcps_usedrttvar;
  u_int32_t tcps_usedssthresh;
  u_int32_t tcps_persistdrop;
  u_int32_t tcps_badsyn;
  u_int32_t tcps_mturesent;
  u_int32_t tcps_listendrop;
  u_int32_t tcps_synchallenge;
  u_int32_t tcps_rstchallenge;
  u_int32_t tcps_minmssdrops;
  u_int32_t tcps_sndrexmitbad;
  u_int32_t tcps_badrst;
  u_int32_t tcps_sc_added;
  u_int32_t tcps_sc_retransmitted;
  u_int32_t tcps_sc_dupsyn;
  u_int32_t tcps_sc_dropped;
  u_int32_t tcps_sc_completed;
  u_int32_t tcps_sc_bucketoverflow;
  u_int32_t tcps_sc_cacheoverflow;
  u_int32_t tcps_sc_reset;
  u_int32_t tcps_sc_stale;
  u_int32_t tcps_sc_aborted;
  u_int32_t tcps_sc_badack;
  u_int32_t tcps_sc_unreach;
  u_int32_t tcps_sc_zonefail;
  u_int32_t tcps_sc_sendcookie;
  u_int32_t tcps_sc_recvcookie;
  u_int32_t tcps_hc_added;
  u_int32_t tcps_hc_bucketoverflow;
  u_int32_t tcps_sack_recovery_episode;
  u_int32_t tcps_sack_rexmits;
  u_int32_t tcps_sack_rexmit_bytes;
  u_int32_t tcps_sack_rcv_blocks;
  u_int32_t tcps_sack_send_blocks;
  u_int32_t tcps_sack_sboverflow;
  u_int32_t tcps_bg_rcvtotal;
  u_int32_t tcps_rxtfindrop;
  u_int32_t tcps_fcholdpacket;
  u_int32_t tcps_limited_txt;
  u_int32_t tcps_early_rexmt;
  u_int32_t tcps_sack_ackadv;
  u_int32_t tcps_rcv_swcsum;
  u_int32_t tcps_rcv_swcsum_bytes;
  u_int32_t tcps_rcv6_swcsum;
  u_int32_t tcps_rcv6_swcsum_bytes;
  u_int32_t tcps_snd_swcsum;
  u_int32_t tcps_snd_swcsum_bytes;
  u_int32_t tcps_snd6_swcsum;
  u_int32_t tcps_snd6_swcsum_bytes;
  u_int32_t tcps_unused_1;
  u_int32_t tcps_unused_2;
  u_int32_t tcps_unused_3;
  u_int32_t tcps_invalid_mpcap;
  u_int32_t tcps_invalid_joins;
  u_int32_t tcps_mpcap_fallback;
  u_int32_t tcps_join_fallback;
  u_int32_t tcps_estab_fallback;
  u_int32_t tcps_invalid_opt;
  u_int32_t tcps_mp_outofwin;
  u_int32_t tcps_mp_reducedwin;
  u_int32_t tcps_mp_badcsum;
  u_int32_t tcps_mp_oodata;
  u_int32_t tcps_mp_switches;
  u_int32_t tcps_mp_rcvtotal;
  u_int32_t tcps_mp_rcvbytes;
  u_int32_t tcps_mp_sndpacks;
  u_int32_t tcps_mp_sndbytes;
  u_int32_t tcps_join_rxmts;
  u_int32_t tcps_tailloss_rto;
  u_int32_t tcps_reordered_pkts;
  u_int32_t tcps_recovered_pkts;
  u_int32_t tcps_pto;
  u_int32_t tcps_rto_after_pto;
  u_int32_t tcps_tlp_recovery;
  u_int32_t tcps_tlp_recoverlastpkt;
  u_int32_t tcps_ecn_client_success;
  u_int32_t tcps_ecn_recv_ece;
  u_int32_t tcps_ecn_sent_ece;
  u_int32_t tcps_detect_reordering;
  u_int32_t tcps_delay_recovery;
  u_int32_t tcps_avoid_rxmt;
  u_int32_t tcps_unnecessary_rxmt;
  u_int32_t tcps_nostretchack;
  u_int32_t tcps_rescue_rxmt;
  u_int32_t tcps_pto_in_recovery;
  u_int32_t tcps_pmtudbh_reverted;
  u_int32_t tcps_dsack_disable;
  u_int32_t tcps_dsack_ackloss;
  u_int32_t tcps_dsack_badrexmt;
  u_int32_t tcps_dsack_sent;
  u_int32_t tcps_dsack_recvd;
  u_int32_t tcps_dsack_recvd_old;
  u_int32_t tcps_mp_sel_symtomsd;
  u_int32_t tcps_mp_sel_rtt;
  u_int32_t tcps_mp_sel_rto;
  u_int32_t tcps_mp_sel_peer;
  u_int32_t tcps_mp_num_probes;
  u_int32_t tcps_mp_verdowngrade;
  u_int32_t tcps_drop_after_sleep;
  u_int32_t tcps_probe_if;
  u_int32_t tcps_probe_if_conflict;
  u_int32_t tcps_ecn_client_setup;
  u_int32_t tcps_ecn_server_setup;
  u_int32_t tcps_ecn_server_success;
  u_int32_t tcps_ecn_ace_syn_not_ect;
  u_int32_t tcps_ecn_ace_syn_ect1;
  u_int32_t tcps_ecn_ace_syn_ect0;
  u_int32_t tcps_ecn_ace_syn_ce;
  u_int32_t tcps_ecn_lost_synack;
  u_int32_t tcps_ecn_lost_syn;
  u_int32_t tcps_ecn_not_supported;
  u_int32_t tcps_ecn_recv_ce;
  u_int32_t tcps_ecn_ace_recv_ce;
  u_int32_t tcps_ecn_conn_recv_ce;
  u_int32_t tcps_ecn_conn_recv_ece;
  u_int32_t tcps_ecn_conn_plnoce;
  u_int32_t tcps_ecn_conn_pl_ce;
  u_int32_t tcps_ecn_conn_nopl_ce;
  u_int32_t tcps_ecn_fallback_synloss;
  u_int32_t tcps_ecn_fallback_reorder;
  u_int32_t tcps_ecn_fallback_ce;
  u_int32_t tcps_tfo_syn_data_rcv;
  u_int32_t tcps_tfo_cookie_req_rcv;
  u_int32_t tcps_tfo_cookie_sent;
  u_int32_t tcps_tfo_cookie_invalid;
  u_int32_t tcps_tfo_cookie_req;
  u_int32_t tcps_tfo_cookie_rcv;
  u_int32_t tcps_tfo_syn_data_sent;
  u_int32_t tcps_tfo_syn_data_acked;
  u_int32_t tcps_tfo_syn_loss;
  u_int32_t tcps_tfo_blackhole;
  u_int32_t tcps_tfo_cookie_wrong;
  u_int32_t tcps_tfo_no_cookie_rcv;
  u_int32_t tcps_tfo_heuristics_disable;
  u_int32_t tcps_tfo_sndblackhole;
  u_int32_t tcps_mss_to_default;
  u_int32_t tcps_mss_to_medium;
  u_int32_t tcps_mss_to_low;
  u_int32_t tcps_ecn_fallback_droprst;
  u_int32_t tcps_ecn_fallback_droprxmt;
  u_int32_t tcps_ecn_fallback_synrst;
  u_int32_t tcps_mptcp_rcvmemdrop;
  u_int32_t tcps_mptcp_rcvduppack;
  u_int32_t tcps_mptcp_rcvpackafterwin;
  u_int32_t tcps_timer_drift_le_1_ms;
  u_int32_t tcps_timer_drift_le_10_ms;
  u_int32_t tcps_timer_drift_le_20_ms;
  u_int32_t tcps_timer_drift_le_50_ms;
  u_int32_t tcps_timer_drift_le_100_ms;
  u_int32_t tcps_timer_drift_le_200_ms;
  u_int32_t tcps_timer_drift_le_500_ms;
  u_int32_t tcps_timer_drift_le_1000_ms;
  u_int32_t tcps_timer_drift_gt_1000_ms;
  u_int32_t tcps_mptcp_handover_attempt;
  u_int32_t tcps_mptcp_interactive_attempt;
  u_int32_t tcps_mptcp_aggregate_attempt;
  u_int32_t tcps_mptcp_fp_handover_attempt;
  u_int32_t tcps_mptcp_fp_interactive_attempt;
  u_int32_t tcps_mptcp_fp_aggregate_attempt;
  u_int32_t tcps_mptcp_heuristic_fallback;
  u_int32_t tcps_mptcp_fp_heuristic_fallback;
  u_int32_t tcps_mptcp_handover_success_wifi;
  u_int32_t tcps_mptcp_handover_success_cell;
  u_int32_t tcps_mptcp_interactive_success;
  u_int32_t tcps_mptcp_aggregate_success;
  u_int32_t tcps_mptcp_fp_handover_success_wifi;
  u_int32_t tcps_mptcp_fp_handover_success_cell;
  u_int32_t tcps_mptcp_fp_interactive_success;
  u_int32_t tcps_mptcp_fp_aggregate_success;
  u_int32_t tcps_mptcp_handover_cell_from_wifi;
  u_int32_t tcps_mptcp_handover_wifi_from_cell;
  u_int32_t tcps_mptcp_interactive_cell_from_wifi;
  u_int64_t tcps_mptcp_handover_cell_bytes;
  u_int64_t tcps_mptcp_interactive_cell_bytes;
  u_int64_t tcps_mptcp_aggregate_cell_bytes;
  u_int64_t tcps_mptcp_handover_all_bytes;
  u_int64_t tcps_mptcp_interactive_all_bytes;
  u_int64_t tcps_mptcp_aggregate_all_bytes;
  u_int32_t tcps_mptcp_back_to_wifi;
  u_int32_t tcps_mptcp_wifi_proxy;
  u_int32_t tcps_mptcp_cell_proxy;
  u_int32_t tcps_ka_offload_drops;
  u_int32_t tcps_mptcp_triggered_cell;
  u_int32_t tcps_fin_timeout_drops;
};

/* 8010 */
enum ip_check_if_result : __int32
{
  ip_check_if_result::IP_CHECK_IF_NONE = 0x0,
  ip_check_if_result::IP_CHECK_IF_OURS = 0x1,
  ip_check_if_result::IP_CHECK_IF_DROP = 0x2,
  ip_check_if_result::IP_CHECK_IF_FORWARD = 0x3,
};

/* 8011 */
typedef mbuf *(*gre_input_func_t)(mbuf *, int, int);

/* 8013 */
struct net_qos_dscp_map
{
  uint8_t sotc_to_dscp[10];
  uint8_t netsvctype_to_dscp[9];
};

/* 8014 */
struct __attribute__((aligned(8))) in_ifadown_arg
{
  radix_node_head *rnh;
  ifaddr *ifa;
  int del;
};

/* 8015 */
struct inp_fc_tree
{
  inpcb *rbh_root;
};

/* 8016 */
struct arptf_arg
{
  boolean_t draining;
  boolean_t probing;
  uint32_t killed;
  uint32_t aging;
  uint32_t sticky;
  uint32_t found;
  uint32_t qlen;
  uint32_t qsize;
};

/* 8023 */
struct tb_profile
{
  u_int64_t rate;
  u_int32_t percent;
  u_int32_t depth;
};

/* 8024 */
typedef void (*ifnet_event_func_2)(ifnet_t, const kev_msg *);

/* 8025 */
struct __attribute__((aligned(8))) restricted_port_entry
{
  const char *rpe_entitlement;
  in_port_t rpe_port;
  uint16_t rpe_flags;
};

/* 8028 */
enum pfrw_op : __int32
{
  pfrw_op::PFRW_MARK = 0x0,
  pfrw_op::PFRW_SWEEP = 0x1,
  pfrw_op::PFRW_ENQUEUE = 0x2,
  pfrw_op::PFRW_GET_ADDRS = 0x3,
  pfrw_op::PFRW_GET_ASTATS = 0x4,
  pfrw_op::PFRW_POOL_GET = 0x5,
  pfrw_op::PFRW_DYNADDR_UPDATE = 0x6,
};

/* 8026 */
struct pfr_walktree
{
  pfrw_op pfrw_op;
  union
  {
    user_addr_t_0 pfrw1_addr;
    user_addr_t_0 pfrw1_astats;
    pfr_kentryworkq *pfrw1_workq;
    pfr_kentry *pfrw1_kentry;
    pfi_dynaddr *pfrw1_dyn;
  } pfrw_1;
  int pfrw_free;
  int pfrw_flags;
};

/* 8029 */
struct pfr_ktablehead
{
  pfr_ktable *rbh_root;
};

/* 8030 */
struct pf_anchor_global
{
  pf_anchor *rbh_root;
};

/* 8034 */
struct pf_osfp_list
{
  pf_os_fingerprint *slh_first;
};

/* 8035 */
struct pf_frag_tree
{
  pf_fragment *rbh_root;
};

/* 8036 */
struct pfioc_limit
{
  int index;
  unsigned int limit;
};

/* 8037 */
struct pfioc_tm
{
  int timeout;
  int seconds;
};

/* 8038 */
struct pfioc_remove_token
{
  u_int64_t token_value;
  u_int64_t refcount;
};

/* 8039 */
struct pf_tags
{
  pf_tagname *tqh_first;
  pf_tagname **tqh_last;
};

/* 8040 */
struct pfi_ifhead
{
  pfi_kif *rbh_root;
};

/* 8041 */
enum pfi_kif_refs : __int32
{
  pfi_kif_refs::PFI_KIF_REF_NONE = 0x0,
  pfi_kif_refs::PFI_KIF_REF_STATE = 0x1,
  pfi_kif_refs::PFI_KIF_REF_RULE = 0x2,
};

/* 8042 */
struct pool
{
  zone *pool_zone;
  const char *pool_name;
  unsigned int pool_count;
  unsigned int pool_hiwat;
  unsigned int pool_limit;
  unsigned int pool_fails;
};

/* 8043 */
struct pf_src_tree
{
  pf_src_node *rbh_root;
};

/* 8044 */
struct pf_state_tree_ext_gwy
{
  pf_state_key *rbh_root;
};

/* 8045 */
struct pf_state_tree_lan_ext
{
  pf_state_key *rbh_root;
};

/* 8046 */
struct pf_state_tree_id
{
  pf_state *rbh_root;
};

/* 8048 */
struct necp_client_signable_default
{
  uuid_t_1 client_id;
  u_int32_t sign_type;
  u_int8_t signable_data[128];
};

/* 8049 */
struct _necp_client_global_tree
{
  necp_client *rbh_root;
};

/* 8050 */
struct _necp_client_flow_global_tree
{
  necp_client_flow_registration *rbh_root;
};

/* 8051 */
enum necp_drop_all_bypass_check_result_t : __int32
{
  NECP_DROP_ALL_BYPASS_CHECK_RESULT_NONE = 0x0,
  NECP_DROP_ALL_BYPASS_CHECK_RESULT_TRUE = 0x1,
  NECP_DROP_ALL_BYPASS_CHECK_RESULT_FALSE = 0x2,
};

/* 8052 */
struct substring
{
  char *string;
  size_t length;
};

/* 8054 */
struct necp_route_rule_list
{
  necp_route_rule *lh_first;
};

/* 8055 */
struct necp_string_id_mapping_list
{
  necp_string_id_mapping *lh_first;
};

/* 8056 */
typedef errno_t (*nxnet_prepare_fn_t_0)(kern_nexus_t, ifnet_t);

/* 8060 */
struct nstat_sysinfo_data
{
  uint32_t flags;
  uint32_t unsent_data_cnt;
  union __attribute__((packed)) __attribute__((aligned(8)))
  {
    nstat_sysinfo_mbuf_stats mb_stats;
    nstat_sysinfo_tcp_stats tcp_stats;
    nstat_sysinfo_ifnet_ecn_stats ifnet_ecn_stats;
    nstat_sysinfo_lim_stats lim_stats;
    nstat_sysinfo_net_api_stats net_api_stats;
  } u;
};

/* 8061 */
struct netsrc_repv2
{
  union
  {
    sockaddr_in_4_6 nrp_src;
    sockaddr_in_4_6 _usa;
  };
  uint32_t nrp_min_rtt;
  uint32_t nrp_connection_attempts;
  uint32_t nrp_connection_successes;
  uint32_t nrp_flags;
  uint16_t nrp_label;
  uint16_t nrp_precedence;
  uint16_t nrp_dstlabel;
  uint16_t nrp_dstprecedence;
  uint16_t nrp_ifindex;
  uint16_t nrp_unused;
};

/* 8062 */
struct matchleaf_arg
{
  unsigned int ifscope;
};

/* 8063 */
struct rtfc_arg
{
  rtentry *rt0;
  radix_node_head *rnh;
};

/* 8068 */
typedef errno_t (*proto_media_input_1)(ifnet_t, protocol_family_t, mbuf_t, char *);

/* 8069 */
struct if_bond_req
{
  u_int32_t ibr_op;
  union
  {
    char ibru_if_name[16];
    if_bond_status_req ibru_status;
    int ibru_int_val;
  } ibr_ibru;
};

/* 8070 */
typedef lacpdu_s *lacpdu_ref;

/* 8072 */
typedef lacp_actor_partner_tlv_s *lacp_actor_partner_tlv_ref;

/* 8073 */
typedef struct *lacp_system_ref;

/* 8074 */
typedef bond_globals_s *bond_globals_ref;

/* 8075 */
typedef mbuf *packet_buffer_ref;

/* 8077 */
struct if_fake_request
{
  uint64_t iffr_reserved[4];
  union
  {
    char iffru_buf[128];
    if_fake_media iffru_media;
    char iffru_peer_name[16];
    uint32_t iffru_dequeue_stall;
  } iffr_u;
};

/* 8078 */
typedef if_fake *if_fake_ref;

/* 8081 */
typedef void (*nxdom_prov_fini_fn_t_0)(kern_nexus_domain_provider_t);

/* 8082 */
typedef vlan_globals_s *vlan_globals_ref;

/* 8083 */
struct ifnet_fc_tree
{
  ifnet_fc_entry *rbh_root;
};

/* 8084 */
struct chain_len_stats
{
  uint64_t cls_one;
  uint64_t cls_two;
  uint64_t cls_three;
  uint64_t cls_four;
  uint64_t cls_five_or_more;
};

/* 8085 */
struct dlil_main_threading_info
{
  dlil_threading_info inp;
  class_queue_t lo_rcvq_pkts;
};

/* 8086 */
typedef const net_thread_marks *net_thread_marks_t;

/* 8087 */
struct __attribute__((aligned(8))) skmem_region_params_0
{
  const char *srp_name;
  skmem_region_id_t srp_id;
  uint32_t srp_cflags;
  uint32_t srp_r_seg_size;
  uint32_t srp_c_seg_size;
  uint32_t srp_seg_cnt;
  uint32_t srp_r_obj_size;
  uint32_t srp_r_obj_cnt;
  uint32_t srp_c_obj_size;
  uint32_t srp_c_obj_cnt;
  size_t srp_align;
  nexus_meta_type_t srp_md_type;
  nexus_meta_subtype_t srp_md_subtype;
  uint16_t srp_max_frags;
};

/* 8089 */
struct ip_packet_info
{
  u_int ip_hlen;
  u_int ip_pay_len;
  u_int ip_opt_len;
  uint8_t ip_proto;
  bool ip_is_ipv4;
  bool ip_is_fragmented;
  iphdr ip_hdr;
  void *ip_proto_hdr;
};

/* 8090 */
struct bridge_link_event::event
{
  u_int32_t ifnet_family;
  u_int32_t unit;
  char if_name[16];
};

/* 8094 */
typedef errno_t (*ifnet_set_bpf_tap_1)(ifnet_t, bpf_tap_mode, bpf_packet_func);

/* 8095 */
typedef errno_t (*ifnet_ctl_func_1)(ifnet_t, ifnet_ctl_cmd_t, u_int32_t, void *);

/* 8098 */
enum nsoperation : __int32
{
  nsoperation::NS_OPEN = 0x0,
  nsoperation::NS_CREATE = 0x1,
  nsoperation::NS_DELETE = 0x2,
};

/* 8099 */
typedef attr_info attr_info_t;

/* 9301 */
struct __attribute__((aligned(8))) attr_info
{
  vfs_context_t context;
  vnode_t filevp;
  size_t filesize;
  size_t iosize;
  u_int8_t *rawdata;
  size_t rawsize;
  apple_double_header_t *filehdr;
  apple_double_entry_t *finderinfo;
  apple_double_entry_t *rsrcfork;
  attr_header_t *attrhdr;
  attr_entry_t *attr_entry;
  u_int8_t readonly;
  u_int8_t emptyfinderinfo;
};

/* 8105 */
struct fsioc_ungraft_fs
{
  uint64_t ungraft_flags;
};

/* 8106 */
typedef fsioc_graft_fs fsioc_graft_fs_t;

/* 8107 */
struct fsioc_graft_fs
{
  uint32_t graft_version;
  uint32_t graft_type;
  uint32_t graft_4cc;
  uint64_t graft_flags;
  uint64_t dir_ino;
  void *authentic_manifest;
  size_t authentic_manifest_size;
  void *user_manifest;
  size_t user_manifest_size;
  void *payload;
  size_t payload_size;
};

/* 8111 */
struct unmount_info
{
  int u_errs;
  int u_busy;
  int u_count;
  int u_only_non_system;
};

/* 8112 */
struct vfs_switch_root::preserved_mount
{
  vnode_t pm_rootvnode;
  mount_t pm_mount;
  vnode_t pm_new_covered_vp;
  vnode_t pm_old_covered_vp;
  const char *pm_path;
};

/* 8113 */
struct async_work_lst
{
  vnode *tqh_first;
  vnode **tqh_last;
};

/* 8114 */
struct ragelst
{
  vnode *tqh_first;
  vnode **tqh_last;
};

/* 8115 */
struct freelst
{
  vnode *tqh_first;
  vnode **tqh_last;
};

/* 8116 */
struct vnode_trace_paths_context
{
  uint64_t count;
  unsigned __int64 path[131];
};

/* 8117 */
typedef file_lease *file_lease_t;

/* 8118 */
enum resolver_status : __int32
{
  resolver_status::RESOLVER_RESOLVED = 0x0,
  resolver_status::RESOLVER_NOCHANGE = 0x1,
  resolver_status::RESOLVER_UNRESOLVED = 0x2,
  resolver_status::RESOLVER_ERROR = 0x3,
  resolver_status::RESOLVER_STOP = 0x4,
};

/* 8119 */
typedef _vnode_authorize_context *vauth_ctx;

/* 8120 */
struct _vnode_authorize_context
{
  vnode_t vp;
  vnode_attr *vap;
  vnode_t dvp;
  vnode_attr *dvap;
  vfs_context_t ctx;
  int flags;
  int flags_valid;
};

/* 8121 */
struct cl_extent
{
  daddr64_t b_addr;
  daddr64_t e_addr;
};

/* 8136 */
typedef dtrace_proc_awaited_entry dtrace_proc_awaited_entry_t;

/* 8138 */
typedef uintptr_t dtrace_meta_provider_id_t;

/* 8140 */
enum dtrace_json_state : __int32
{
  dtrace_json_state::DTRACE_JSON_REST = 0x1,
  dtrace_json_state::DTRACE_JSON_OBJECT = 0x2,
  dtrace_json_state::DTRACE_JSON_STRING = 0x3,
  dtrace_json_state::DTRACE_JSON_STRING_ESCAPE = 0x4,
  dtrace_json_state::DTRACE_JSON_STRING_ESCAPE_UNICODE = 0x5,
  dtrace_json_state::DTRACE_JSON_COLON = 0x6,
  dtrace_json_state::DTRACE_JSON_COMMA = 0x7,
  dtrace_json_state::DTRACE_JSON_VALUE = 0x8,
  dtrace_json_state::DTRACE_JSON_IDENTIFIER = 0x9,
  dtrace_json_state::DTRACE_JSON_NUMBER = 0xA,
  dtrace_json_state::DTRACE_JSON_NUMBER_FRAC = 0xB,
  dtrace_json_state::DTRACE_JSON_NUMBER_EXP = 0xC,
  dtrace_json_state::DTRACE_JSON_COLLECT_OBJECT = 0xD,
};

/* 8142 */
enum cpu_setup_t : __int32
{
  CPU_INIT = 0x0,
  CPU_CONFIG = 0x1,
  CPU_UNCONFIG = 0x2,
  CPU_ON = 0x3,
  CPU_OFF = 0x4,
  CPU_CPUPART_IN = 0x5,
  CPU_CPUPART_OUT = 0x6,
};

/* 8144 */
struct __attribute__((aligned(4))) dtrace_fmtdesc
{
  char *dtfd_string;
  int dtfd_length;
  uint16_t dtfd_format;
};

/* 8145 */
struct dtrace_status
{
  uint64_t dtst_dyndrops;
  uint64_t dtst_dyndrops_rinsing;
  uint64_t dtst_dyndrops_dirty;
  uint64_t dtst_specdrops;
  uint64_t dtst_specdrops_busy;
  uint64_t dtst_specdrops_unavail;
  uint64_t dtst_errors;
  uint64_t dtst_filled;
  uint64_t dtst_stkstroverflows;
  uint64_t dtst_dblerrors;
  char dtst_killed;
  char dtst_exiting;
  char dtst_pad[6];
};

/* 8146 */
struct dtrace_bufdesc
{
  uint64_t dtbd_size;
  uint32_t dtbd_cpu;
  uint32_t dtbd_errors;
  uint64_t dtbd_drops;
  char *dtbd_data;
  uint64_t dtbd_oldest;
  uint64_t dtbd_timestamp;
};

/* 8147 */
typedef uint32_t dtrace_specid_t;

/* 8157 */
struct __attribute__((aligned(8))) dtrace_anon
{
  dtrace_state_t *dta_state;
  dtrace_enabling_t *dta_enabling;
  processorid_t dta_beganon;
};

/* 8171 */
typedef errno_t (*ifnet_del_proto_func_1)(ifnet_t, protocol_family_t);

/* 8172 */
typedef errno_t (*ifnet_add_proto_func_1)(ifnet_t, protocol_family_t, const ifnet_demux_desc *, u_int32_t);

/* 8173 */
struct gss_1964_header_desc_struct
{
  uint8_t App0;
  uint8_t AppLen[];
};

/* 8175 */
enum etypes : __int32
{
  etypes::DES3_CBC_SHA1_KD = 0x10,
  etypes::AES128_CTS_HMAC_SHA1_96 = 0x11,
  etypes::AES256_CTS_HMAC_SHA1_96 = 0x12,
};

/* 8176 */
typedef crypt_walker_ctx *crypt_walker_ctx_t;

/* 8177 */
typedef hmac_walker_ctx *hmac_walker_ctx_t;

/* 8178 */
struct gss_1964_token_body_struct
{
  uint8_t OIDType;
  uint8_t OIDLen;
  uint8_t kerb_mech[9];
  gss_1964_tok_type body;
  uint8_t SND_SEQ[8];
  uint8_t Hash[];
};

/* 8183 */
struct nfsrv_getvfs_by_mntonname_callback_args
{
  const char *path;
  mount_t mp;
};

/* 8186 */
struct nfs_hooks_in
{
  int (*f_vinvalbuf)(vnode_t, int, vfs_context_t, int);
  int (*f_buf_page_inval)(vnode_t, off_t);
};

/* 8187 */
typedef resolver_result_t (*trigger_vnode_resolve_callback_t_7)(vnode_t, const componentname *, path_operation, int, void *, vfs_context_t);

/* 8190 */
struct fileops_1
{
  file_type_t fo_type;
  int (*fo_read)(fileproc *, uio *, int, vfs_context_t);
  int (*fo_write)(fileproc *, uio *, int, vfs_context_t);
  int (*fo_ioctl)(fileproc *, u_long, caddr_t, vfs_context_t);
  int (*fo_select)(fileproc *, int, void *, vfs_context_t);
  int (*fo_close)(fileglob *, vfs_context_t);
  int (*fo_kqfilter)(fileproc *, knote *, kevent_qos_s *);
  int (*fo_drain)(fileproc *, vfs_context_t);
};

/* 8192 */
struct kpc_get_counters_remote
{
  uint32_t classes;
  uint32_t nb_counters;
  uint32_t buf_stride;
  uint64_t *buf;
};

/* 8209 */
enum dbgwrap_status_t : __int32
{
  DBGWRAP_ERR_SELF_HALT = 0xFFFFFFFA,
  DBGWRAP_ERR_UNSUPPORTED = 0xFFFFFFFB,
  DBGWRAP_ERR_INPROGRESS = 0xFFFFFFFC,
  DBGWRAP_ERR_INSTR_ERROR = 0xFFFFFFFD,
  DBGWRAP_ERR_INSTR_TIMEOUT = 0xFFFFFFFE,
  DBGWRAP_ERR_HALT_TIMEOUT = 0xFFFFFFFF,
  DBGWRAP_SUCCESS = 0x0,
  DBGWRAP_WARN_ALREADY_HALTED = 0x1,
  DBGWRAP_WARN_CPU_OFFLINE = 0x2,
};

/* 8213 */
enum ptrauth_key : __int32
{
  ptrauth_key_asia = 0x0,
  ptrauth_key_asib = 0x1,
  ptrauth_key_asda = 0x2,
  ptrauth_key_asdb = 0x3,
  ptrauth_key_process_independent_code = 0x0,
  ptrauth_key_process_dependent_code = 0x1,
  ptrauth_key_process_independent_data = 0x2,
  ptrauth_key_process_dependent_data = 0x3,
  ptrauth_key_function_pointer = 0x0,
  ptrauth_key_return_address = 0x1,
  ptrauth_key_frame_pointer = 0x3,
  ptrauth_key_block_function = 0x0,
  ptrauth_key_cxx_vtable_pointer = 0x2,
};

/* 8214 */
typedef void (*cpu_qos_update_t)(int, uint64_t, uint64_t);

/* 8215 */
typedef kern_return_t (*mem_fault_report_enable_function_t)(void *, uint32_t);

/* 8216 */
typedef kern_return_t (*mcache_flush_function)(void *);

/* 8217 */
typedef void (*invalidate_fn_t)(void);

/* 8234 */
typedef usimple_lock_data_t *simple_lock_t;

/* 8235 */
typedef void (*broadcastFunc)(void *);

/* 8236 */
typedef integer_t *processor_info_t;

/* 8237 */
struct sysreg_restore
{
  uint64_t tcr_el1;
};

/* 8238 */
typedef uint16_t pp_attr_t;

/* 8243 */
struct _TrustCacheQueryToken_0
{
  const TrustCache_t *trustCache;
  const void *trustCacheEntry;
};

/* 8244 */
enum pmap_trim_state_t : __int32
{
  PMAP_TRIM_STATE_START = 0x0,
  PMAP_TRIM_STATE_GRAND_BEFORE = 0x1,
  PMAP_TRIM_STATE_GRAND_AFTER = 0x2,
  PMAP_TRIM_STATE_SUBORD = 0x3,
  PMAP_TRIM_STATE_DONE = 0x4,
  PMAP_TRIM_STATE_COUNT = 0x5,
};

/* 8250 */
enum health_test_result : __int32
{
  health_test_result::health_test_failure = 0x0,
  health_test_result::health_test_success = 0x1,
};

/* 8251 */
typedef entropy_cpu_data entropy_cpu_data_t;

/* 9356 */
struct entropy_cpu_data
{
  entropy_sample_t samples[2048];
  uint32_t sample_count;
};

/* 8255 */
struct cckprng_funcs
{
  _BYTE gap0[48];
};

/* 8260 */
enum micro_snapshot_flags : __int32
{
  micro_snapshot_flags::kInterruptRecord = 0x1,
  micro_snapshot_flags::kTimerArmingRecord = 0x2,
  micro_snapshot_flags::kUserMode = 0x4,
  micro_snapshot_flags::kIORecord = 0x8,
  micro_snapshot_flags::kPMIRecord = 0x10,
  micro_snapshot_flags::kMACFRecord = 0x20,
};

/* 8258 */
struct telemetry_target
{
  thread_t_0 thread;
  uintptr_t *frames;
  size_t frames_count;
  bool user64_regs;
  uint16_t async_start_index;
  micro_snapshot_flags microsnapshot_flags;
  micro_snapshot_buffer *buffer;
  lck_mtx_t *buffer_mtx;
};

/* 8259 */
struct __attribute__((aligned(8))) micro_snapshot_buffer
{
  vm_offset_t buffer;
  uint32_t size;
  uint32_t current_position;
  uint32_t end_point;
};

/* 8261 */
struct vc_info
{
  unsigned int v_height;
  unsigned int v_width;
  unsigned int v_depth;
  unsigned int v_rowbytes;
  unsigned __int64 v_baseaddr;
  unsigned int v_type;
  char v_name[32];
  uint64_t v_physaddr;
  unsigned int v_rows;
  unsigned int v_columns;
  unsigned int v_rowscanbytes;
  unsigned int v_scale;
  unsigned int v_rotate;
  unsigned int v_reserved[3];
};

/* 8262 */
typedef void (*kpc_pm_handler_t)(boolean_t);

/* 8264 */
struct __Request__io_object_get_class_t
{
  mach_msg_header_t_0 Head;
};

/* 8265 */
struct __Request__io_object_conforms_to_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t classNameOffset;
  mach_msg_type_number_t classNameCnt;
  char className[128];
};

/* 8266 */
struct __Request__io_iterator_next_t
{
  mach_msg_header_t_0 Head;
};

/* 8267 */
struct __Request__io_iterator_reset_t
{
  mach_msg_header_t_0 Head;
};

/* 8268 */
struct __Request__io_service_get_matching_services_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingOffset;
  mach_msg_type_number_t matchingCnt;
  char matching[512];
};

/* 8269 */
struct __Request__io_registry_entry_get_property_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t property_nameOffset;
  mach_msg_type_number_t property_nameCnt;
  char property_name[128];
};

/* 8270 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_registry_create_iterator_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  uint32_t options;
};

/* 8271 */
struct __Request__io_registry_iterator_enter_entry_t
{
  mach_msg_header_t_0 Head;
};

/* 8272 */
struct __Request__io_registry_iterator_exit_entry_t
{
  mach_msg_header_t_0 Head;
};

/* 8273 */
struct __Request__io_registry_entry_from_path_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t pathOffset;
  mach_msg_type_number_t pathCnt;
  char path[512];
};

/* 8274 */
struct __Request__io_registry_entry_get_name_t
{
  mach_msg_header_t_0 Head;
};

/* 8275 */
struct __Request__io_registry_entry_get_properties_t
{
  mach_msg_header_t_0 Head;
};

/* 8276 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_registry_entry_get_property_bytes_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t property_nameOffset;
  mach_msg_type_number_t property_nameCnt;
  char property_name[128];
  mach_msg_type_number_t dataCnt;
};

/* 8277 */
struct __Request__io_registry_entry_get_child_iterator_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
};

/* 8278 */
struct __Request__io_registry_entry_get_parent_iterator_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
};

/* 8279 */
struct __Request__io_service_close_t
{
  mach_msg_header_t_0 Head;
};

/* 8280 */
struct __Request__io_connect_get_service_t
{
  mach_msg_header_t_0 Head;
};

/* 8281 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_connect_set_notification_port_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t port;
  NDR_record_t_0 NDR;
  uint32_t notification_type;
  uint32_t reference;
};

/* 8282 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_connect_map_memory_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t into_task;
  NDR_record_t_0 NDR;
  uint32_t memory_type;
  uint32_t address;
  uint32_t size;
  uint32_t flags;
};

/* 8283 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_connect_add_client_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t connect_to;
};

/* 8284 */
struct __Request__io_connect_set_properties_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t properties;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t propertiesCnt;
};

/* 8285 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_connect_method_scalarI_scalarO_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  int input[16];
  mach_msg_type_number_t outputCnt;
};

/* 8286 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_connect_method_scalarI_structureO_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  int input[16];
  mach_msg_type_number_t outputCnt;
};

/* 8287 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_connect_method_scalarI_structureI_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  int input[16];
  mach_msg_type_number_t inputStructCnt;
  char inputStruct[4096];
};

/* 8288 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_connect_method_structureI_structureO_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  char input[4096];
  mach_msg_type_number_t outputCnt;
};

/* 8289 */
struct __Request__io_registry_entry_get_path_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
};

/* 8290 */
struct __Request__io_registry_get_root_entry_t
{
  mach_msg_header_t_0 Head;
};

/* 8291 */
struct __Request__io_registry_entry_set_properties_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t properties;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t propertiesCnt;
};

/* 8292 */
struct __Request__io_registry_entry_in_plane_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
};

/* 8293 */
struct __Request__io_object_get_retain_count_t
{
  mach_msg_header_t_0 Head;
};

/* 8294 */
struct __Request__io_service_get_busy_state_t
{
  mach_msg_header_t_0 Head;
};

/* 8295 */
struct __Request__io_service_wait_quiet_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_timespec_t wait_time;
};

/* 8296 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_registry_entry_create_iterator_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  uint32_t options;
};

/* 8297 */
struct __Request__io_iterator_is_valid_t
{
  mach_msg_header_t_0 Head;
};

/* 8298 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_catalog_send_data_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t inData;
  NDR_record_t_0 NDR;
  uint32_t flag;
  mach_msg_type_number_t inDataCnt;
};

/* 8299 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_catalog_terminate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t flag;
  mach_msg_type_number_t nameOffset;
  mach_msg_type_number_t nameCnt;
  char name[128];
};

/* 8300 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_catalog_get_data_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t flag;
};

/* 8301 */
struct __Request__io_catalog_get_gen_count_t
{
  mach_msg_header_t_0 Head;
};

/* 8302 */
struct __Request__io_catalog_module_loaded_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t nameOffset;
  mach_msg_type_number_t nameCnt;
  char name[128];
};

/* 8303 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_catalog_reset_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t flag;
};

/* 8304 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_service_request_probe_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t options;
};

/* 8305 */
struct __Request__io_registry_entry_get_name_in_plane_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
};

/* 8306 */
struct __Request__io_service_match_property_table_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingOffset;
  mach_msg_type_number_t matchingCnt;
  char matching[512];
};

/* 8307 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_async_method_scalarI_scalarO_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  int input[16];
  mach_msg_type_number_t outputCnt;
};

/* 8308 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_async_method_scalarI_structureO_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  int input[16];
  mach_msg_type_number_t outputCnt;
};

/* 8309 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_async_method_scalarI_structureI_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  int input[16];
  mach_msg_type_number_t inputStructCnt;
  char inputStruct[4096];
};

/* 8310 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_async_method_structureI_structureO_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
  uint32_t selector;
  mach_msg_type_number_t inputCnt;
  char input[4096];
  mach_msg_type_number_t outputCnt;
};

/* 8311 */
struct __Request__io_service_add_notification_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t notification_typeOffset;
  mach_msg_type_number_t notification_typeCnt;
  char notification_type[128];
  mach_msg_type_number_t matchingOffset;
  mach_msg_type_number_t matchingCnt;
  char matching[512];
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
};

/* 8312 */
struct __Request__io_service_add_interest_notification_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t type_of_interestOffset;
  mach_msg_type_number_t type_of_interestCnt;
  char type_of_interest[128];
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
};

/* 8313 */
struct __Request__io_service_acknowledge_notification_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  natural_t notify_ref;
  natural_t response;
};

/* 8314 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_connect_get_notification_semaphore_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  natural_t notification_type;
};

/* 8315 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_connect_unmap_memory_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t into_task;
  NDR_record_t_0 NDR;
  uint32_t memory_type;
  uint32_t address;
};

/* 8316 */
struct __Request__io_registry_entry_get_location_in_plane_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
};

/* 8317 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_registry_entry_get_property_recursively_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  mach_msg_type_number_t property_nameOffset;
  mach_msg_type_number_t property_nameCnt;
  char property_name[128];
  uint32_t options;
};

/* 8318 */
struct __Request__io_service_get_state_t
{
  mach_msg_header_t_0 Head;
};

/* 8319 */
struct __Request__io_service_get_matching_services_ool_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t matching;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingCnt;
};

/* 8320 */
struct __Request__io_service_match_property_table_ool_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t matching;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingCnt;
};

/* 8321 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_service_add_notification_ool_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t matching;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t notification_typeOffset;
  mach_msg_type_number_t notification_typeCnt;
  char notification_type[128];
  mach_msg_type_number_t matchingCnt;
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
};

/* 8322 */
struct __Request__io_object_get_superclass_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t obj_nameOffset;
  mach_msg_type_number_t obj_nameCnt;
  char obj_name[128];
};

/* 8323 */
struct __Request__io_object_get_bundle_identifier_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t obj_nameOffset;
  mach_msg_type_number_t obj_nameCnt;
  char obj_name[128];
};

/* 8324 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_service_open_extended_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t owningTask;
  mach_msg_ool_descriptor_t properties;
  NDR_record_t_0 NDR;
  uint32_t connect_type;
  NDR_record_t_0 ndr;
  mach_msg_type_number_t propertiesCnt;
};

/* 8325 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_connect_map_memory_into_task_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t into_task;
  NDR_record_t_0 NDR;
  uint32_t memory_type;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  uint32_t flags;
};

/* 8326 */
struct __Request__io_connect_unmap_memory_from_task_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t from_task;
  NDR_record_t_0 NDR;
  uint32_t memory_type;
  mach_vm_address_t_0 address;
};

/* 8327 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_connect_method_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t selector;
  mach_msg_type_number_t scalar_inputCnt;
  io_user_scalar_t scalar_input[16];
  mach_msg_type_number_t inband_inputCnt;
  char inband_input[4096];
  mach_vm_address_t_0 ool_input;
  mach_vm_size_t_0 ool_input_size;
  mach_msg_type_number_t inband_outputCnt;
  mach_msg_type_number_t scalar_outputCnt;
  mach_vm_address_t_0 ool_output;
  mach_vm_size_t_0 ool_output_size;
};

/* 8328 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_connect_async_method_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t referenceCnt;
  io_user_reference_t_0 reference[8];
  uint32_t selector;
  mach_msg_type_number_t scalar_inputCnt;
  io_user_scalar_t scalar_input[16];
  mach_msg_type_number_t inband_inputCnt;
  char inband_input[4096];
  mach_vm_address_t_0 ool_input;
  mach_vm_size_t_0 ool_input_size;
  mach_msg_type_number_t inband_outputCnt;
  mach_msg_type_number_t scalar_outputCnt;
  mach_vm_address_t_0 ool_output;
  mach_vm_size_t_0 ool_output_size;
};

/* 8329 */
struct __Request__io_connect_set_notification_port_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t port;
  NDR_record_t_0 NDR;
  uint32_t notification_type;
  io_user_reference_t_0 reference;
};

/* 8330 */
struct __Request__io_service_add_notification_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t notification_typeOffset;
  mach_msg_type_number_t notification_typeCnt;
  char notification_type[128];
  mach_msg_type_number_t matchingOffset;
  mach_msg_type_number_t matchingCnt;
  char matching[512];
  mach_msg_type_number_t referenceCnt;
  io_user_reference_t_0 reference[8];
};

/* 8331 */
struct __Request__io_service_add_interest_notification_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t type_of_interestOffset;
  mach_msg_type_number_t type_of_interestCnt;
  char type_of_interest[128];
  mach_msg_type_number_t referenceCnt;
  io_user_reference_t_0 reference[8];
};

/* 8332 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_service_add_notification_ool_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t matching;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t notification_typeOffset;
  mach_msg_type_number_t notification_typeCnt;
  char notification_type[128];
  mach_msg_type_number_t matchingCnt;
  mach_msg_type_number_t referenceCnt;
  io_user_reference_t_0 reference[8];
};

/* 8333 */
struct __Request__io_registry_entry_get_registry_entry_id_t
{
  mach_msg_header_t_0 Head;
};

/* 8334 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_connect_method_var_output_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t selector;
  mach_msg_type_number_t scalar_inputCnt;
  io_user_scalar_t scalar_input[16];
  mach_msg_type_number_t inband_inputCnt;
  char inband_input[4096];
  mach_vm_address_t_0 ool_input;
  mach_vm_size_t_0 ool_input_size;
  mach_msg_type_number_t inband_outputCnt;
  mach_msg_type_number_t scalar_outputCnt;
};

/* 8335 */
struct __Request__io_service_get_matching_service_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingOffset;
  mach_msg_type_number_t matchingCnt;
  char matching[512];
};

/* 8336 */
struct __Request__io_service_get_matching_service_ool_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t matching;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingCnt;
};

/* 8337 */
struct __Request__io_service_get_authorization_id_t
{
  mach_msg_header_t_0 Head;
};

/* 8338 */
struct __Request__io_service_set_authorization_id_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint64_t authorization_id;
};

/* 8339 */
struct __Request__io_server_version_t
{
  mach_msg_header_t_0 Head;
};

/* 8340 */
struct __Request__io_registry_entry_get_properties_bin_t
{
  mach_msg_header_t_0 Head;
};

/* 8341 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_registry_entry_get_property_bin_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
  mach_msg_type_number_t property_nameOffset;
  mach_msg_type_number_t property_nameCnt;
  char property_name[128];
  uint32_t options;
};

/* 8342 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_service_get_matching_service_bin_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingCnt;
  char matching[4096];
};

/* 8343 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_service_get_matching_services_bin_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingCnt;
  char matching[4096];
};

/* 8344 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_service_match_property_table_bin_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t matchingCnt;
  char matching[4096];
};

/* 8345 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_service_add_notification_bin_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t notification_typeOffset;
  mach_msg_type_number_t notification_typeCnt;
  char notification_type[128];
  mach_msg_type_number_t matchingCnt;
  char matching[4096];
  mach_msg_type_number_t referenceCnt;
  natural_t reference[8];
};

/* 8346 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_service_add_notification_bin_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t wake_port;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t notification_typeOffset;
  mach_msg_type_number_t notification_typeCnt;
  char notification_type[128];
  mach_msg_type_number_t matchingCnt;
  char matching[4096];
  mach_msg_type_number_t referenceCnt;
  io_user_reference_t_0 reference[8];
};

/* 8347 */
struct __Request__io_registry_entry_get_path_ool_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t planeOffset;
  mach_msg_type_number_t planeCnt;
  char plane[128];
};

/* 8348 */
struct __Request__io_registry_entry_from_path_ool_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t path_ool;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t pathOffset;
  mach_msg_type_number_t pathCnt;
  char path[4096];
  mach_msg_type_number_t path_oolCnt;
};

/* 8349 */
struct __Request__io_device_tree_entry_exists_with_name_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t nameOffset;
  mach_msg_type_number_t nameCnt;
  char name[128];
};

/* 8350 */
struct __Request__io_registry_entry_get_properties_bin_buf_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 buf;
  mach_vm_size_t_0 bufsize;
};

/* 8352 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__io_service_wait_quiet_with_options_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_timespec_t wait_time;
  uint32_t options;
};

/* 8353 */
typedef __Reply__io_service_wait_quiet_with_options_t _Xio_service_wait_quiet_with_options::Reply;

/* 9500 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_wait_quiet_with_options_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8354 */
typedef __Reply__io_registry_entry_get_property_bin_buf_t _Xio_registry_entry_get_property_bin_buf::Reply;

/* 9501 */
struct __Reply__io_registry_entry_get_property_bin_buf_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t properties;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_size_t_0 bufsize;
  mach_msg_type_number_t propertiesCnt;
};

/* 8355 */
typedef __Reply__io_registry_entry_get_properties_bin_buf_t _Xio_registry_entry_get_properties_bin_buf::Reply;

/* 9502 */
struct __Reply__io_registry_entry_get_properties_bin_buf_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t properties;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_size_t_0 bufsize;
  mach_msg_type_number_t propertiesCnt;
};

/* 8356 */
typedef __Reply__io_device_tree_entry_exists_with_name_t _Xio_device_tree_entry_exists_with_name::Reply;

/* 9503 */
struct __Reply__io_device_tree_entry_exists_with_name_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  boolean_t exists;
};

/* 8357 */
typedef __Reply__io_registry_entry_from_path_ool_t _Xio_registry_entry_from_path_ool::Reply;

/* 9504 */
struct __Reply__io_registry_entry_from_path_ool_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t registry_entry;
  NDR_record_t_0 NDR;
  kern_return_t result;
};

/* 8358 */
typedef __Reply__io_registry_entry_get_path_ool_t _Xio_registry_entry_get_path_ool::Reply;

/* 9505 */
struct __Reply__io_registry_entry_get_path_ool_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t path_ool;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t pathOffset;
  mach_msg_type_number_t pathCnt;
  char path[4096];
  mach_msg_type_number_t path_oolCnt;
};

/* 8359 */
typedef __Reply__io_service_add_notification_bin_64_t _Xio_service_add_notification_bin_64::Reply;

/* 9506 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_add_notification_bin_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t notification;
};

/* 8360 */
typedef __Reply__io_service_add_notification_bin_t _Xio_service_add_notification_bin::Reply;

/* 9507 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_add_notification_bin_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t notification;
};

/* 8361 */
typedef __Reply__io_service_match_property_table_bin_t _Xio_service_match_property_table_bin::Reply;

/* 9508 */
struct __Reply__io_service_match_property_table_bin_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  boolean_t matches;
};

/* 8362 */
typedef __Reply__io_service_get_matching_services_bin_t _Xio_service_get_matching_services_bin::Reply;

/* 9509 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_get_matching_services_bin_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t existing;
};

/* 8363 */
typedef __Reply__io_service_get_matching_service_bin_t _Xio_service_get_matching_service_bin::Reply;

/* 9510 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_get_matching_service_bin_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t service;
};

/* 8364 */
typedef __Reply__io_registry_entry_get_property_bin_t _Xio_registry_entry_get_property_bin::Reply;

/* 9511 */
struct __Reply__io_registry_entry_get_property_bin_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t properties;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t propertiesCnt;
};

/* 8365 */
typedef __Reply__io_registry_entry_get_properties_bin_t _Xio_registry_entry_get_properties_bin::Reply;

/* 9512 */
struct __Reply__io_registry_entry_get_properties_bin_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t properties;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t propertiesCnt;
};

/* 8366 */
typedef __Reply__io_server_version_t _Xio_server_version::Reply;

/* 9513 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_server_version_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  uint64_t version;
};

/* 8367 */
typedef __Reply__io_service_set_authorization_id_t _Xio_service_set_authorization_id::Reply;

/* 9514 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_set_authorization_id_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8368 */
typedef __Reply__io_service_get_authorization_id_t _Xio_service_get_authorization_id::Reply;

/* 9515 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_get_authorization_id_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  uint64_t authorization_id;
};

/* 8369 */
typedef __Reply__io_service_get_matching_service_ool_t _Xio_service_get_matching_service_ool::Reply;

/* 9516 */
struct __Reply__io_service_get_matching_service_ool_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t service;
  NDR_record_t_0 NDR;
  kern_return_t result;
};

/* 8370 */
typedef __Reply__io_service_get_matching_service_t _Xio_service_get_matching_service::Reply;

/* 9517 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_get_matching_service_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t service;
};

/* 8371 */
typedef __Reply__io_connect_method_var_output_t _Xio_connect_method_var_output::Reply;

/* 9518 */
struct __Reply__io_connect_method_var_output_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t var_output;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t inband_outputCnt;
  char inband_output[4096];
  mach_msg_type_number_t scalar_outputCnt;
  __attribute__((packed)) __attribute__((aligned(1))) io_user_scalar_t scalar_output[16];
  mach_msg_type_number_t var_outputCnt;
};

/* 8372 */
typedef __Reply__io_registry_entry_get_registry_entry_id_t _Xio_registry_entry_get_registry_entry_id::Reply;

/* 9519 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_registry_entry_get_registry_entry_id_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  uint64_t entry_id;
};

/* 8373 */
typedef __Reply__io_service_add_notification_ool_64_t _Xio_service_add_notification_ool_64::Reply;

/* 9520 */
struct __Reply__io_service_add_notification_ool_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t notification;
  NDR_record_t_0 NDR;
  kern_return_t result;
};

/* 8374 */
typedef __Reply__io_service_add_interest_notification_64_t _Xio_service_add_interest_notification_64::Reply;

/* 9521 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_add_interest_notification_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t notification;
};

/* 8375 */
typedef __Reply__io_service_add_notification_64_t _Xio_service_add_notification_64::Reply;

/* 9522 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_add_notification_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t notification;
};

/* 8376 */
typedef __Reply__io_connect_set_notification_port_64_t _Xio_connect_set_notification_port_64::Reply;

/* 9523 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_connect_set_notification_port_64_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8377 */
typedef __Reply__io_connect_async_method_t _Xio_connect_async_method::Reply;

/* 9524 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_connect_async_method_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t inband_outputCnt;
  char inband_output[4096];
  mach_msg_type_number_t scalar_outputCnt;
  io_user_scalar_t scalar_output[16];
  mach_vm_size_t_0 ool_output_size;
};

/* 8378 */
typedef __Reply__io_connect_method_t _Xio_connect_method::Reply;

/* 9525 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_connect_method_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t inband_outputCnt;
  char inband_output[4096];
  mach_msg_type_number_t scalar_outputCnt;
  io_user_scalar_t scalar_output[16];
  mach_vm_size_t_0 ool_output_size;
};

/* 8379 */
typedef __Reply__io_connect_unmap_memory_from_task_t _Xio_connect_unmap_memory_from_task::Reply;

/* 9526 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_connect_unmap_memory_from_task_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8380 */
typedef __Reply__io_connect_map_memory_into_task_t _Xio_connect_map_memory_into_task::Reply;

/* 9527 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_connect_map_memory_into_task_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
};

/* 8381 */
typedef __Reply__io_service_open_extended_t _Xio_service_open_extended::Reply;

/* 9528 */
struct __Reply__io_service_open_extended_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t connection;
  NDR_record_t_0 NDR;
  kern_return_t result;
};

/* 8382 */
typedef __Reply__io_object_get_bundle_identifier_t _Xio_object_get_bundle_identifier::Reply;

/* 9529 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_object_get_bundle_identifier_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t class_nameOffset;
  mach_msg_type_number_t class_nameCnt;
  char class_name[128];
};

/* 8383 */
typedef __Reply__io_object_get_superclass_t _Xio_object_get_superclass::Reply;

/* 9530 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_object_get_superclass_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t class_nameOffset;
  mach_msg_type_number_t class_nameCnt;
  char class_name[128];
};

/* 8384 */
typedef __Reply__io_service_add_notification_ool_t _Xio_service_add_notification_ool::Reply;

/* 9531 */
struct __Reply__io_service_add_notification_ool_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t notification;
  NDR_record_t_0 NDR;
  kern_return_t result;
};

/* 8385 */
typedef __Reply__io_service_match_property_table_ool_t _Xio_service_match_property_table_ool::Reply;

/* 9532 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_match_property_table_ool_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  kern_return_t result;
  boolean_t matches;
};

/* 8386 */
typedef __Reply__io_service_get_matching_services_ool_t _Xio_service_get_matching_services_ool::Reply;

/* 9533 */
struct __Reply__io_service_get_matching_services_ool_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t existing;
  NDR_record_t_0 NDR;
  kern_return_t result;
};

/* 8387 */
typedef __Reply__io_service_get_state_t _Xio_service_get_state::Reply;

/* 9534 */
struct __Reply__io_service_get_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t state;
  uint32_t busy_state;
  uint64_t accumulated_busy_time;
};

/* 8388 */
typedef __Reply__io_registry_entry_get_property_recursively_t _Xio_registry_entry_get_property_recursively::Reply;

/* 9535 */
struct __Reply__io_registry_entry_get_property_recursively_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t properties;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t propertiesCnt;
};

/* 8389 */
typedef __Reply__io_registry_entry_get_location_in_plane_t _Xio_registry_entry_get_location_in_plane::Reply;

/* 9536 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_registry_entry_get_location_in_plane_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t locationOffset;
  mach_msg_type_number_t locationCnt;
  char location[128];
};

/* 8390 */
typedef __Reply__io_connect_unmap_memory_t _Xio_connect_unmap_memory::Reply;

/* 9537 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_connect_unmap_memory_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8391 */
typedef __Reply__io_connect_get_notification_semaphore_t _Xio_connect_get_notification_semaphore::Reply;

/* 9538 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_connect_get_notification_semaphore_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t semaphore;
};

/* 8392 */
typedef __Reply__io_service_acknowledge_notification_t _Xio_service_acknowledge_notification::Reply;

/* 9539 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_acknowledge_notification_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8393 */
typedef __Reply__io_service_add_interest_notification_t _Xio_service_add_interest_notification::Reply;

/* 9540 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_add_interest_notification_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t notification;
};

/* 8394 */
typedef __Reply__io_service_add_notification_t _Xio_service_add_notification::Reply;

/* 9541 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_add_notification_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t notification;
};

/* 8395 */
typedef __Reply__io_async_method_structureI_structureO_t _Xio_async_method_structureI_structureO::Reply;

/* 9542 */
struct __Reply__io_async_method_structureI_structureO_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t outputCnt;
  char output[4096];
};

/* 8396 */
typedef __Reply__io_async_method_scalarI_structureI_t _Xio_async_method_scalarI_structureI::Reply;

/* 9543 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_async_method_scalarI_structureI_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8397 */
typedef __Reply__io_async_method_scalarI_structureO_t _Xio_async_method_scalarI_structureO::Reply;

/* 9544 */
struct __Reply__io_async_method_scalarI_structureO_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t outputCnt;
  char output[4096];
};

/* 8398 */
typedef __Reply__io_async_method_scalarI_scalarO_t _Xio_async_method_scalarI_scalarO::Reply;

/* 9545 */
struct __Reply__io_async_method_scalarI_scalarO_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t outputCnt;
  int output[16];
};

/* 8399 */
typedef __Reply__io_service_match_property_table_t _Xio_service_match_property_table::Reply;

/* 9546 */
struct __Reply__io_service_match_property_table_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  boolean_t matches;
};

/* 8400 */
typedef __Reply__io_registry_entry_get_name_in_plane_t _Xio_registry_entry_get_name_in_plane::Reply;

/* 9547 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_registry_entry_get_name_in_plane_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t nameOffset;
  mach_msg_type_number_t nameCnt;
  char name[128];
};

/* 8401 */
typedef __Reply__io_service_request_probe_t _Xio_service_request_probe::Reply;

/* 9548 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_request_probe_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8402 */
typedef __Reply__io_catalog_reset_t _Xio_catalog_reset::Reply;

/* 9549 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_catalog_reset_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8403 */
typedef __Reply__io_catalog_module_loaded_t _Xio_catalog_module_loaded::Reply;

/* 9550 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_catalog_module_loaded_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8404 */
typedef __Reply__io_catalog_get_gen_count_t _Xio_catalog_get_gen_count::Reply;

/* 9551 */
struct __Reply__io_catalog_get_gen_count_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  uint32_t genCount;
};

/* 8405 */
typedef __Reply__io_catalog_get_data_t _Xio_catalog_get_data::Reply;

/* 9552 */
struct __Reply__io_catalog_get_data_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t outData;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t outDataCnt;
};

/* 8406 */
typedef __Reply__io_catalog_terminate_t _Xio_catalog_terminate::Reply;

/* 9553 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_catalog_terminate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8407 */
typedef __Reply__io_catalog_send_data_t _Xio_catalog_send_data::Reply;

/* 9554 */
struct __Reply__io_catalog_send_data_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  kern_return_t result;
};

/* 8408 */
typedef __Reply__io_iterator_is_valid_t _Xio_iterator_is_valid::Reply;

/* 9555 */
struct __Reply__io_iterator_is_valid_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  boolean_t is_valid;
};

/* 8409 */
typedef __Reply__io_registry_entry_create_iterator_t _Xio_registry_entry_create_iterator::Reply;

/* 9556 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_registry_entry_create_iterator_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t iterator;
};

/* 8410 */
typedef __Reply__io_service_wait_quiet_t _Xio_service_wait_quiet::Reply;

/* 9557 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_wait_quiet_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8411 */
typedef __Reply__io_service_get_busy_state_t _Xio_service_get_busy_state::Reply;

/* 9558 */
struct __Reply__io_service_get_busy_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  uint32_t busyState;
};

/* 8412 */
typedef __Reply__io_object_get_retain_count_t _Xio_object_get_retain_count::Reply;

/* 9559 */
struct __Reply__io_object_get_retain_count_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  uint32_t retainCount;
};

/* 8413 */
typedef __Reply__io_registry_entry_in_plane_t _Xio_registry_entry_in_plane::Reply;

/* 9560 */
struct __Reply__io_registry_entry_in_plane_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  boolean_t inPlane;
};

/* 8414 */
typedef __Reply__io_registry_entry_set_properties_t _Xio_registry_entry_set_properties::Reply;

/* 9561 */
struct __Reply__io_registry_entry_set_properties_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  kern_return_t result;
};

/* 8415 */
typedef __Reply__io_registry_get_root_entry_t _Xio_registry_get_root_entry::Reply;

/* 9562 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_registry_get_root_entry_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t root;
};

/* 8416 */
typedef __Reply__io_registry_entry_get_path_t _Xio_registry_entry_get_path::Reply;

/* 9563 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_registry_entry_get_path_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t pathOffset;
  mach_msg_type_number_t pathCnt;
  char path[512];
};

/* 8417 */
typedef __Reply__io_connect_method_structureI_structureO_t _Xio_connect_method_structureI_structureO::Reply;

/* 9564 */
struct __Reply__io_connect_method_structureI_structureO_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t outputCnt;
  char output[4096];
};

/* 8418 */
typedef __Reply__io_connect_method_scalarI_structureI_t _Xio_connect_method_scalarI_structureI::Reply;

/* 9565 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_connect_method_scalarI_structureI_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8419 */
typedef __Reply__io_connect_method_scalarI_structureO_t _Xio_connect_method_scalarI_structureO::Reply;

/* 9566 */
struct __Reply__io_connect_method_scalarI_structureO_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t outputCnt;
  char output[4096];
};

/* 8420 */
typedef __Reply__io_connect_method_scalarI_scalarO_t _Xio_connect_method_scalarI_scalarO::Reply;

/* 9567 */
struct __Reply__io_connect_method_scalarI_scalarO_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t outputCnt;
  int output[16];
};

/* 8421 */
typedef __Reply__io_connect_set_properties_t _Xio_connect_set_properties::Reply;

/* 9568 */
struct __Reply__io_connect_set_properties_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  kern_return_t result;
};

/* 8422 */
typedef __Reply__io_connect_add_client_t _Xio_connect_add_client::Reply;

/* 9569 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_connect_add_client_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8423 */
typedef __Reply__io_connect_map_memory_t _Xio_connect_map_memory::Reply;

/* 9570 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_connect_map_memory_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  uint32_t address;
  uint32_t size;
};

/* 8424 */
typedef __Reply__io_connect_set_notification_port_t _Xio_connect_set_notification_port::Reply;

/* 9571 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_connect_set_notification_port_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8425 */
typedef __Reply__io_connect_get_service_t _Xio_connect_get_service::Reply;

/* 9572 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_connect_get_service_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t service;
};

/* 8426 */
typedef __Reply__io_service_close_t _Xio_service_close::Reply;

/* 9573 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_close_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8427 */
typedef __Reply__io_registry_entry_get_parent_iterator_t _Xio_registry_entry_get_parent_iterator::Reply;

/* 9574 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_registry_entry_get_parent_iterator_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t iterator;
};

/* 8428 */
typedef __Reply__io_registry_entry_get_child_iterator_t _Xio_registry_entry_get_child_iterator::Reply;

/* 9575 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_registry_entry_get_child_iterator_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t iterator;
};

/* 8429 */
typedef __Reply__io_registry_entry_get_property_bytes_t _Xio_registry_entry_get_property_bytes::Reply;

/* 9576 */
struct __Reply__io_registry_entry_get_property_bytes_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t dataCnt;
  char data[4096];
};

/* 8430 */
typedef __Reply__io_registry_entry_get_properties_t _Xio_registry_entry_get_properties::Reply;

/* 9577 */
struct __Reply__io_registry_entry_get_properties_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t properties;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t propertiesCnt;
};

/* 8431 */
typedef __Reply__io_registry_entry_get_name_t _Xio_registry_entry_get_name::Reply;

/* 9578 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_registry_entry_get_name_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t nameOffset;
  mach_msg_type_number_t nameCnt;
  char name[128];
};

/* 8432 */
typedef __Reply__io_registry_entry_from_path_t _Xio_registry_entry_from_path::Reply;

/* 9579 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_registry_entry_from_path_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t registry_entry;
};

/* 8433 */
typedef __Reply__io_registry_iterator_exit_entry_t _Xio_registry_iterator_exit_entry::Reply;

/* 9580 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_registry_iterator_exit_entry_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8434 */
typedef __Reply__io_registry_iterator_enter_entry_t _Xio_registry_iterator_enter_entry::Reply;

/* 9581 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_registry_iterator_enter_entry_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8435 */
typedef __Reply__io_registry_create_iterator_t _Xio_registry_create_iterator::Reply;

/* 9582 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_registry_create_iterator_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t iterator;
};

/* 8436 */
typedef __Reply__io_registry_entry_get_property_t _Xio_registry_entry_get_property::Reply;

/* 9583 */
struct __Reply__io_registry_entry_get_property_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t properties;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t propertiesCnt;
};

/* 8437 */
typedef __Reply__io_service_get_matching_services_t _Xio_service_get_matching_services::Reply;

/* 9584 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_service_get_matching_services_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t existing;
};

/* 8438 */
typedef __Reply__io_iterator_reset_t _Xio_iterator_reset::Reply;

/* 9585 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_iterator_reset_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8439 */
typedef __Reply__io_iterator_next_t _Xio_iterator_next::Reply;

/* 9586 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_iterator_next_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t object;
};

/* 8440 */
typedef __Reply__io_object_conforms_to_t _Xio_object_conforms_to::Reply;

/* 9587 */
struct __Reply__io_object_conforms_to_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  boolean_t conforms;
};

/* 8441 */
typedef __Reply__io_object_get_class_t _Xio_object_get_class::Reply;

/* 9588 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__io_object_get_class_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t classNameOffset;
  mach_msg_type_number_t classNameCnt;
  char className[128];
};

/* 8442 */
struct __attribute__((aligned(8))) task_watchport_elem_0
{
  task_t_0 twe_task;
  ipc_port_t_0 twe_port;
  _BYTE gap10[8];
};

/* 8443 */
typedef struct IOObject *io_object_t_1;

/* 8444 */
typedef int *vm_region_recurse_info_64_t;

/* 8446 */
typedef vm_offset_t pointer_t;

/* 8447 */
typedef uint64_t upl_control_flags_t;

/* 8448 */
struct vm_named_entry_kernel_flags_t
{
  _BYTE gap0[4];
};

/* 8449 */
typedef mach_vm_offset_t vm_shared_region_map_file::slid_mappings_t;

/* 8450 */
typedef vm_page_packed_queue_entry *vm_page_queue_entry_t;

/* 8454 */
typedef uint64_t chunk_state_t;

/* 8455 */
typedef _vm_map *vm_map_t_1;

/* 8456 */
typedef vm_region_top_info *vm_region_top_info_t;

/* 8457 */
typedef vm_region_extended_info *vm_region_extended_info_t;

/* 8460 */
typedef void kmem_range_id_t;

/* 8461 */
struct thread_pri_floor
{
  thread_t_0 thread;
};

/* 8462 */
typedef mach_port_t_0 memory_object_default_t;

/* 8463 */
struct vm_object_update::extent
{
  vm_object_offset_t e_base;
  vm_object_offset_t e_min;
  vm_object_offset_t e_max;
};

/* 8464 */
typedef int *memory_object_info_t;

/* 8465 */
typedef device_pager *device_pager_t;

/* 8466 */
typedef compressor_pager *compressor_pager_t;

/* 8467 */
typedef c_slot_mapping *c_slot_mapping_t;

/* 8468 */
typedef vnode_pager *vnode_pager_t;

/* 8469 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__region_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm_region_flavor_t flavor;
  mach_msg_type_number_t infoCnt;
};

/* 8470 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__allocate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  int flags;
};

/* 8471 */
struct __Request__deallocate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
};

/* 8472 */
struct __Request__protect_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  boolean_t set_maximum;
  vm_prot_t new_protection;
};

/* 8473 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__inherit_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  vm_inherit_t new_inheritance;
};

/* 8474 */
struct __Request__read_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
};

/* 8475 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__read_list_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_read_entry_t data_list;
  natural_t count;
};

/* 8476 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__write_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t data;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  mach_msg_type_number_t dataCnt;
};

/* 8477 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__copy_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t source_address;
  vm32_size_t size;
  vm32_address_t dest_address;
};

/* 8478 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__read_overwrite_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  vm32_address_t data;
};

/* 8479 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__msync_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  vm_sync_t sync_flags;
};

/* 8480 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__behavior_set_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  vm_behavior_t new_behavior;
};

/* 8481 */
struct __Request__map_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t object;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  vm32_address_t mask;
  int flags;
  vm32_offset_t offset;
  boolean_t copy;
  vm_prot_t cur_protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
};

/* 8482 */
struct __Request__machine_attribute_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  vm_machine_attribute_t attribute;
  vm_machine_attribute_val_t value;
};

/* 8483 */
struct __Request__remap_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t src_task;
  NDR_record_t_0 NDR;
  vm32_address_t target_address;
  vm32_size_t size;
  vm32_address_t mask;
  boolean_t anywhere;
  vm32_address_t src_address;
  boolean_t copy;
  vm_inherit_t inheritance;
};

/* 8484 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request___task_wire_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  boolean_t must_wire;
};

/* 8485 */
struct __Request__make_memory_entry_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t parent_entry;
  NDR_record_t_0 NDR;
  vm32_size_t size;
  vm32_offset_t offset;
  vm_prot_t permission;
};

/* 8486 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__map_page_query_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_offset_t offset;
};

/* 8487 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__region_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
};

/* 8488 */
struct __Request__mapped_pages_info_t
{
  mach_msg_header_t_0 Head;
};

/* 8489 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__region_recurse_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  natural_t nesting_depth;
  mach_msg_type_number_t infoCnt;
};

/* 8490 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__region_recurse_64_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  natural_t nesting_depth;
  mach_msg_type_number_t infoCnt;
};

/* 8491 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__region_info_64_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
};

/* 8492 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__region_64_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm_region_flavor_t flavor;
  mach_msg_type_number_t infoCnt;
};

/* 8493 */
struct __Request__make_memory_entry_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t parent_entry;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) memory_object_size_t size;
  __attribute__((packed)) __attribute__((aligned(1))) memory_object_offset_t offset;
  vm_prot_t permission;
};

/* 8494 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__map_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t object;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  vm32_address_t mask;
  int flags;
  memory_object_offset_t offset;
  boolean_t copy;
  vm_prot_t cur_protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
};

/* 8495 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__purgable_control_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm_purgable_t control;
  int state;
};

/* 8496 */
struct __Request___map_exec_lockdown_t
{
  mach_msg_header_t_0 Head;
};

/* 8497 */
typedef __Reply___map_exec_lockdown_t _X_map_exec_lockdown::Reply;

/* 9589 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply___map_exec_lockdown_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8498 */
typedef __Reply__purgable_control_t _Xpurgable_control::Reply;

/* 9590 */
struct __Reply__purgable_control_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int state;
};

/* 8499 */
typedef __Reply__map_64_t _Xmap_64::Reply;

/* 9591 */
struct __Reply__map_64_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  vm32_address_t address;
};

/* 8500 */
typedef __Reply__make_memory_entry_64_t _Xmake_memory_entry_64::Reply;

/* 9592 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__make_memory_entry_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t object_handle;
  NDR_record_t_0 NDR;
  memory_object_size_t size;
};

/* 8501 */
typedef __Reply__region_64_t _Xregion_64::Reply;

/* 9593 */
struct __Reply__region_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t object_name;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  mach_msg_type_number_t infoCnt;
  int info[10];
};

/* 8503 */
typedef __Reply__region_info_64_t _Xregion_info_64::Reply;

/* 9594 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__region_info_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t objects;
  NDR_record_t_0 NDR;
  vm_info_region_64_t region;
  mach_msg_type_number_t objectsCnt;
};

/* 8504 */
typedef __Reply__region_recurse_64_t _Xregion_recurse_64::Reply;

/* 9595 */
struct __Reply__region_recurse_64_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  vm32_address_t address;
  vm32_size_t size;
  natural_t nesting_depth;
  mach_msg_type_number_t infoCnt;
  int info[19];
};

/* 8505 */
typedef __Reply__region_recurse_t _Xregion_recurse::Reply;

/* 9596 */
struct __Reply__region_recurse_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  vm32_address_t address;
  vm32_size_t size;
  natural_t nesting_depth;
  mach_msg_type_number_t infoCnt;
  int info[19];
};

/* 8506 */
typedef __Reply__mapped_pages_info_t _Xmapped_pages_info::Reply;

/* 9597 */
struct __Reply__mapped_pages_info_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t pages;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t pagesCnt;
};

/* 8508 */
typedef __Reply__region_info_t _Xregion_info::Reply;

/* 9598 */
struct __Reply__region_info_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t objects;
  NDR_record_t_0 NDR;
  vm_info_region_t region;
  mach_msg_type_number_t objectsCnt;
};

/* 8509 */
typedef __Reply__map_page_query_t _Xmap_page_query::Reply;

/* 9599 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__map_page_query_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  integer_t disposition;
  integer_t ref_count;
};

/* 8510 */
typedef __Reply__make_memory_entry_t _Xmake_memory_entry::Reply;

/* 9600 */
struct __Reply__make_memory_entry_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t object_handle;
  NDR_record_t_0 NDR;
  vm32_size_t size;
};

/* 8511 */
typedef __Reply___task_wire_t _X_task_wire::Reply;

/* 9601 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply___task_wire_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8512 */
typedef __Reply__remap_t _Xremap::Reply;

/* 9602 */
struct __Reply__remap_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  vm32_address_t target_address;
  vm_prot_t cur_protection;
  vm_prot_t max_protection;
};

/* 8513 */
typedef __Reply__machine_attribute_t _Xmachine_attribute::Reply;

/* 9603 */
struct __Reply__machine_attribute_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  vm_machine_attribute_val_t value;
};

/* 8514 */
typedef __Reply__map_t _Xmap::Reply;

/* 9604 */
struct __Reply__map_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  vm32_address_t address;
};

/* 8515 */
typedef __Reply__behavior_set_t _Xbehavior_set::Reply;

/* 9605 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__behavior_set_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8516 */
typedef __Reply__msync_t _Xmsync::Reply;

/* 9606 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__msync_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8517 */
typedef __Reply__read_overwrite_t _Xread_overwrite::Reply;

/* 9607 */
struct __Reply__read_overwrite_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  vm32_size_t outsize;
};

/* 8518 */
typedef __Reply__copy_t _Xcopy::Reply;

/* 9608 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__copy_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8519 */
typedef __Reply__write_t _Xwrite::Reply;

/* 9609 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__write_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8520 */
typedef __Reply__read_list_t _Xread_list::Reply;

/* 9610 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__read_list_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  vm32_read_entry_t data_list;
};

/* 8521 */
typedef __Reply__read_t _Xread::Reply;

/* 9611 */
struct __Reply__read_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t data;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t dataCnt;
};

/* 8522 */
typedef __Reply__inherit_t _Xinherit::Reply;

/* 9612 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__inherit_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8523 */
typedef __Reply__protect_t _Xprotect::Reply;

/* 9613 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__protect_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8524 */
typedef __Reply__deallocate_t _Xdeallocate::Reply;

/* 9614 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__deallocate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8525 */
typedef __Reply__allocate_t _Xallocate::Reply;

/* 9615 */
struct __Reply__allocate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  vm32_address_t address;
};

/* 8526 */
typedef __Reply__region_t _Xregion::Reply;

/* 9616 */
struct __Reply__region_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t object_name;
  NDR_record_t_0 NDR;
  vm32_address_t address;
  vm32_size_t size;
  mach_msg_type_number_t infoCnt;
  int info[10];
};

/* 8527 */
struct __Request__thread_terminate_from_user_t
{
  mach_msg_header_t_0 Head;
};

/* 8528 */
struct __Request__act_get_state_to_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int flavor;
  mach_msg_type_number_t old_stateCnt;
};

/* 8529 */
struct __Request__act_set_state_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
};

/* 8530 */
struct __Request__thread_get_state_to_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_state_flavor_t flavor;
  mach_msg_type_number_t old_stateCnt;
};

/* 8531 */
struct __Request__thread_set_state_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_state_flavor_t flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
};

/* 8532 */
struct __Request__thread_suspend_t
{
  mach_msg_header_t_0 Head;
};

/* 8533 */
struct __Request__thread_resume_t
{
  mach_msg_header_t_0 Head;
};

/* 8534 */
struct __Request__thread_abort_t
{
  mach_msg_header_t_0 Head;
};

/* 8535 */
struct __Request__thread_abort_safely_t
{
  mach_msg_header_t_0 Head;
};

/* 8536 */
struct __Request__thread_depress_abort_from_user_t
{
  mach_msg_header_t_0 Head;
};

/* 8537 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__thread_get_special_port_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int which_port;
};

/* 8538 */
struct __Request__thread_set_special_port_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t special_port;
  NDR_record_t_0 NDR;
  int which_port;
};

/* 8539 */
struct __Request__thread_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_flavor_t flavor;
  mach_msg_type_number_t thread_info_outCnt;
};

/* 8540 */
struct __Request__thread_set_exception_ports_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t new_port;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  exception_behavior_t behavior;
  thread_state_flavor_t new_flavor;
};

/* 8541 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__thread_get_exception_ports_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
};

/* 8542 */
struct __Request__thread_swap_exception_ports_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t new_port;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  exception_behavior_t behavior;
  thread_state_flavor_t new_flavor;
};

/* 8543 */
struct __Request__thread_policy_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  policy_t policy;
  mach_msg_type_number_t baseCnt;
  integer_t base[5];
  boolean_t set_limit;
};

/* 8544 */
struct __Request__thread_policy_set_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_policy_flavor_t flavor;
  mach_msg_type_number_t policy_infoCnt;
  integer_t policy_info[16];
};

/* 8545 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__thread_policy_get_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_policy_flavor_t flavor;
  mach_msg_type_number_t policy_infoCnt;
  boolean_t get_default;
};

/* 8546 */
struct __Request__thread_set_policy_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t pset;
  NDR_record_t_0 NDR;
  policy_t policy;
  mach_msg_type_number_t baseCnt;
  integer_t base[5];
  mach_msg_type_number_t limitCnt;
  integer_t limit[1];
};

/* 8547 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__thread_get_mach_voucher_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_voucher_selector_t which;
};

/* 8548 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__thread_set_mach_voucher_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t voucher;
};

/* 8549 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__thread_swap_mach_voucher_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t new_voucher;
  mach_msg_port_descriptor_t old_voucher;
};

/* 8550 */
struct __Request__thread_convert_thread_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int direction;
  thread_state_flavor_t flavor;
  mach_msg_type_number_t in_stateCnt;
  natural_t in_state[1296];
  mach_msg_type_number_t out_stateCnt;
};

/* 8551 */
struct __Request__thread_raise_exception_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int exception;
  natural_t code_count;
  int64_t code;
  int64_t sub_code;
};

/* 8552 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__thread_get_exception_ports_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
};

/* 8554 */
typedef __Reply__thread_get_exception_ports_info_t _Xthread_get_exception_ports_info::Reply;

/* 9617 */
struct __Reply__thread_get_exception_ports_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t masksCnt;
  exception_mask_t masks[32];
  exception_handler_info_t old_handlers_info[32];
  exception_behavior_t old_behaviors[32];
  thread_state_flavor_t old_flavors[32];
};

/* 8555 */
typedef __Reply__thread_raise_exception_t _Xthread_raise_exception::Reply;

/* 9618 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_raise_exception_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8556 */
typedef __Reply__thread_convert_thread_state_t _Xthread_convert_thread_state::Reply;

/* 9619 */
struct __Reply__thread_convert_thread_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t out_stateCnt;
  natural_t out_state[1296];
};

/* 8557 */
typedef __Reply__thread_swap_mach_voucher_t _Xthread_swap_mach_voucher::Reply;

/* 9620 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_swap_mach_voucher_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t old_voucher;
};

/* 8558 */
typedef __Reply__thread_set_mach_voucher_t _Xthread_set_mach_voucher::Reply;

/* 9621 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_set_mach_voucher_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8559 */
typedef __Reply__thread_get_mach_voucher_t _Xthread_get_mach_voucher::Reply;

/* 9622 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_get_mach_voucher_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t voucher;
};

/* 8560 */
typedef __Reply__thread_set_policy_t _Xthread_set_policy::Reply;

/* 9623 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_set_policy_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8561 */
typedef __Reply__thread_policy_get_t _Xthread_policy_get::Reply;

/* 9624 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_policy_get_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t policy_infoCnt;
  integer_t policy_info[16];
  boolean_t get_default;
};

/* 8562 */
typedef __Reply__thread_policy_set_t _Xthread_policy_set::Reply;

/* 9625 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_policy_set_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8563 */
typedef __Reply__thread_policy_t _Xthread_policy::Reply;

/* 9626 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_policy_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8564 */
typedef __Reply__thread_swap_exception_ports_t _Xthread_swap_exception_ports::Reply;

/* 9627 */
struct __Reply__thread_swap_exception_ports_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t old_handlers[32];
  NDR_record_t_0 NDR;
  mach_msg_type_number_t masksCnt;
  exception_mask_t masks[32];
  exception_behavior_t old_behaviors[32];
  thread_state_flavor_t old_flavors[32];
};

/* 8565 */
typedef __Reply__thread_get_exception_ports_from_user_t _Xthread_get_exception_ports_from_user::Reply;

/* 9628 */
struct __Reply__thread_get_exception_ports_from_user_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t old_handlers[32];
  NDR_record_t_0 NDR;
  mach_msg_type_number_t masksCnt;
  exception_mask_t masks[32];
  exception_behavior_t old_behaviors[32];
  thread_state_flavor_t old_flavors[32];
};

/* 8566 */
typedef __Reply__thread_set_exception_ports_t _Xthread_set_exception_ports::Reply;

/* 9629 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_set_exception_ports_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8567 */
typedef __Reply__thread_info_t _Xthread_info::Reply;

/* 9630 */
struct __Reply__thread_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t thread_info_outCnt;
  integer_t thread_info_out[32];
};

/* 8568 */
typedef __Reply__thread_set_special_port_t _Xthread_set_special_port::Reply;

/* 9631 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_set_special_port_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8569 */
typedef __Reply__thread_get_special_port_from_user_t _Xthread_get_special_port_from_user::Reply;

/* 9632 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_get_special_port_from_user_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t special_port;
};

/* 8570 */
typedef __Reply__thread_depress_abort_from_user_t _Xthread_depress_abort_from_user::Reply;

/* 9633 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_depress_abort_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8571 */
typedef __Reply__thread_abort_safely_t _Xthread_abort_safely::Reply;

/* 9634 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_abort_safely_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8572 */
typedef __Reply__thread_abort_t _Xthread_abort::Reply;

/* 9635 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_abort_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8573 */
typedef __Reply__thread_resume_t _Xthread_resume::Reply;

/* 9636 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_resume_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8574 */
typedef __Reply__thread_suspend_t _Xthread_suspend::Reply;

/* 9637 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_suspend_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8575 */
typedef __Reply__thread_set_state_from_user_t _Xthread_set_state_from_user::Reply;

/* 9638 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_set_state_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8576 */
typedef __Reply__thread_get_state_to_user_t _Xthread_get_state_to_user::Reply;

/* 9639 */
struct __Reply__thread_get_state_to_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
};

/* 8577 */
typedef __Reply__act_set_state_from_user_t _Xact_set_state_from_user::Reply;

/* 9640 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__act_set_state_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8578 */
typedef __Reply__act_get_state_to_user_t _Xact_get_state_to_user::Reply;

/* 9641 */
struct __Reply__act_get_state_to_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
};

/* 8579 */
typedef __Reply__thread_terminate_from_user_t _Xthread_terminate_from_user::Reply;

/* 9642 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_terminate_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8580 */
struct __Request__task_terminate_t
{
  mach_msg_header_t_0 Head;
};

/* 8581 */
struct __Request__task_threads_from_user_t
{
  mach_msg_header_t_0 Head;
};

/* 8582 */
struct __Request__mach_ports_register_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_ports_descriptor_t init_port_set;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t init_port_setCnt;
};

/* 8583 */
struct __Request__mach_ports_lookup_t
{
  mach_msg_header_t_0 Head;
};

/* 8584 */
struct __Request__task_info_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_flavor_t flavor;
  mach_msg_type_number_t task_info_outCnt;
};

/* 8585 */
struct __Request__task_set_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_flavor_t flavor;
  mach_msg_type_number_t task_info_inCnt;
  integer_t task_info_in[90];
};

/* 8586 */
struct __Request__task_suspend_t
{
  mach_msg_header_t_0 Head;
};

/* 8587 */
struct __Request__task_resume_t
{
  mach_msg_header_t_0 Head;
};

/* 8588 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_get_special_port_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int which_port;
};

/* 8589 */
struct __Request__task_set_special_port_from_user_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t special_port;
  NDR_record_t_0 NDR;
  int which_port;
};

/* 8590 */
struct __Request__thread_create_from_user_t
{
  mach_msg_header_t_0 Head;
};

/* 8591 */
struct __Request__thread_create_running_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_state_flavor_t flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
};

/* 8592 */
struct __Request__task_set_exception_ports_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t new_port;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  exception_behavior_t behavior;
  thread_state_flavor_t new_flavor;
};

/* 8593 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_get_exception_ports_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
};

/* 8594 */
struct __Request__task_swap_exception_ports_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t new_port;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  exception_behavior_t behavior;
  thread_state_flavor_t new_flavor;
};

/* 8595 */
struct __Request__semaphore_create_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int policy;
  int value;
};

/* 8596 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__semaphore_destroy_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t semaphore;
};

/* 8597 */
struct __Request__task_policy_set_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_policy_flavor_t flavor;
  mach_msg_type_number_t policy_infoCnt;
  integer_t policy_info[16];
};

/* 8598 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_policy_get_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_policy_flavor_t flavor;
  mach_msg_type_number_t policy_infoCnt;
  boolean_t get_default;
};

/* 8599 */
struct __Request__task_get_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_state_flavor_t flavor;
  mach_msg_type_number_t old_stateCnt;
};

/* 8600 */
struct __Request__task_set_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  thread_state_flavor_t flavor;
  mach_msg_type_number_t new_stateCnt;
  natural_t new_state[1296];
};

/* 8601 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_set_phys_footprint_limit_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int new_limit;
};

/* 8602 */
struct __Request__task_suspend2_mig_t
{
  mach_msg_header_t_0 Head;
};

/* 8603 */
struct __Request__task_resume2_mig_t
{
  mach_msg_header_t_0 Head;
};

/* 8604 */
struct __Request__task_purgable_info_t
{
  mach_msg_header_t_0 Head;
};

/* 8605 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_get_mach_voucher_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_voucher_selector_t which;
};

/* 8606 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_set_mach_voucher_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t voucher;
};

/* 8607 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_swap_mach_voucher_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t new_voucher;
  mach_msg_port_descriptor_t old_voucher;
};

/* 8608 */
struct __Request__task_generate_corpse_t
{
  mach_msg_header_t_0 Head;
};

/* 8609 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_map_corpse_info_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t corspe_task;
};

/* 8610 */
struct __Request__task_register_dyld_image_infos_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t dyld_images;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t dyld_imagesCnt;
};

/* 8611 */
struct __Request__task_unregister_dyld_image_infos_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t dyld_images;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t dyld_imagesCnt;
};

/* 8612 */
struct __Request__task_get_dyld_image_infos_t
{
  mach_msg_header_t_0 Head;
};

/* 8613 */
struct __Request__task_register_dyld_shared_cache_image_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  dyld_kernel_image_info_t dyld_cache_image;
  boolean_t no_cache;
  boolean_t private_cache;
};

/* 8614 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_register_dyld_set_dyld_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint8_t dyld_state;
  char dyld_statePad[3];
};

/* 8615 */
struct __Request__task_register_dyld_get_process_state_t
{
  mach_msg_header_t_0 Head;
};

/* 8616 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_map_corpse_info_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t corspe_task;
};

/* 8617 */
struct __Request__task_inspect_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_inspect_flavor_t flavor;
  mach_msg_type_number_t info_outCnt;
};

/* 8618 */
struct __Request__task_get_exc_guard_behavior_t
{
  mach_msg_header_t_0 Head;
};

/* 8619 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_set_exc_guard_behavior_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_exc_guard_behavior_t behavior;
};

/* 8620 */
struct __Request__mach_task_is_self_t
{
  mach_msg_header_t_0 Head;
};

/* 8621 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_dyld_process_info_notify_register_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t notify;
};

/* 8622 */
struct __Request__task_create_identity_token_t
{
  mach_msg_header_t_0 Head;
};

/* 8623 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_identity_token_get_task_port_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_flavor_t flavor;
};

/* 8624 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_dyld_process_info_notify_deregister_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 notify;
};

/* 8625 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_get_exception_ports_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
};

/* 8626 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_test_sync_upcall_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t port;
};

/* 8627 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_set_corpse_forking_behavior_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  task_corpse_forking_behavior_t behavior;
};

/* 8628 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_test_async_upcall_propagation_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t port;
  NDR_record_t_0 NDR;
  int qos;
  int iotier;
};

/* 8629 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_map_kcdata_object_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t kcdata_object;
};

/* 8630 */
typedef __Reply__task_map_kcdata_object_64_t _Xtask_map_kcdata_object_64::Reply;

/* 9643 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_map_kcdata_object_64_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_vm_address_t_0 kcd_addr_begin;
  mach_vm_size_t_0 kcd_size;
};

/* 8631 */
typedef __Reply__task_test_async_upcall_propagation_t _Xtask_test_async_upcall_propagation::Reply;

/* 9644 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_test_async_upcall_propagation_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8632 */
typedef __Reply__task_set_corpse_forking_behavior_t _Xtask_set_corpse_forking_behavior::Reply;

/* 9645 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_set_corpse_forking_behavior_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8633 */
typedef __Reply__task_test_sync_upcall_t _Xtask_test_sync_upcall::Reply;

/* 9646 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_test_sync_upcall_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8634 */
typedef __Reply__task_get_exception_ports_info_t _Xtask_get_exception_ports_info::Reply;

/* 9647 */
struct __Reply__task_get_exception_ports_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t masksCnt;
  exception_mask_t masks[32];
  exception_handler_info_t old_handlers_info[32];
  exception_behavior_t old_behaviors[32];
  thread_state_flavor_t old_flavors[32];
};

/* 8635 */
typedef __Reply__task_dyld_process_info_notify_deregister_t _Xtask_dyld_process_info_notify_deregister::Reply;

/* 9648 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_dyld_process_info_notify_deregister_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8636 */
typedef __Reply__task_identity_token_get_task_port_t _Xtask_identity_token_get_task_port::Reply;

/* 9649 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_identity_token_get_task_port_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t task_port;
};

/* 8637 */
typedef __Reply__task_create_identity_token_t _Xtask_create_identity_token::Reply;

/* 9650 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_create_identity_token_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t token;
};

/* 8638 */
typedef __Reply__task_dyld_process_info_notify_register_t _Xtask_dyld_process_info_notify_register::Reply;

/* 9651 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_dyld_process_info_notify_register_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8639 */
typedef __Reply__mach_task_is_self_t _Xmach_task_is_self::Reply;

/* 9652 */
struct __Reply__mach_task_is_self_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  boolean_t is_self;
};

/* 8640 */
typedef __Reply__task_set_exc_guard_behavior_t _Xtask_set_exc_guard_behavior::Reply;

/* 9653 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_set_exc_guard_behavior_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8641 */
typedef __Reply__task_get_exc_guard_behavior_t _Xtask_get_exc_guard_behavior::Reply;

/* 9654 */
struct __Reply__task_get_exc_guard_behavior_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  task_exc_guard_behavior_t behavior;
};

/* 8642 */
typedef __Reply__task_inspect_t _Xtask_inspect::Reply;

/* 9655 */
struct __Reply__task_inspect_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t info_outCnt;
  integer_t info_out[4];
};

/* 8643 */
typedef __Reply__task_map_corpse_info_64_t _Xtask_map_corpse_info_64::Reply;

/* 9656 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_map_corpse_info_64_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_vm_address_t_0 kcd_addr_begin;
  mach_vm_size_t_0 kcd_size;
};

/* 8645 */
typedef __Reply__task_register_dyld_get_process_state_t _Xtask_register_dyld_get_process_state::Reply;

/* 9658 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_register_dyld_get_process_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  dyld_kernel_process_info_t dyld_process_state;
};

/* 8646 */
typedef __Reply__task_register_dyld_set_dyld_state_t _Xtask_register_dyld_set_dyld_state::Reply;

/* 9659 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_register_dyld_set_dyld_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8647 */
typedef __Reply__task_register_dyld_shared_cache_image_info_t _Xtask_register_dyld_shared_cache_image_info::Reply;

/* 9660 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_register_dyld_shared_cache_image_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8648 */
typedef __Reply__task_get_dyld_image_infos_t _Xtask_get_dyld_image_infos::Reply;

/* 9661 */
struct __Reply__task_get_dyld_image_infos_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t dyld_images;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t dyld_imagesCnt;
};

/* 8649 */
typedef __Reply__task_unregister_dyld_image_infos_t _Xtask_unregister_dyld_image_infos::Reply;

/* 9662 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_unregister_dyld_image_infos_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8650 */
typedef __Reply__task_register_dyld_image_infos_t _Xtask_register_dyld_image_infos::Reply;

/* 9663 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_register_dyld_image_infos_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8651 */
typedef __Reply__task_map_corpse_info_t _Xtask_map_corpse_info::Reply;

/* 9664 */
struct __Reply__task_map_corpse_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  __attribute__((packed)) __attribute__((aligned(1))) vm_address_t_0 kcd_addr_begin;
  uint32_t kcd_size;
};

/* 8652 */
typedef __Reply__task_generate_corpse_t _Xtask_generate_corpse::Reply;

/* 9665 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_generate_corpse_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t corpse_task_port;
};

/* 8653 */
typedef __Reply__task_swap_mach_voucher_t _Xtask_swap_mach_voucher::Reply;

/* 9666 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_swap_mach_voucher_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t old_voucher;
};

/* 8654 */
typedef __Reply__task_set_mach_voucher_t _Xtask_set_mach_voucher::Reply;

/* 9667 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_set_mach_voucher_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8655 */
typedef __Reply__task_get_mach_voucher_t _Xtask_get_mach_voucher::Reply;

/* 9668 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_get_mach_voucher_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t voucher;
};

/* 8656 */
typedef __Reply__task_purgable_info_t _Xtask_purgable_info::Reply;

/* 9669 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_purgable_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  task_purgable_info_t stats;
};

/* 8657 */
typedef __Reply__task_resume2_mig_t _Xtask_resume2_mig::Reply;

/* 9670 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_resume2_mig_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8658 */
typedef __Reply__task_suspend2_mig_t _Xtask_suspend2_mig::Reply;

/* 9671 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_suspend2_mig_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t suspend_token;
};

/* 8659 */
typedef __Reply__task_set_phys_footprint_limit_t _Xtask_set_phys_footprint_limit::Reply;

/* 9672 */
struct __Reply__task_set_phys_footprint_limit_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int old_limit;
};

/* 8660 */
typedef __Reply__task_set_state_t _Xtask_set_state::Reply;

/* 9673 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_set_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8661 */
typedef __Reply__task_get_state_t _Xtask_get_state::Reply;

/* 9674 */
struct __Reply__task_get_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
};

/* 8662 */
typedef __Reply__task_policy_get_t _Xtask_policy_get::Reply;

/* 9675 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_policy_get_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t policy_infoCnt;
  integer_t policy_info[16];
  boolean_t get_default;
};

/* 8663 */
typedef __Reply__task_policy_set_t _Xtask_policy_set::Reply;

/* 9676 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_policy_set_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8664 */
typedef __Reply__semaphore_destroy_t _Xsemaphore_destroy::Reply;

/* 9677 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__semaphore_destroy_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8665 */
typedef __Reply__semaphore_create_t _Xsemaphore_create::Reply;

/* 9678 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__semaphore_create_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t semaphore;
};

/* 8666 */
typedef __Reply__task_swap_exception_ports_t _Xtask_swap_exception_ports::Reply;

/* 9679 */
struct __Reply__task_swap_exception_ports_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t old_handlers[32];
  NDR_record_t_0 NDR;
  mach_msg_type_number_t masksCnt;
  exception_mask_t masks[32];
  exception_behavior_t old_behaviors[32];
  thread_state_flavor_t old_flavors[32];
};

/* 8667 */
typedef __Reply__task_get_exception_ports_from_user_t _Xtask_get_exception_ports_from_user::Reply;

/* 9680 */
struct __Reply__task_get_exception_ports_from_user_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t old_handlers[32];
  NDR_record_t_0 NDR;
  mach_msg_type_number_t masksCnt;
  exception_mask_t masks[32];
  exception_behavior_t old_behaviors[32];
  thread_state_flavor_t old_flavors[32];
};

/* 8668 */
typedef __Reply__task_set_exception_ports_t _Xtask_set_exception_ports::Reply;

/* 9681 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_set_exception_ports_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8669 */
typedef __Reply__thread_create_running_from_user_t _Xthread_create_running_from_user::Reply;

/* 9682 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_create_running_from_user_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t child_act;
};

/* 8670 */
typedef __Reply__thread_create_from_user_t _Xthread_create_from_user::Reply;

/* 9683 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_create_from_user_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t child_act;
};

/* 8671 */
typedef __Reply__task_set_special_port_from_user_t _Xtask_set_special_port_from_user::Reply;

/* 9684 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_set_special_port_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8672 */
typedef __Reply__task_get_special_port_from_user_t _Xtask_get_special_port_from_user::Reply;

/* 9685 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_get_special_port_from_user_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t special_port;
};

/* 8673 */
typedef __Reply__task_resume_t _Xtask_resume::Reply;

/* 9686 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_resume_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8674 */
typedef __Reply__task_suspend_t _Xtask_suspend::Reply;

/* 9687 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_suspend_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8675 */
typedef __Reply__task_set_info_t _Xtask_set_info::Reply;

/* 9688 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_set_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8676 */
typedef __Reply__task_info_from_user_t _Xtask_info_from_user::Reply;

/* 9689 */
struct __Reply__task_info_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t task_info_outCnt;
  integer_t task_info_out[90];
};

/* 8677 */
typedef __Reply__mach_ports_lookup_t _Xmach_ports_lookup::Reply;

/* 9690 */
struct __Reply__mach_ports_lookup_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_ports_descriptor_t init_port_set;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t init_port_setCnt;
};

/* 8678 */
typedef __Reply__mach_ports_register_t _Xmach_ports_register::Reply;

/* 9691 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_ports_register_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8679 */
typedef __Reply__task_threads_from_user_t _Xtask_threads_from_user::Reply;

/* 9692 */
struct __Reply__task_threads_from_user_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_ports_descriptor_t act_list;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t act_listCnt;
};

/* 8680 */
typedef __Reply__task_terminate_t _Xtask_terminate::Reply;

/* 9693 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_terminate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8681 */
struct __Request__processor_set_statistics_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  processor_set_flavor_t flavor;
  mach_msg_type_number_t info_outCnt;
};

/* 8682 */
struct __Request__processor_set_tasks_t
{
  mach_msg_header_t_0 Head;
};

/* 8683 */
struct __Request__processor_set_threads_t
{
  mach_msg_header_t_0 Head;
};

/* 8684 */
struct __Request__processor_set_stack_usage_t
{
  mach_msg_header_t_0 Head;
};

/* 8685 */
struct __Request__processor_set_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int flavor;
  mach_msg_type_number_t info_outCnt;
};

/* 8686 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__processor_set_tasks_with_flavor_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_task_flavor_t flavor;
};

/* 8687 */
typedef __Reply__processor_set_tasks_with_flavor_t _Xprocessor_set_tasks_with_flavor::Reply;

/* 9694 */
struct __Reply__processor_set_tasks_with_flavor_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_ports_descriptor_t task_list;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t task_listCnt;
};

/* 8688 */
typedef __Reply__processor_set_info_t _Xprocessor_set_info::Reply;

/* 9695 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__processor_set_info_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t host;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t info_outCnt;
  integer_t info_out[5];
};

/* 8689 */
typedef __Reply__processor_set_stack_usage_t _Xprocessor_set_stack_usage::Reply;

/* 9696 */
struct __Reply__processor_set_stack_usage_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  unsigned int ltotal;
  vm_size_t_0 space;
  vm_size_t_0 resident;
  vm_size_t_0 maxusage;
  vm_offset_t maxstack;
};

/* 8690 */
typedef __Reply__processor_set_threads_t _Xprocessor_set_threads::Reply;

/* 9697 */
struct __Reply__processor_set_threads_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_ports_descriptor_t thread_list;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t thread_listCnt;
};

/* 8691 */
typedef __Reply__processor_set_tasks_t _Xprocessor_set_tasks::Reply;

/* 9698 */
struct __Reply__processor_set_tasks_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_ports_descriptor_t task_list;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t task_listCnt;
};

/* 8692 */
typedef __Reply__processor_set_statistics_t _Xprocessor_set_statistics::Reply;

/* 9699 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__processor_set_statistics_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t info_outCnt;
  integer_t info_out[5];
};

/* 8693 */
struct __Request__processor_start_from_user_t
{
  mach_msg_header_t_0 Head;
};

/* 8694 */
struct __Request__processor_exit_from_user_t
{
  mach_msg_header_t_0 Head;
};

/* 8695 */
struct __Request__processor_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  processor_flavor_t flavor;
  mach_msg_type_number_t processor_info_outCnt;
};

/* 8696 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__processor_control_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t processor_cmdCnt;
  integer_t processor_cmd[20];
};

/* 8697 */
struct __Request__processor_assign_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t new_set;
  NDR_record_t_0 NDR;
  boolean_t wait;
};

/* 8698 */
struct __Request__processor_get_assignment_t
{
  mach_msg_header_t_0 Head;
};

/* 8699 */
typedef __Reply__processor_get_assignment_t _Xprocessor_get_assignment::Reply;

/* 9700 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__processor_get_assignment_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t assigned_set;
};

/* 8700 */
typedef __Reply__processor_assign_t _Xprocessor_assign::Reply;

/* 9701 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__processor_assign_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8701 */
typedef __Reply__processor_control_t _Xprocessor_control::Reply;

/* 9702 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__processor_control_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8702 */
typedef __Reply__processor_info_t _Xprocessor_info::Reply;

/* 9703 */
struct __Reply__processor_info_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t host;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t processor_info_outCnt;
  integer_t processor_info_out[20];
};

/* 8703 */
typedef __Reply__processor_exit_from_user_t _Xprocessor_exit_from_user::Reply;

/* 9704 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__processor_exit_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8704 */
typedef __Reply__processor_start_from_user_t _Xprocessor_start_from_user::Reply;

/* 9705 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__processor_start_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8705 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__arcade_register_new_upcall_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t arcade_upcall;
};

/* 8706 */
typedef __Reply__arcade_register_new_upcall_t Reply;

/* 9706 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__arcade_register_new_upcall_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8708 */
typedef bank_account *bank_account_t;

/* 8710 */
enum kcdata_compression_flush : __int32
{
  kcdata_compression_flush::KCDCF_NO_FLUSH = 0x0,
  kcdata_compression_flush::KCDCF_SYNC_FLUSH = 0x1,
  kcdata_compression_flush::KCDCF_FINISH = 0x2,
};

/* 8711 */
typedef const char *string_t_0;

/* 8712 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_restartable_ranges_register_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t rangesCnt;
  task_restartable_range_t ranges[64];
};

/* 8713 */
struct __Request__task_restartable_ranges_synchronize_t
{
  mach_msg_header_t_0 Head;
};

/* 8714 */
typedef __Reply__task_restartable_ranges_synchronize_t _Xtask_restartable_ranges_synchronize::Reply;

/* 9709 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_restartable_ranges_synchronize_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8715 */
typedef __Reply__task_restartable_ranges_register_t _Xtask_restartable_ranges_register::Reply;

/* 9710 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_restartable_ranges_register_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8716 */
struct __Request__mach_memory_entry_purgable_control_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  vm_purgable_t control;
  int state;
};

/* 8717 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_memory_entry_access_tracking_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int access_tracking;
};

/* 8718 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_memory_entry_ownership_from_user_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t owner;
  NDR_record_t_0 NDR;
  int ledger_tag;
  int ledger_flags;
};

/* 8719 */
typedef __Reply__mach_memory_entry_ownership_from_user_t _Xmach_memory_entry_ownership_from_user::Reply;

/* 9711 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_memory_entry_ownership_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8720 */
typedef __Reply__mach_memory_entry_access_tracking_t _Xmach_memory_entry_access_tracking::Reply;

/* 9712 */
struct __Reply__mach_memory_entry_access_tracking_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int access_tracking;
  uint32_t access_tracking_reads;
  uint32_t access_tracking_writes;
};

/* 8721 */
typedef __Reply__mach_memory_entry_purgable_control_t _Xmach_memory_entry_purgable_control::Reply;

/* 9713 */
struct __Reply__mach_memory_entry_purgable_control_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int state;
};

/* 8722 */
struct __Request__mach_voucher_extract_attr_content_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_voucher_attr_key_t key;
  mach_msg_type_number_t contentCnt;
};

/* 8723 */
struct __Request__mach_voucher_extract_attr_recipe_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_voucher_attr_key_t key;
  mach_msg_type_number_t recipeCnt;
};

/* 8724 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_voucher_extract_all_attr_recipes_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t recipesCnt;
};

/* 8725 */
struct __Request__mach_voucher_attr_command_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_voucher_attr_key_t key;
  mach_voucher_attr_command_t command;
  mach_msg_type_number_t in_contentCnt;
  uint8_t in_content[4096];
  mach_msg_type_number_t out_contentCnt;
};

/* 8726 */
struct __Request__mach_voucher_debug_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 voucher_name;
  mach_msg_type_number_t recipesCnt;
};

/* 8727 */
typedef __Reply__mach_voucher_debug_info_t _Xmach_voucher_debug_info::Reply;

/* 9714 */
struct __Reply__mach_voucher_debug_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t recipesCnt;
  uint8_t recipes[5120];
};

/* 8728 */
typedef __Reply__mach_voucher_attr_command_t _Xmach_voucher_attr_command::Reply;

/* 9715 */
struct __Reply__mach_voucher_attr_command_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t out_contentCnt;
  uint8_t out_content[4096];
};

/* 8729 */
typedef __Reply__mach_voucher_extract_all_attr_recipes_t _Xmach_voucher_extract_all_attr_recipes::Reply;

/* 9716 */
struct __Reply__mach_voucher_extract_all_attr_recipes_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t recipesCnt;
  uint8_t recipes[5120];
};

/* 8730 */
typedef __Reply__mach_voucher_extract_attr_recipe_t _Xmach_voucher_extract_attr_recipe::Reply;

/* 9717 */
struct __Reply__mach_voucher_extract_attr_recipe_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t recipeCnt;
  uint8_t recipe[4096];
};

/* 8731 */
typedef __Reply__mach_voucher_extract_attr_content_t _Xmach_voucher_extract_attr_content::Reply;

/* 9718 */
struct __Reply__mach_voucher_extract_attr_content_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t contentCnt;
  uint8_t content[4096];
};

/* 8732 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_vm_allocate_external_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  int flags;
};

/* 8733 */
struct __Request__mach_vm_deallocate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
};

/* 8734 */
struct __Request__mach_vm_protect_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  boolean_t set_maximum;
  vm_prot_t new_protection;
};

/* 8735 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_vm_inherit_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  vm_inherit_t new_inheritance;
};

/* 8736 */
struct __Request__mach_vm_read_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
};

/* 8737 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_vm_read_list_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_read_entry_t data_list;
  natural_t count;
};

/* 8738 */
struct __Request__mach_vm_write_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t data;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 address;
  mach_msg_type_number_t dataCnt;
};

/* 8739 */
struct __Request__mach_vm_copy_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 source_address;
  mach_vm_size_t_0 size;
  mach_vm_address_t_0 dest_address;
};

/* 8740 */
struct __Request__mach_vm_read_overwrite_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  mach_vm_address_t_0 data;
};

/* 8741 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_vm_msync_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  vm_sync_t sync_flags;
};

/* 8742 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_vm_behavior_set_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  vm_behavior_t new_behavior;
};

/* 8743 */
struct __Request__mach_vm_map_external_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t object;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 address;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_size_t_0 size;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_offset_t mask;
  int flags;
  memory_object_offset_t offset;
  boolean_t copy;
  vm_prot_t cur_protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
};

/* 8744 */
struct __Request__mach_vm_machine_attribute_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  mach_vm_size_t_0 size;
  vm_machine_attribute_t attribute;
  vm_machine_attribute_val_t value;
};

/* 8745 */
struct __Request__mach_vm_remap_external_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t src_task;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 target_address;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_size_t_0 size;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_offset_t mask;
  int flags;
  mach_vm_address_t_0 src_address;
  boolean_t copy;
  vm_inherit_t inheritance;
};

/* 8746 */
struct __Request__mach_vm_page_query_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_offset_t offset;
};

/* 8747 */
struct __Request__mach_vm_region_recurse_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  natural_t nesting_depth;
  mach_msg_type_number_t infoCnt;
};

/* 8748 */
struct __Request__mach_vm_region_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  vm_region_flavor_t flavor;
  mach_msg_type_number_t infoCnt;
};

/* 8749 */
struct __Request___mach_make_memory_entry_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t parent_handle;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) memory_object_size_t size;
  __attribute__((packed)) __attribute__((aligned(1))) memory_object_offset_t offset;
  vm_prot_t permission;
};

/* 8750 */
struct __Request__mach_vm_purgable_control_external_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  vm_purgable_t control;
  int state;
};

/* 8751 */
struct __Request__mach_vm_page_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_address_t_0 address;
  vm_page_info_flavor_t flavor;
  mach_msg_type_number_t infoCnt;
};

/* 8752 */
struct __Request__mach_vm_page_range_query_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_offset_t address;
  mach_vm_size_t_0 size;
  mach_vm_address_t_0 dispositions;
  mach_vm_size_t_0 dispositions_count;
};

/* 8753 */
struct __Request__mach_vm_remap_new_external_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t src_tport;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 target_address;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_size_t_0 size;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_offset_t mask;
  int flags;
  mach_vm_address_t_0 src_address;
  boolean_t copy;
  vm_prot_t cur_protection;
  vm_prot_t max_protection;
  vm_inherit_t inheritance;
};

/* 8754 */
struct __Request__mach_vm_deferred_reclamation_buffer_init_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_offset_t address;
  mach_vm_size_t_0 size;
  mach_vm_address_t_0 indices;
};

/* 8755 */
struct __Request__mach_vm_deferred_reclamation_buffer_synchronize_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_size_t_0 num_entries_to_reclaim;
};

/* 8756 */
struct __Request__mach_vm_deferred_reclamation_buffer_update_reclaimable_bytes_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_vm_size_t_0 reclaimable_bytes;
};

/* 8757 */
typedef __Reply__mach_vm_deferred_reclamation_buffer_update_reclaimable_bytes_t _Xmach_vm_deferred_reclamation_buffer_update_reclaimable_bytes::Reply;

/* 9719 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_deferred_reclamation_buffer_update_reclaimable_bytes_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8758 */
typedef __Reply__mach_vm_deferred_reclamation_buffer_synchronize_t _Xmach_vm_deferred_reclamation_buffer_synchronize::Reply;

/* 9720 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_deferred_reclamation_buffer_synchronize_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8759 */
typedef __Reply__mach_vm_deferred_reclamation_buffer_init_t _Xmach_vm_deferred_reclamation_buffer_init::Reply;

/* 9721 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_deferred_reclamation_buffer_init_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8760 */
typedef __Reply__mach_vm_remap_new_external_t _Xmach_vm_remap_new_external::Reply;

/* 9722 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_remap_new_external_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_vm_address_t_0 target_address;
  vm_prot_t cur_protection;
  vm_prot_t max_protection;
};

/* 8761 */
typedef __Reply__mach_vm_page_range_query_t _Xmach_vm_page_range_query::Reply;

/* 9723 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_page_range_query_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_vm_size_t_0 dispositions_count;
};

/* 8762 */
typedef __Reply__mach_vm_page_info_t _Xmach_vm_page_info::Reply;

/* 9724 */
struct __Reply__mach_vm_page_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t infoCnt;
  int info[32];
};

/* 8763 */
typedef __Reply__mach_vm_purgable_control_external_t _Xmach_vm_purgable_control_external::Reply;

/* 9725 */
struct __Reply__mach_vm_purgable_control_external_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  int state;
};

/* 8764 */
typedef __Reply___mach_make_memory_entry_t _X_mach_make_memory_entry::Reply;

/* 9726 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply___mach_make_memory_entry_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t object_handle;
  NDR_record_t_0 NDR;
  memory_object_size_t size;
};

/* 8765 */
typedef __Reply__mach_vm_region_t _Xmach_vm_region::Reply;

/* 9727 */
struct __Reply__mach_vm_region_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t object_name;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 address;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_size_t_0 size;
  mach_msg_type_number_t infoCnt;
  int info[10];
};

/* 8766 */
typedef __Reply__mach_vm_region_recurse_t _Xmach_vm_region_recurse::Reply;

/* 9728 */
struct __Reply__mach_vm_region_recurse_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 address;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_size_t_0 size;
  natural_t nesting_depth;
  mach_msg_type_number_t infoCnt;
  int info[19];
};

/* 8767 */
typedef __Reply__mach_vm_page_query_t _Xmach_vm_page_query::Reply;

/* 9729 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_page_query_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  integer_t disposition;
  integer_t ref_count;
};

/* 8768 */
typedef __Reply__mach_vm_remap_external_t _Xmach_vm_remap_external::Reply;

/* 9730 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_remap_external_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_vm_address_t_0 target_address;
  vm_prot_t cur_protection;
  vm_prot_t max_protection;
};

/* 8769 */
typedef __Reply__mach_vm_machine_attribute_t _Xmach_vm_machine_attribute::Reply;

/* 9731 */
struct __Reply__mach_vm_machine_attribute_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  vm_machine_attribute_val_t value;
};

/* 8770 */
typedef __Reply__mach_vm_map_external_t _Xmach_vm_map_external::Reply;

/* 9732 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_map_external_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_vm_address_t_0 address;
};

/* 8771 */
typedef __Reply__mach_vm_behavior_set_t _Xmach_vm_behavior_set::Reply;

/* 9733 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_behavior_set_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8772 */
typedef __Reply__mach_vm_msync_t _Xmach_vm_msync::Reply;

/* 9734 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_msync_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8773 */
typedef __Reply__mach_vm_read_overwrite_t _Xmach_vm_read_overwrite::Reply;

/* 9735 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_read_overwrite_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_vm_size_t_0 outsize;
};

/* 8774 */
typedef __Reply__mach_vm_copy_t _Xmach_vm_copy::Reply;

/* 9736 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_copy_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8775 */
typedef __Reply__mach_vm_write_t _Xmach_vm_write::Reply;

/* 9737 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_write_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8776 */
typedef __Reply__mach_vm_read_list_t _Xmach_vm_read_list::Reply;

/* 9738 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_read_list_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_vm_read_entry_t data_list;
};

/* 8777 */
typedef __Reply__mach_vm_read_t _Xmach_vm_read::Reply;

/* 9739 */
struct __Reply__mach_vm_read_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t data;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t dataCnt;
};

/* 8778 */
typedef __Reply__mach_vm_inherit_t _Xmach_vm_inherit::Reply;

/* 9740 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_inherit_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8779 */
typedef __Reply__mach_vm_protect_t _Xmach_vm_protect::Reply;

/* 9741 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_protect_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8780 */
typedef __Reply__mach_vm_deallocate_t _Xmach_vm_deallocate::Reply;

/* 9742 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_deallocate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8781 */
typedef __Reply__mach_vm_allocate_external_t _Xmach_vm_allocate_external::Reply;

/* 9743 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_allocate_external_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_vm_address_t_0 address;
};

/* 8782 */
struct __Request__mach_port_names_t
{
  mach_msg_header_t_0 Head;
};

/* 8783 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_type_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 8784 */
struct __Request__mach_port_allocate_name_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_right_t right;
  mach_port_name_t_0 name;
};

/* 8785 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_allocate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_right_t right;
};

/* 8786 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_destroy_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 8787 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_deallocate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 8788 */
struct __Request__mach_port_get_refs_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_right_t right;
};

/* 8789 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_mod_refs_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_right_t right;
  mach_port_delta_t delta;
};

/* 8790 */
struct __Request__mach_port_peek_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_trailer_type_t trailer_type;
  mach_port_seqno_t request_seqnop;
  mach_msg_type_number_t trailer_infopCnt;
};

/* 8791 */
struct __Request__mach_port_set_mscount_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_mscount_t mscount;
};

/* 8792 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_get_set_status_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 8793 */
struct __Request__mach_port_move_member_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 member;
  mach_port_name_t_0 after;
};

/* 8794 */
struct __Request__mach_port_request_notification_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t notify;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_id_t msgid;
  mach_port_mscount_t sync;
};

/* 8795 */
struct __Request__mach_port_insert_right_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t poly;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 8796 */
struct __Request__mach_port_extract_right_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_msg_type_name_t msgt_name;
};

/* 8797 */
struct __Request__mach_port_set_seqno_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_seqno_t seqno;
};

/* 8798 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_get_attributes_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_flavor_t flavor;
  mach_msg_type_number_t port_info_outCnt;
};

/* 8799 */
struct __Request__mach_port_set_attributes_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_flavor_t flavor;
  mach_msg_type_number_t port_infoCnt;
  integer_t port_info[17];
};

/* 8800 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_allocate_qos_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_right_t right;
  mach_port_qos_t qos;
};

/* 8801 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_allocate_full_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t proto;
  NDR_record_t_0 NDR;
  mach_port_right_t right;
  mach_port_qos_t qos;
  mach_port_name_t_0 name;
};

/* 8802 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__task_set_port_space_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int table_entries;
};

/* 8803 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_get_srights_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 8804 */
struct __Request__mach_port_space_info_from_user_t
{
  mach_msg_header_t_0 Head;
};

/* 8805 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_dnrequest_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 8806 */
struct __Request__mach_port_insert_member_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_name_t_0 pset;
};

/* 8807 */
struct __Request__mach_port_extract_member_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_name_t_0 pset;
};

/* 8808 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_get_context_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 8809 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_set_context_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_vm_address_t_0 context;
};

/* 8810 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_kobject_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 8811 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_construct_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t options;
  NDR_record_t_0 NDR;
  uint64_t context;
};

/* 8812 */
struct __Request__mach_port_destruct_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_delta_t srdelta;
  uint64_t guard;
};

/* 8813 */
struct __Request__mach_port_guard_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t guard;
  boolean_t strict;
};

/* 8814 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_unguard_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  uint64_t guard;
};

/* 8815 */
struct __Request__mach_port_space_basic_info_t
{
  mach_msg_header_t_0 Head;
};

/* 8816 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_special_reply_port_reset_link_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 8817 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_guard_with_flags_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  uint64_t guard;
  uint64_t flags;
};

/* 8818 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_swap_guard_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  uint64_t old_guard;
  uint64_t new_guard;
};

/* 8819 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_kobject_description_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 8820 */
struct __Request__mach_port_is_connection_for_service_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 connection_port;
  mach_port_name_t_0 service_port;
};

/* 8821 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_port_get_service_port_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
};

/* 8822 */
struct __Request__mach_port_assert_attributes_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_port_name_t_0 name;
  mach_port_flavor_t flavor;
  mach_msg_type_number_t infoCnt;
  integer_t info[17];
};

/* 8823 */
typedef __Reply__mach_port_assert_attributes_t _Xmach_port_assert_attributes::Reply;

/* 9744 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_assert_attributes_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8824 */
typedef __Reply__mach_port_get_service_port_info_t _Xmach_port_get_service_port_info::Reply;

/* 9745 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_get_service_port_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_service_port_info_data_t sp_info_out;
};

/* 8825 */
typedef __Reply__mach_port_is_connection_for_service_t _Xmach_port_is_connection_for_service::Reply;

/* 9746 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_is_connection_for_service_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  uint64_t filter_policy_id;
};

/* 8826 */
typedef __Reply__mach_port_kobject_description_from_user_t _Xmach_port_kobject_description_from_user::Reply;

/* 9747 */
struct __Reply__mach_port_kobject_description_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  natural_t object_type;
  mach_vm_address_t_0 object_addr;
  mach_msg_type_number_t descriptionOffset;
  mach_msg_type_number_t descriptionCnt;
  char description[512];
};

/* 8827 */
typedef __Reply__mach_port_swap_guard_t _Xmach_port_swap_guard::Reply;

/* 9748 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_swap_guard_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8828 */
typedef __Reply__mach_port_guard_with_flags_t _Xmach_port_guard_with_flags::Reply;

/* 9749 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_guard_with_flags_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8829 */
typedef __Reply__mach_port_special_reply_port_reset_link_t _Xmach_port_special_reply_port_reset_link::Reply;

/* 9750 */
struct __Reply__mach_port_special_reply_port_reset_link_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  boolean_t srp_lost_link;
};

/* 8831 */
typedef __Reply__mach_port_space_basic_info_t _Xmach_port_space_basic_info::Reply;

/* 9751 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_space_basic_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  ipc_info_space_basic_t basic_info;
};

/* 8832 */
typedef __Reply__mach_port_unguard_t _Xmach_port_unguard::Reply;

/* 9752 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_unguard_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8833 */
typedef __Reply__mach_port_guard_t _Xmach_port_guard::Reply;

/* 9753 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_guard_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8834 */
typedef __Reply__mach_port_destruct_t _Xmach_port_destruct::Reply;

/* 9754 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_destruct_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8835 */
typedef __Reply__mach_port_construct_t _Xmach_port_construct::Reply;

/* 9755 */
struct __Reply__mach_port_construct_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_port_name_t_0 name;
};

/* 8836 */
typedef __Reply__mach_port_kobject_from_user_t _Xmach_port_kobject_from_user::Reply;

/* 9756 */
struct __Reply__mach_port_kobject_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  natural_t object_type;
  mach_vm_address_t_0 object_addr;
};

/* 8837 */
typedef __Reply__mach_port_set_context_t _Xmach_port_set_context::Reply;

/* 9757 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_set_context_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8838 */
typedef __Reply__mach_port_get_context_from_user_t _Xmach_port_get_context_from_user::Reply;

/* 9758 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_get_context_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_vm_address_t_0 context;
};

/* 8839 */
typedef __Reply__mach_port_extract_member_t _Xmach_port_extract_member::Reply;

/* 9759 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_extract_member_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8840 */
typedef __Reply__mach_port_insert_member_t _Xmach_port_insert_member::Reply;

/* 9760 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_insert_member_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8841 */
typedef __Reply__mach_port_dnrequest_info_t _Xmach_port_dnrequest_info::Reply;

/* 9761 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_dnrequest_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  unsigned int dnr_total;
  unsigned int dnr_used;
};

/* 8843 */
typedef __Reply__mach_port_space_info_from_user_t _Xmach_port_space_info_from_user::Reply;

/* 9762 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_space_info_from_user_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t table_info;
  mach_msg_ool_descriptor_t tree_info;
  NDR_record_t_0 NDR;
  ipc_info_space_t space_info;
  mach_msg_type_number_t table_infoCnt;
  mach_msg_type_number_t tree_infoCnt;
};

/* 8844 */
typedef __Reply__mach_port_get_srights_t _Xmach_port_get_srights::Reply;

/* 9763 */
struct __Reply__mach_port_get_srights_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_port_rights_t srights;
};

/* 8845 */
typedef __Reply__task_set_port_space_t _Xtask_set_port_space::Reply;

/* 9764 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__task_set_port_space_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8847 */
typedef __Reply__mach_port_allocate_full_t _Xmach_port_allocate_full::Reply;

/* 9765 */
struct __Reply__mach_port_allocate_full_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_port_qos_t qos;
  mach_port_name_t_0 name;
};

/* 8848 */
typedef __Reply__mach_port_allocate_qos_t _Xmach_port_allocate_qos::Reply;

/* 9766 */
struct __Reply__mach_port_allocate_qos_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_port_qos_t qos;
  mach_port_name_t_0 name;
};

/* 8850 */
typedef __Reply__mach_port_set_attributes_t _Xmach_port_set_attributes::Reply;

/* 9767 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_set_attributes_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8851 */
typedef __Reply__mach_port_get_attributes_from_user_t _Xmach_port_get_attributes_from_user::Reply;

/* 9768 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_get_attributes_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t port_info_outCnt;
  integer_t port_info_out[17];
};

/* 8852 */
typedef __Reply__mach_port_set_seqno_t _Xmach_port_set_seqno::Reply;

/* 9769 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_set_seqno_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8854 */
typedef __Reply__mach_port_extract_right_t _Xmach_port_extract_right::Reply;

/* 9770 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_extract_right_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t poly;
};

/* 8855 */
typedef __Reply__mach_port_insert_right_t _Xmach_port_insert_right::Reply;

/* 9771 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_insert_right_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8856 */
typedef __Reply__mach_port_request_notification_t _Xmach_port_request_notification::Reply;

/* 9772 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_request_notification_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t previous;
};

/* 8857 */
typedef __Reply__mach_port_move_member_t _Xmach_port_move_member::Reply;

/* 9773 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_move_member_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8858 */
typedef __Reply__mach_port_get_set_status_from_user_t _Xmach_port_get_set_status_from_user::Reply;

/* 9774 */
struct __Reply__mach_port_get_set_status_from_user_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t members;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t membersCnt;
};

/* 8859 */
typedef __Reply__mach_port_set_mscount_t _Xmach_port_set_mscount::Reply;

/* 9775 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_set_mscount_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8860 */
typedef __Reply__mach_port_peek_t _Xmach_port_peek::Reply;

/* 9776 */
struct __Reply__mach_port_peek_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_port_seqno_t request_seqnop;
  mach_msg_size_t msg_sizep;
  mach_msg_id_t msg_idp;
  mach_msg_type_number_t trailer_infopCnt;
  char trailer_infop[68];
};

/* 8861 */
typedef __Reply__mach_port_mod_refs_t _Xmach_port_mod_refs::Reply;

/* 9777 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_mod_refs_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8863 */
typedef __Reply__mach_port_get_refs_t _Xmach_port_get_refs::Reply;

/* 9778 */
struct __Reply__mach_port_get_refs_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_port_urefs_t refs;
};

/* 8864 */
typedef __Reply__mach_port_deallocate_t _Xmach_port_deallocate::Reply;

/* 9779 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_deallocate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8865 */
typedef __Reply__mach_port_destroy_t _Xmach_port_destroy::Reply;

/* 9780 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_destroy_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8866 */
typedef __Reply__mach_port_allocate_t _Xmach_port_allocate::Reply;

/* 9781 */
struct __Reply__mach_port_allocate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_port_name_t_0 name;
};

/* 8867 */
typedef __Reply__mach_port_allocate_name_t _Xmach_port_allocate_name::Reply;

/* 9782 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_allocate_name_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8869 */
typedef __Reply__mach_port_type_t _Xmach_port_type::Reply;

/* 9783 */
struct __Reply__mach_port_type_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_port_type_t ptype;
};

/* 8870 */
typedef __Reply__mach_port_names_t _Xmach_port_names::Reply;

/* 9784 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_port_names_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t names;
  mach_msg_ool_descriptor_t types;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t namesCnt;
  mach_msg_type_number_t typesCnt;
};

/* 8871 */
struct __Request__host_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  host_flavor_t flavor;
  mach_msg_type_number_t host_info_outCnt;
};

/* 8872 */
struct __Request__host_kernel_version_t
{
  mach_msg_header_t_0 Head;
};

/* 8873 */
struct __Request__host_page_size_t
{
  mach_msg_header_t_0 Head;
};

/* 8874 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_memory_object_memory_entry_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t pager;
  NDR_record_t_0 NDR;
  boolean_t internal;
  vm_size_t_0 size;
  vm_prot_t permission;
};

/* 8875 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__host_processor_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  processor_flavor_t flavor;
};

/* 8876 */
struct __Request__host_get_io_main_t
{
  mach_msg_header_t_0 Head;
};

/* 8877 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__host_get_clock_service_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  clock_id_t clock_id;
};

/* 8878 */
struct __Request__kmod_get_info_t
{
  mach_msg_header_t_0 Head;
};

/* 8879 */
struct __Request__host_virtual_physical_table_info_t
{
  mach_msg_header_t_0 Head;
};

/* 8880 */
struct __Request__processor_set_default_t
{
  mach_msg_header_t_0 Head;
};

/* 8881 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_memory_object_memory_entry_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t pager;
  NDR_record_t_0 NDR;
  boolean_t internal;
  memory_object_size_t size;
  vm_prot_t permission;
};

/* 8882 */
struct __Request__host_statistics_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  host_flavor_t flavor;
  mach_msg_type_number_t host_info_outCnt;
};

/* 8883 */
struct __Request__host_request_notification_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t notify_port;
  NDR_record_t_0 NDR;
  host_flavor_t notify_type;
};

/* 8884 */
struct __Request__host_lockgroup_info_t
{
  mach_msg_header_t_0 Head;
};

/* 8885 */
struct __Request__host_statistics64_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  host_flavor_t flavor;
  mach_msg_type_number_t host_info64_outCnt;
};

/* 8886 */
struct __Request__mach_zone_info_t
{
  mach_msg_header_t_0 Head;
};

/* 8887 */
struct __Request__mach_zone_force_gc_t
{
  mach_msg_header_t_0 Head;
};

/* 8888 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__host_create_mach_voucher_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t recipesCnt;
  uint8_t recipes[5120];
};

/* 8889 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__host_set_atm_diagnostic_flag_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t diagnostic_flag;
};

/* 8890 */
struct __Request__mach_memory_info_t
{
  mach_msg_header_t_0 Head;
};

/* 8891 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__host_set_multiuser_config_flags_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  uint32_t multiuser_flags;
};

/* 8892 */
struct __Request__mach_zone_info_for_zone_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_zone_name_t name;
};

/* 8893 */
struct __Request__mach_zone_info_for_largest_zone_t
{
  mach_msg_header_t_0 Head;
};

/* 8894 */
struct __Request__mach_zone_get_zlog_zones_t
{
  mach_msg_header_t_0 Head;
};

/* 8895 */
struct __Request__mach_zone_get_btlog_records_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  mach_zone_name_t name;
};

/* 8896 */
typedef __Reply__mach_zone_get_btlog_records_t _Xmach_zone_get_btlog_records::Reply;

/* 9785 */
struct __Reply__mach_zone_get_btlog_records_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t recs;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t recsCnt;
};

/* 8897 */
typedef __Reply__mach_zone_get_zlog_zones_t _Xmach_zone_get_zlog_zones::Reply;

/* 9786 */
struct __Reply__mach_zone_get_zlog_zones_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t names;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t namesCnt;
};

/* 8898 */
typedef __Reply__mach_zone_info_for_largest_zone_t _Xmach_zone_info_for_largest_zone::Reply;

/* 9787 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_zone_info_for_largest_zone_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_zone_name_t name;
  mach_zone_info_t info;
};

/* 8899 */
typedef __Reply__mach_zone_info_for_zone_t _Xmach_zone_info_for_zone::Reply;

/* 9788 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_zone_info_for_zone_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_zone_info_t info;
};

/* 8900 */
typedef __Reply__host_set_multiuser_config_flags_t _Xhost_set_multiuser_config_flags::Reply;

/* 9789 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_set_multiuser_config_flags_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8901 */
typedef __Reply__mach_memory_info_t _Xmach_memory_info::Reply;

/* 9790 */
struct __Reply__mach_memory_info_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t names;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t info;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t memory_info;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t namesCnt;
  mach_msg_type_number_t infoCnt;
  mach_msg_type_number_t memory_infoCnt;
};

/* 8902 */
typedef __Reply__host_set_atm_diagnostic_flag_t _Xhost_set_atm_diagnostic_flag::Reply;

/* 9791 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_set_atm_diagnostic_flag_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8903 */
typedef __Reply__host_create_mach_voucher_t _Xhost_create_mach_voucher::Reply;

/* 9792 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_create_mach_voucher_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t voucher;
};

/* 8904 */
typedef __Reply__mach_zone_force_gc_t _Xmach_zone_force_gc::Reply;

/* 9793 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_zone_force_gc_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8907 */
typedef __Reply__mach_zone_info_t _Xmach_zone_info::Reply;

/* 9794 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_zone_info_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t names;
  mach_msg_ool_descriptor_t info;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t namesCnt;
  mach_msg_type_number_t infoCnt;
};

/* 8908 */
typedef __Reply__host_statistics64_from_user_t _Xhost_statistics64_from_user::Reply;

/* 9795 */
struct __Reply__host_statistics64_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t host_info64_outCnt;
  integer_t host_info64_out[256];
};

/* 8909 */
typedef __Reply__host_lockgroup_info_t _Xhost_lockgroup_info::Reply;

/* 9796 */
struct __Reply__host_lockgroup_info_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t lockgroup_info;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t lockgroup_infoCnt;
};

/* 8910 */
typedef __Reply__host_request_notification_t _Xhost_request_notification::Reply;

/* 9797 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_request_notification_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8911 */
typedef __Reply__host_statistics_from_user_t _Xhost_statistics_from_user::Reply;

/* 9798 */
struct __Reply__host_statistics_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t host_info_outCnt;
  integer_t host_info_out[68];
};

/* 8912 */
typedef __Reply__mach_memory_object_memory_entry_64_t _Xmach_memory_object_memory_entry_64::Reply;

/* 9799 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_memory_object_memory_entry_64_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t entry_handle;
};

/* 8913 */
typedef __Reply__processor_set_default_t _Xprocessor_set_default::Reply;

/* 9800 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__processor_set_default_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t default_set;
};

/* 8914 */
typedef __Reply__host_virtual_physical_table_info_t _Xhost_virtual_physical_table_info::Reply;

/* 9801 */
struct __Reply__host_virtual_physical_table_info_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t info;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t infoCnt;
};

/* 8915 */
typedef __Reply__kmod_get_info_t _Xkmod_get_info::Reply;

/* 9802 */
struct __Reply__kmod_get_info_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t modules;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t modulesCnt;
};

/* 8916 */
typedef __Reply__host_get_clock_service_t _Xhost_get_clock_service::Reply;

/* 9803 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_get_clock_service_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t clock_serv;
};

/* 8917 */
typedef __Reply__host_get_io_main_t _Xhost_get_io_main::Reply;

/* 9804 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_get_io_main_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t io_main;
};

/* 8918 */
typedef integer_t *processor_info_array_t;

/* 8919 */
typedef __Reply__host_processor_info_t _Xhost_processor_info::Reply;

/* 9805 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_processor_info_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t out_processor_info;
  NDR_record_t_0 NDR;
  natural_t out_processor_count;
  mach_msg_type_number_t out_processor_infoCnt;
};

/* 8920 */
typedef __Reply__mach_memory_object_memory_entry_t _Xmach_memory_object_memory_entry::Reply;

/* 9806 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_memory_object_memory_entry_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t entry_handle;
};

/* 8921 */
typedef __Reply__host_page_size_t _Xhost_page_size::Reply;

/* 9807 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_page_size_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  vm_size_t_0 out_page_size;
};

/* 8922 */
typedef __Reply__host_kernel_version_t _Xhost_kernel_version::Reply;

/* 9808 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_kernel_version_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t kernel_versionOffset;
  mach_msg_type_number_t kernel_versionCnt;
  char kernel_version[512];
};

/* 8923 */
typedef __Reply__host_info_t _Xhost_info::Reply;

/* 9809 */
struct __Reply__host_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t host_info_outCnt;
  integer_t host_info_out[68];
};

/* 8924 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_exception_raise_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
};

/* 8925 */
struct __Request__mach_exception_raise_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
};

/* 8926 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_exception_raise_state_identity_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
};

/* 8927 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_exception_raise_identity_protected_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t task_id_token_t;
  NDR_record_t_0 NDR;
  uint64_t thread_id;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
};

/* 8928 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_exception_raise_backtrace_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t kcdata_object_t;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  int64_t code[2];
};

/* 8929 */
typedef __Reply__mach_exception_raise_backtrace_t _Xmach_exception_raise_backtrace::Reply;

/* 8930 */
typedef __Reply__mach_exception_raise_identity_protected_t _Xmach_exception_raise_identity_protected::Reply;

/* 8931 */
typedef __Reply__mach_exception_raise_state_identity_t _Xmach_exception_raise_state_identity::Reply;

/* 8932 */
typedef __Reply__mach_exception_raise_state_t _Xmach_exception_raise_state::Reply;

/* 8933 */
typedef __Reply__mach_exception_raise_t _Xmach_exception_raise::Reply;

/* 8934 */
struct __Request__host_get_boot_info_t
{
  mach_msg_header_t_0 Head;
};

/* 8935 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__host_reboot_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int options;
};

/* 8936 */
struct __Request__host_priv_statistics_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  host_flavor_t flavor;
  mach_msg_type_number_t host_info_outCnt;
};

/* 8937 */
struct __Request__host_default_memory_manager_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t default_manager;
  NDR_record_t_0 NDR;
  memory_object_cluster_size_t cluster_size;
};

/* 8938 */
struct __Request__vm_wire_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) vm_address_t_0 address;
  __attribute__((packed)) __attribute__((aligned(1))) vm_size_t_0 size;
  vm_prot_t desired_access;
};

/* 8939 */
struct __Request__thread_wire_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t thread;
  NDR_record_t_0 NDR;
  boolean_t wired;
};

/* 8940 */
struct __Request__vm_allocate_cpm_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) vm_address_t_0 address;
  __attribute__((packed)) __attribute__((aligned(1))) vm_size_t_0 size;
  int flags;
};

/* 8941 */
struct __Request__host_processors_t
{
  mach_msg_header_t_0 Head;
};

/* 8942 */
struct __Request__host_get_special_port_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int node;
  int which;
};

/* 8943 */
struct __Request__host_set_special_port_from_user_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t port;
  NDR_record_t_0 NDR;
  int which;
};

/* 8944 */
struct __Request__host_set_exception_ports_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t new_port;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  exception_behavior_t behavior;
  thread_state_flavor_t new_flavor;
};

/* 8945 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__host_get_exception_ports_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
};

/* 8946 */
struct __Request__host_swap_exception_ports_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t new_port;
  NDR_record_t_0 NDR;
  exception_mask_t exception_mask;
  exception_behavior_t behavior;
  thread_state_flavor_t new_flavor;
};

/* 8947 */
struct __Request__mach_vm_wire_external_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 address;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_size_t_0 size;
  vm_prot_t desired_access;
};

/* 8948 */
struct __Request__host_processor_sets_t
{
  mach_msg_header_t_0 Head;
};

/* 8949 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__host_processor_set_priv_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t set_name;
};

/* 8950 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__host_set_UNDServer_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t server;
};

/* 8951 */
struct __Request__host_get_UNDServer_t
{
  mach_msg_header_t_0 Head;
};

/* 8952 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__kext_request_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t request_data;
  NDR_record_t_0 NDR;
  uint32_t user_log_flags;
  mach_msg_type_number_t request_dataCnt;
};

/* 8953 */
typedef __Reply__kext_request_t _Xkext_request::Reply;

/* 9810 */
struct __Reply__kext_request_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t response_data;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_descriptor_t log_data;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t response_dataCnt;
  mach_msg_type_number_t log_dataCnt;
  kern_return_t op_result;
};

/* 8954 */
typedef __Reply__host_get_UNDServer_t _Xhost_get_UNDServer::Reply;

/* 9811 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_get_UNDServer_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t server;
};

/* 8955 */
typedef __Reply__host_set_UNDServer_t _Xhost_set_UNDServer::Reply;

/* 9812 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_set_UNDServer_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8956 */
typedef __Reply__host_processor_set_priv_t _Xhost_processor_set_priv::Reply;

/* 9813 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_processor_set_priv_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t set;
};

/* 8957 */
typedef __Reply__host_processor_sets_t _Xhost_processor_sets::Reply;

/* 9814 */
struct __Reply__host_processor_sets_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_ports_descriptor_t processor_sets;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t processor_setsCnt;
};

/* 8958 */
typedef __Reply__mach_vm_wire_external_t _Xmach_vm_wire_external::Reply;

/* 9815 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_vm_wire_external_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8959 */
typedef __Reply__host_swap_exception_ports_t _Xhost_swap_exception_ports::Reply;

/* 9816 */
struct __Reply__host_swap_exception_ports_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t old_handlerss[32];
  NDR_record_t_0 NDR;
  mach_msg_type_number_t masksCnt;
  exception_mask_t masks[32];
  exception_behavior_t old_behaviors[32];
  thread_state_flavor_t old_flavors[32];
};

/* 8960 */
typedef __Reply__host_get_exception_ports_t _Xhost_get_exception_ports::Reply;

/* 9817 */
struct __Reply__host_get_exception_ports_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t old_handlers[32];
  NDR_record_t_0 NDR;
  mach_msg_type_number_t masksCnt;
  exception_mask_t masks[32];
  exception_behavior_t old_behaviors[32];
  thread_state_flavor_t old_flavors[32];
};

/* 8961 */
typedef __Reply__host_set_exception_ports_t _Xhost_set_exception_ports::Reply;

/* 9818 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_set_exception_ports_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8962 */
typedef __Reply__host_set_special_port_from_user_t _Xhost_set_special_port_from_user::Reply;

/* 9819 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_set_special_port_from_user_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8963 */
typedef __Reply__host_get_special_port_from_user_t _Xhost_get_special_port_from_user::Reply;

/* 9820 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_get_special_port_from_user_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t port;
};

/* 8964 */
typedef __Reply__host_processors_t _Xhost_processors::Reply;

/* 9821 */
struct __Reply__host_processors_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_ool_ports_descriptor_t out_processor_list;
  NDR_record_t_0 NDR;
  mach_msg_type_number_t out_processor_listCnt;
};

/* 8965 */
typedef __Reply__vm_allocate_cpm_t _Xvm_allocate_cpm::Reply;

/* 9822 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__vm_allocate_cpm_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  vm_address_t_0 address;
};

/* 8966 */
typedef __Reply__thread_wire_t _Xthread_wire::Reply;

/* 9823 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__thread_wire_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8967 */
typedef __Reply__vm_wire_t _Xvm_wire::Reply;

/* 9824 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__vm_wire_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8968 */
typedef __Reply__host_default_memory_manager_t _Xhost_default_memory_manager::Reply;

/* 9825 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_default_memory_manager_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t default_manager;
};

/* 8969 */
typedef __Reply__host_priv_statistics_t _Xhost_priv_statistics::Reply;

/* 9826 */
struct __Reply__host_priv_statistics_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t host_info_outCnt;
  integer_t host_info_out[68];
};

/* 8970 */
typedef __Reply__host_reboot_t _Xhost_reboot::Reply;

/* 9827 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_reboot_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8971 */
typedef __Reply__host_get_boot_info_t _Xhost_get_boot_info::Reply;

/* 9828 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__host_get_boot_info_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t boot_infoOffset;
  mach_msg_type_number_t boot_infoCnt;
  char boot_info[4096];
};

/* 8972 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_eventlink_create_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  _BYTE gap28[4];
};

/* 8973 */
struct __Request__mach_eventlink_destroy_t
{
  mach_msg_header_t_0 Head;
};

/* 8974 */
struct __attribute__((aligned(8))) __Request__mach_eventlink_associate_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t thread;
  NDR_record_t_0 NDR;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 copyin_addr_wait;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t copyin_mask_wait;
  __attribute__((packed)) __attribute__((aligned(1))) mach_vm_address_t_0 copyin_addr_signal;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t copyin_mask_signal;
};

/* 8975 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__mach_eventlink_disassociate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  _BYTE gap28[4];
};

/* 8976 */
typedef __Reply__mach_eventlink_disassociate_t _Xmach_eventlink_disassociate::Reply;

/* 9829 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_eventlink_disassociate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8977 */
typedef __Reply__mach_eventlink_associate_t _Xmach_eventlink_associate::Reply;

/* 9830 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_eventlink_associate_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8978 */
typedef __Reply__mach_eventlink_destroy_t _Xmach_eventlink_destroy::Reply;

/* 9831 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_eventlink_destroy_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8979 */
typedef __Reply__mach_eventlink_create_t _Xmach_eventlink_create::Reply;

/* 9832 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__mach_eventlink_create_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t eventlink_pair[2];
};

/* 8980 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__exception_raise_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  integer_t code[2];
};

/* 8981 */
struct __Request__exception_raise_state_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  integer_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
};

/* 8982 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__exception_raise_state_identity_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t thread;
  mach_msg_port_descriptor_t task;
  NDR_record_t_0 NDR;
  exception_type_t exception;
  mach_msg_type_number_t codeCnt;
  integer_t code[2];
  int flavor;
  mach_msg_type_number_t old_stateCnt;
  natural_t old_state[1296];
};

/* 8983 */
typedef __Reply__exception_raise_state_identity_t _Xexception_raise_state_identity::Reply;

/* 8984 */
typedef __Reply__exception_raise_state_t _Xexception_raise_state::Reply;

/* 8985 */
typedef __Reply__exception_raise_t _Xexception_raise::Reply;

/* 8986 */
struct __Request__clock_get_time_t
{
  mach_msg_header_t_0 Head;
};

/* 8987 */
struct __Request__clock_get_attributes_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  clock_flavor_t flavor;
  mach_msg_type_number_t clock_attrCnt;
};

/* 8988 */
struct __Request__clock_alarm_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  __attribute__((packed)) __attribute__((aligned(1))) mach_msg_port_descriptor_t alarm_port;
  NDR_record_t_0 NDR;
  alarm_type_t alarm_type;
  mach_timespec_t alarm_time;
};

/* 8989 */
typedef __Reply__clock_alarm_t _Xclock_alarm::Reply;

/* 9833 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__clock_alarm_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 8990 */
typedef __Reply__clock_get_attributes_t _Xclock_get_attributes::Reply;

/* 9834 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__clock_get_attributes_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_msg_type_number_t clock_attrCnt;
  int clock_attr[1];
};

/* 8991 */
typedef __Reply__clock_get_time_t _Xclock_get_time::Reply;

/* 9835 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__clock_get_time_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
  mach_timespec_t cur_time;
};

/* 8992 */
typedef uint64_t socd_client_trace_arg_t;

/* 8993 */
typedef task_id_token *task_id_token_t;

/* 8994 */
typedef struct ipc_entry_table *ipc_entry_table_t;

/* 8995 */
struct zone_create_startup_spec
{
  zone_t *z_var;
  const char *z_name;
  vm_size_t_0 z_size;
  __attribute__((aligned(16))) zone_id_t z_zid;
  struct *z_setup;
};

/* 8996 */
typedef void (*zone_smr_free_cb_t)(void *, size_t);

/* 8998 */
typedef zone_cache *zone_cache_t;

/* 9002 */
typedef unsigned int spl_t;

/* 9005 */
enum turnstile_stats_update_flags : __int32
{
  turnstile_stats_update_flags::TSU_FLAGS_NONE = 0x0,
  turnstile_stats_update_flags::TSU_TURNSTILE_BLOCK_COUNT = 0x1,
  turnstile_stats_update_flags::TSU_REGULAR_WAITQ_BLOCK_COUNT = 0x2,
  turnstile_stats_update_flags::TSU_PRI_PROPAGATION = 0x4,
  turnstile_stats_update_flags::TSU_NO_INHERITOR = 0x8,
  turnstile_stats_update_flags::TSU_NO_TURNSTILE = 0x10,
  turnstile_stats_update_flags::TSU_NO_PRI_CHANGE_NEEDED = 0x20,
  turnstile_stats_update_flags::TSU_THREAD_RUNNABLE = 0x40,
  turnstile_stats_update_flags::TSU_ABOVE_UI_PRI_CHANGE = 0x80,
  turnstile_stats_update_flags::TSU_THREAD_ARG = 0x100,
  turnstile_stats_update_flags::TSU_TURNSTILE_ARG = 0x200,
  turnstile_stats_update_flags::TSU_BOOST_ARG = 0x400,
};

/* 9003 */
typedef turnstile_stats_update_flags turnstile_stats_update_flags_t;

/* 9004 */
typedef uint16_t priority_queue_key_t;

/* 9008 */
enum running_timer : __int32
{
  running_timer::RUNNING_TIMER_QUANTUM = 0x0,
  running_timer::RUNNING_TIMER_KPERF = 0x1,
  running_timer::RUNNING_TIMER_MAX = 0x2,
};

/* 9009 */
struct timer_longterm_t
{
  mpqueue_head_t queue;
  uint64_t enqueues;
  uint64_t dequeues;
  uint64_t escalates;
  uint64_t scan_time;
  threshold_t threshold;
  uint64_t scan_limit;
  uint64_t scan_interval;
  uint64_t scan_pauses;
};

/* 9011 */
typedef thread_policy_state *thread_policy_state_t;

/* 9013 */
typedef thread_call_group *thread_call_group_t;

/* 9014 */
enum thread_call_flavor_t : __int32
{
  TCF_ABSOLUTE = 0x0,
  TCF_CONTINUOUS = 0x1,
  TCF_COUNT = 0x2,
};

/* 9015 */
typedef thread_pri_floor thread_pri_floor_t;

/* 9016 */
typedef thread_basic_info *thread_basic_info_t;

/* 9017 */
typedef task_qos_policy *task_qos_policy_t;

/* 9019 */
typedef int (*mac_task_kobj_filter_cbfunc_t)(struct proc *, int, int);

/* 9020 */
typedef int (*mac_task_mach_filter_cbfunc_t)(struct proc *, int);

/* 9021 */
typedef integer_t *task_info_t;

/* 9022 */
typedef dyld_kernel_image_info_t *dyld_kernel_image_info_array_t;

/* 9023 */
typedef task_power_info_v2 *task_power_info_v2_t;

/* 9024 */
typedef task_power_info *task_power_info_t;

/* 9026 */
typedef void (*semaphore_cont_t)(kern_return_t);

/* 9027 */
struct __attribute__((aligned(4))) startup_tunable_spec
{
  const char *name;
  void *var_addr;
  int var_len;
  bool var_is_bool;
  bool var_is_str;
};

/* 9028 */
struct __attribute__((aligned(8))) stack_cache
{
  vm_offset_t free;
  unsigned int count;
};

/* 9031 */
typedef smr_bucket *smr_bucket_t;

/* 9032 */
typedef smr_pcpu *smr_pcpu_t;

/* 9034 */
struct sfi_class_registration_t
{
  sfi_class_id_t class_id;
  thread_continue_t class_continuation;
  const char *class_name;
  const char *class_ledger_name;
};

/* 9035 */
enum sched_ipi_type_t : __int32
{
  SCHED_IPI_NONE = 0x0,
  SCHED_IPI_IMMEDIATE = 0x1,
  SCHED_IPI_IDLE = 0x2,
  SCHED_IPI_DEFERRED = 0x3,
};

/* 9036 */
enum sched_ipi_event_t : __int32
{
  SCHED_IPI_EVENT_BOUND_THR = 0x1,
  SCHED_IPI_EVENT_PREEMPT = 0x2,
  SCHED_IPI_EVENT_SMT_REBAL = 0x3,
  SCHED_IPI_EVENT_SPILL = 0x4,
  SCHED_IPI_EVENT_REBALANCE = 0x5,
  SCHED_IPI_EVENT_RT_PREEMPT = 0x6,
};

/* 9037 */
typedef sched_clutch *sched_clutch_t;

/* 9038 */
typedef sched_clutch_bucket_group *sched_clutch_bucket_group_t;

/* 9039 */
typedef sched_clutch_bucket_runq *sched_clutch_bucket_runq_t;

/* 9040 */
typedef sched_clutch_root_bucket *sched_clutch_root_bucket_t;

/* 9041 */
typedef circle_queue_head *circle_queue_t_0;

/* 9044 */
typedef integer_t *policy_limit_t;

/* 9045 */
struct io_timeout_override
{
  io_timeout_override_entry *rbh_root;
};

/* 9046 */
typedef mnl_msg *mnl_msg_t;

/* 9047 */
typedef mnl_node_info *mnl_node_info_t;

/* 9049 */
typedef struct cond_swi_var *cond_swi_var_t;

/* 9050 */
enum lockstat_probe_id : __int32
{
  lockstat_probe_id::LS_NO_PROBE = 0x0,
  lockstat_probe_id::LS_LCK_SPIN_LOCK_ACQUIRE = 0x1,
  lockstat_probe_id::LS_LCK_SPIN_LOCK_SPIN = 0x2,
  lockstat_probe_id::LS_LCK_SPIN_UNLOCK_RELEASE = 0x3,
  lockstat_probe_id::LS_LCK_MTX_LOCK_ACQUIRE = 0x4,
  lockstat_probe_id::LS_LCK_MTX_LOCK_SPIN_ACQUIRE = 0x5,
  lockstat_probe_id::LS_LCK_MTX_TRY_LOCK_ACQUIRE = 0x6,
  lockstat_probe_id::LS_LCK_MTX_TRY_LOCK_SPIN_ACQUIRE = 0x7,
  lockstat_probe_id::LS_LCK_MTX_UNLOCK_RELEASE = 0x8,
  lockstat_probe_id::LS_LCK_MTX_LOCK_BLOCK = 0x9,
  lockstat_probe_id::LS_LCK_MTX_LOCK_ADAPTIVE_SPIN = 0xA,
  lockstat_probe_id::LS_LCK_MTX_LOCK_SPIN_SPIN = 0xB,
  lockstat_probe_id::LS_LCK_RW_LOCK_SHARED_ACQUIRE = 0xC,
  lockstat_probe_id::LS_LCK_RW_LOCK_SHARED_BLOCK = 0xD,
  lockstat_probe_id::LS_LCK_RW_LOCK_SHARED_SPIN = 0xE,
  lockstat_probe_id::LS_LCK_RW_LOCK_EXCL_ACQUIRE = 0xF,
  lockstat_probe_id::LS_LCK_RW_LOCK_EXCL_BLOCK = 0x10,
  lockstat_probe_id::LS_LCK_RW_LOCK_EXCL_SPIN = 0x11,
  lockstat_probe_id::LS_LCK_RW_DONE_RELEASE = 0x12,
  lockstat_probe_id::LS_LCK_RW_TRY_LOCK_SHARED_ACQUIRE = 0x13,
  lockstat_probe_id::LS_LCK_RW_TRY_LOCK_SHARED_SPIN = 0x14,
  lockstat_probe_id::LS_LCK_RW_TRY_LOCK_EXCL_ACQUIRE = 0x15,
  lockstat_probe_id::LS_LCK_RW_TRY_LOCK_EXCL_ILK_SPIN = 0x16,
  lockstat_probe_id::LS_LCK_RW_LOCK_SHARED_TO_EXCL_UPGRADE = 0x17,
  lockstat_probe_id::LS_LCK_RW_LOCK_SHARED_TO_EXCL_SPIN = 0x18,
  lockstat_probe_id::LS_LCK_RW_LOCK_SHARED_TO_EXCL_BLOCK = 0x19,
  lockstat_probe_id::LS_LCK_RW_LOCK_EXCL_TO_SHARED_DOWNGRADE = 0x1A,
  lockstat_probe_id::LS_LCK_RW_LOCK_EXCL_TO_SHARED_ILK_SPIN = 0x1B,
  lockstat_probe_id::LS_LCK_TICKET_LOCK_ACQUIRE = 0x1C,
  lockstat_probe_id::LS_LCK_TICKET_LOCK_RELEASE = 0x1D,
  lockstat_probe_id::LS_LCK_TICKET_LOCK_SPIN = 0x1E,
  lockstat_probe_id::LS_NPROBES = 0x1F,
};

/* 9053 */
struct hw_lck_ticket_reserve_arg
{
  uint8_t mt;
  bool validate;
};

/* 9056 */
typedef lck_mcs *lck_mcs_t;

/* 9055 */
typedef uint16_t lck_mcs_id_t;

/* 9054 */
struct __attribute__((aligned(8))) lck_spin_txn_t
{
  lck_mcs_t txn_mcs;
  lck_spin_mcs_t txn_slot;
  lck_mcs_id_t txn_mcs_id;
};

/* 9057 */
typedef lck_mtx_mcs *lck_mtx_mcs_t;

/* 9059 */
typedef kern_apfs_reflock *kern_apfs_reflock_t;

/* 9060 */
typedef ipc_space *ipc_space_inspect_t;

/* 9061 */
typedef void *ipc_kobject_t;

/* 9062 */
typedef ipc_kobject_label *ipc_kobject_label_t;

/* 9063 */
typedef const ipc_kobject_ops *ipc_kobject_ops_t;

/* 9064 */
struct ipc_kobject_ops
{
  _BYTE gap0[8];
  const char *iko_op_name;
  void (*iko_op_no_senders)(ipc_port_t_0, mach_port_mscount_t);
  void (*iko_op_destroy)(ipc_port_t_0);
};

/* 9065 */
typedef clock *clock_t;

/* 9066 */
typedef host_notify_entry *host_notify_t;

/* 9067 */
typedef processor_t *processor_array_t;

/* 9068 */
typedef integer_t *host_info_t;

/* 9069 */
typedef vm_statistics64 *vm_statistics64_t;

/* 9070 */
struct host_cpu_load_info
{
  natural_t cpu_ticks[4];
};

/* 9071 */
struct vm_statistics
{
  natural_t free_count;
  natural_t active_count;
  natural_t inactive_count;
  natural_t wire_count;
  natural_t zero_fill_count;
  natural_t reactivations;
  natural_t pageins;
  natural_t pageouts;
  natural_t faults;
  natural_t cow_faults;
  natural_t lookups;
  natural_t hits;
  natural_t purgeable_count;
  natural_t purges;
  natural_t speculative_count;
};

/* 9072 */
struct host_load_info
{
  integer_t avenrun[3];
  integer_t mach_factor[3];
};

/* 9073 */
typedef uint64_t (*gpu_set_fceiling_t)(uint32_t, uint64_t);

/* 9074 */
typedef uint64_t (*io_rate_update_callback_t)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

/* 9075 */
struct phys_carveout_init::carveout
{
  const char *name;
  vm_offset_t *va;
  uint32_t requested_size;
  uintptr_t *pa;
  size_t *allocated_size;
  uint64_t present;
};

/* 9076 */
enum debugger_op : __int32
{
  DBOP_NONE = 0x0,
  DBOP_STACKSHOT = 0x1,
  DBOP_RESET_PGO_COUNTERS = 0x2,
  DBOP_PANIC = 0x3,
  DBOP_DEBUGGER = 0x4,
  DBOP_BREAKPOINT = 0x5,
};

/* 9077 */
struct debugger_state
{
  uint64_t db_panic_options;
  debugger_op db_current_op;
  boolean_t db_proceed_on_sync_failure;
  const char *db_message;
  const char *db_panic_str;
  va_list *db_panic_args;
  void *db_panic_data_ptr;
  unsigned __int64 db_panic_caller;
  uint32_t db_entry_count;
  kern_return_t db_op_return;
};

/* 9078 */
typedef unsigned __int64 checkin_mask_t;

/* 9079 */
struct cpu_quiesce
{
  cpu_quiescent_state_t state;
  uint64_t last_checkin;
};

/* 9080 */
typedef alarm *alarm_t;

/* 9082 */
typedef bt_stack *bt_stack_t;

/* 9085 */
typedef affinity_space *affinity_space_t;

/* 9086 */
typedef integer_t *mach_port_info_t;

/* 9087 */
typedef ipc_port_request_table *ipc_port_request_table_t;

/* 9090 */
struct mach_msg_filter_callbacks
{
  unsigned int version;
  const mach_msg_fetch_filter_policy_cbfunc_t fetch_filter_policy;
  const mach_msg_filter_alloc_service_port_sblabel_cbfunc_t alloc_service_port_sblabel;
  const mach_msg_filter_dealloc_service_port_sblabel_cbfunc_t dealloc_service_port_sblabel;
  const mach_msg_filter_derive_sblabel_from_service_port_cbfunc_t derive_sblabel_from_service_port;
  const mach_msg_filter_get_connection_port_filter_policy_cbfunc_t get_connection_port_filter_policy;
  const mach_msg_filter_retain_sblabel_cbfunc_t retain_sblabel;
};

/* 9094 */
typedef ipc_info_name_t *ipc_info_name_array_t;

/* 9095 */
typedef ipc_voucher_attr_control *ipc_voucher_attr_control_t;

/* 9096 */
typedef user_data_value_element *user_data_element_t;

/* 9098 */
typedef ipc_service_port_label *ipc_service_port_label_t;

/* 9100 */
typedef unsigned int mach_msg_guard_flags_t;

/* 9101 */
typedef unsigned int mach_msg_descriptor_type_t;

/* 9103 */
typedef ipc_importance_inherit *ipc_importance_inherit_t;

/* 9104 */
typedef int iit_update_type_t;

/* 9105 */
typedef kern_return_t (*ipc_voucher_attr_manager_release_value_t_0)(ipc_voucher_attr_manager_t, mach_voucher_attr_key_t, mach_voucher_attr_value_handle_t, mach_voucher_attr_value_reference_t);

/* 9107 */
struct main_bin_spec_note
{
  uint32_t version;
  uint32_t type;
  uint64_t address;
  uuid_t_0 uuid;
  uint32_t log2_pagesize;
  uint32_t unused;
};

/* 9108 */
struct panic_context_note
{
  uuid_string_t kernel_uuid_string;
};

/* 9109 */
struct user_dump_send_segdata_context
{
  core_save_segment_data_cb callback;
  void *context;
};

/* 9110 */
struct user_dump_send_seg_desc_context
{
  core_save_segment_descriptions_cb callback;
  void *context;
};

/* 9111 */
struct user_dump_preflight_context
{
  kern_userspace_coredump_context *uccontext;
  uint32_t region_count;
  uint64_t dumpable_bytes;
};

/* 9112 */
enum kern_dump_type : __int32
{
  kern_dump_type::KERN_DUMP_DISK = 0x0,
  kern_dump_type::KERN_DUMP_NET = 0x1,
  kern_dump_type::KERN_DUMP_HW_SHMEM_DBG = 0x2,
  kern_dump_type::KERN_DUMP_STACKSHOT_DISK = 0x3,
};

/* 9113 */
struct kdp_ip
{
  union
  {
    uint32_t ip_w;
    struct
    {
      _BYTE gap0[4];
    } ip_x;
  } ip_vhltl;
  u_short ip_id;
  short ip_off;
  u_char ip_ttl;
  u_char ip_p;
  u_short ip_sum;
  kdp_in_addr ip_src;
  kdp_in_addr ip_dst;
};

/* 9114 */
struct kdp_udpiphdr
{
  kdp_ipovly ui_i;
  kdp_udphdr ui_u;
};

/* 9115 */
typedef boolean_t (*kdp_mode_t)(boolean_t);

/* 9116 */
typedef uint32_t (*kdp_link_t)(void);

/* 9117 */
typedef void (*kdp_receive_t)(void *, unsigned int *, unsigned int);

/* 9118 */
typedef void (*kdp_send_t)(void *, unsigned int);

/* 9119 */
typedef void find_phys_fn_t;

/* 9120 */
struct __attribute__((aligned(4))) _stackshot_backtrace_context
{
  vm_map_t_0 sbc_map;
  vm_offset_t sbc_prev_page;
  vm_offset_t sbc_prev_kva;
  uint32_t sbc_flags;
  bool sbc_allow_faulting;
};

/* 9121 */
struct __attribute__((aligned(8))) stackshot_context
{
  int pid;
  uint64_t trace_flags;
  bool include_drivers;
};

/* 9122 */
enum stackshot_plh_lookup_type : __int32
{
  stackshot_plh_lookup_type::STACKSHOT_PLH_LOOKUP_UNKNOWN = 0x0,
  stackshot_plh_lookup_type::STACKSHOT_PLH_LOOKUP_SEND = 0x1,
  stackshot_plh_lookup_type::STACKSHOT_PLH_LOOKUP_RECEIVE = 0x2,
};

/* 9123 */
struct __attribute__((packed)) __attribute__((aligned(1))) mem_and_io_snapshot
{
  uint32_t snapshot_magic;
  uint32_t free_pages;
  uint32_t active_pages;
  uint32_t inactive_pages;
  uint32_t purgeable_pages;
  uint32_t wired_pages;
  uint32_t speculative_pages;
  uint32_t throttled_pages;
  uint32_t filebacked_pages;
  uint32_t compressions;
  uint32_t decompressions;
  uint32_t compressor_size;
  int32_t busy_buffer_count;
  uint32_t pages_wanted;
  uint32_t pages_reclaimed;
  uint8_t pages_wanted_reclaimed_valid;
};

/* 9124 */
struct stackshot_duration_v2
{
  uint64_t stackshot_duration;
  uint64_t stackshot_duration_outer;
  uint64_t stackshot_duration_prior;
};

/* 9125 */
struct __attribute__((aligned(4))) port_label_hash
{
  uint16_t plh_size;
  uint16_t plh_count;
  ipc_service_port_label **plh_array;
  int16_t *plh_chains;
  uint8_t *plh_gen;
  int16_t *plh_hash;
  int16_t plh_curgen_min;
  int16_t plh_curgen_max;
  uint8_t plh_curgen;
};

/* 9126 */
struct memory_object_pager_ops_0
{
  void (*memory_object_reference)(memory_object_t);
  void (*memory_object_deallocate)(memory_object_t);
  kern_return_t (*memory_object_init)(memory_object_t, memory_object_control_t, memory_object_cluster_size_t);
  kern_return_t (*memory_object_terminate)(memory_object_t);
  kern_return_t (*memory_object_data_request)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t, vm_prot_t, memory_object_fault_info_t);
  kern_return_t (*memory_object_data_return)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t, memory_object_offset_t *, int *, boolean_t, boolean_t, int);
  kern_return_t (*memory_object_data_initialize)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t);
  void *__obsolete_memory_object_data_unlock;
  void *__obsolete_memory_object_synchronize;
  kern_return_t (*memory_object_map)(memory_object_t, vm_prot_t);
  kern_return_t (*memory_object_last_unmap)(memory_object_t);
  void *__obsolete_memory_object_data_reclaim;
  boolean_t (*memory_object_backing_object)(memory_object_t, memory_object_offset_t, vm_object_t *, vm_object_offset_t *);
  const char *memory_object_pager_name;
};

/* 9127 */
typedef uintptr_t KUNCUserNotificationID;

/* 9128 */
typedef const char *xmlData_t;

/* 9129 */
typedef UNDReply *UNDReplyRef;

/* 9132 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__UNDAlertCompletedWithResult_rpc_t
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_ool_descriptor_t data;
  NDR_record_t_0 NDR;
  int result;
  mach_msg_type_number_t dataCnt;
};

/* 9133 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Request__UNDNotificationCreated_rpc_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int userLandNotificationKey;
};

/* 9134 */
typedef __Reply__UNDNotificationCreated_rpc_t _XUNDNotificationCreated_rpc::Reply;

/* 9846 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__UNDNotificationCreated_rpc_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 9135 */
typedef __Reply__UNDAlertCompletedWithResult_rpc_t _XUNDAlertCompletedWithResult_rpc::Reply;

/* 9847 */
struct __attribute__((packed)) __attribute__((aligned(4))) __Reply__UNDAlertCompletedWithResult_rpc_t
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  kern_return_t RetCode;
};

/* 9138 */
typedef IOOptionBits IODirection_1;

/* 9139 */
typedef IOOptionBits IOMemoryDescriptor::DMACommandOps_1;

/* 9141 */
struct __cppobj KLDBootstrap
{
  _BYTE gap0;
};

/* 9145 */
typedef void (*OSKextRequestResourceCallback_0)(OSKextRequestTag, OSReturn, const void *, uint32_t, void *);

/* 9146 */
typedef OSTaggedSharedPtr<const OSSymbol,OSCollection> OSTaggedPtr<const OSSymbol>_0;

/* 9148 */
typedef ccdigest_ctx_0 *ccdigest_ctx_t_2;

/* 9156 */
struct PE_state_0
{
  boolean_t initialized;
  PE_Video_1 video;
  void *deviceTreeHead;
  void *bootArgs;
  vm_size_t_0 deviceTreeSize;
};

/* 9159 */
struct ppl_iommu_desc_0
{
  const char *name;
  const uintptr_t magic;
  bool dynamic_state;
  kern_return_t (*init)(const ppl_iommu_desc *, const char *, const void *, size_t, ppl_iommu_state **, uint32_t *);
  kern_return_t (*iovmalloc)(ppl_iommu_state *, vm_address_t, size_t, uintptr_t, uintptr_t *, uint32_t *);
  kern_return_t (*map)(ppl_iommu_state *, const ppl_iommu_seg *, size_t, uintptr_t, ppl_iommu_seg_iter *, uintptr_t *, uint32_t *);
  kern_return_t (*unmap)(ppl_iommu_state *, const ppl_iommu_seg *, size_t, uintptr_t, ppl_iommu_seg_iter *, uintptr_t *);
  void (*iovmfree)(ppl_iommu_state *, vm_address_t, size_t, uintptr_t, uintptr_t *);
  kern_return_t (*ioctl)(ppl_iommu_state *, uintptr_t, const void *, size_t, void *, size_t);
};

/* 9160 */
typedef IOSKMapper *IOSKMapperRef_0;

/* 9161 */
typedef IOMemoryDescriptor_0 *IOSKMemoryRef_0;

/* 9163 */
typedef libkern::safe_allocation<char,os_detail::IOKit_typed_allocator<char,true>,os_detail::panic_trapping_policy> OSAllocation<char>;

/* 9164 */
typedef libkern::safe_allocation<unsigned char,os_detail::IOKit_typed_allocator<unsigned char,true>,os_detail::panic_trapping_policy> OSAllocation<unsigned char>;

/* 9168 */
typedef libkern::safe_allocation<SerData,os_detail::IOKit_typed_allocator<SerData,true>,os_detail::panic_trapping_policy> OSAllocation<SerData>;

/* 9169 */
struct memory_object_pager_ops_1
{
  void (*memory_object_reference)(memory_object_t);
  void (*memory_object_deallocate)(memory_object_t);
  kern_return_t (*memory_object_init)(memory_object_t, memory_object_control_t, memory_object_cluster_size_t);
  kern_return_t (*memory_object_terminate)(memory_object_t);
  kern_return_t (*memory_object_data_request)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t, vm_prot_t, memory_object_fault_info_t);
  kern_return_t (*memory_object_data_return)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t, memory_object_offset_t *, int *, boolean_t, boolean_t, int);
  kern_return_t (*memory_object_data_initialize)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t);
  void *__obsolete_memory_object_data_unlock;
  void *__obsolete_memory_object_synchronize;
  kern_return_t (*memory_object_map)(memory_object_t, vm_prot_t);
  kern_return_t (*memory_object_last_unmap)(memory_object_t);
  void *__obsolete_memory_object_data_reclaim;
  boolean_t (*memory_object_backing_object)(memory_object_t, memory_object_offset_t, vm_object_t *, vm_object_offset_t *);
  const char *memory_object_pager_name;
};

/* 9170 */
typedef IOGeneralMemoryDescriptor::serialize::SerData libkern::sa_detail::remove_const<SerData>::type;

/* 9185 */
struct ccchacha20poly1305_fns_0
{
  const ccchacha20poly1305_info *(*info)(void);
  int (*init)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, const uint8_t *);
  int (*reset)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *);
  int (*setnonce)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, const uint8_t *);
  int (*incnonce)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, uint8_t *);
  int (*aad)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, size_t, const void *);
  int (*encrypt)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, size_t, const void *, void *);
  int (*finalize)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, uint8_t *);
  int (*decrypt)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, size_t, const void *, void *);
  int (*verify)(const ccchacha20poly1305_info *, ccchacha20poly1305_ctx *, const uint8_t *);
};

/* 9187 */
struct z_stream_s_0
{
  Bytef *next_in;
  uInt avail_in;
  uLong total_in;
  Bytef *next_out;
  uInt avail_out;
  uLong total_out;
  char *msg;
  internal_state *state;
  alloc_func zalloc;
  free_func zfree;
  voidpf opaque;
  int data_type;
  uLong adler;
  uLong reserved;
};

/* 9189 */
struct internal_state_1
{
  z_streamp strm;
  z_input_func zinput;
  z_output_func zoutput;
  int status;
  Bytef *pending_buf;
  ulg pending_buf_size;
  Bytef *pending_out;
  uInt pending;
  int wrap;
  gz_headerp gzhead;
  uInt gzindex;
  Byte method;
  int last_flush;
  uInt w_size;
  uInt w_bits;
  uInt w_mask;
  Bytef *window;
  ulg window_size;
  Posf *prev;
  Posf *head;
  uInt ins_h;
  uInt hash_size;
  uInt hash_bits;
  uInt hash_mask;
  uInt hash_shift;
  long block_start;
  uInt match_length;
  IPos prev_match;
  int match_available;
  uInt strstart;
  uInt match_start;
  uInt lookahead;
  uInt prev_length;
  uInt max_chain_length;
  uInt max_lazy_match;
  int level;
  int strategy;
  uInt good_match;
  int nice_match;
  ct_data_s dyn_ltree[573];
  ct_data_s dyn_dtree[61];
  ct_data_s bl_tree[39];
  tree_desc_s l_desc;
  tree_desc_s d_desc;
  tree_desc_s bl_desc;
  ush bl_count[16];
  int heap[573];
  int heap_len;
  int heap_max;
  uch depth[573];
  uchf *l_buf;
  uInt lit_bufsize;
  uInt last_lit;
  ushf *d_buf;
  ulg opt_len;
  ulg static_len;
  uInt matches;
  int last_eob_len;
  ush bi_buf;
  int bi_valid;
};

/* 9190 */
struct mach_header_64_1
{
  uint32_t magic;
  cpu_type_t cputype;
  cpu_subtype_t_0 cpusubtype;
  uint32_t filetype;
  uint32_t ncmds;
  uint32_t sizeofcmds;
  uint32_t flags;
  uint32_t reserved;
};

/* 9199 */
typedef const OSMetaClassBase_0 *libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_osobject_retainer>::pointer_0;

/* 9202 */
struct __attribute__((aligned(8))) _bsdthread_terminate_0
{
  user_addr_t_0 ulock_addr;
  mach_port_name_t kport;
};

/* 9214 */
typedef arm_saved_state arm_saved_state_t_0;

/* 9221 */
typedef void (*nxprov_disconnected_fn_t_0)(kern_nexus_provider_t, kern_nexus_t, kern_channel_t);

/* 9222 */
struct kern_nexus_provider_init_0
{
  uint32_t nxpi_version;
  uint32_t nxpi_flags;
  nxprov_pre_connect_fn_t nxpi_pre_connect;
  nxprov_connected_fn_t_0 nxpi_connected;
  nxprov_pre_disconnect_fn_t_0 nxpi_pre_disconnect;
  nxprov_disconnected_fn_t_0 nxpi_disconnected;
  nxprov_ring_init_fn_t_0 nxpi_ring_init;
  nxprov_ring_fini_fn_t nxpi_ring_fini;
  nxprov_slot_init_fn_t nxpi_slot_init;
  nxprov_slot_fini_fn_t nxpi_slot_fini;
  nxprov_sync_tx_fn_t nxpi_sync_tx;
  nxprov_sync_rx_fn_t nxpi_sync_rx;
  nxprov_tx_doorbell_fn_t nxpi_tx_doorbell;
  nxprov_sync_packets_fn_t nxpi_rx_sync_packets;
  nxprov_sync_packets_fn_t nxpi_tx_sync_packets;
  nxprov_capab_config_fn_t nxpi_config_capab;
};

/* 9223 */
struct nxdom_prov_cb_0
{
  int (*dp_cb_init)(kern_nexus_domain_provider *);
  void (*dp_cb_fini)(kern_nexus_domain_provider *);
  int (*dp_cb_params)(kern_nexus_domain_provider *, const uint32_t, const nxprov_params *, nxprov_params *, skmem_region_params *, uint32_t);
  int (*dp_cb_mem_new)(kern_nexus_domain_provider *, kern_nexus *, nexus_adapter *);
  int (*dp_cb_config)(kern_nexus_domain_provider *, kern_nexus *, nx_cfg_req *, int, proc *, kauth_cred_t);
  int (*dp_cb_nx_ctor)(kern_nexus *);
  void (*dp_cb_nx_dtor)(kern_nexus *);
  int (*dp_cb_nx_mem_info)(kern_nexus *, kern_pbufpool **, kern_pbufpool **);
  size_t (*dp_cb_nx_mib_get)(kern_nexus *, nexus_mib_filter *, void *, size_t, proc *);
  int (*dp_cb_nx_stop)(kern_nexus *);
};

/* 9227 */
struct kern_nexus_provider_init_1
{
  uint32_t nxpi_version;
  uint32_t nxpi_flags;
  nxprov_pre_connect_fn_t nxpi_pre_connect;
  nxprov_connected_fn_t_0 nxpi_connected;
  nxprov_pre_disconnect_fn_t_0 nxpi_pre_disconnect;
  nxprov_disconnected_fn_t_0 nxpi_disconnected;
  nxprov_ring_init_fn_t_0 nxpi_ring_init;
  nxprov_ring_fini_fn_t nxpi_ring_fini;
  nxprov_slot_init_fn_t nxpi_slot_init;
  nxprov_slot_fini_fn_t_0 nxpi_slot_fini;
  nxprov_sync_tx_fn_t nxpi_sync_tx;
  nxprov_sync_rx_fn_t nxpi_sync_rx;
  nxprov_tx_doorbell_fn_t nxpi_tx_doorbell;
  nxprov_sync_packets_fn_t nxpi_rx_sync_packets;
  nxprov_sync_packets_fn_t nxpi_tx_sync_packets;
  nxprov_capab_config_fn_t nxpi_config_capab;
};

/* 9231 */
struct kern_nexus_provider_init_2
{
  uint32_t nxpi_version;
  uint32_t nxpi_flags;
  nxprov_pre_connect_fn_t_0 nxpi_pre_connect;
  nxprov_connected_fn_t_0 nxpi_connected;
  nxprov_pre_disconnect_fn_t_0 nxpi_pre_disconnect;
  nxprov_disconnected_fn_t_0 nxpi_disconnected;
  nxprov_ring_init_fn_t_0 nxpi_ring_init;
  nxprov_ring_fini_fn_t nxpi_ring_fini;
  nxprov_slot_init_fn_t nxpi_slot_init;
  nxprov_slot_fini_fn_t nxpi_slot_fini;
  nxprov_sync_tx_fn_t nxpi_sync_tx;
  nxprov_sync_rx_fn_t nxpi_sync_rx;
  nxprov_tx_doorbell_fn_t nxpi_tx_doorbell;
  nxprov_sync_packets_fn_t nxpi_rx_sync_packets;
  nxprov_sync_packets_fn_t nxpi_tx_sync_packets;
  nxprov_capab_config_fn_t nxpi_config_capab;
};

/* 9232 */
struct vfsops_0
{
  int (*vfs_mount)(mount *, vnode_t, user_addr_t_0, vfs_context_t);
  int (*vfs_start)(mount *, int, vfs_context_t);
  int (*vfs_unmount)(mount *, int, vfs_context_t);
  int (*vfs_root)(mount *, vnode **, vfs_context_t);
  int (*vfs_quotactl)(mount *, int, uid_t, caddr_t, vfs_context_t);
  int (*vfs_getattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_sync)(mount *, int, vfs_context_t);
  int (*vfs_vget)(mount *, ino64_t, vnode **, vfs_context_t);
  int (*vfs_fhtovp)(mount *, int, unsigned __int8 *, vnode **, vfs_context_t);
  int (*vfs_vptofh)(vnode *, int *, unsigned __int8 *, vfs_context_t);
  int (*vfs_init)(vfsconf *);
  int (*vfs_sysctl)(int *, u_int, user_addr_t_0, size_t *, user_addr_t_0, size_t, vfs_context_t);
  int (*vfs_setattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_ioctl)(mount *, u_long, caddr_t, int, vfs_context_t);
  int (*vfs_vget_snapdir)(mount *, vnode **, vfs_context_t);
  void *vfs_reserved5;
  void *vfs_reserved4;
  void *vfs_reserved3;
  void *vfs_reserved2;
  void *vfs_reserved1;
};

/* 9233 */
struct __attribute__((aligned(8))) vm_packing_params_0
{
  vm_offset_t_0 vmpp_base;
  uint8_t vmpp_bits;
  uint8_t vmpp_shift;
  bool vmpp_base_relative;
};

/* 9234 */
typedef vm_packing_params_0 vm_packing_params_t_0;

/* 9235 */
struct filedesc_0
{
  lck_mtx_t fd_lock;
  uint8_t fd_fpdrainwait;
  u_short fd_cmask;
  int fd_nfiles;
  int fd_afterlast;
  int fd_freefile;
  int fd_knlistsize;
  _BYTE gap24[12];
  char *fd_ofileflags;
  klist *fd_knlist;
  kqworkq *fd_wqkqueue;
  vnode *fd_cdir;
  vnode *fd_rdir;
  lck_rw_t fd_dirs_lock;
  lck_mtx_t fd_kqhashlock;
  u_long fd_kqhashmask;
  kqwllist *fd_kqhash;
  lck_mtx_t fd_knhashlock;
  u_long fd_knhashmask;
  klist *fd_knhash;
};

/* 9236 */
typedef errno_t (*bpf_packet_func_1)(ifnet_t, mbuf_t);

/* 9237 */
typedef void (*ifnet_detached_func_0)(ifnet_t);

/* 9238 */
struct vfsops_1
{
  int (*vfs_mount)(mount *, vnode_t, user_addr_t_0, vfs_context_t);
  int (*vfs_start)(mount *, int, vfs_context_t);
  int (*vfs_unmount)(mount *, int, vfs_context_t);
  int (*vfs_root)(mount *, vnode **, vfs_context_t);
  int (*vfs_quotactl)(mount *, int, uid_t, caddr_t, vfs_context_t);
  int (*vfs_getattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_sync)(mount *, int, vfs_context_t);
  int (*vfs_vget)(mount *, ino64_t, vnode **, vfs_context_t);
  int (*vfs_fhtovp)(mount *, int, unsigned __int8 *, vnode **, vfs_context_t);
  int (*vfs_vptofh)(vnode *, int *, unsigned __int8 *, vfs_context_t);
  int (*vfs_init)(vfsconf *);
  int (*vfs_sysctl)(int *, u_int, user_addr_t_0, size_t *, user_addr_t_0, size_t, vfs_context_t);
  int (*vfs_setattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_ioctl)(mount *, u_long, caddr_t, int, vfs_context_t);
  int (*vfs_vget_snapdir)(mount *, vnode **, vfs_context_t);
  void *vfs_reserved5;
  void *vfs_reserved4;
  void *vfs_reserved3;
  void *vfs_reserved2;
  void *vfs_reserved1;
};

/* 9239 */
struct memory_object_pager_ops_2
{
  void (*memory_object_reference)(memory_object_t);
  void (*memory_object_deallocate)(memory_object_t);
  kern_return_t (*memory_object_init)(memory_object_t, memory_object_control_t, memory_object_cluster_size_t);
  kern_return_t (*memory_object_terminate)(memory_object_t);
  kern_return_t (*memory_object_data_request)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t, vm_prot_t, memory_object_fault_info_t);
  kern_return_t (*memory_object_data_return)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t, memory_object_offset_t *, int *, boolean_t, boolean_t, int);
  kern_return_t (*memory_object_data_initialize)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t);
  void *__obsolete_memory_object_data_unlock;
  void *__obsolete_memory_object_synchronize;
  kern_return_t (*memory_object_map)(memory_object_t, vm_prot_t);
  kern_return_t (*memory_object_last_unmap)(memory_object_t);
  void *__obsolete_memory_object_data_reclaim;
  boolean_t (*memory_object_backing_object)(memory_object_t, memory_object_offset_t, vm_object_t *, vm_object_offset_t *);
  const char *memory_object_pager_name;
};

/* 9240 */
struct __attribute__((aligned(8))) crypt_file_data
{
  char *filename;
  cpu_type_t cputype;
  cpu_subtype_t_0 cpusubtype;
  crypt_origin_t origin;
};

/* 9242 */
union user_semun
{
  user_addr_t_0 buf;
  user_addr_t_0 array;
};

/* 9244 */
struct devnode_0
{
  devfstype_t dn_type;
  os_ref_atomic_t dn_refcount;
  u_short dn_mode;
  uid_t dn_uid;
  gid_t dn_gid;
  timespec dn_atime;
  timespec dn_mtime;
  timespec dn_ctime;
  int (***dn_ops)(void *);
  int dn_links;
  devfsmount *dn_dvm;
  vnode *dn_vn;
  int dn_len;
  devdirent_t *dn_linklist;
  devnode_t *dn_nextsibling;
  devnode_t **dn_prevsiblingp;
  devnode_type_t dn_typeinfo;
  int dn_change;
  int dn_update;
  int dn_access;
  int dn_lflags;
  ino_t dn_ino;
  int (*dn_clone)(dev_t, int);
  label *dn_label;
};

/* 9246 */
struct firehose_buffer_map_info_s
{
  mach_vm_address_t_0 fbmi_addr;
  mach_vm_size_t_0 fbmi_size;
};

/* 9247 */
struct _img4_dgst_0
{
  img4_struct_version_t i4d_version;
  size_t i4d_len;
  uint8_t i4d_bytes[48];
};

/* 9248 */
typedef errno_t (*img4_runtime_copy_object_t_0)(const img4_runtime_t *, const img4_runtime_object_spec_t *, img4_buff_t *, size_t *);

/* 9249 */
struct __attribute__((aligned(32))) _img4_runtime_0
{
  img4_struct_version_t i4rt_version;
  const char *i4rt_name;
  img4_runtime_init_t i4rt_init;
  img4_runtime_alloc_t_0 i4rt_alloc;
  img4_runtime_dealloc_t_0 i4rt_dealloc;
  __attribute__((aligned(16))) img4_runtime_log_handle_t i4rt_log_handle;
  _BYTE gap38[32];
  void *i4rt_context;
  _BYTE gap60[8];
  img4_runtime_execute_object_t i4rt_execute_object;
  img4_runtime_copy_object_t_0 i4rt_copy_object;
  img4_runtime_alloc_type_t i4rt_alloc_type;
  img4_runtime_dealloc_type_t i4rt_dealloc_type;
};

/* 9250 */
typedef _img4_runtime_0 img4_runtime_t_0;

/* 9251 */
struct _img4_buff_0
{
  img4_struct_version_t i4b_version;
  uint8_t *i4b_bytes;
  size_t i4b_len;
  img4_runtime_dealloc_t_0 i4b_dealloc;
};

/* 9252 */
typedef _img4_buff_0 img4_buff_t_0;

/* 9254 */
struct memorystatus_memlimit_properties2
{
  memorystatus_memlimit_properties_t v1;
  uint32_t memlimit_increase;
  uint32_t memlimit_increase_bytes;
};

/* 9261 */
struct kcdata_compress_descriptor_0
{
  z_stream kcd_cd_zs;
  void *kcd_cd_base;
  uint64_t kcd_cd_offset;
  size_t kcd_cd_maxoffset;
  uint64_t kcd_cd_mark_begin;
  _BYTE gap90[16];
  void (*kcd_cd_memcpy_f)(void *, const void *, size_t);
  mach_vm_address_t_0 kcd_cd_totalout_addr;
  mach_vm_address_t_0 kcd_cd_totalin_addr;
};

/* 9262 */
struct __attribute__((aligned(8))) kcdata_descriptor_0
{
  uint32_t kcd_length;
  uint16_t kcd_flags;
  uint16_t kcd_user_flags;
  mach_vm_address_t_0 kcd_addr_begin;
  mach_vm_address_t_0 kcd_addr_end;
  kcdata_compress_descriptor_0 kcd_comp_d;
  uint32_t kcd_endalloced;
};

/* 9263 */
struct vfsops_2
{
  int (*vfs_mount)(mount *, vnode_t, user_addr_t_0, vfs_context_t);
  int (*vfs_start)(mount *, int, vfs_context_t);
  int (*vfs_unmount)(mount *, int, vfs_context_t);
  int (*vfs_root)(mount *, vnode **, vfs_context_t);
  int (*vfs_quotactl)(mount *, int, uid_t, caddr_t, vfs_context_t);
  int (*vfs_getattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_sync)(mount *, int, vfs_context_t);
  int (*vfs_vget)(mount *, ino64_t, vnode **, vfs_context_t);
  int (*vfs_fhtovp)(mount *, int, unsigned __int8 *, vnode **, vfs_context_t);
  int (*vfs_vptofh)(vnode *, int *, unsigned __int8 *, vfs_context_t);
  int (*vfs_init)(vfsconf *);
  int (*vfs_sysctl)(int *, u_int, user_addr_t_0, size_t *, user_addr_t_0, size_t, vfs_context_t);
  int (*vfs_setattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_ioctl)(mount *, u_long, caddr_t, int, vfs_context_t);
  int (*vfs_vget_snapdir)(mount *, vnode **, vfs_context_t);
  void *vfs_reserved5;
  void *vfs_reserved4;
  void *vfs_reserved3;
  void *vfs_reserved2;
  void *vfs_reserved1;
};

/* 9265 */
struct vfsops_3
{
  int (*vfs_mount)(mount *, vnode_t, user_addr_t_0, vfs_context_t);
  int (*vfs_start)(mount *, int, vfs_context_t);
  int (*vfs_unmount)(mount *, int, vfs_context_t);
  int (*vfs_root)(mount *, vnode **, vfs_context_t);
  int (*vfs_quotactl)(mount *, int, uid_t, caddr_t, vfs_context_t);
  int (*vfs_getattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_sync)(mount *, int, vfs_context_t);
  int (*vfs_vget)(mount *, ino64_t, vnode **, vfs_context_t);
  int (*vfs_fhtovp)(mount *, int, unsigned __int8 *, vnode **, vfs_context_t);
  int (*vfs_vptofh)(vnode *, int *, unsigned __int8 *, vfs_context_t);
  int (*vfs_init)(vfsconf *);
  int (*vfs_sysctl)(int *, u_int, user_addr_t_0, size_t *, user_addr_t_0, size_t, vfs_context_t);
  int (*vfs_setattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_ioctl)(mount *, u_long, caddr_t, int, vfs_context_t);
  int (*vfs_vget_snapdir)(mount *, vnode **, vfs_context_t);
  void *vfs_reserved5;
  void *vfs_reserved4;
  void *vfs_reserved3;
  void *vfs_reserved2;
  void *vfs_reserved1;
};

/* 9266 */
struct dk_apfs_wbc_range
{
  dev_t dev;
  uint32_t count;
  dk_extent_t extents[2];
};

/* 9267 */
struct ml_topology_cluster_1
{
  unsigned int cluster_id;
  __attribute__((aligned(8))) unsigned int num_cpus;
  unsigned int first_cpu_id;
  uint64_t cpu_mask;
  vm_offset_t_0 acc_IMPL_regs;
  uint64_t acc_IMPL_pa;
  uint64_t acc_IMPL_len;
  vm_offset_t_0 cpm_IMPL_regs;
  uint64_t cpm_IMPL_pa;
  uint64_t cpm_IMPL_len;
};

/* 9268 */
struct ml_topology_cpu_1
{
  unsigned int cpu_id;
  uint32_t phys_id;
  unsigned int cluster_id;
  unsigned int die_id;
  _BYTE gap10[4];
  uint32_t l2_access_penalty;
  uint32_t l2_cache_size;
  uint32_t l2_cache_id;
  uint32_t l3_cache_size;
  uint32_t l3_cache_id;
  vm_offset_t_0 cpu_IMPL_regs;
  uint64_t cpu_IMPL_pa;
  uint64_t cpu_IMPL_len;
  vm_offset_t_0 cpu_UTTDBG_regs;
  uint64_t cpu_UTTDBG_pa;
  uint64_t cpu_UTTDBG_len;
  vm_offset_t_0 coresight_regs;
  uint64_t coresight_pa;
  uint64_t coresight_len;
  unsigned int die_cluster_id;
  unsigned int cluster_core_id;
};

/* 9270 */
struct vfsops_4
{
  int (*vfs_mount)(mount *, vnode_t, user_addr_t_0, vfs_context_t);
  int (*vfs_start)(mount *, int, vfs_context_t);
  int (*vfs_unmount)(mount *, int, vfs_context_t);
  int (*vfs_root)(mount *, vnode **, vfs_context_t);
  int (*vfs_quotactl)(mount *, int, uid_t, caddr_t, vfs_context_t);
  int (*vfs_getattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_sync)(mount *, int, vfs_context_t);
  int (*vfs_vget)(mount *, ino64_t, vnode **, vfs_context_t);
  int (*vfs_fhtovp)(mount *, int, unsigned __int8 *, vnode **, vfs_context_t);
  int (*vfs_vptofh)(vnode *, int *, unsigned __int8 *, vfs_context_t);
  int (*vfs_init)(vfsconf *);
  int (*vfs_sysctl)(int *, u_int, user_addr_t_0, size_t *, user_addr_t_0, size_t, vfs_context_t);
  int (*vfs_setattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_ioctl)(mount *, u_long, caddr_t, int, vfs_context_t);
  int (*vfs_vget_snapdir)(mount *, vnode **, vfs_context_t);
  void *vfs_reserved5;
  void *vfs_reserved4;
  void *vfs_reserved3;
  void *vfs_reserved2;
  void *vfs_reserved1;
};

/* 9272 */
struct vfsops_5
{
  int (*vfs_mount)(mount *, vnode_t, user_addr_t_0, vfs_context_t);
  int (*vfs_start)(mount *, int, vfs_context_t);
  int (*vfs_unmount)(mount *, int, vfs_context_t);
  int (*vfs_root)(mount *, vnode **, vfs_context_t);
  int (*vfs_quotactl)(mount *, int, uid_t, caddr_t, vfs_context_t);
  int (*vfs_getattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_sync)(mount *, int, vfs_context_t);
  int (*vfs_vget)(mount *, ino64_t, vnode **, vfs_context_t);
  int (*vfs_fhtovp)(mount *, int, unsigned __int8 *, vnode **, vfs_context_t);
  int (*vfs_vptofh)(vnode *, int *, unsigned __int8 *, vfs_context_t);
  int (*vfs_init)(vfsconf *);
  int (*vfs_sysctl)(int *, u_int, user_addr_t_0, size_t *, user_addr_t_0, size_t, vfs_context_t);
  int (*vfs_setattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_ioctl)(mount *, u_long, caddr_t, int, vfs_context_t);
  int (*vfs_vget_snapdir)(mount *, vnode **, vfs_context_t);
  void *vfs_reserved5;
  void *vfs_reserved4;
  void *vfs_reserved3;
  void *vfs_reserved2;
  void *vfs_reserved1;
};

/* 9274 */
typedef errno_t (*ipf_output_func_0)(void *, mbuf_t *, ipf_pktopts_t);

/* 9275 */
typedef errno_t (*ipf_input_func_0)(void *, mbuf_t *, int, u_int8_t);

/* 9276 */
struct ipf_filter_0
{
  void *cookie;
  const char *name;
  ipf_input_func_0 ipf_input;
  ipf_output_func_0 ipf_output;
  ipf_detach_func ipf_detach;
};

/* 9279 */
typedef errno_t (*ifnet_output_func_0)(ifnet_t, mbuf_t);

/* 9280 */
typedef void (*ifnet_input_poll_func_0)(ifnet_t, u_int32_t, u_int32_t, mbuf_t *, mbuf_t *, u_int32_t *, u_int32_t *);

/* 9281 */
typedef errno_t (*ifnet_pre_enqueue_func_0)(ifnet_t, mbuf_t);

/* 9285 */
struct fq_if_bitmap_ops_0
{
  _BYTE gap0[32];
};

/* 9286 */
struct pbuf_0
{
  pbuf_type pb_type;
  union
  {
    mbuf *pbu_mbuf;
    pbuf_memory pbu_memory;
  } pb_u;
  void *pb_data;
  uint32_t pb_packet_len;
  uint32_t pb_contig_len;
  uint32_t *pb_csum_flags;
  uint32_t *pb_csum_data;
  uint8_t *pb_proto;
  uint8_t *pb_flowsrc;
  uint32_t *pb_flowid;
  uint32_t *pb_flow_gencnt;
  uint32_t *pb_flags;
  pf_mtag *pb_pftag;
  pf_fragment_tag *pb_pf_fragtag;
  ifnet *pb_ifp;
  pbuf *pb_next;
};

/* 9287 */
typedef void (*ifnet_free_func_0)(ifnet_t);

/* 9288 */
typedef errno_t (*proto_media_resolve_multi_0)(ifnet_t, const sockaddr *, sockaddr_dl *, size_t);

/* 9291 */
struct nstat_msg_query_src
{
  nstat_msg_hdr hdr;
  nstat_src_ref_t srcref;
};

/* 9293 */
struct kern_nexus_domain_provider_init_1
{
  uint32_t nxdpi_version;
  uint32_t nxdpi_flags;
  nxdom_prov_init_fn_t nxdpi_init;
  nxdom_prov_fini_fn_t_0 nxdpi_fini;
};

/* 9294 */
struct nxdom_prov_cb_1
{
  int (*dp_cb_init)(kern_nexus_domain_provider *);
  void (*dp_cb_fini)(kern_nexus_domain_provider *);
  int (*dp_cb_params)(kern_nexus_domain_provider *, const uint32_t, const nxprov_params *, nxprov_params *, skmem_region_params_0 *, uint32_t);
  int (*dp_cb_mem_new)(kern_nexus_domain_provider *, kern_nexus *, nexus_adapter *);
  int (*dp_cb_config)(kern_nexus_domain_provider *, kern_nexus *, nx_cfg_req *, int, proc *, kauth_cred_t);
  int (*dp_cb_nx_ctor)(kern_nexus *);
  void (*dp_cb_nx_dtor)(kern_nexus *);
  int (*dp_cb_nx_mem_info)(kern_nexus *, kern_pbufpool **, kern_pbufpool **);
  size_t (*dp_cb_nx_mib_get)(kern_nexus *, nexus_mib_filter *, void *, size_t, proc *);
  int (*dp_cb_nx_stop)(kern_nexus *);
};

/* 9298 */
struct nxdom_prov_cb_2
{
  int (*dp_cb_init)(kern_nexus_domain_provider *);
  void (*dp_cb_fini)(kern_nexus_domain_provider *);
  int (*dp_cb_params)(kern_nexus_domain_provider *, const uint32_t, const nxprov_params *, nxprov_params *, skmem_region_params *, uint32_t);
  int (*dp_cb_mem_new)(kern_nexus_domain_provider *, kern_nexus *, nexus_adapter *);
  int (*dp_cb_config)(kern_nexus_domain_provider *, kern_nexus *, nx_cfg_req *, int, proc *, kauth_cred_t);
  int (*dp_cb_nx_ctor)(kern_nexus *);
  void (*dp_cb_nx_dtor)(kern_nexus *);
  int (*dp_cb_nx_mem_info)(kern_nexus *, kern_pbufpool **, kern_pbufpool **);
  size_t (*dp_cb_nx_mib_get)(kern_nexus *, nexus_mib_filter *, void *, size_t, proc *);
  int (*dp_cb_nx_stop)(kern_nexus *);
};

/* 9299 */
struct devnode_1
{
  devfstype_t dn_type;
  os_ref_atomic_t dn_refcount;
  u_short dn_mode;
  uid_t dn_uid;
  gid_t dn_gid;
  timespec dn_atime;
  timespec dn_mtime;
  timespec dn_ctime;
  int (***dn_ops)(void *);
  int dn_links;
  devfsmount *dn_dvm;
  vnode *dn_vn;
  int dn_len;
  devdirent_t *dn_linklist;
  devnode_t *dn_nextsibling;
  devnode_t **dn_prevsiblingp;
  devnode_type_t dn_typeinfo;
  int dn_change;
  int dn_update;
  int dn_access;
  int dn_lflags;
  ino_t dn_ino;
  int (*dn_clone)(dev_t, int);
  label *dn_label;
};

/* 9300 */
struct vfsops_6
{
  int (*vfs_mount)(mount *, vnode_t, user_addr_t_0, vfs_context_t);
  int (*vfs_start)(mount *, int, vfs_context_t);
  int (*vfs_unmount)(mount *, int, vfs_context_t);
  int (*vfs_root)(mount *, vnode **, vfs_context_t);
  int (*vfs_quotactl)(mount *, int, uid_t, caddr_t, vfs_context_t);
  int (*vfs_getattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_sync)(mount *, int, vfs_context_t);
  int (*vfs_vget)(mount *, ino64_t, vnode **, vfs_context_t);
  int (*vfs_fhtovp)(mount *, int, unsigned __int8 *, vnode **, vfs_context_t);
  int (*vfs_vptofh)(vnode *, int *, unsigned __int8 *, vfs_context_t);
  int (*vfs_init)(vfsconf *);
  int (*vfs_sysctl)(int *, u_int, user_addr_t_0, size_t *, user_addr_t_0, size_t, vfs_context_t);
  int (*vfs_setattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_ioctl)(mount *, u_long, caddr_t, int, vfs_context_t);
  int (*vfs_vget_snapdir)(mount *, vnode **, vfs_context_t);
  void *vfs_reserved5;
  void *vfs_reserved4;
  void *vfs_reserved3;
  void *vfs_reserved2;
  void *vfs_reserved1;
};

/* 9304 */
struct fsioc_auth_fs
{
  vnode_t authvp;
};

/* 9305 */
union graft_args
{
  u_int8_t max_size[512];
  secure_boot_cryptex_args_t sbc_args;
};

/* 9306 */
struct __attribute__((aligned(8))) fs_role_mount_args
{
  mount_t root_mp;
  uint32_t mount_role;
};

/* 9307 */
struct fasttrap_instr_query
{
  uint64_t ftiq_pc;
  pid_t ftiq_pid;
  fasttrap_instr_t ftiq_instr;
};

/* 9316 */
struct sdt_probe_0
{
  sdt_provider_t *sdp_provider;
  char *sdp_name;
  int sdp_namelen;
  dtrace_id_t sdp_id;
  modctl *sdp_ctl;
  int sdp_loadcnt;
  int sdp_primary;
  sdt_instr_t *sdp_patchpoint;
  sdt_instr_t sdp_patchval;
  sdt_instr_t sdp_savedval;
  sdt_probe *sdp_next;
  sdt_probe *sdp_hashnext;
};

/* 9320 */
struct dtrace_conf
{
  uint_t_0 dtc_difversion;
  uint_t_0 dtc_difintregs;
  uint_t_0 dtc_diftupregs;
  uint_t_0 dtc_ctfmodel;
  uint_t_0 dtc_pad[8];
};

/* 9321 */
struct dtrace_providerdesc
{
  char dtvd_name[64];
  dtrace_pattr_t dtvd_attr;
  dtrace_ppriv_t dtvd_priv;
};

/* 9334 */
struct dtrace_difo_0
{
  dif_instr_t *dtdo_buf;
  uint64_t *dtdo_inttab;
  char *dtdo_strtab;
  dtrace_difv_t *dtdo_vartab;
  uint_t_0 dtdo_len;
  uint_t_0 dtdo_intlen;
  uint_t_0 dtdo_strlen;
  uint_t_0 dtdo_varlen;
  dtrace_diftype_t dtdo_rtype;
  uint_t_0 dtdo_refcnt;
  uint_t_0 dtdo_destructive;
};

/* 9338 */
struct gss_cfx_wrap_token_desc_struct
{
  uint8_t TOK_ID[2];
  uint8_t Flags;
  uint8_t Filler;
  uint8_t EC[2];
  uint8_t RRC[2];
  uint8_t SND_SEQ[8];
};

/* 9339 */
struct crypto_ctx_0
{
  uint32_t etype;
  uint32_t flags;
  size_t mpad;
  lck_mtx_t lock;
  lucid_context_t gss_ctx;
  void *key;
  const ccdigest_info_0 *di;
  const ccmode_cbc *enc_mode;
  const ccmode_cbc *dec_mode;
  key_schedule ks;
  uint32_t digest_size;
  uint32_t keylen;
  krb5_key_t ckeys[2];
};

/* 9340 */
struct vfsops_7
{
  int (*vfs_mount)(mount *, vnode_t, user_addr_t_0, vfs_context_t);
  int (*vfs_start)(mount *, int, vfs_context_t);
  int (*vfs_unmount)(mount *, int, vfs_context_t);
  int (*vfs_root)(mount *, vnode **, vfs_context_t);
  int (*vfs_quotactl)(mount *, int, uid_t, caddr_t, vfs_context_t);
  int (*vfs_getattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_sync)(mount *, int, vfs_context_t);
  int (*vfs_vget)(mount *, ino64_t, vnode **, vfs_context_t);
  int (*vfs_fhtovp)(mount *, int, unsigned __int8 *, vnode **, vfs_context_t);
  int (*vfs_vptofh)(vnode *, int *, unsigned __int8 *, vfs_context_t);
  int (*vfs_init)(vfsconf *);
  int (*vfs_sysctl)(int *, u_int, user_addr_t_0, size_t *, user_addr_t_0, size_t, vfs_context_t);
  int (*vfs_setattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_ioctl)(mount *, u_long, caddr_t, int, vfs_context_t);
  int (*vfs_vget_snapdir)(mount *, vnode **, vfs_context_t);
  void *vfs_reserved5;
  void *vfs_reserved4;
  void *vfs_reserved3;
  void *vfs_reserved2;
  void *vfs_reserved1;
};

/* 9341 */
struct ppl_iommu_desc_1
{
  const char *name;
  const uintptr_t magic;
  bool dynamic_state;
  kern_return_t (*init)(const ppl_iommu_desc *, const char *, const void *, size_t, ppl_iommu_state **, uint32_t *);
  kern_return_t (*iovmalloc)(ppl_iommu_state *, vm_address_t_0, size_t, uintptr_t, uintptr_t *, uint32_t *);
  kern_return_t (*map)(ppl_iommu_state *, const ppl_iommu_seg_0 *, size_t, uintptr_t, ppl_iommu_seg_iter *, uintptr_t *, uint32_t *);
  kern_return_t (*unmap)(ppl_iommu_state *, const ppl_iommu_seg *, size_t, uintptr_t, ppl_iommu_seg_iter *, uintptr_t *);
  void (*iovmfree)(ppl_iommu_state *, vm_address_t_0, size_t, uintptr_t, uintptr_t *);
  kern_return_t (*ioctl)(ppl_iommu_state *, uintptr_t, const void *, size_t, void *, size_t);
};

/* 9346 */
typedef ipc_port_t_1 mach_port_t_2;

/* 9347 */
struct memory_object_pager_ops_3
{
  void (*memory_object_reference)(memory_object_t);
  void (*memory_object_deallocate)(memory_object_t);
  kern_return_t (*memory_object_init)(memory_object_t, memory_object_control_t, memory_object_cluster_size_t);
  kern_return_t (*memory_object_terminate)(memory_object_t);
  kern_return_t (*memory_object_data_request)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t, vm_prot_t, memory_object_fault_info_t);
  kern_return_t (*memory_object_data_return)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t, memory_object_offset_t *, int *, boolean_t, boolean_t, int);
  kern_return_t (*memory_object_data_initialize)(memory_object_t, memory_object_offset_t, memory_object_cluster_size_t);
  void *__obsolete_memory_object_data_unlock;
  void *__obsolete_memory_object_synchronize;
  kern_return_t (*memory_object_map)(memory_object_t, vm_prot_t);
  kern_return_t (*memory_object_last_unmap)(memory_object_t);
  void *__obsolete_memory_object_data_reclaim;
  boolean_t (*memory_object_backing_object)(memory_object_t, memory_object_offset_t, vm_object_t *, vm_object_offset_t *);
  const char *memory_object_pager_name;
};

/* 9348 */
struct recount_task_0
{
  recount_track *rtk_lifetime;
  recount_usage *rtk_terminated;
};

/* 9349 */
struct mach_header_64_2
{
  uint32_t magic;
  cpu_type_t_0 cputype;
  cpu_subtype_t_0 cpusubtype;
  uint32_t filetype;
  uint32_t ncmds;
  uint32_t sizeofcmds;
  uint32_t flags;
  uint32_t reserved;
};

/* 9350 */
struct mach_header_64_3
{
  uint32_t magic;
  cpu_type_t_0 cputype;
  cpu_subtype_t_0 cpusubtype;
  uint32_t filetype;
  uint32_t ncmds;
  uint32_t sizeofcmds;
  uint32_t flags;
  uint32_t reserved;
};

/* 9352 */
struct __attribute__((aligned(2))) pmap_cpu_data_0
{
  pmap_t cpu_nested_pmap;
  uint64_t commpage_page_shift;
  const page_table_attr *cpu_nested_pmap_attr;
  vm_map_address_t cpu_nested_region_addr;
  vm_map_offset_t cpu_nested_region_size;
  unsigned int cpu_number;
  bool copywindow_strong_sync[4];
  bool inflight_disconnect;
  pv_free_list_t pv_free;
  pv_entry_t *pv_free_spill_marker;
  uint8_t cpu_sw_asids[255];
};

/* 9357 */
struct entropy_data
{
  SHA256_CTX sha256_ctx;
  bool sha256_ctx_init;
  bitmap_t filter[32];
  uint64_t total_sample_count;
  uint64_t startup_sample_count;
  uint64_t read_sample_count;
  lck_grp_t lock_group;
  lck_mtx_t_0 mutex;
  entropy_health_test_t repetition_count_test;
  entropy_health_test_t adaptive_proportion_test;
};

/* 9363 */
struct __attribute__((aligned(8))) task_watchport_elem_1
{
  task_t_1 twe_task;
  ipc_port_t_0 twe_port;
  _BYTE gap10[8];
};

/* 9365 */
struct vm_locks_array
{
  char pad;
  __attribute__((aligned(64))) lck_mtx_t_0 vm_page_queue_lock2;
  __attribute__((aligned(64))) lck_mtx_t_0 vm_page_queue_free_lock2;
  __attribute__((aligned(64))) char pad2;
};

/* 9367 */
struct host_basic_info_0
{
  integer_t max_cpus;
  integer_t avail_cpus;
  natural_t memory_size;
  cpu_type_t_0 cpu_type;
  cpu_subtype_t_0 cpu_subtype;
  cpu_threadtype_t cpu_threadtype;
  integer_t physical_cpu;
  integer_t physical_cpu_max;
  integer_t logical_cpu;
  integer_t logical_cpu_max;
  uint64_t max_mem;
};

/* 9370 */
struct ipc_mqueue_0
{
  circle_queue_head_t imq_messages;
  mach_port_seqno_t imq_seqno;
  mach_port_name_t_0 imq_receiver_name;
  uint16_t imq_msgcount;
  uint16_t imq_qlimit;
  uint32_t imq_context;
  union
  {
    klist imq_klist;
    knote *imq_inheritor_knote;
    turnstile *imq_inheritor_turnstile;
    thread_t_0 imq_inheritor_thread_ref;
    thread_t_0 imq_srp_owner_thread;
  };
};

/* 9371 */
struct clock_ops_0
{
  int (*c_config)(void);
  int (*c_init)(void);
  kern_return_t (*c_gettime)(mach_timespec_t *);
  kern_return_t (*c_getattr)(clock_flavor_t, clock_attr_t, mach_msg_type_number_t *);
};

/* 9372 */
struct __attribute__((aligned(8))) task_watchport_elem_2
{
  task_t_1 twe_task;
  ipc_port_t_1 twe_port;
  _BYTE gap10[8];
};

/* 9373 */
struct thread_pri_floor_0
{
  thread_t_1 thread;
};

/* 9377 */
typedef struct semaphore *semaphore_t_1;

/* 9378 */
struct mk_timer_expire_msg
{
  mach_msg_header_t_0 header;
  uint64_t unused[3];
};

/* 9380 */
struct mach_msg_port_descriptor_t_0
{
  mach_port_t_1 name;
  _BYTE gap8[4];
  uint32_t pad_end;
};

/* 9390 */
struct ipc_notify_nsenders_0
{
  ipc_port_t_0 ns_notify;
  mach_port_mscount_t ns_mscount;
  boolean_t ns_is_kobject;
};

/* 9391 */
typedef ipc_notify_nsenders_0 ipc_notify_nsenders_t_0;

/* 9393 */
struct __attribute__((aligned(8))) ipc_voucher_attr_manager_0
{
  ipc_voucher_attr_manager_release_value_t_0 ivam_release_value;
  ipc_voucher_attr_manager_get_value_t ivam_get_value;
  ipc_voucher_attr_manager_extract_content_t ivam_extract_content;
  ipc_voucher_attr_manager_command_t ivam_command;
  ipc_voucher_attr_manager_flags ivam_flags;
};

/* 9394 */
struct Request_0
{
  mach_msg_header_t_0 Head;
};

/* 9395 */
typedef OSObject_0 *OSObjectPtr_0;

/* 9398 */
typedef OSSharedPtr<OSData> OSPtr<OSData>_0;

/* 9399 */
typedef OSSharedPtr<OSDextStatistics> OSPtr<OSDextStatistics>_0;

/* 9400 */
typedef OSTaggedSharedPtr<const OSMetaClassBase,OSCollection> OSTaggedPtr<const OSMetaClassBase>_0;

/* 9401 */
typedef const OSMetaClassBase_0 *(*OSSerialize::Editor_1)(void *, OSSerialize_0 *, OSCollection_0 *, const OSSymbol_0 *, const OSMetaClassBase_0 *);

/* 9403 */
typedef kern_return_t (*OSObject::CopyDispatchQueue_Handler_0)(OSMetaClassBase_0 *, const char *, IODispatchQueue **);

/* 9404 */
typedef kern_return_t (*OSObject::SetDispatchQueue_Handler_0)(OSMetaClassBase_0 *, const char *, IODispatchQueue *);

/* 9405 */
typedef kern_return_t (*OSDispatchMethod_0)(OSMetaClassBase_0 *, const IORPC_0);

/* 9406 */
struct fbt_probe_0
{
  fbt_probe *fbtp_hashnext;
  machine_inst_t *fbtp_patchpoint;
  int8_t fbtp_rval;
  machine_inst_t fbtp_patchval;
  machine_inst_t fbtp_savedval;
  machine_inst_t fbtp_currentval;
  uintptr_t fbtp_roffset;
  dtrace_id_t fbtp_id;
  char fbtp_name[16];
  modctl *fbtp_ctl;
  int fbtp_loadcnt;
  fbt_probe *fbtp_next;
};

/* 9407 */
struct __attribute__((aligned(8))) ccchacha20poly1305_ctx_0
{
  ccchacha20_ctx chacha20_ctx;
  ccpoly1305_ctx poly1305_ctx;
  uint64_t aad_nbytes;
  uint64_t text_nbytes;
  uint8_t state;
};

/* 9409 */
typedef IOSKMemoryRef_0 IOSKMemoryBufferRef_0;

/* 9411 */
typedef queue_entry_0 *queue_entry_t_0;

/* 9412 */
typedef libkern::sa_detail::remove_const<SerData>::type libkern::sa_detail::remove_const_t<SerData>;

/* 9414 */
typedef void (*IOInterruptAction_1)(OSObject_0 *, void *, IOService_0 *, int);

/* 9415 */
typedef void (*OSObjectApplierFunction_1)(OSObject_0 *, void *);

/* 9416 */
typedef IOReturn_0 (*IORegistryEntry::Action_1)(OSObject_0 *, void *, void *, void *, void *);

/* 9417 */
typedef kern_return_t (*IOMemoryMap::_CopyState_Handler_0)(OSMetaClassBase_0 *, _IOMemoryMapPrivateState *);

/* 9418 */
typedef kern_return_t (*IOMemoryDescriptor::CreateMapping_Handler_0)(OSMetaClassBase_0 *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, IOMemoryMap_0 **);

/* 9419 */
typedef kern_return_t (*IOMemoryDescriptor::_CopyState_Handler_0)(OSMetaClassBase_0 *, _IOMDPrivateState *);

/* 9420 */
typedef kern_return_t (*IOService::RemoveProperty_Handler_0)(OSMetaClassBase_0 *, OSString_0 *);

/* 9421 */
typedef kern_return_t (*IOService::NewUserClient_Handler_0)(OSMetaClassBase_0 *, uint32_t, IOUserClient_0 **);

/* 9422 */
typedef kern_return_t (*IOService::ChangePowerState_Handler_0)(OSMetaClassBase_0 *, uint32_t);

/* 9423 */
typedef kern_return_t (*IOService::SetPowerState_Handler_0)(OSMetaClassBase_0 *, uint32_t);

/* 9424 */
typedef kern_return_t (*IOService::SetProperties_Handler_0)(OSMetaClassBase_0 *, OSDictionary_0 *);

/* 9425 */
typedef kern_return_t (*IOService::SearchProperty_Handler_0)(OSMetaClassBase_0 *, const char *, const char *, uint64_t, OSContainer **);

/* 9426 */
typedef kern_return_t (*IOService::CopyProperties_Handler_0)(OSMetaClassBase_0 *, OSDictionary_0 **);

/* 9427 */
typedef kern_return_t (*IOService::RegisterService_Handler_0)(OSMetaClassBase_0 *);

/* 9428 */
typedef kern_return_t (*IOService::SetName_Handler_0)(OSMetaClassBase_0 *, const char *);

/* 9429 */
typedef kern_return_t (*IOService::GetRegistryEntryID_Handler_0)(OSMetaClassBase_0 *, uint64_t *);

/* 9430 */
typedef kern_return_t (*IOService::ClientCrashed_Handler_0)(OSMetaClassBase_0 *, IOService_0 *, uint64_t);

/* 9431 */
typedef kern_return_t (*IOService::Stop_Handler_0)(OSMetaClassBase_0 *, IOService_0 *);

/* 9432 */
typedef kern_return_t (*IOService::Start_Handler_0)(OSMetaClassBase_0 *, IOService_0 *);

/* 9433 */
typedef IOReturn_0 (*IOService::UpdateReport_Handler_0)(OSMetaClassBase_0 *, OSData_0 *, uint32_t, uint32_t *, uint64_t, uint64_t, IOMemoryDescriptor_0 *);

/* 9434 */
typedef kern_return_t (*IOService::CoreAnalyticsSendEvent_Handler_0)(OSMetaClassBase_0 *, uint64_t, OSString_0 *, OSDictionary_0 *);

/* 9435 */
typedef kern_return_t (*IOService::StateNotificationItemCreate_Handler_0)(OSMetaClassBase_0 *, OSString_0 *, OSDictionary_0 *);

/* 9436 */
typedef kern_return_t (*IOService::StateNotificationItemSet_Handler_0)(OSMetaClassBase_0 *, OSString_0 *, OSDictionary_0 *);

/* 9437 */
typedef kern_return_t (*IOService::_ClaimSystemWakeEvent_Handler_0)(OSMetaClassBase_0 *, IOService_0 *, uint64_t, const char *, OSContainer *);

/* 9438 */
typedef kern_return_t (*IOService::CreateDefaultDispatchQueue_Handler_0)(OSMetaClassBase_0 *, IODispatchQueue **);

/* 9439 */
typedef kern_return_t (*IOService::Terminate_Handler_0)(OSMetaClassBase_0 *, uint64_t);

/* 9440 */
typedef kern_return_t (*IOService::GetBusyState_Handler_0)(OSMetaClassBase_0 *, uint32_t *);

/* 9441 */
typedef kern_return_t (*IOService::SendIOMessageServicePropertyChange_Handler_0)(OSMetaClassBase_0 *);

/* 9442 */
typedef void (*IOService::Stop_async_Handler_0)(OSMetaClassBase_0 *, IOService_0 *);

/* 9443 */
typedef kern_return_t (*IOService::UserSetProperties_Handler_0)(OSMetaClassBase_0 *, OSContainer *);

/* 9444 */
typedef kern_return_t (*IOService::AdjustBusy_Handler_0)(OSMetaClassBase_0 *, int32_t);

/* 9445 */
typedef IOReturn_0 (*IOService::ConfigureReport_Handler_0)(OSMetaClassBase_0 *, OSData_0 *, uint32_t, uint32_t *);

/* 9446 */
typedef kern_return_t (*IOService::JoinPMTree_Handler_0)(OSMetaClassBase_0 *);

/* 9447 */
typedef IOReturn_0 (*IOService::SetLegend_Handler_0)(OSMetaClassBase_0 *, OSArray_0 *, bool);

/* 9448 */
typedef kern_return_t (*IOService::_NewUserClient_Handler_0)(OSMetaClassBase_0 *, uint32_t, OSDictionary_0 *, IOUserClient_0 **);

/* 9449 */
typedef kern_return_t (*IOService::RequireMaxBusStall_Handler_0)(OSMetaClassBase_0 *, uint64_t);

/* 9450 */
typedef kern_return_t (*IOService::StateNotificationItemCopy_Handler_0)(OSMetaClassBase_0 *, OSString_0 *, OSDictionary_0 **);

/* 9455 */
struct __cppobj OSSerialize::MetaClass_0 : OSMetaClass_0
{
};

/* 9460 */
struct libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_osobject_retainer>_0
{
  libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_osobject_retainer>::pointer_0 ptr_;
};

/* 9461 */
struct __cppobj OSSharedPtr<const OSMetaClassBase>_0 : libkern::intrusive_shared_ptr<const OSMetaClassBase,intrusive_osobject_retainer>_0
{
};

/* 9462 */
struct __cppobj OSData::MetaClass_0 : OSMetaClass_0
{
};

/* 9463 */
struct __cppobj OSData_1 : OSObject_1
{
  unsigned int length;
  unsigned int capacity;
  unsigned int capacityIncrement;
  OSData::ExpansionData *reserved;
};

/* 9468 */
struct __cppobj OSObject::MetaClass_0 : OSMetaClass_0
{
};

/* 9469 */
typedef bool (*OSMetaClassInstanceApplierFunction_0)(const OSObject_0 *, void *);

/* 9474 */
struct kern_nexus_netif_provider_init_0
{
  uint32_t nxnpi_version;
  uint32_t nxnpi_flags;
  nxprov_pre_connect_fn_t nxnpi_pre_connect;
  nxprov_connected_fn_t_0 nxnpi_connected;
  nxprov_pre_disconnect_fn_t_0 nxnpi_pre_disconnect;
  nxprov_disconnected_fn_t_0 nxnpi_disconnected;
  nxprov_qset_init_fn_t nxnpi_qset_init;
  nxprov_qset_fini_fn_t nxnpi_qset_fini;
  nxprov_queue_init_fn_t nxnpi_queue_init;
  nxprov_queue_fini_fn_t nxnpi_queue_fini;
  nxprov_tx_qset_notify_fn_t nxnpi_tx_qset_notify;
  nxprov_capab_config_fn_t nxnpi_config_capab;
};

/* 9478 */
struct kern_nexus_domain_provider_0
{
  struct
  {
    kern_nexus_domain_provider *stqe_next;
  } nxdom_prov_link;
  struct
  {
    kern_nexus_domain_provider *stqe_next;
  } nxdom_prov_detaching_link;
  char nxdom_prov_name[64];
  uuid_t_1 nxdom_prov_uuid;
  uint64_t nxdom_prov_gencnt;
  uint32_t nxdom_prov_refcnt;
  uint32_t nxdom_prov_flags;
  nxdom *nxdom_prov_dom;
  kern_nexus_domain_provider_init nxdom_prov_ext;
  nxdom_prov_cb_0 nxdom_prov_cb;
};

/* 9479 */
struct kern_nexus_netif_provider_init_1
{
  uint32_t nxnpi_version;
  uint32_t nxnpi_flags;
  nxprov_pre_connect_fn_t_0 nxnpi_pre_connect;
  nxprov_connected_fn_t_0 nxnpi_connected;
  nxprov_pre_disconnect_fn_t_0 nxnpi_pre_disconnect;
  nxprov_disconnected_fn_t_0 nxnpi_disconnected;
  nxprov_qset_init_fn_t nxnpi_qset_init;
  nxprov_qset_fini_fn_t nxnpi_qset_fini;
  nxprov_queue_init_fn_t nxnpi_queue_init;
  nxprov_queue_fini_fn_t nxnpi_queue_fini;
  nxprov_tx_qset_notify_fn_t nxnpi_tx_qset_notify;
  nxprov_capab_config_fn_t nxnpi_config_capab;
};

/* 9481 */
struct mcache_0
{
  struct
  {
    mcache *le_next;
    mcache **le_prev;
  } mc_list;
  char mc_name[32];
  zone *mc_slab_zone;
  mcache_allocfn_t mc_slab_alloc;
  mcache_freefn_t mc_slab_free;
  mcache_auditfn_t mc_slab_audit;
  mcache_logfn_t mc_slab_log;
  mcache_notifyfn_t mc_slab_notify;
  void *mc_private;
  size_t mc_bufsize;
  size_t mc_align;
  u_int32_t mc_flags;
  u_int32_t mc_purge_cnt;
  u_int32_t mc_enable_cnt;
  u_int32_t mc_waiter_cnt;
  u_int32_t mc_wretry_cnt;
  u_int32_t mc_nwretry_cnt;
  u_int32_t mc_nwfail_cnt;
  lck_mtx_t mc_sync_lock;
  lck_grp_t *mc_sync_lock_grp;
  lck_grp_t *mc_cpu_lock_grp;
  lck_mtx_t mc_bkt_lock;
  lck_grp_t *mc_bkt_lock_grp;
  mcache_bkttype_t *cache_bkttype;
  mcache_bktlist_t mc_full;
  mcache_bktlist_t mc_empty;
  size_t mc_chunksize;
  u_int32_t mc_bkt_contention;
  u_int32_t mc_bkt_contention_prev;
  mcache_cpu_t mc_cpu[1];
};

/* 9482 */
struct __attribute__((packed)) __attribute__((aligned(4))) vfsstatfs_0
{
  uint32_t f_bsize;
  size_t f_iosize;
  uint64_t f_blocks;
  uint64_t f_bfree;
  uint64_t f_bavail;
  uint64_t f_bused;
  uint64_t f_files;
  uint64_t f_ffree;
  fsid_t f_fsid;
  uid_t f_owner;
  uint64_t f_flags;
  char f_fstypename[16];
  char f_mntonname[1024];
  char f_mntfromname[1024];
  uint32_t f_fssubtype;
  void *f_reserved[2];
};

/* 9484 */
struct protosw_0
{
  struct
  {
    protosw *tqe_next;
    protosw **tqe_prev;
  } pr_entry;
  domain *pr_domain;
  protosw *pr_protosw;
  u_int16_t pr_type;
  u_int16_t pr_protocol;
  u_int32_t pr_flags;
  void (*pr_input)(mbuf *, int);
  int (*pr_output)(mbuf *, socket *);
  void (*pr_ctlinput)(int, sockaddr *, void *, ifnet *);
  int (*pr_ctloutput)(socket *, sockopt *);
  pr_usrreqs *pr_usrreqs;
  void (*pr_init)(protosw *, domain *);
  void (*pr_drain)(void);
  int (*pr_sysctl)(int *, u_int, void *, size_t *, void *, size_t);
  int (*pr_lock)(socket *, int, void *);
  int (*pr_unlock)(socket *, int, void *);
  lck_mtx_t *(*pr_getlock)(socket *, int);
  struct
  {
    socket_filter *tqh_first;
    socket_filter **tqh_last;
  } pr_filter_head;
  protosw_old *pr_old;
  void (*pr_update_last_owner)(socket *, proc *, proc *);
  void (*pr_copy_last_owner)(socket *, socket *);
};

/* 9488 */
struct llentry_0
{
  struct
  {
    llentry *le_next;
    llentry **le_prev;
  } lle_next;
  union
  {
    in_addr addr4;
    in6_addr_0 addr6;
  } r_l3addr;
  uint16_t r_flags;
  uint16_t r_skip_req;
  lltable *lle_tbl;
  llentries *lle_head;
  void (*lle_free)(llentry *);
  mbuf *la_hold;
  int la_numheld;
  u_int64_t la_expire;
  uint16_t la_flags;
  uint16_t la_asked;
  uint16_t la_preempt;
  int16_t ln_state;
  uint16_t ln_router;
  time_t ln_ntick;
  time_t lle_remtime;
  time_t lle_hittime;
  int lle_refcnt;
  union
  {
    uint64_t mac_aligned;
    uint16_t mac16[3];
  } ll_addr;
  struct
  {
    llentry *le_next;
    llentry **le_prev;
  } lle_chain;
  thread_call_t lle_timer;
  u_int64_t ln_lastused;
  if_llreach *ln_llreach;
  lck_rw_t lle_lock;
  lck_mtx_t req_mtx;
};

/* 9490 */
struct iff_filter_0
{
  void *iff_cookie;
  const char *iff_name;
  protocol_family_t iff_protocol;
  iff_input_func_0 iff_input;
  iff_output_func_0 iff_output;
  iff_event_func_0 iff_event;
  iff_ioctl_func_0 iff_ioctl;
  iff_detached_func_0 iff_detached;
};

/* 9491 */
struct flow_mgr_0
{
  char fm_name[16];
  uuid_t_1 fm_uuid;
  struct
  {
    flow_mgr *rbe_left;
    flow_mgr *rbe_right;
    flow_mgr *rbe_parent;
  } fm_link;
  cuckoo_hashtable *fm_flow_table;
  size_t fm_flow_hash_count[7];
  uint16_t fm_flow_hash_masks[7];
  void *fm_owner_buckets;
  const size_t fm_owner_buckets_cnt;
  const size_t fm_owner_bucket_sz;
  const size_t fm_owner_bucket_tot_sz;
  void *fm_route_buckets;
  const size_t fm_route_buckets_cnt;
  const size_t fm_route_bucket_sz;
  const size_t fm_route_bucket_tot_sz;
  void *fm_route_id_buckets;
  const size_t fm_route_id_buckets_cnt;
  const size_t fm_route_id_bucket_sz;
  const size_t fm_route_id_bucket_tot_sz;
};

/* 9494 */
struct dtrace_repldesc
{
  dtrace_probedesc_t dtrpd_match;
  dtrace_probedesc_t dtrpd_create;
};

/* 9495 */
struct dtrace_eprobedesc
{
  dtrace_epid_t dtepd_epid;
  dtrace_id_t dtepd_probeid;
  uint64_t dtepd_uarg;
  uint32_t dtepd_size;
  int dtepd_nrecs;
  dtrace_recdesc_t dtepd_rec[1];
};

/* 9498 */
struct __attribute__((aligned(8))) ml_processor_info_1
{
  cpu_id_t_0 cpu_id;
  vm_offset_t start_paddr;
  boolean_t supports_nap;
  void *platform_cache_dispatch;
  time_base_enable_t_0 time_base_enable;
  processor_idle_t_0 processor_idle;
  idle_tickle_t_0 *idle_tickle;
  idle_timer_t_0 idle_timer;
  void *idle_timer_refcon;
  vm_offset_t powergate_stub_addr;
  uint32_t powergate_stub_length;
  uint32_t powergate_latency;
  platform_error_handler_t_0 platform_error_handler;
  uint64_t regmap_paddr;
  uint32_t phys_id;
  uint32_t log_id;
  uint32_t l2_access_penalty;
  uint32_t cluster_id;
  cluster_type_t_0 cluster_type;
  uint32_t l2_cache_id;
  uint32_t l2_cache_size;
  uint32_t l3_cache_id;
  uint32_t l3_cache_size;
};

/* 9707 */
typedef mach_port_t_2 exception_handler_t_1;

/* 9708 */
struct __attribute__((packed)) __attribute__((aligned(4))) Request_1
{
  mach_msg_header_t_0 Head;
  NDR_record_t_0 NDR;
  int flags;
};

/* 9836 */
typedef queue_entry_0 *queue_t_0;

/* 9837 */
struct circle_queue_head_0
{
  queue_entry_t_0 head;
};

/* 9838 */
typedef circle_queue_head_0 circle_queue_head_t_0;

/* 9840 */
typedef clock *clock_t_0;

/* 9845 */
typedef mach_port_t_1 UNDServerRef_0;

/* 9848 */
struct __cppobj IOService_1 : IORegistryEntry_0
{
  IOService::ExpansionData_0 *reserved;
  IOService_0 *__provider;
  SInt32 __providerGeneration;
  IOService_0 *__owner;
  IOOptionBits __state[2];
  uint64_t __timeBusy;
  uint64_t __accumBusy;
  IOServicePM *pwrMgt;
  bool initialized;
  void *pm_vars;
  int _numInterruptSources;
  IOInterruptSource_0 *_interruptSources;
};

/* 9849 */
typedef kern_return_t (*IOService::CopyProviderProperties_Handler_0)(OSMetaClassBase_0 *, OSArray_0 *, OSArray_0 **);

/* 9850 */
struct __cppobj OSSharedPtr<OSObject>_0 : libkern::intrusive_shared_ptr<OSObject,intrusive_osobject_retainer>
{
};

/* 9851 */
struct __cppobj OSSerialize_1 : OSObject_0
{
  char *data;
  unsigned int length;
  unsigned int capacity;
  unsigned int capacityIncrement;
  OSPtr<OSArray>_0 tags;
  bool binary;
  bool endCollection;
  OSSerialize::Editor_1 editor;
  void *editRef;
  OSPtr<OSData>_0 indexData;
};

/* 9852 */
struct __cppobj OSOrderedSet::MetaClass_0 : OSMetaClass_1
{
};

/* 9853 */
struct __cppobj OSCollectionIterator::MetaClass_0 : OSMetaClass_1
{
};

/* 9854 */
struct __cppobj OSIterator::MetaClass_0 : OSMetaClass_1
{
};

/* 9856 */
struct __cppobj OSBoolean::MetaClass_0 : OSMetaClass_1
{
};

/* 9857 */
struct __cppobj OSNumber::MetaClass_0 : OSMetaClass_1
{
};

/* 9858 */
struct __cppobj OSDextStatistics::MetaClass_0 : OSMetaClass_1
{
};

/* 9859 */
struct __cppobj OSSet::MetaClass_0 : OSMetaClass_1
{
};

/* 9860 */
struct __cppobj OSKext::MetaClass_0 : OSMetaClass_1
{
};

/* 9861 */
typedef OSSharedPtr<OSString> OSPtr<OSString>_0;

/* 9862 */
struct __cppobj OSArray::MetaClass_0 : OSMetaClass_1
{
};

/* 9863 */
struct __cppobj OSDictionary::MetaClass_0 : OSMetaClass_1
{
};

/* 9864 */
struct __cppobj OSCollection::MetaClass_0 : OSMetaClass_1
{
};

/* 9865 */
struct __cppobj OSSymbol::MetaClass_0 : OSMetaClass_1
{
};

/* 9866 */
struct __cppobj OSString::MetaClass_0 : OSMetaClass_1
{
};

/* 9869 */
struct __cppobj IORegistryPlane_0 : OSObject_1
{
  const OSSymbol_0 *nameKey;
  const OSSymbol_0 *keys[2];
  const OSSymbol_0 *pathNameKey;
  const OSSymbol_0 *pathLocationKey;
  int reserved[2];
};

/* 9870 */
typedef kern_return_t (*IOService::Create_Handler_0)(OSMetaClassBase_1 *, IOService_0 *, const char *, IOService_0 **);

/* 9871 */
typedef kern_return_t (*IOService::StringFromReturn_Handler_0)(OSMetaClassBase_1 *, IOReturn_0, OSString_0 **);

/* 9872 */
typedef kern_return_t (*IOService::CopyName_Handler_0)(OSMetaClassBase_1 *, OSString_0 **);

/* 9873 */
typedef kern_return_t (*IOService::CopySystemStateNotificationService_Handler_0)(OSMetaClassBase_1 *, IOService_0 **);

/* 9875 */
struct __cppobj OSBoolean_1 : OSObject_1
{
  bool value;
};

/* 9876 */
struct __cppobj OSNumber_1 : OSObject_1
{
  unsigned int size;
  union
  {
    unsigned __int64 value;
    double fpValue;
  };
};

/* 9877 */
struct __cppobj IOServicePM_0 : OSObject_1
{
  queue_chain_t_0 WorkChain;
  queue_head_t_0 RequestHead;
  IOService_0 *Owner;
  IOPMinformeeList *InterestedDrivers;
  IOReturn_0 DriverTimer;
  uint32_t MachineState;
  thread_call_t AckTimer;
  thread_call_t IdleTimer;
  thread_call_t WatchdogTimer;
  thread_call_t SpinDumpTimer;
  IOLock_0 *WatchdogLock;
  OSArray_0 *BlockedArray;
  uint64_t PendingResponseDeadline;
  uint64_t WatchdogDeadline;
  IOPMPowerStateIndex IdleTimerGeneration;
  IOPMPowerChangeFlags HeadNoteChangeFlags;
  IOPMPowerStateIndex HeadNotePowerState;
  IOPMPSEntry *HeadNotePowerArrayEntry;
  IOPMPowerFlags HeadNoteDomainFlags;
  IOPMPowerFlags HeadNoteDomainTargetFlags;
  IOPowerConnection_0 *HeadNoteParentConnection;
  IOPMPowerFlags HeadNoteParentFlags;
  uint32_t HeadNotePendingAcks;
  IOLock_0 *PMLock;
  __attribute__((aligned(16))) AbsoluteTime_0 DeviceActiveTimestamp;
  AbsoluteTime_0 MaxPowerStateEntryTime;
  AbsoluteTime_0 MaxPowerStateExitTime;
  IOLock_0 *ActivityLock;
  int IdleTimerPeriod;
  int NextIdleTimerPeriod;
  IOPMPowerStateIndex IdleTimerMinPowerState;
  AbsoluteTime_0 IdleTimerStartTime;
  IOPMPowerStateIndex DeviceDesire;
  IOPMPowerStateIndex DesiredPowerState;
  IOPMPowerFlags PreviousRequestPowerFlags;
  const char *Name;
  IOPMPowerStateIndex NumberOfPowerStates;
  IOPMPowerStateIndex HighestPowerState;
  IOPMPSEntry *PowerStates;
  IOService_0 *ControllingDriver;
  IOPMPowerStateIndex CurrentPowerState;
  IOPMPowerFlags ParentsCurrentPowerFlags;
  IOPMPowerStateIndex MaxPowerState;
  IOPMPowerFlags MergedOutputPowerFlags;
  OSArray_0 *ResponseArray;
  OSArray_0 *NotifyClientArray;
  uint16_t SerialNumber;
  int OutOfBandParameter;
  AbsoluteTime_0 DriverCallStartTime;
  IOPMPowerFlags CurrentCapabilityFlags;
  unsigned __int64 CurrentPowerConsumption;
  IOPMPowerStateIndex TempClampPowerState;
  OSArray_0 *NotifyChildArray;
  OSDictionary_0 *PowerClients;
  thread_call_t DriverCallEntry;
  void *DriverCallParamPtr;
  IOItemCount_0 DriverCallParamCount;
  IOItemCount_0 DriverCallParamSlots;
  uint32_t DriverCallReason;
  uint32_t OutOfBandMessage;
  uint32_t TempClampCount;
  IOPMPowerStateIndex OverrideMaxPowerState;
  IOPMPowerStateIndex DeviceUsablePowerState;
  thread_call_t DriverCallTimer;
  IOPMPowerStateIndex ActivityTicklePowerState;
  IOPMPowerStateIndex AdvisoryTicklePowerState;
  uint32_t ActivityTickleCount;
  __attribute__((aligned(8))) uint32_t WaitReason;
  uint32_t SavedMachineState;
  struct
  {
    _BYTE gap0[4];
  } LockedFlags;
  queue_head_t_0 PMDriverCallQueue;
  OSSet_0 *InsertInterestSet;
  OSSet_0 *RemoveInterestSet;
  uint32_t ReportClientCnt;
  void *ReportBuf;
  IOPMActions PMActions;
};

/* 9882 */
struct __attribute__((aligned(32))) __kern_channel_ring_0
{
  __user_channel_ring *ckr_ring;
  uint32_t ckr_flags;
  slot_idx_t ckr_num_slots;
  uint32_t ckr_max_pkt_len;
  uint32_t ckr_largest;
  const slot_idx_t ckr_lim;
  txrx ckr_tx;
  volatile slot_idx_t ckr_khead;
  volatile slot_idx_t ckr_ktail;
  volatile slot_idx_t ckr_khead_pre;
  volatile slot_idx_t ckr_rhead;
  volatile slot_idx_t ckr_rtail;
  uint32_t ckr_transfer_decay;
  uint64_t ckr_ready_bytes;
  uint64_t ckr_ready_slots;
  lck_spin_t ckr_slock;
  thread *ckr_owner;
  uint32_t ckr_busy;
  uint32_t ckr_want;
  uint32_t ckr_state;
  volatile uint32_t ckr_alloc_ws;
  nexus_adapter *ckr_na;
  kern_pbufpool *ckr_pp;
  __slot_desc *ckr_usds;
  __slot_desc *ckr_ksds;
  __slot_desc *ckr_ksds_last;
  skmem_cache *ckr_ksds_cache;
  uint32_t ckr_ring_id;
  boolean_t ckr_rate_limited;
  uint64_t *ckr_scratch;
  int (*ckr_na_sync)(__kern_channel_ring *, proc *, uint32_t);
  int (*volatile ckr_na_notify)(__kern_channel_ring *, proc *, uint32_t);
  int (*ckr_prologue)(kern_channel *, __kern_channel_ring *, const slot_idx_t, uint32_t *, uint64_t *, proc *);
  void (*ckr_finalize)(kern_channel *, __kern_channel_ring *, const slot_idx_t, proc *);
  uint64_t ckr_sync_time;
  int (*ckr_save_notify)(__kern_channel_ring *, proc *, uint32_t);
  uint32_t *ckr_leases;
  slot_idx_t ckr_klease;
  slot_idx_t ckr_lease_idx;
  kern_packet_svc_class_t ckr_svc;
  uint32_t ckr_slot_ctxs_set;
  slot_ctx *ckr_slot_ctxs;
  void *ckr_ctx;
  ch_selinfo ckr_si;
  int (*ckr_netif_notify)(__kern_channel_ring *, proc *, uint32_t);
  void (*ckr_netif_mit_stats)(__kern_channel_ring *, uint64_t, uint64_t);
  nx_netif_mit *ckr_mit;
  volatile uint32_t ckr_pending_intr;
  volatile uint32_t ckr_pending_doorbell;
  mbuf **ckr_tx_pool;
  nx_mbq ckr_rx_queue;
  __kern_channel_ring *ckr_pipe;
  __user_channel_ring *ckr_save_ring;
  lck_mtx_t ckr_qlock;
  __kern_channel_ring **ckr_monitors;
  uint32_t ckr_max_monitors;
  uint32_t ckr_n_monitors;
  int (*ckr_mon_sync)(__kern_channel_ring *, proc *, uint32_t);
  int (*ckr_mon_notify)(__kern_channel_ring *, proc *, uint32_t);
  uint32_t ckr_mon_tail;
  uint32_t ckr_mon_pos;
  uint32_t ckr_users;
  int64_t ckr_tbr_token;
  int64_t ckr_tbr_depth;
  uint64_t ckr_tbr_last;
  channel_ring_error_stats ckr_err_stats;
  channel_ring_stats ckr_stats;
  uint64_t ckr_accumulated_bytes;
  uint64_t ckr_accumulated_slots;
  uint64_t ckr_accumulate_start;
  channel_ring_user_stats ckr_usr_stats;
  uint64_t ckr_user_accumulated_bytes;
  uint64_t ckr_user_accumulated_slots;
  uint64_t ckr_user_accumulated_syncs;
  uint64_t ckr_user_accumulate_start;
  lck_grp_t *ckr_qlock_group;
  lck_grp_t *ckr_slock_group;
  char ckr_name[64];
};

/* 9883 */
struct proc_0
{
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_list;
  _BYTE gap10[8];
  proc_ro_t p_proc_ro;
  pid_t p_ppid;
  pid_t p_original_ppid;
  pid_t p_pgrpid;
  uid_t p_uid;
  gid_t p_gid;
  uid_t p_ruid;
  gid_t p_rgid;
  uid_t p_svuid;
  gid_t p_svgid;
  pid_t p_sessionid;
  uint64_t p_puniqueid;
  lck_mtx_t p_mlock;
  pid_t p_pid;
  char p_stat;
  char p_shutdownstate;
  char p_kdebug;
  char p_btrace;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_pglist;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_sibling;
  struct
  {
    proc *lh_first;
  } p_children;
  struct
  {
    uthread *tqh_first;
    uthread **tqh_last;
  } p_uthlist;
  smrq_slink p_hash;
  persona *p_persona;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_persona_list;
  lck_mtx_t p_ucred_mlock;
  filedesc p_fd;
  pstats *p_stats;
  struct
  {
    plimit *volatile __smr_ptr;
  } p_limit;
  struct
  {
    _BYTE gap0[8];
  } p_pgrp;
  sigacts p_sigacts;
  lck_spin_t p_slock;
  int p_siglist;
  unsigned int p_flag;
  unsigned int p_lflag;
  unsigned int p_listflag;
  unsigned int p_ladvflag;
  os_ref_atomic_t p_refcount;
  os_ref_atomic_t p_waitref;
  int p_childrencnt;
  int p_parentref;
  pid_t p_oppid;
  u_int p_xstat;
  int p_aio_total_count;
  itimerval p_realtimer;
  timeval p_rtime;
  itimerval p_vtimer_user;
  itimerval p_vtimer_prof;
  timeval p_rlim_cpu;
  int p_debugger;
  boolean_t sigwait;
  void *sigwait_thread;
  void *exit_thread;
  pid_t si_pid;
  u_int si_status;
  u_int si_code;
  uid_t si_uid;
  void *vm_shm;
  int p_ractive;
  pid_t p_responsible_pid;
  int p_dtrace_probes;
  u_int p_dtrace_count;
  uint8_t p_dtrace_stop;
  user_addr_t_0 p_dtrace_argv;
  user_addr_t_0 p_dtrace_envp;
  lck_mtx_t p_dtrace_sprlock;
  dtrace_ptss_page *p_dtrace_ptss_pages;
  dtrace_ptss_page_entry *p_dtrace_ptss_free_list;
  dtrace_helpers *p_dtrace_helpers;
  dof_ioctl_data *p_dtrace_lazy_dofs;
  union
  {
    struct __attribute__((aligned(8)))
    {
      u_int p_argslen;
      int p_argc;
      user_addr_t_0 user_stack;
      _BYTE gap10[8];
      off_t p_textoff;
      sigset_t p_sigmask;
      sigset_t p_sigignore;
      sigset_t p_sigcatch;
      u_char p_priority;
      u_char p_resv0;
      char p_nice;
      u_char p_resv1;
      command_t p_comm;
      proc_name_t p_name;
      uint8_t p_xhighbits;
      pid_t p_contproc;
      uint32_t p_pcaction;
      uint8_t p_uuid[16];
      cpu_type_t p_cputype;
      cpu_subtype_t_0 p_cpusubtype;
    };
    proc_forkcopy_data p_forkcopy;
  };
  struct
  {
    aio_workq_entry *tqh_first;
    aio_workq_entry **tqh_last;
  } p_aio_activeq;
  struct
  {
    aio_workq_entry *tqh_first;
    aio_workq_entry **tqh_last;
  } p_aio_doneq;
  klist p_klist;
  rusage_superset *p_ru;
  thread_t_0 p_signalholder;
  thread_t_0 p_transholder;
  int p_sigwaitcnt;
  u_short p_acflag;
  volatile u_short p_vfs_iopolicy;
  user_addr_t_0 p_threadstart;
  user_addr_t_0 p_wqthread;
  int p_pthsize;
  uint32_t p_pth_tsd_offset;
  user_addr_t_0 p_stack_addr_hint;
  workqueue *p_wqptr;
  timeval p_start;
  void *p_rcall;
  void *p_pthhash;
  volatile uint64_t was_throttled;
  volatile uint64_t did_throttle;
  uint64_t p_dispatchqueue_offset;
  uint64_t p_dispatchqueue_serialno_offset;
  uint64_t p_dispatchqueue_label_offset;
  uint64_t p_return_to_kernel_offset;
  uint64_t p_mach_thread_self_offset;
  uint64_t p_pthread_wq_quantum_offset;
  timeval vm_pressure_last_notify_tstamp;
  uint8_t p_crash_behavior;
  bool p_posix_spawn_failed;
  bool p_disallow_map_with_linking;
  uint32_t p_memstat_state;
  int32_t p_memstat_effectivepriority;
  int32_t p_memstat_requestedpriority;
  int32_t p_memstat_assertionpriority;
  uint32_t p_memstat_dirty;
  struct
  {
    proc *tqe_next;
    proc **tqe_prev;
  } p_memstat_list;
  uint64_t p_memstat_userdata;
  uint64_t p_memstat_idledeadline;
  uint64_t p_memstat_idle_start;
  uint64_t p_memstat_idle_delta;
  int32_t p_memstat_memlimit;
  int32_t p_memstat_memlimit_active;
  int32_t p_memstat_memlimit_inactive;
  int32_t p_memstat_relaunch_flags;
  uint32_t p_user_faults;
  uint32_t p_memlimit_increase;
  uint64_t p_crash_behavior_deadline;
  uint32_t p_crash_count;
  uint32_t p_throttle_timeout;
  os_reason *p_exit_reason;
  uint64_t p_user_data;
  char *p_subsystem_root_path;
};

/* 9884 */
struct ifnet_0
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func_0 if_output_dlil;
  volatile ifnet_start_func if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func if_input_ctl;
  ifnet_ioctl_func if_ioctl;
  ifnet_set_bpf_tap if_set_bpf_tap;
  ifnet_detached_func if_free;
  ifnet_demux_func_0 if_demux;
  ifnet_event_func if_event;
  ifnet_framer_func_1 if_framer_legacy;
  ifnet_framer_extended_func_0 if_framer;
  ifnet_add_proto_func if_add_proto;
  ifnet_del_proto_func if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route_0 if_fwd_route;
  route_0 if_src_route;
  route_in6 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 9885 */
struct route_in6_0
{
  rtentry *ro_rt;
  llentry *ro_lle;
  ifaddr *ro_srcia;
  uint32_t ro_flags;
  sockaddr_in6 ro_dst;
};

/* 9887 */
struct conninfo_mptcp
{
  uint64_t mptcpci_len;
  uint64_t mptcpci_flow_offset;
  uint64_t mptcpci_nflows;
  uint32_t mptcpci_state;
  uint32_t mptcpci_mpte_flags;
  uint32_t mptcpci_flags;
  uint32_t mptcpci_ltoken;
  uint32_t mptcpci_rtoken;
  uint32_t mptcpci_notsent_lowat;
  uint64_t mptcpci_snduna;
  uint64_t mptcpci_sndnxt;
  uint64_t mptcpci_sndmax;
  uint64_t mptcpci_lidsn;
  uint32_t mptcpci_sndwnd;
  uint64_t mptcpci_rcvnxt;
  uint64_t mptcpci_rcvatmark;
  uint64_t mptcpci_ridsn;
  uint32_t mptcpci_rcvwnd;
  uint8_t mptcpci_mpte_addrid;
  mptcp_flow_t mptcpci_flows[1];
};

/* 9888 */
struct ifnet_1
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func if_output_dlil;
  volatile ifnet_start_func if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func if_input_ctl;
  ifnet_ioctl_func if_ioctl;
  ifnet_set_bpf_tap if_set_bpf_tap;
  ifnet_detached_func if_free;
  ifnet_demux_func if_demux;
  ifnet_event_func if_event;
  ifnet_framer_func_0 if_framer_legacy;
  ifnet_framer_extended_func if_framer;
  ifnet_add_proto_func if_add_proto;
  ifnet_del_proto_func if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route_0 if_fwd_route;
  route_0 if_src_route;
  route_in6 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 9890 */
struct dtrace_aggdesc
{
  char *dtagd_name;
  dtrace_aggvarid_t dtagd_varid;
  int dtagd_flags;
  dtrace_aggid_t dtagd_id;
  dtrace_epid_t dtagd_epid;
  uint32_t dtagd_size;
  int dtagd_nrecs;
  uint32_t dtagd_pad;
  dtrace_recdesc_t dtagd_rec[1];
};

/* 9891 */
struct __attribute__((aligned(16))) cpu_data_0
{
  short cpu_number;
  unsigned __int16 cpu_flags;
  int cpu_type;
  int cpu_subtype;
  int cpu_threadtype;
  vm_offset_t istackptr;
  vm_offset_t intstack_top;
  vm_offset_t excepstackptr;
  vm_offset_t excepstack_top;
  thread_t_0 cpu_active_thread;
  vm_offset_t cpu_active_stack;
  cpu_id_t_0 cpu_id;
  volatile unsigned int cpu_signal;
  ast_t cpu_pending_ast;
  cache_dispatch_t cpu_cache_dispatch;
  uint64_t cpu_base_timebase;
  uint64_t cpu_timebase;
  bool cpu_hibernate;
  bool cpu_running;
  bool cluster_master;
  bool sync_on_cswitch;
  bool in_state_transition;
  uint32_t cpu_decrementer;
  get_decrementer_t cpu_get_decrementer_func;
  set_decrementer_t cpu_set_decrementer_func;
  fiq_handler_t cpu_get_fiq_handler;
  void *cpu_tbd_hardware_addr;
  void *cpu_tbd_hardware_val;
  processor_idle_t_0 cpu_idle_notify;
  uint64_t cpu_idle_latency;
  uint64_t cpu_idle_pop;
  vm_offset_t cpu_reset_handler;
  uintptr_t cpu_reset_assist;
  uint32_t cpu_reset_type;
  unsigned int interrupt_source;
  void *cpu_int_state;
  IOInterruptHandler_0 interrupt_handler;
  void *interrupt_nub;
  void *interrupt_target;
  void *interrupt_refCon;
  idle_timer_t_0 idle_timer_notify;
  void *idle_timer_refcon;
  uint64_t idle_timer_deadline;
  uint64_t rtcPop;
  rtclock_timer_t rtclock_timer;
  _rtclock_data_ *rtclock_datap;
  arm_debug_state_t *cpu_user_debug;
  vm_offset_t cpu_debug_interface_map;
  volatile int debugger_active;
  volatile int PAB_active;
  void *cpu_xcall_p0;
  void *cpu_xcall_p1;
  void *cpu_imm_xcall_p0;
  void *cpu_imm_xcall_p1;
  vm_offset_t coresight_base[4];
  uint64_t cpu_regmap_paddr;
  uint32_t cpu_phys_id;
  uint32_t cpu_l2_access_penalty;
  platform_error_handler_t_0 platform_error_handler;
  int cpu_mcount_off;
  volatile unsigned int cpu_sleep_token;
  unsigned int cpu_sleep_token_last;
  cluster_type_t_0 cpu_cluster_type;
  uint32_t cpu_cluster_id;
  uint32_t cpu_l2_id;
  uint32_t cpu_l2_size;
  uint32_t cpu_l3_id;
  uint32_t cpu_l3_size;
  enum : __int32
  {
    CPU_NOT_HALTED = 0x0,
    CPU_HALTED = 0x1,
    CPU_HALTED_WITH_STATE = 0x2,
  } halt_status;
  uint64_t rop_key;
  uint64_t jop_key;
  uint64_t *cpu_kpc_buf[2];
  uint64_t *cpu_kpc_shadow;
  uint64_t *cpu_kpc_reload;
  cpu_stat_t cpu_stat;
  pmap_cpu_data_0 cpu_pmap_cpu_data;
  dbgwrap_thread_state_t halt_state;
  uint64_t ipi_pc;
  uint64_t ipi_lr;
  uint64_t ipi_fp;
};

/* 9892 */
struct ipc_mqueue_1
{
  circle_queue_head_t_0 imq_messages;
  mach_port_seqno_t imq_seqno;
  mach_port_name_t_0 imq_receiver_name;
  uint16_t imq_msgcount;
  uint16_t imq_qlimit;
  uint32_t imq_context;
  union
  {
    klist imq_klist;
    knote *imq_inheritor_knote;
    turnstile *imq_inheritor_turnstile;
    thread_t_1 imq_inheritor_thread_ref;
    thread_t_1 imq_srp_owner_thread;
  };
};

/* 9893 */
struct waitq_1
{
  struct
  {
    _BYTE gap0[4];
  };
  hw_lck_ticket_t waitq_interlock;
  union
  {
    circle_queue_head_t_0 waitq_queue;
    priority_queue_sched_max waitq_prio_queue;
    turnstile *waitq_ts;
  };
  union
  {
    circle_queue_head_t_0 waitq_links;
    waitq_link_list_t waitq_sellinks;
    void *waitq_inheritor;
    mpsc_queue_chain waitq_defer;
  };
};

/* 9894 */
struct sched_clutch_bucket_runq_0
{
  int scbrq_highq;
  int scbrq_count;
  bitmap_t scbrq_bitmap[2];
  circle_queue_head_t_0 scbrq_queues[128];
};

/* 9895 */
struct run_queue_0
{
  int highq;
  bitmap_t bitmap[2];
  int count;
  int urgency;
  circle_queue_head_t_0 queues[96];
  runq_stats runq_stats;
};

/* 9897 */
struct __cppobj __attribute__((aligned(8))) OSKext_1 : OSObject_0
{
  OSPtr<OSDictionary>_0 infoDict;
  OSPtr<const OSSymbol>_0 bundleID;
  OSPtr<OSString>_0 path;
  OSPtr<OSString>_0 executableRelPath;
  OSPtr<OSString>_0 userExecutableRelPath;
  OSKextVersion version;
  OSKextVersion compatibleVersion;
  OSKextLoadTag_0 loadTag;
  kmod_info_t_0 *kmod_info;
  OSPtr<OSArray>_0 dependencies;
  OSPtr<OSData>_0 linkedExecutable;
  OSPtr<OSSet>_0 metaClasses;
  OSPtr<OSData>_0 interfaceUUID;
  OSPtr<OSData>_0 driverKitUUID;
  struct
  {
    _BYTE gap0[4];
  } flags;
  uint32_t matchingRefCount;
  kc_kind_t_0 kc_type;
  list_head_0 pendingPgoHead;
  uuid_t_0 instance_uuid;
  OSKextAccount *account;
  uint32_t builtinKmodIdx;
  OSPtr<OSArray>_0 savedMutableSegments;
  OSPtr<OSDextStatistics>_0 dextStatistics;
  OSPtr<OSData>_0 dextUniqueID;
  uint32_t dextLaunchedCount;
};

/* 9898 */
struct __cppobj OSDextStatistics_0 : OSObject_0
{
  OSPtr<OSArray>_0 crashes;
  IOLock_0 *lock;
};

/* 9899 */
struct __cppobj __attribute__((aligned(8))) IODTNVRAMVariables_0 : IOService_0
{
  IODTNVRAM_0 *_provider;
  uuid_t_0 _guid;
  bool _systemActive;
};

/* 9900 */
struct __cppobj OSOrderedSet_1 : OSCollection_1
{
  _Element *array;
  OSOrderedSet::OSOrderFunction_0 ordering;
  void *orderingRef;
  unsigned int count;
  unsigned int capacity;
  unsigned int capacityIncrement;
  OSOrderedSet::ExpansionData_0 *reserved;
};

/* 9901 */
struct __cppobj __attribute__((aligned(4))) OSCollectionIterator_1 : OSIterator_1
{
  OSPtr<const OSCollection> collection;
  union
  {
    struct
    {
      uint8_t inlineStorage[4];
      uint8_t __padding[4];
    };
    void *collIterator;
  };
  unsigned int initialUpdateStamp;
  bool valid;
};

/* 9902 */
struct __cppobj OSSet_1 : OSCollection_1
{
  OSPtr<OSArray> members;
};

/* 9904 */
struct ifnet_2
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func_0 if_output_dlil;
  volatile ifnet_start_func if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func if_input_ctl;
  ifnet_ioctl_func if_ioctl;
  ifnet_set_bpf_tap if_set_bpf_tap;
  ifnet_detached_func if_free;
  ifnet_demux_func_0 if_demux;
  ifnet_event_func if_event;
  ifnet_framer_func_1 if_framer_legacy;
  ifnet_framer_extended_func_0 if_framer;
  ifnet_add_proto_func if_add_proto;
  ifnet_del_proto_func if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route_0 if_fwd_route;
  route_0 if_src_route;
  route_in6 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 9905 */
struct __attribute__((aligned(8))) __kern_quantum_1
{
  __quantum qum_com;
  struct
  {
    __kern_quantum *sle_next;
  } qum_upp_link;
  const kern_pbufpool_1 *qum_pp;
  const __user_quantum *qum_user;
  const __kern_slot_desc *qum_ksd;
  __kern_buflet_0 qum_buf[1];
  pid_t qum_pid;
};

/* 9906 */
struct nexus_adapter_1
{
  volatile uint32_t na_flags;
  nexus_adapter_type_t na_type;
  const nexus_meta_type_t na_md_type;
  const nexus_meta_subtype_t na_md_subtype;
  nexus_port_t na_nx_port;
  uint32_t na_channels;
  uint32_t na_num_rx_rings;
  uint32_t na_num_tx_rings;
  uint32_t na_num_allocator_ring_pairs;
  uint32_t na_num_event_rings;
  uint64_t na_work_ts;
  __kern_channel_ring *na_tx_rings;
  __kern_channel_ring *na_rx_rings;
  kern_nexus *na_nx;
  volatile uint32_t na_refcount;
  int na_si_users[5];
  ch_selinfo na_si[5];
  skmem_arena *na_arena;
  uint32_t na_num_tx_slots;
  uint32_t na_num_rx_slots;
  uint32_t na_num_allocator_slots;
  uint32_t na_num_event_slots;
  uint32_t na_total_slots;
  const uint32_t na_flowadv_max;
  const nexus_stats_type_t na_stats_type;
  __kern_channel_ring *na_alloc_rings;
  __kern_channel_ring *na_free_rings;
  __kern_channel_ring *na_event_rings;
  uint64_t na_ch_mit_ival;
  kern_nexus_domain_provider *na_nxdom_prov;
  slot_ctx *na_slot_ctxs;
  kern_packet_t *na_scratch;
  __kern_channel_ring *na_tail;
  void *na_private;
  ifnet *na_ifp;
  uint8_t na_kring_svc_lut[10];
  uint32_t na_next_pipe;
  uint32_t na_max_pipes;
  nexus_upipe_adapter **na_pipes;
  char na_name[64];
  uuid_t_1 na_uuid;
  int (*na_activate)(nexus_adapter *, na_activate_mode_t);
  int (*na_special)(nexus_adapter *, kern_channel *, chreq *, nxspec_cmd_t);
  int (*na_txsync)(__kern_channel_ring *, proc *, uint32_t);
  int (*na_rxsync)(__kern_channel_ring *, proc *, uint32_t);
  int (*na_notify)(__kern_channel_ring *, proc *, uint32_t);
  int (*na_channel_event_notify)(nexus_adapter *, __kern_channel_event *, uint16_t);
  int (*na_config)(nexus_adapter *, uint32_t *, uint32_t *, uint32_t *, uint32_t *);
  int (*na_krings_create)(nexus_adapter *, kern_channel *);
  void (*na_krings_delete)(nexus_adapter *, kern_channel *, boolean_t);
  void (*na_dtor)(nexus_adapter *);
  void (*na_free)(nexus_adapter *);
  void (*na_rx)(nexus_adapter *, __kern_packet *, nexus_pkt_stats *);
};

/* 9907 */
struct ip6po_rhinfo_0
{
  ip6_rthdr *ip6po_rhi_rthdr;
  route_in6_1 ip6po_rhi_route;
};

/* 9908 */
struct ip6po_nhinfo_0
{
  sockaddr *ip6po_nhi_nexthop;
  route_in6_1 ip6po_nhi_route;
};

/* 9909 */
struct ifnet_3
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func_1 if_output_dlil;
  volatile ifnet_start_func_0 if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func_0 if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func_0 if_input_ctl;
  ifnet_ioctl_func_0 if_ioctl;
  ifnet_set_bpf_tap_0 if_set_bpf_tap;
  ifnet_detached_func_0 if_free;
  ifnet_demux_func_1 if_demux;
  ifnet_event_func_0 if_event;
  ifnet_framer_func_1 if_framer_legacy;
  ifnet_framer_extended_func_0 if_framer;
  ifnet_add_proto_func_0 if_add_proto;
  ifnet_del_proto_func_0 if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func_0 if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func_0 if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route_0 if_fwd_route;
  route_0 if_src_route;
  route_in6 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 9911 */
struct ifnet_5
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func_0 if_output_dlil;
  volatile ifnet_start_func if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func if_input_ctl;
  ifnet_ioctl_func if_ioctl;
  ifnet_set_bpf_tap if_set_bpf_tap;
  ifnet_detached_func if_free;
  ifnet_demux_func_0 if_demux;
  ifnet_event_func if_event;
  ifnet_framer_func_1 if_framer_legacy;
  ifnet_framer_extended_func_0 if_framer;
  ifnet_add_proto_func if_add_proto;
  ifnet_del_proto_func if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route_0 if_fwd_route;
  route_0 if_src_route;
  route_in6_1 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 9912 */
struct sched_clutch_root_bucket_0
{
  uint8_t scrb_bucket;
  bool scrb_bound;
  bool scrb_starvation_avoidance;
  union
  {
    sched_clutch_bucket_runq_0 scrb_clutch_buckets;
    run_queue_0 scrb_bound_thread_runq;
  };
  priority_queue_entry_deadline scrb_pqlink;
  uint64_t scrb_warped_deadline;
  uint64_t scrb_warp_remaining;
  uint64_t scrb_starvation_ts;
};

/* 9913 */
struct __attribute__((aligned(8))) firehose_loss_payload_s
{
  uint64_t start_stamp;
  uint64_t end_stamp;
  uint32_t count;
};

/* 9914 */
typedef firehose_buffer_header_s *firehose_buffer_header_t;

/* 9915 */
typedef firehose_buffer_stream_s *firehose_buffer_stream_t;

/* 9916 */
typedef unsigned __int64 __ARRAY_SIZE_TYPE__;

/* 9917 */
typedef ccchacha20poly1305_ctx_0 chacha20poly1305_ctx_0;

/* 9918 */
typedef const ccchacha20poly1305_fns *ccchacha20poly1305_fns_t_0;

/* 9919 */
struct __block_literal_1_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(label *);
  __block_descriptor *__descriptor;
};

/* 9920 */
struct mac_policy_conf_0
{
  const char *mpc_name;
  const char *mpc_fullname;
  const char *const *mpc_labelnames;
  unsigned int mpc_labelname_count;
  const mac_policy_ops_0 *mpc_ops;
  int mpc_loadtime_flags;
  int *mpc_field_off;
  int mpc_runtime_flags;
  mac_policy_conf *mpc_list;
  void *mpc_data;
};

/* 9921 */
struct vfstable_0
{
  const vfsops *vfc_vfsops;
  char vfc_name[15];
  int vfc_typenum;
  int vfc_refcount;
  int vfc_flags;
  int (*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);
  vfstable *vfc_next;
  int32_t vfc_reserved1;
  int32_t vfc_reserved2;
  int vfc_vfsflags;
  void *vfc_descptr;
  uint32_t vfc_descsize;
  sysctl_oid_0 *vfc_sysctl;
};

/* 9922 */
struct vnode_resolve_0
{
  lck_mtx_t vr_lock;
  trigger_vnode_resolve_callback_t_0 vr_resolve_func;
  trigger_vnode_unresolve_callback_t_0 vr_unresolve_func;
  trigger_vnode_rearm_callback_t vr_rearm_func;
  trigger_vnode_reclaim_callback_t_0 vr_reclaim_func;
  void *vr_data;
  uint32_t vr_flags;
  uint32_t vr_lastseq;
};

/* 9923 */
typedef posix_cred *posix_cred_t_0;

/* 9924 */
struct vnode_resolve_1
{
  lck_mtx_t vr_lock;
  trigger_vnode_resolve_callback_t_1 vr_resolve_func;
  trigger_vnode_unresolve_callback_t_0 vr_unresolve_func;
  trigger_vnode_rearm_callback_t vr_rearm_func;
  trigger_vnode_reclaim_callback_t_0 vr_reclaim_func;
  void *vr_data;
  uint32_t vr_flags;
  uint32_t vr_lastseq;
};

/* 9925 */
struct __block_literal_1_1
{
  void *__isa;
  int __flags;
  int __reserved;
  int (*__FuncPtr)(char *, size_t);
  __block_descriptor *__descriptor;
  image_params *imgp;
};

/* 9926 */
struct vnode_0
{
  lck_mtx_t v_lock;
  struct
  {
    vnode *tqe_next;
    vnode **tqe_prev;
  } v_freelist;
  struct
  {
    vnode *tqe_next;
    vnode **tqe_prev;
  } v_mntvnodes;
  struct
  {
    namecache *tqh_first;
    namecache **tqh_last;
  } v_ncchildren;
  struct
  {
    namecache *lh_first;
  } v_nclinks;
  vnode_t v_defer_reclaimlist;
  uint32_t v_listflag;
  uint32_t v_flag;
  uint16_t v_lflag;
  uint8_t v_iterblkflags;
  uint8_t v_references;
  int32_t v_kusecount;
  int32_t v_usecount;
  int32_t v_iocount;
  _BYTE gap68[8];
  uint16_t v_type;
  uint16_t v_tag;
  uint32_t v_id;
  _BYTE gap78[8];
  buflists v_cleanblkhd;
  buflists v_dirtyblkhd;
  klist v_knotes;
  _BYTE gap98[8];
  kauth_action_t v_authorized_actions;
  int v_cred_timestamp;
  int v_nc_generation;
  int32_t v_numoutput;
  int32_t v_writecount;
  uint32_t v_holdcount;
  const char *v_name;
  _BYTE gapC0[8];
  lockf *v_lockf;
  int (**v_op)(void *);
  _BYTE gapD8[8];
  void *v_data;
  label *v_label;
  vnode_resolve_t v_resolve;
  vnode_t v_fmlink;
  fl_head v_leases;
};

/* 9927 */
struct __block_literal_6_0
{
  void *__isa;
  int __flags;
  int __reserved;
  int (*__FuncPtr)(char *, char *, size_t);
  __block_descriptor *__descriptor;
  mount *mp;
};

/* 9928 */
struct __block_literal_5_0
{
  void *__isa;
  int __flags;
  int __reserved;
  int (*__FuncPtr)(char *, size_t);
  __block_descriptor *__descriptor;
  __mac_set_fd_args *uap;
  proc_t p;
};

/* 9929 */
struct __block_literal_4_0
{
  void *__isa;
  int __flags;
  int __reserved;
  int (*__FuncPtr)(char *, char *, size_t);
  __block_descriptor *__descriptor;
  __mac_get_fd_args *uap;
  proc_t p;
};

/* 9930 */
struct __block_literal_3_0
{
  void *__isa;
  int __flags;
  int __reserved;
  int (*__FuncPtr)(char *, size_t);
  __block_descriptor *__descriptor;
  proc_t p;
};

/* 9931 */
struct __block_literal_2_0
{
  void *__isa;
  int __flags;
  int __reserved;
  int (*__FuncPtr)(char *, char *, size_t);
  __block_descriptor *__descriptor;
};

/* 9932 */
struct __block_literal_1_2
{
  void *__isa;
  int __flags;
  int __reserved;
  int (*__FuncPtr)(char *, char *, size_t);
  __block_descriptor *__descriptor;
  __mac_get_pid_args *uap;
};

/* 9933 */
struct user64_mac
{
  uint64_t m_buflen;
  uint64_t m_string;
};

/* 9934 */
struct user32_mac
{
  uint32_t m_buflen;
  uint32_t m_string;
};

/* 9935 */
struct kalloc_result
{
  void *addr;
  vm_size_t_0 size;
};

/* 9936 */
typedef mac_policy_list mac_policy_list_t;

/* 9937 */
struct __attribute__((aligned(8))) tty_0
{
  lck_mtx_t t_lock;
  clist t_rawq;
  long t_rawcc;
  clist t_canq;
  long t_cancc;
  clist t_outq;
  long t_outcc;
  int t_line;
  dev_t t_dev;
  int t_state;
  int t_flags;
  int t_timeout;
  pgrp *t_pgrp;
  session *t_session;
  selinfo t_rsel;
  selinfo t_wsel;
  termios t_termios;
  winsize t_winsize;
  void (*t_oproc)(tty *);
  void (*t_stop)(tty *, int);
  int (*t_param)(tty *, termios *);
  void *t_sc;
  int t_column;
  int t_rocount;
  int t_rocol;
  int t_hiwat;
  int t_lowat;
  int t_gen;
  void *t_iokit;
  os_ref_atomic_t t_refcnt;
};

/* 9938 */
struct vfstable_1
{
  const vfsops *vfc_vfsops;
  char vfc_name[15];
  int vfc_typenum;
  int vfc_refcount;
  int vfc_flags;
  int (*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);
  vfstable *vfc_next;
  int32_t vfc_reserved1;
  int32_t vfc_reserved2;
  int vfc_vfsflags;
  void *vfc_descptr;
  uint32_t vfc_descsize;
  sysctl_oid_0 *vfc_sysctl;
};

/* 9939 */
typedef const OpaqueDTEntry *DTEntry_0;

/* 9940 */
typedef void (*PE_kputc_t)(char);

/* 9941 */
typedef PE_state_0 PE_state_t_0;

/* 9942 */
typedef uint64_t machine_timeout_t;

/* 9943 */
typedef kc_index kc_index_t;

/* 9944 */
typedef void (*PE_putc_t)(char);

/* 9945 */
typedef char DTEntryNameBuf[64];

/* 9946 */
typedef OSData_0 *OSDataPtr;

/* 9947 */
typedef const OSSymbol_0 *OSSymbolConstPtr;

/* 9948 */
typedef ml_topology_cluster ml_topology_cluster_t_0;

/* 9949 */
typedef ml_topology_cpu ml_topology_cpu_t_0;

/* 9950 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_2_1
{
  void *__isa;
  int __flags;
  int __reserved;
  IOReturn_0 (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  uint32_t mode;
};

/* 9951 */
struct __block_literal_1_3
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(4))) {void *__isa;void *__forwarding;int __flags;int __size;unsigned int count;}; *count;
};

/* 9952 */
struct PMStatsStruct
{
  PMStatsBounds hibWrite;
  PMStatsBounds hibRead;
};

/* 9953 */
struct libkern::sa_detail::remove_const<unsigned int>
{
  _BYTE gap0;
};

/* 9954 */
typedef OSSharedPtr<OSValueObject<PMAssertStruct> > OSPtr<OSValueObject<PMAssertStruct> >;

/* 9955 */
struct uat_ppl_prepare_params
{
  vm_address_t virt_addr;
  uint64_t size;
};

/* 9956 */
struct __attribute__((aligned(8))) uat_ppl_fault_params
{
  vm_address_t virt_addr;
  uint32_t fault_level;
};

/* 9957 */
struct uat_ppl_init_data
{
  uint64_t version;
  vm_address_t context_table_base;
  vm_address_t ttbr1_l1;
  vm_address_t handoff_region_base;
};

/* 9958 */
typedef uint64_t uat_tte_t;

/* 9959 */
typedef IOMemoryMap_0 *OSPtr<IOMemoryMap>_0;

/* 9960 */
struct __block_literal_5_1
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct *ret;
  UInt32 *workIntervalFlags;
};

/* 9961 */
struct __block_literal_4_1
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(const OSSymbol_0 *, OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct *ret;
  const OSSymbol_0 *id;
  workload_config_ctx_t *ctx;
};

/* 9962 */
struct __block_literal_6_1
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct *ret;
  workload_config_ctx_t *ctx;
};

/* 9963 */
struct __block_literal_3_1
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(const OSSymbol_0 *, OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct *ret;
  workload_config_ctx_t *ctx;
};

/* 9964 */
typedef OSAllocation<char> OSDataAllocation<char>;

/* 9965 */
typedef libkern::sa_detail::remove_const_t<char> RawT_0;

/* 9966 */
struct __block_literal_8_0
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(1))) {void *__isa;void *__forwarding;int __flags;int __size;bool allPresent;}; *allPresent;
  OSDictionary_0 *entitlements;
  OSDictionary_0 *matching;
};

/* 9967 */
struct __block_literal_7_0
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(1))) {void *__isa;void *__forwarding;int __flags;int __size;bool allPresent;}; *allPresent;
  OSDictionary_0 *entitlements;
  OSDictionary_0 *matching;
};

/* 9968 */
typedef char io_name_t[128];

/* 9969 */
struct __block_literal_6_2
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(const OSSymbol_0 *, OSObject_0 *);
  __block_descriptor *__descriptor;
};

/* 9970 */
struct __block_literal_5_2
{
  void *__isa;
  int __flags;
  int __reserved;
  IOReturn_0 (*__FuncPtr)(uint32_t, IOService_0 *, void *, size_t);
  __block_descriptor *__descriptor;
  IOServiceNotificationDispatchSource *inst;
  IOService_0 *newService;
};

/* 9971 */
struct __block_literal_4_2
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(IOService_0 *, IONotifier_0 *);
  __block_descriptor *__descriptor;
  IOServiceNotificationDispatchSource *inst;
};

/* 9972 */
typedef OSAllocation<unsigned char> OSDataAllocation<unsigned char>;

/* 9973 */
struct __block_literal_3_2
{
  void *__isa;
  int __flags;
  int __reserved;
  IOReturn_0 (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  IOService_0 *this;
  OSString_0 *propertyName;
};

/* 9974 */
struct __block_literal_2_2
{
  void *__isa;
  int __flags;
  int __reserved;
  IOReturn_0 (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  IOService_0 *this;
  OSDictionary_0 *dict;
};

/* 9975 */
struct __block_literal_1_4
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(const OSSymbol_0 *, OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(1))) {void *__isa;void *__forwarding;int __flags;int __size;bool ok;}; *ok;
  IOService_0 *this;
};

/* 9976 */
struct IOInterruptDispatchSourcePayload
{
  uint64_t time;
  uint64_t count;
};

/* 9977 */
typedef libkern::bounded_ptr<const char,os_detail::panic_trapping_policy> OSBoundedPtr<const char>;

/* 9978 */
typedef libkern::sa_detail::remove_const_t<unsigned char> RawT_1;

/* 9979 */
typedef unsigned int mach_msg_copy_options_t;

/* 9980 */
typedef IOServiceStateNotificationEventSource *OSPtr<IOServiceStateNotificationEventSource>;

/* 9981 */
struct os_detail::IOKit_typed_allocator<unsigned char,true>
{
  _BYTE gap0;
};

/* 9982 */
struct libkern::bounded_ptr<unsigned char,os_detail::panic_trapping_policy>;

/* 9983 */
struct libkern::sa_detail::remove_const<unsigned char>
{
  _BYTE gap0;
};

/* 9984 */
typedef libkern::bounded_ptr<const unsigned char,os_detail::panic_trapping_policy> libkern::safe_allocation<unsigned char,os_detail::IOKit_typed_allocator<unsigned char,true>,os_detail::panic_trapping_policy>::const_iterator;

/* 9985 */
typedef void libkern::safe_allocation<unsigned char,os_detail::IOKit_typed_allocator<unsigned char,true>,os_detail::panic_trapping_policy>::iterator;

/* 9986 */
typedef libkern::bounded_ptr<const IOExternalTrap,os_detail::panic_trapping_policy> libkern::bounded_array<IOExternalTrap,2UL,os_detail::panic_trapping_policy>::const_iterator;

/* 9987 */
typedef void libkern::bounded_array<IOExternalTrap,2UL,os_detail::panic_trapping_policy>::iterator;

/* 9988 */
struct libkern::detail::copy_cv<const IOExternalTrap,char>
{
  _BYTE gap0;
};

/* 9989 */
struct libkern::bounded_ptr<IOExternalTrap,os_detail::panic_trapping_policy>;

/* 9990 */
typedef libkern::bounded_ptr<const IOExternalTrap,os_detail::panic_trapping_policy> libkern::bounded_array<IOExternalTrap,1UL,os_detail::panic_trapping_policy>::const_iterator;

/* 9991 */
typedef void libkern::bounded_array<IOExternalTrap,1UL,os_detail::panic_trapping_policy>::iterator;

/* 9992 */
typedef int BOOL;

/* 9993 */
typedef IOReportLegend *OSPtr<IOReportLegend>;

/* 9994 */
typedef OSSharedPtr<IOHistogramReporter> OSPtr<IOHistogramReporter>;

/* 9995 */
typedef OSSharedPtr<IOStateReporter> OSPtr<IOStateReporter>;

/* 9996 */
typedef IOStatistics::ClassTree IOStatistics::ClassTreeHead;

/* 9997 */
typedef IOStatistics::KextAddressTree IOStatistics::KextAddressTreeHead;

/* 9998 */
typedef IOStatistics::KextTree IOStatistics::KextTreeHead;

/* 9999 */
struct IOStatistics
{
  _BYTE gap0;
};

/* 10000 */
typedef OSSharedPtr<IOSharedDataQueue> OSPtr<IOSharedDataQueue>;

/* 10001 */
typedef OSSharedPtr<IODataQueue> OSPtr<IODataQueue>;

/* 10002 */
typedef IOReturn_0 (*IOTrap_1)(IOService_0 *, void *, void *, void *, void *, void *, void *);

/* 10003 */
typedef io_user_scalar_t io_scalar_inband64_t[16];

/* 10004 */
struct __block_literal_5_3
{
  void *__isa;
  int __flags;
  int __reserved;
  IOReturn_0 (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  IORegistryEntry_0 *entry;
  OSObject_0 *obj;
};

/* 10005 */
struct __block_literal_4_3
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(const OSSymbol_0 *, OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(1))) {void *__isa;void *__forwarding;int __flags;int __size;bool found;}; *found;
  struct __attribute__((packed)) __attribute__((aligned(1))) {void *__isa;void *__forwarding;int __flags;int __size;bool allFound;}; *allFound;
  OSArray_0 *allowableArray;
  IORegistryEntry_0 *entry;
};

/* 10006 */
typedef io_user_reference_t_0 io_async_ref64_t[8];

/* 10007 */
typedef libkern::bounded_array<unsigned long long,16UL,os_detail::panic_trapping_policy> OSBoundedArray<unsigned long long,kMaxAsyncArgs>;

/* 10008 */
struct __block_literal_3_3
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor *__descriptor;
};

/* 10009 */
typedef IOReturn_0 (*IOMethod_1)(IOService_0 *, void *, void *, void *, void *, void *, void *);

/* 10010 */
typedef int io_scalar_inband_t[16];

/* 10011 */
typedef IOReturn_0 (*IOAsyncMethod_1)(IOService_0 *, natural_t *, void *, void *, void *, void *, void *, void *);

/* 10012 */
typedef natural_t io_async_ref_t[8];

/* 10013 */
struct __block_literal_2_3
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(mach_msg_header_t_0 *, mach_msg_descriptor_t *, void *);
  __block_descriptor *__descriptor;
  IOServiceMessageUserNotification *this;
  ipc_port_t_0 thisPort;
  ipc_port_t_0 providerPort;
  vm_size_t_0 callerArgSize;
  void *messageArgument;
  mach_msg_size_t thisMsgSize;
  mach_msg_size_t extraSize;
  natural_t type;
  UInt32 messageType;
};

/* 10014 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_1_5
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(mach_msg_header_t_0 *, mach_msg_descriptor_t *, void *);
  __block_descriptor *__descriptor;
  IOServiceUserNotification *this;
  ipc_port_t_0 port;
  mach_msg_size_t msgSize;
};

/* 10015 */
struct IOUserClient::_sendAsyncResult64::ReplyMsg
{
  mach_msg_header_t_1 msgHdr;
  union
  {
    struct
    {
      OSNotificationHeader notifyHdr;
      IOAsyncCompletionContent asyncContent;
      uint32_t args[16];
    } msg32;
    struct __attribute__((aligned(8)))
    {
      OSNotificationHeader64 notifyHdr;
      IOAsyncCompletionContent asyncContent;
      __attribute__((packed)) __attribute__((aligned(1))) io_user_reference_t_0 args[16];
    } msg64;
  } m;
};

/* 10016 */
struct libkern::bounded_ptr<const unsigned long long,os_detail::panic_trapping_policy>;

/* 10017 */
typedef void libkern::bounded_array<unsigned long long,16UL,os_detail::panic_trapping_policy>::const_iterator;

/* 10018 */
typedef libkern::bounded_ptr<unsigned long long,os_detail::panic_trapping_policy> libkern::bounded_array<unsigned long long,16UL,os_detail::panic_trapping_policy>::iterator;

/* 10019 */
struct libkern::detail::copy_cv<unsigned long long,char>
{
  _BYTE gap0;
};

/* 10020 */
typedef libkern::bounded_ptr<const unsigned char,os_detail::panic_trapping_policy> OSBoundedPtr<const unsigned char>;

/* 10021 */
struct libkern::detail::copy_cv<const unsigned char,char>
{
  _BYTE gap0;
};

/* 10022 */
typedef OSSharedPtr<OSObject> OSPtr<OSObject>_0;

/* 10023 */
typedef OSSharedPtr<IOGuardPageMemoryDescriptor> OSPtr<IOGuardPageMemoryDescriptor>;

/* 10024 */
typedef OSAllocation<SerData> OSDataAllocation<SerData>;

/* 10025 */
struct __block_literal_1_6
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct *result;
  IOMemoryDescriptor_0 *this;
  IOMemoryMap_0 *mapping;
  mach_vm_size_t_0 offset;
};

/* 10026 */
typedef libkern::sa_detail::remove_const_t<SerData> RawT_2;

/* 10027 */
struct os_detail::IOKit_typed_allocator<SerData,true>
{
  _BYTE gap0;
};

/* 10028 */
struct OSSharedPtr<IOMultiMemoryDescriptor>;

/* 10029 */
typedef void OSPtr<IOMultiMemoryDescriptor>;

/* 10030 */
struct OSSharedPtr<IOSubMemoryDescriptor>;

/* 10031 */
typedef void OSPtr<IOSubMemoryDescriptor>;

/* 10032 */
struct memory_object_0
{
  mo_ipc_object_bits_t mo_ikot;
  os_ref_atomic_t mo_ref;
  const memory_object_pager_ops_1 *mo_pager_ops;
  memory_object_control_t mo_control;
};

/* 10033 */
struct libkern::bounded_ptr<const SerData,os_detail::panic_trapping_policy>;

/* 10034 */
struct libkern::sa_detail::remove_const<SerData>
{
  _BYTE gap0;
};

/* 10035 */
typedef void libkern::safe_allocation<SerData,os_detail::IOKit_typed_allocator<SerData,true>,os_detail::panic_trapping_policy>::const_iterator;

/* 10036 */
typedef libkern::bounded_ptr<SerData,os_detail::panic_trapping_policy> libkern::safe_allocation<SerData,os_detail::IOKit_typed_allocator<SerData,true>,os_detail::panic_trapping_policy>::iterator;

/* 10037 */
struct libkern::detail::copy_cv<SerData,char>
{
  _BYTE gap0;
};

/* 10038 */
typedef OSSharedPtr<_IOMemoryDescriptorMixedData> OSPtr<_IOMemoryDescriptorMixedData>_0;

/* 10039 */
typedef OSSharedPtr<IOLittleMemoryCursor> OSPtr<IOLittleMemoryCursor>;

/* 10040 */
typedef OSSharedPtr<IOBigMemoryCursor> OSPtr<IOBigMemoryCursor>;

/* 10041 */
typedef OSSharedPtr<IONaturalMemoryCursor> OSPtr<IONaturalMemoryCursor>;

/* 10042 */
typedef OSSharedPtr<IOMemoryCursor> OSPtr<IOMemoryCursor>;

/* 10043 */
typedef IOInterleavedMemoryDescriptor_0 *OSPtr<IOInterleavedMemoryDescriptor>;

/* 10044 */
typedef OSSharedPtr<IOFilterInterruptEventSource> OSPtr<IOFilterInterruptEventSource>;

/* 10045 */
typedef OSSharedPtr<IOInterruptEventSource> OSPtr<IOInterruptEventSource>;

/* 10046 */
typedef OSSharedPtr<IODMAEventSource> OSPtr<IODMAEventSource>;

/* 10047 */
struct __cppobj OSSharedPtr<IOCommand> : libkern::intrusive_shared_ptr<IOCommand,intrusive_osobject_retainer>
{
};

/* 10048 */
typedef IOInterruptEventSource_0 *OSPtr<IOInterruptEventSource>_0;

/* 10049 */
typedef IOCommand_0 *OSPtr<IOCommand>;

/* 10050 */
typedef IOCommandPool_0 *OSPtr<IOCommandPool>;

/* 10051 */
struct __block_literal_2_4
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSDictionary_0 *);
  __block_descriptor *__descriptor;
};

/* 10052 */
struct __block_literal_5_4
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor *__descriptor;
  const OSSymbol_0 *moduleName;
};

/* 10053 */
struct __block_literal_4_4
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(const OSSymbol_0 *, OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  const OSSymbol_0 *moduleName;
  OSSharedPtr<OSOrderedSet> set;
};

/* 10054 */
struct __block_literal_3_4
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  OSSharedPtr<OSArray> servicesToTerminate;
};

/* 10055 */
struct __block_literal_1_7
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSDictionary_0 *);
  __block_descriptor *__descriptor;
  OSDictionary_0 *matching;
};

/* 10056 */
typedef int SInt;

/* 10057 */
typedef OSSharedPtr<OSOrderedSet> OSPtr<OSOrderedSet>;

/* 10058 */
typedef IOCatalogue_0 *libkern::intrusive_shared_ptr<IOCatalogue,intrusive_osobject_retainer>::pointer_0;

/* 10059 */
typedef OSOrderedSet_0 *libkern::intrusive_shared_ptr<OSOrderedSet,intrusive_osobject_retainer>::pointer_0;

/* 10060 */
struct __cppobj IOCatalogue::MetaClass_0 : OSMetaClass_0
{
};

/* 10061 */
struct __cppobj IOCatalogue_1 : OSObject_1
{
  IORWLock_0 *lock;
  SInt32 generation;
  OSPtr<OSDictionary>_0 personalities;
};

/* 10062 */
typedef void (*IOPMPowerStateQueueAction)(OSObject_0 *, uint32_t, void *, uint64_t);

/* 10063 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_5_5
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor *__descriptor;
  int howto;
};

/* 10064 */
struct __block_literal_4_5
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor *__descriptor;
};

/* 10065 */
struct __block_literal_1_8
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor *__descriptor;
};

/* 10066 */
typedef thread_precedence_policy thread_precedence_policy_data_t;

/* 10067 */
struct __block_literal_2_5
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor *__descriptor;
};

/* 10068 */
struct os_detail::IOKit_typed_allocator<char,true>
{
  _BYTE gap0;
};

/* 10069 */
struct _IOServiceMatchingNotificationHandlerRef
{
  IOServiceNotificationHandler handler;
  void *ref;
};

/* 10070 */
struct libkern::detail::copy_cv<const char,char>
{
  _BYTE gap0;
};

/* 10071 */
struct libkern::sa_detail::remove_const<char>
{
  _BYTE gap0;
};

/* 10072 */
typedef libkern::bounded_ptr<const char,os_detail::panic_trapping_policy> libkern::safe_allocation<char,os_detail::IOKit_typed_allocator<char,true>,os_detail::panic_trapping_policy>::const_iterator;

/* 10073 */
typedef libkern::bounded_ptr<char,os_detail::panic_trapping_policy> libkern::safe_allocation<char,os_detail::IOKit_typed_allocator<char,true>,os_detail::panic_trapping_policy>::iterator;

/* 10074 */
typedef semaphore_t_0 semaphore_port_t;

/* 10075 */
typedef libkern::bounded_ptr<char,os_detail::panic_trapping_policy> OSBoundedPtr<char>;

/* 10076 */
struct libkern::detail::copy_cv<char,char>
{
  _BYTE gap0;
};

/* 10077 */
typedef OSOrderedSet_0 *OSPtr<OSOrderedSet>_0;

/* 10078 */
typedef IORegistryIterator_0 *OSPtr<IORegistryIterator>;

/* 10079 */
typedef IOConditionLock_0 *OSPtr<IOConditionLock>;

/* 10080 */
struct __attribute__((aligned(8))) kmem_range_startup_spec_0
{
  const char *kc_name;
  mach_vm_range *kc_range;
  vm_map_size_t kc_size;
  struct *kc_calculate_sz;
  _BYTE gap20[8];
};

/* 10081 */
union IODMACommand_Create_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODMACommand_Create_Msg *message;
    IODMACommand_Create_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10082 */
union IODMACommand_GetPreparation_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODMACommand_GetPreparation_Msg *message;
    IODMACommand_GetPreparation_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10083 */
union IODMACommand_CompleteDMA_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODMACommand_CompleteDMA_Msg *message;
    IODMACommand_CompleteDMA_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10084 */
union IODMACommand_PrepareForDMA_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODMACommand_PrepareForDMA_Msg *message;
    IODMACommand_PrepareForDMA_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10085 */
union IODMACommand_PerformOperation_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODMACommand_PerformOperation_Msg *message;
    IODMACommand_PerformOperation_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10086 */
union IOUserServer_Create_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOUserServer_Create_Msg *message;
    IOUserServer_Create_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10087 */
union IOUserServer_LoadModule_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOUserServer_LoadModule_Msg *message;
    IOUserServer_LoadModule_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10088 */
union IOUserServer_Exit_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOUserServer_Exit_Msg *message;
    IOUserServer_Exit_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10089 */
union IOWorkGroup_Create_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOWorkGroup_Create_Msg *message;
    IOWorkGroup_Create_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10090 */
union IOWorkGroup_InvalidateKernel_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOWorkGroup_InvalidateKernel_Msg *message;
    IOWorkGroup_InvalidateKernel_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10091 */
union IOWorkGroup_SetWorkGroupPort_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOWorkGroup_SetWorkGroupPort_Msg *message;
    IOWorkGroup_SetWorkGroupPort_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10092 */
union IOEventLink_Create_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOEventLink_Create_Msg *message;
    IOEventLink_Create_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10093 */
union IOEventLink_InvalidateKernel_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOEventLink_InvalidateKernel_Msg *message;
    IOEventLink_InvalidateKernel_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10094 */
union IOEventLink_SetEventlinkPort_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOEventLink_SetEventlinkPort_Msg *message;
    IOEventLink_SetEventlinkPort_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10095 */
union IOServiceStateNotificationDispatchSource_Create_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOServiceStateNotificationDispatchSource_Create_Msg *message;
    IOServiceStateNotificationDispatchSource_Create_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10096 */
union IOServiceStateNotificationDispatchSource_SetHandler_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOServiceStateNotificationDispatchSource_SetHandler_Msg *message;
    IOServiceStateNotificationDispatchSource_SetHandler_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10097 */
union IOServiceStateNotificationDispatchSource_StateNotificationBegin_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOServiceStateNotificationDispatchSource_StateNotificationBegin_Msg *message;
    IOServiceStateNotificationDispatchSource_StateNotificationBegin_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10098 */
union IOServiceNotificationDispatchSource_Create_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOServiceNotificationDispatchSource_Create_Msg *message;
    IOServiceNotificationDispatchSource_Create_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10099 */
union IOServiceNotificationDispatchSource_SetHandler_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOServiceNotificationDispatchSource_SetHandler_Msg *message;
    IOServiceNotificationDispatchSource_SetHandler_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10100 */
union IOServiceNotificationDispatchSource_CopyNextNotification_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOServiceNotificationDispatchSource_CopyNextNotification_Msg *message;
    IOServiceNotificationDispatchSource_CopyNextNotification_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10101 */
struct libkern::bounded_ptr<OSArray *const,os_detail::panic_trapping_policy>;

/* 10102 */
struct libkern::detail::copy_cv<OSArray *,char>
{
  _BYTE gap0;
};

/* 10103 */
typedef void libkern::bounded_array<OSArray *,2UL,os_detail::panic_trapping_policy>::const_iterator;

/* 10104 */
typedef libkern::bounded_ptr<OSArray *,os_detail::panic_trapping_policy> libkern::bounded_array<OSArray *,2UL,os_detail::panic_trapping_policy>::iterator;

/* 10105 */
union IODataQueueDispatchSource_DataServiced_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODataQueueDispatchSource_DataServiced_Msg *message;
    IODataQueueDispatchSource_DataServiced_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10106 */
union IODataQueueDispatchSource_DataAvailable_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODataQueueDispatchSource_DataAvailable_Msg *message;
    IODataQueueDispatchSource_DataAvailable_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10107 */
union IODataQueueDispatchSource_Create_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODataQueueDispatchSource_Create_Msg *message;
    IODataQueueDispatchSource_Create_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10108 */
union IODataQueueDispatchSource_CopyDataAvailableHandler_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODataQueueDispatchSource_CopyDataAvailableHandler_Msg *message;
    IODataQueueDispatchSource_CopyDataAvailableHandler_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10109 */
union IODataQueueDispatchSource_SetDataAvailableHandler_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODataQueueDispatchSource_SetDataAvailableHandler_Msg *message;
    IODataQueueDispatchSource_SetDataAvailableHandler_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10110 */
union IODataQueueDispatchSource_CopyMemory_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODataQueueDispatchSource_CopyMemory_Msg *message;
    IODataQueueDispatchSource_CopyMemory_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10111 */
union IODataQueueDispatchSource_SetDataServicedHandler_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODataQueueDispatchSource_SetDataServicedHandler_Msg *message;
    IODataQueueDispatchSource_SetDataServicedHandler_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10112 */
union IODataQueueDispatchSource_CopyDataServicedHandler_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODataQueueDispatchSource_CopyDataServicedHandler_Msg *message;
    IODataQueueDispatchSource_CopyDataServicedHandler_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10113 */
union IOInterruptDispatchSource_Create_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOInterruptDispatchSource_Create_Msg *message;
    IOInterruptDispatchSource_Create_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10114 */
union IOInterruptDispatchSource_GetInterruptType_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOInterruptDispatchSource_GetInterruptType_Msg *message;
    IOInterruptDispatchSource_GetInterruptType_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10115 */
union IOInterruptDispatchSource_GetLastInterrupt_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOInterruptDispatchSource_GetLastInterrupt_Msg *message;
    IOInterruptDispatchSource_GetLastInterrupt_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10116 */
union IOInterruptDispatchSource_SetHandler_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOInterruptDispatchSource_SetHandler_Msg *message;
    IOInterruptDispatchSource_SetHandler_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10117 */
union IOInterruptDispatchSource_InterruptOccurred_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOInterruptDispatchSource_InterruptOccurred_Msg *message;
    IOInterruptDispatchSource_InterruptOccurred_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10118 */
typedef struct *IODispatchSourceCancelHandler_0;

/* 10119 */
union IODispatchQueue_Create_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODispatchQueue_Create_Msg *message;
    IODispatchQueue_Create_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10120 */
union IODispatchQueue_SetPort_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODispatchQueue_SetPort_Msg *message;
    IODispatchQueue_SetPort_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10121 */
union IODispatchSource_CheckForWork_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODispatchSource_CheckForWork_Msg *message;
    IODispatchSource_CheckForWork_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10122 */
union IODispatchSource_Cancel_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODispatchSource_Cancel_Msg *message;
    IODispatchSource_Cancel_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10123 */
union IODispatchSource_SetEnableWithCompletion_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODispatchSource_SetEnableWithCompletion_Msg *message;
    IODispatchSource_SetEnableWithCompletion_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10124 */
union IODispatchSource_SetEnable_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IODispatchSource_SetEnable_Msg *message;
    IODispatchSource_SetEnable_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10125 */
union IOMemoryMap__CopyState_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOMemoryMap__CopyState_Msg *message;
    IOMemoryMap__CopyState_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10126 */
union IOBufferMemoryDescriptor_Create_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOBufferMemoryDescriptor_Create_Msg *message;
    IOBufferMemoryDescriptor_Create_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10127 */
union IOBufferMemoryDescriptor_SetLength_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOBufferMemoryDescriptor_SetLength_Msg *message;
    IOBufferMemoryDescriptor_SetLength_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10128 */
union IOMemoryDescriptor_CreateWithMemoryDescriptors_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOMemoryDescriptor_CreateWithMemoryDescriptors_Msg *message;
    IOMemoryDescriptor_CreateWithMemoryDescriptors_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10129 */
union IOMemoryDescriptor_CreateSubMemoryDescriptor_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOMemoryDescriptor_CreateSubMemoryDescriptor_Msg *message;
    IOMemoryDescriptor_CreateSubMemoryDescriptor_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10130 */
union IOMemoryDescriptor_CreateMapping_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOMemoryDescriptor_CreateMapping_Msg *message;
    IOMemoryDescriptor_CreateMapping_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10131 */
union IOMemoryDescriptor__CopyState_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOMemoryDescriptor__CopyState_Msg *message;
    IOMemoryDescriptor__CopyState_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10132 */
union IOUserClient_CopyClientMemoryForType_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOUserClient_CopyClientMemoryForType_Msg *message;
    IOUserClient_CopyClientMemoryForType_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10133 */
union IOUserClient__ExternalMethod_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOUserClient__ExternalMethod_Msg *message;
    IOUserClient__ExternalMethod_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10134 */
union IOUserClient_AsyncCompletion_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOUserClient_AsyncCompletion_Msg *message;
    IOUserClient_AsyncCompletion_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10135 */
union IOUserClient_CopyClientEntitlements_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOUserClient_CopyClientEntitlements_Msg *message;
    IOUserClient_CopyClientEntitlements_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10136 */
union IOUserClient_CreateMemoryDescriptorFromClient_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOUserClient_CreateMemoryDescriptorFromClient_Msg *message;
    IOUserClient_CreateMemoryDescriptorFromClient_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10137 */
union IOService_StateNotificationItemSet_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_StateNotificationItemSet_Msg *message;
    IOService_StateNotificationItemSet_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10138 */
union IOService_StateNotificationItemCreate_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_StateNotificationItemCreate_Msg *message;
    IOService_StateNotificationItemCreate_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10139 */
union IOService__ClaimSystemWakeEvent_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService__ClaimSystemWakeEvent_Msg *message;
    IOService__ClaimSystemWakeEvent_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10140 */
union IOService_UpdateReport_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_UpdateReport_Msg *message;
    IOService_UpdateReport_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10141 */
union IOService_CoreAnalyticsSendEvent_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_CoreAnalyticsSendEvent_Msg *message;
    IOService_CoreAnalyticsSendEvent_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10142 */
union IOService_SetProperties_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_SetProperties_Msg *message;
    IOService_SetProperties_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10143 */
union IOService_CopyProperties_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_CopyProperties_Msg *message;
    IOService_CopyProperties_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10144 */
union IOService_StringFromReturn_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_StringFromReturn_Msg *message;
    IOService_StringFromReturn_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10145 */
union IOService_SearchProperty_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_SearchProperty_Msg *message;
    IOService_SearchProperty_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10146 */
union IOService_ChangePowerState_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_ChangePowerState_Msg *message;
    IOService_ChangePowerState_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10147 */
union IOService_Stop_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_Stop_Msg *message;
    IOService_Stop_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10148 */
union IOService_CopyProviderProperties_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_CopyProviderProperties_Msg *message;
    IOService_CopyProviderProperties_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10149 */
union IOService_CreateDefaultDispatchQueue_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_CreateDefaultDispatchQueue_Msg *message;
    IOService_CreateDefaultDispatchQueue_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10150 */
union IOService_CopyName_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_CopyName_Msg *message;
    IOService_CopyName_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10151 */
union IOService_Terminate_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_Terminate_Msg *message;
    IOService_Terminate_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10152 */
union IOService_Create_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_Create_Msg *message;
    IOService_Create_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10153 */
union IOService_CopySystemStateNotificationService_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_CopySystemStateNotificationService_Msg *message;
    IOService_CopySystemStateNotificationService_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10154 */
union IOService_GetRegistryEntryID_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_GetRegistryEntryID_Msg *message;
    IOService_GetRegistryEntryID_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10155 */
union IOService_GetBusyState_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_GetBusyState_Msg *message;
    IOService_GetBusyState_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10156 */
union IOService_SendIOMessageServicePropertyChange_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_SendIOMessageServicePropertyChange_Msg *message;
    IOService_SendIOMessageServicePropertyChange_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10157 */
union IOService_Start_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_Start_Msg *message;
    IOService_Start_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10158 */
union IOService_Stop_async_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_Stop_async_Msg *message;
    IOService_Stop_async_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10159 */
union IOService_RemoveProperty_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_RemoveProperty_Msg *message;
    IOService_RemoveProperty_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10160 */
union IOService_NewUserClient_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_NewUserClient_Msg *message;
    IOService_NewUserClient_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10161 */
union IOService_UserSetProperties_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_UserSetProperties_Msg *message;
    IOService_UserSetProperties_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10162 */
union IOService_AdjustBusy_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_AdjustBusy_Msg *message;
    IOService_AdjustBusy_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10163 */
union IOService_ConfigureReport_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_ConfigureReport_Msg *message;
    IOService_ConfigureReport_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10164 */
union IOService_JoinPMTree_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_JoinPMTree_Msg *message;
    IOService_JoinPMTree_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10165 */
union IOService_SetLegend_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_SetLegend_Msg *message;
    IOService_SetLegend_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10166 */
union IOService_SetPowerState_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_SetPowerState_Msg *message;
    IOService_SetPowerState_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10167 */
union IOService__NewUserClient_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService__NewUserClient_Msg *message;
    IOService__NewUserClient_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10168 */
union IOService_SetName_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_SetName_Msg *message;
    IOService_SetName_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10169 */
union IOService_RequireMaxBusStall_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_RequireMaxBusStall_Msg *message;
    IOService_RequireMaxBusStall_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10170 */
union IOService_RegisterService_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_RegisterService_Msg *message;
    IOService_RegisterService_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10171 */
union IOService_ClientCrashed_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_ClientCrashed_Msg *message;
    IOService_ClientCrashed_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10172 */
union IOService_StateNotificationItemCopy_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const IOService_StateNotificationItemCopy_Msg *message;
    IOService_StateNotificationItemCopy_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10173 */
union OSAction_CreateWithTypeName_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const OSAction_CreateWithTypeName_Msg *message;
    OSAction_CreateWithTypeName_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10174 */
union OSAction_Create_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const OSAction_Create_Msg *message;
    OSAction_Create_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10175 */
union OSAction_Aborted_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const OSAction_Aborted_Msg *message;
    OSAction_Aborted_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10176 */
union OSObject_CopyDispatchQueue_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const OSObject_CopyDispatchQueue_Msg *message;
    OSObject_CopyDispatchQueue_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10177 */
union OSObject_SetDispatchQueue_Invocation
{
  const IORPC_0 rpc;
  struct
  {
    const OSObject_SetDispatchQueue_Msg *message;
    OSObject_SetDispatchQueue_Rpl *reply;
    uint32_t sendSize;
    uint32_t replySize;
  };
};

/* 10178 */
struct _img4_object_spec;

/* 10179 */
struct __attribute__((aligned(8))) ccdigest_state_1
{
  uint8_t state[1];
};

/* 10180 */
typedef z_stream_s_0 z_stream_0;

/* 10181 */
typedef internal_state_1 deflate_state_0;

/* 10182 */
union os_log_fmt_types_u
{
  uint16_t u16;
  uint32_t u32;
  uint64_t u64;
  char ch;
  short s;
  int i;
  void *p;
  char *pch;
  size_t z;
  intmax_t im;
  ptrdiff_t pd;
  long l;
  __int64 ll;
};

/* 10183 */
typedef os_log_fmt_cmd_s *os_log_fmt_cmd_t;

/* 10184 */
struct __attribute__((aligned(16))) os_log_context_s_0
{
  logmem_t *ctx_logmem;
  uint8_t *ctx_buffer;
  size_t ctx_buffer_sz;
  os_log_fmt_hdr_t ctx_hdr;
  char *ctx_pubdata[32];
  uint16_t ctx_content_off;
  uint16_t ctx_content_sz;
  uint16_t ctx_pubdata_sz;
  uint16_t ctx_pubdata_cnt;
};

/* 10185 */
struct kmem_return_t
{
  kern_return_t kmr_return;
  union
  {
    vm_address_t kmr_address;
    vm_size_t_0 kmr_size;
    void *kmr_ptr;
    vm_map_t_0 kmr_submap;
  };
};

/* 10186 */
enum OSKextVersionStage : __int32
{
  kOSKextVersionStageInvalid = 0x0,
  kOSKextVersionStageDevelopment = 0x1,
  kOSKextVersionStageAlpha = 0x3,
  kOSKextVersionStageBeta = 0x5,
  kOSKextVersionStageCandidate = 0x7,
  kOSKextVersionStageRelease = 0x9,
};

/* 10187 */
struct pqueue_entry_traits<priority_queue_sched_stable_max *,priority_queue_entry_stable *>
{
  _BYTE gap0;
};

/* 10188 */
struct pqueue_entry_traits<priority_queue_deadline_min *,priority_queue_entry_deadline *>
{
  _BYTE gap0;
};

/* 10189 */
struct pqueue_entry_traits<priority_queue_sched_max *,priority_queue_entry_sched *>
{
  _BYTE gap0;
};

/* 10190 */
struct pqueue<priority_queue_deadline_min *,priority_queue_entry_deadline *>
{
  _BYTE gap0;
};

/* 10191 */
struct pqueue<priority_queue_sched_max *,priority_queue_entry_sched *>
{
  _BYTE gap0;
};

/* 10192 */
struct pqueue<priority_queue_sched_stable_max *,priority_queue_entry_stable *>
{
  _BYTE gap0;
};

/* 10193 */
typedef OSSharedPtr<OSSerializer> OSPtr<OSSerializer>;

/* 10194 */
struct __attribute__((packed)) __attribute__((aligned(1))) __block_literal_7_1
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(const OSSymbol_0 *, OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  OSArray_0 *kextIdentifiers;
  OSArray_0 *infoKeys;
  OSSharedPtr<OSDictionary> result;
  uint32_t idCount;
  bool onlyLoaded;
};

/* 10195 */
struct __attribute__((packed)) __attribute__((aligned(2))) __block_literal_4_6
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(const OSSymbol_0 *, OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  OSArray_0 *infoKeys;
  OSSharedPtr<OSDictionary> result;
  kc_kind_t_0 kc_request_kind;
  bool onlyLoaded;
  bool onlyUnloaded;
};

/* 10196 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_6_3
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(const OSSymbol_0 *, OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  OSArray_0 *kextIdentifiers;
  OSArray_0 *infoKeys;
  OSSharedPtr<OSArray> result;
  uint32_t idCount;
};

/* 10197 */
struct __attribute__((packed)) __attribute__((aligned(1))) __block_literal_5_6
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(const OSSymbol_0 *, OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  OSArray_0 *kextIdentifiers;
  OSArray_0 *infoKeys;
  OSSharedPtr<OSArray> result;
  uint32_t idCount;
  bool getActive;
  bool getUnloaded;
  bool getLoaded;
};

/* 10198 */
struct __block_literal_3_5
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(OSObject_0 *);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(1))) {void *__isa;void *__forwarding;int __flags;int __size;bool result;}; *result;
  const OSSymbol_0 *depID;
};

/* 10199 */
struct __block_literal_1_9
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(const OSSymbol_0 *, OSObject_0 *);
  __block_descriptor *__descriptor;
};

/* 10200 */
typedef firehose_trace_uuid_info_s *firehose_trace_uuid_info_t;

/* 10201 */
typedef vm_region_submap_short_info_64 vm_region_submap_short_info_data_64_t;

/* 10202 */
typedef OSSharedPtr<OSValueObject<void *> > OSPtr<OSValueObject<void *> >;

/* 10203 */
typedef OSSharedPtr<OSValueObject<void (*)(unsigned int,int,const void *,unsigned int,void *)> > OSPtr<OSValueObject<void (*)(unsigned int,int,const void *,unsigned int,void *)> >;

/* 10204 */
typedef OSSharedPtr<OSDextCrash> OSPtr<OSDextCrash>;

/* 10205 */
typedef OSSharedPtr<OSKextSavedMutableSegment> OSPtr<OSKextSavedMutableSegment>;

/* 10206 */
typedef OSCollectionIterator_0 *libkern::intrusive_shared_ptr<OSCollectionIterator,intrusive_osobject_retainer>::pointer_0;

/* 10207 */
struct __attribute__((aligned(8))) ExpansionData_0
{
  OSOrderedSet_0 *instances;
  OSKext_0 *kext;
  uint32_t retain;
};

/* 10208 */
typedef OSSerialize_0 *OSPtr<OSSerialize>;

/* 10209 */
typedef OSObject_0 *io_object_t_3;

/* 10210 */
struct __attribute__((aligned(8))) OSAction_IVars_0
{
  OSObject_0 *target;
  uint64_t targetmsgid;
  uint64_t msgid;
  IOUserServer *userServer;
  OSActionAbortedHandler abortedHandler;
  OSString_0 *typeName;
  void *reference;
  size_t referenceSize;
  bool aborted;
};

/* 10211 */
typedef lck_rw_t IORWLock_1;

/* 10212 */
typedef struct *IOStateNotificationHandler_0;

/* 10213 */
struct intrusive_tagged_osobject_retainer<OSCollection>
{
  _BYTE gap0;
};

/* 10214 */
struct _Element_0
{
  OSTaggedPtr<const OSMetaClassBase>_1 obj;
};

/* 10215 */
typedef void (*OSObjectApplierFunction_2)(OSObject_0 *, void *);

/* 10216 */
typedef struct *IOServiceApplierBlock_0;

/* 10217 */
typedef void (*IOServiceApplierFunction_1)(IOService_0 *, void *);

/* 10218 */
typedef struct *IOServiceInterestHandlerBlock_0;

/* 10219 */
typedef IOReturn_0 (*IOServiceInterestHandler_2)(void *, void *, UInt32, IOService_0 *, void *, vm_size_t_0);

/* 10220 */
typedef struct *IOInterruptActionBlock_0;

/* 10221 */
struct OSSharedPtr<IODeviceMemory>;

/* 10222 */
typedef void OSPtr<IODeviceMemory>;

/* 10223 */
struct __cppobj IODeviceMemory::MetaClass_0 : OSMetaClass_0
{
};

/* 10224 */
struct __cppobj __attribute__((aligned(8))) IODeviceMemory_1 : IOMemoryDescriptor_0
{
};

/* 10225 */
typedef IORangeAllocator_0 *OSPtr<IORangeAllocator>;

/* 10226 */
struct IORangeAllocatorElement_0
{
  IORangeScalar_0 start;
  IORangeScalar_0 end;
};

/* 10227 */
struct vnode_resolve_2
{
  lck_mtx_t vr_lock;
  trigger_vnode_resolve_callback_t_2 vr_resolve_func;
  trigger_vnode_unresolve_callback_t vr_unresolve_func;
  trigger_vnode_rearm_callback_t vr_rearm_func;
  trigger_vnode_reclaim_callback_t vr_reclaim_func;
  void *vr_data;
  uint32_t vr_flags;
  uint32_t vr_lastseq;
};

/* 10228 */
struct ucred_0
{
  struct
  {
    ucred *le_next;
    ucred **le_prev;
  } cr_link;
  u_long cr_ref;
  ucred::posix_cred cr_posix;
  __attribute__((aligned(16))) au_session cr_audit;
};

/* 10229 */
struct proc_ro_0
{
  proc *pr_proc;
  task *pr_task;
  union
  {
    struct __attribute__((aligned(8)))
    {
      uint64_t p_uniqueid;
      int p_idversion;
      uint32_t p_csflags;
      ucred *p_ucred;
      uint8_t *syscall_filter_mask;
      proc_platform_ro_data p_platform_data;
    };
    proc_ro::proc_ro_data proc_data;
  };
  union
  {
    struct
    {
      task_token_ro_data task_tokens;
      task_filter_ro_data task_filters;
      uint32_t t_flags_ro;
      uint32_t task_control_port_options;
    };
    proc_ro::task_ro_data task_data;
  };
};

/* 10230 */
struct proc_1
{
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_list;
  _BYTE gap10[8];
  proc_ro_t p_proc_ro;
  pid_t p_ppid;
  pid_t p_original_ppid;
  pid_t p_pgrpid;
  uid_t p_uid;
  gid_t p_gid;
  uid_t p_ruid;
  gid_t p_rgid;
  uid_t p_svuid;
  gid_t p_svgid;
  pid_t p_sessionid;
  uint64_t p_puniqueid;
  lck_mtx_t p_mlock;
  pid_t p_pid;
  char p_stat;
  char p_shutdownstate;
  char p_kdebug;
  char p_btrace;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_pglist;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_sibling;
  struct
  {
    proc *lh_first;
  } p_children;
  struct
  {
    uthread *tqh_first;
    uthread **tqh_last;
  } p_uthlist;
  smrq_slink p_hash;
  persona *p_persona;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_persona_list;
  lck_mtx_t p_ucred_mlock;
  filedesc p_fd;
  pstats *p_stats;
  struct
  {
    plimit *volatile __smr_ptr;
  } p_limit;
  struct
  {
    _BYTE gap0[8];
  } p_pgrp;
  sigacts p_sigacts;
  lck_spin_t p_slock;
  int p_siglist;
  unsigned int p_flag;
  unsigned int p_lflag;
  unsigned int p_listflag;
  unsigned int p_ladvflag;
  os_ref_atomic_t p_refcount;
  os_ref_atomic_t p_waitref;
  int p_childrencnt;
  int p_parentref;
  pid_t p_oppid;
  u_int p_xstat;
  int p_aio_total_count;
  itimerval p_realtimer;
  timeval p_rtime;
  itimerval p_vtimer_user;
  itimerval p_vtimer_prof;
  timeval p_rlim_cpu;
  int p_debugger;
  boolean_t sigwait;
  void *sigwait_thread;
  void *exit_thread;
  pid_t si_pid;
  u_int si_status;
  u_int si_code;
  uid_t si_uid;
  void *vm_shm;
  int p_ractive;
  pid_t p_responsible_pid;
  int p_dtrace_probes;
  u_int p_dtrace_count;
  uint8_t p_dtrace_stop;
  user_addr_t_0 p_dtrace_argv;
  user_addr_t_0 p_dtrace_envp;
  lck_mtx_t p_dtrace_sprlock;
  dtrace_ptss_page *p_dtrace_ptss_pages;
  dtrace_ptss_page_entry *p_dtrace_ptss_free_list;
  dtrace_helpers *p_dtrace_helpers;
  dof_ioctl_data *p_dtrace_lazy_dofs;
  union
  {
    struct __attribute__((aligned(8)))
    {
      u_int p_argslen;
      int p_argc;
      user_addr_t_0 user_stack;
      _BYTE gap10[8];
      off_t p_textoff;
      sigset_t p_sigmask;
      sigset_t p_sigignore;
      sigset_t p_sigcatch;
      u_char p_priority;
      u_char p_resv0;
      char p_nice;
      u_char p_resv1;
      command_t p_comm;
      proc_name_t p_name;
      uint8_t p_xhighbits;
      pid_t p_contproc;
      uint32_t p_pcaction;
      uint8_t p_uuid[16];
      cpu_type_t p_cputype;
      cpu_subtype_t_0 p_cpusubtype;
    };
    proc::proc_forkcopy_data p_forkcopy;
  };
  struct
  {
    aio_workq_entry *tqh_first;
    aio_workq_entry **tqh_last;
  } p_aio_activeq;
  struct
  {
    aio_workq_entry *tqh_first;
    aio_workq_entry **tqh_last;
  } p_aio_doneq;
  klist p_klist;
  rusage_superset *p_ru;
  thread_t_0 p_signalholder;
  thread_t_0 p_transholder;
  int p_sigwaitcnt;
  u_short p_acflag;
  volatile u_short p_vfs_iopolicy;
  user_addr_t_0 p_threadstart;
  user_addr_t_0 p_wqthread;
  int p_pthsize;
  uint32_t p_pth_tsd_offset;
  user_addr_t_0 p_stack_addr_hint;
  workqueue *p_wqptr;
  timeval p_start;
  void *p_rcall;
  void *p_pthhash;
  volatile uint64_t was_throttled;
  volatile uint64_t did_throttle;
  uint64_t p_dispatchqueue_offset;
  uint64_t p_dispatchqueue_serialno_offset;
  uint64_t p_dispatchqueue_label_offset;
  uint64_t p_return_to_kernel_offset;
  uint64_t p_mach_thread_self_offset;
  uint64_t p_pthread_wq_quantum_offset;
  timeval vm_pressure_last_notify_tstamp;
  uint8_t p_crash_behavior;
  bool p_posix_spawn_failed;
  bool p_disallow_map_with_linking;
  uint32_t p_memstat_state;
  int32_t p_memstat_effectivepriority;
  int32_t p_memstat_requestedpriority;
  int32_t p_memstat_assertionpriority;
  uint32_t p_memstat_dirty;
  struct
  {
    proc *tqe_next;
    proc **tqe_prev;
  } p_memstat_list;
  uint64_t p_memstat_userdata;
  uint64_t p_memstat_idledeadline;
  uint64_t p_memstat_idle_start;
  uint64_t p_memstat_idle_delta;
  int32_t p_memstat_memlimit;
  int32_t p_memstat_memlimit_active;
  int32_t p_memstat_memlimit_inactive;
  int32_t p_memstat_relaunch_flags;
  uint32_t p_user_faults;
  uint32_t p_memlimit_increase;
  uint64_t p_crash_behavior_deadline;
  uint32_t p_crash_count;
  uint32_t p_throttle_timeout;
  os_reason *p_exit_reason;
  uint64_t p_user_data;
  char *p_subsystem_root_path;
};

/* 10231 */
struct knote_0
{
  struct
  {
    knote *tqe_next;
    knote **tqe_prev;
  } kn_tqe;
  struct
  {
    knote *sle_next;
  } kn_link;
  struct
  {
    knote *sle_next;
  } kn_selnext;
  _BYTE gap20[8];
  union
  {
    void *kn_hook;
    uint32_t kn_hook32;
  };
  union
  {
    fileproc *kn_fp;
    proc *kn_proc;
    ipc_object *kn_ipc_obj;
    thread_call *kn_thcall;
    thread *kn_thread;
  };
  knote::kevent_internal_s kn_kevent;
};

/* 10232 */
struct vnode_1
{
  lck_mtx_t v_lock;
  struct
  {
    vnode *tqe_next;
    vnode **tqe_prev;
  } v_freelist;
  struct
  {
    vnode *tqe_next;
    vnode **tqe_prev;
  } v_mntvnodes;
  struct
  {
    namecache *tqh_first;
    namecache **tqh_last;
  } v_ncchildren;
  struct
  {
    namecache *lh_first;
  } v_nclinks;
  vnode_t v_defer_reclaimlist;
  uint32_t v_listflag;
  uint32_t v_flag;
  uint16_t v_lflag;
  uint8_t v_iterblkflags;
  uint8_t v_references;
  int32_t v_kusecount;
  int32_t v_usecount;
  int32_t v_iocount;
  _BYTE gap68[8];
  uint16_t v_type;
  uint16_t v_tag;
  uint32_t v_id;
  _BYTE gap78[8];
  buflists v_cleanblkhd;
  buflists v_dirtyblkhd;
  klist v_knotes;
  _BYTE gap98[8];
  kauth_action_t v_authorized_actions;
  int v_cred_timestamp;
  int v_nc_generation;
  int32_t v_numoutput;
  int32_t v_writecount;
  uint32_t v_holdcount;
  const char *v_name;
  _BYTE gapC0[8];
  lockf *v_lockf;
  int (**v_op)(void *);
  _BYTE gapD8[8];
  void *v_data;
  label *v_label;
  vnode_resolve_t v_resolve;
  vnode_t v_fmlink;
  vnode::fl_head v_leases;
};

/* 10233 */
typedef OSSharedPtr<PMTraceWorker> OSPtr<PMTraceWorker>_0;

/* 10234 */
typedef IOWorkLoop_0 *OSPtr<IOWorkLoop>;

/* 10235 */
enum IOWorkLoop::maintCommandEnum : __int32
{
  mAddEvent = 0x0,
  mRemoveEvent = 0x1,
};

/* 10236 */
typedef OSCollectionIterator_0 *OSPtr<OSCollectionIterator>;

/* 10237 */
typedef OSBoolean_0 *OSPtr<OSBoolean>;

/* 10238 */
typedef OSKext_0 *OSPtr<OSKext>;

/* 10239 */
enum OSDextCrashPolicy : __int32
{
  kOSDextCrashPolicyNone = 0x0,
  kOSDextCrashPolicyReboot = 0x1,
};

/* 10240 */
struct OSKextAccount_0
{
  vm_allocation_site_t site;
  uint32_t loadTag;
  OSKext_0 *kext;
};

/* 10241 */
struct kmod_reference_1
{
  kmod_reference_0 *next;
  kmod_info_0 *info;
};

/* 10242 */
typedef kmod_reference_0 kmod_reference_t_1;

/* 10243 */
struct __attribute__((packed)) __attribute__((aligned(4))) kmod_info_2
{
  kmod_info_0 *next;
  int32_t info_version;
  uint32_t id;
  char name[64];
  char version[64];
  int32_t reference_count;
  kmod_reference_t_0 *reference_list;
  vm_address_t address;
  vm_size_t_0 size;
  vm_size_t_0 hdr_size;
  kmod_start_func_t_0 *start;
  kmod_stop_func_t_0 *stop;
};

/* 10244 */
typedef kmod_info_0 kmod_info_t_1;

/* 10245 */
typedef OSNumber_0 *OSPtr<OSNumber>_0;

/* 10246 */
typedef OSSharedPtr<IOService> OSPtr<IOService>_0;

/* 10247 */
typedef struct *IOServiceMatchingNotificationHandlerBlock_0;

/* 10248 */
struct __cppobj IONotifier::MetaClass_0 : OSMetaClass_0
{
};

/* 10249 */
struct __cppobj __attribute__((aligned(8))) IONotifier_1 : OSObject_1
{
};

/* 10250 */
typedef OSSharedPtr<IONotifier> OSPtr<IONotifier>_0;

/* 10251 */
typedef void (*IOInterruptAction_2)(OSObject_0 *, void *, IOService_0 *, int);

/* 10252 */
typedef IOInterruptVector_0 IOInterruptVector_1;

/* 10253 */
typedef IOInterruptSource_0 IOInterruptSource_1;

/* 10254 */
struct os_detail::IOKit_typed_allocator<unsigned int,true>
{
  _BYTE gap0;
};

/* 10255 */
struct os_detail::panic_trapping_policy
{
  _BYTE gap0;
};

/* 10256 */
struct OSObjectUserVars_0
{
  IOUserServer *userServer;
  OSBoundedArrayRef<IODispatchQueue *> queueArray;
  OSUserMetaClass *userMeta;
  OSArray_0 *openProviders;
  IOService_0 *controllingDriver;
  unsigned __int64 willPowerState;
  bool willTerminate;
  bool didTerminate;
  bool serverDied;
  bool started;
  bool stopped;
  bool userServerPM;
  bool willPower;
  bool powerState;
  bool resetPowerOnWake;
  bool deferredRegisterService;
  uint32_t powerOverride;
  IOLock_0 *uvarsLock;
};

/* 10257 */
struct IOInterruptAccountingData_0
{
  OSObject_0 *owner;
  queue_chain_t_0 chain;
  int interruptIndex;
  bool enablePrimaryTimestamp;
  volatile uint64_t primaryTimestamp;
  volatile uint64_t interruptStatistics[10];
};

/* 10258 */
typedef IOSimpleReporter *OSPtr<IOSimpleReporter>;

/* 10259 */
typedef IOVirtualRange_0 IOAddressRange_1;

/* 10260 */
typedef IODMACommand_0 *OSPtr<IODMACommand>;

/* 10261 */
struct IODMACommandInternal_0
{
  IOMDDMAWalkSegmentState fState;
  IOMDDMACharacteristics fMDSummary;
  UInt64 fPreparedOffset;
  UInt64 fPreparedLength;
  UInt32 fSourceAlignMask;
  UInt8 fCursor;
  UInt8 fCheckAddressing;
  UInt8 fIterateOnly;
  UInt8 fMisaligned;
  UInt8 fPrepared;
  UInt8 fDoubleBuffer;
  UInt8 fNewMD;
  UInt8 fLocalMapperAllocValid;
  UInt8 fIOVMAddrValid;
  UInt8 fForceDoubleBuffer;
  UInt8 fSetActiveNoMapper;
  vm_page_t fCopyPageAlloc;
  vm_page_t fCopyNext;
  vm_page_t fNextRemapPage;
  ppnum_t_0 fCopyPageCount;
  uint64_t fLocalMapperAlloc;
  uint64_t fLocalMapperAllocLength;
  OSPtr<IOBufferMemoryDescriptor> fCopyMD;
  IOService_0 *fDevice;
  IOLock_0 *fDextLock;
  IOReturn_0 fStatus;
  UInt64 fActualByteCount;
  AbsoluteTime_0 fTimeStamp;
  IODMACommandMapSegment *fMapSegments;
  uint32_t fMapSegmentsCount;
  uint64_t fLocalMapperAllocBase;
  uint64_t fOffset2Index;
  uint64_t fNextOffset;
  uint64_t fIndex;
};

/* 10262 */
struct queue_entry_1
{
  queue_entry_0 *next;
  queue_entry_0 *prev;
};

/* 10263 */
typedef queue_entry_0 queue_chain_t_1;

/* 10264 */
enum IODMACommand::SynchronizeOptions : __int32
{
  IODMACommand::SynchronizeOptions::kForceDoubleBuffer = 0x1000000,
};

/* 10265 */
struct IODMAMapSpecification_1
{
  uint64_t alignment;
  IOService_0 *device;
  uint32_t options;
  uint8_t numAddressBits;
  uint8_t resvA[3];
  uint32_t resvB[4];
};

/* 10266 */
enum IOMapper::SystemMapperState : __int32
{
  IOMapper::SystemMapperState::kNoMapper = 0x0,
  IOMapper::SystemMapperState::kUnknown = 0x1,
  IOMapper::SystemMapperState::kHasMapper = 0x2,
  IOMapper::SystemMapperState::kWaitMask = 0x3,
};

/* 10267 */
struct __cppobj IOMemoryMap::MetaClass_0 : OSMetaClass_0
{
};

/* 10268 */
typedef kern_return_t (*OSDispatchMethod_1)(OSMetaClassBase_0 *, const IORPC_0);

/* 10269 */
struct IOMemoryDescriptorReserved_0
{
  IOMemoryDescriptorDevicePager dp;
  uint64_t descriptorID;
  uint64_t preparationID;
  uint64_t kernReserved[4];
  vm_tag_t kernelTag;
  vm_tag_t userTag;
  task_t_0 creator;
  OSObject_0 *contextObject;
};

/* 10270 */
struct __cppobj IOMemoryDescriptor::MetaClass_0 : OSMetaClass_0
{
};

/* 10271 */
struct IOReportChannelList_1
{
  uint32_t nchannels;
  IOReportChannel channels[];
};

/* 10272 */
struct OSSharedPtr<const IORegistryPlane>;

/* 10273 */
typedef void OSPtr<const IORegistryPlane>;

/* 10274 */
typedef void (*IORegistryEntryApplierFunction_1)(IORegistryEntry_0 *, void *);

/* 10275 */
typedef OSSharedPtr<OSIterator> OSPtr<OSIterator>;

/* 10276 */
typedef OSSharedPtr<IORegistryEntry> OSPtr<IORegistryEntry>;

/* 10277 */
typedef OSTaggedPtr<const OSMetaClassBase> OSArray::ArrayPtrType_1;

/* 10278 */
struct intrusive_osobject_retainer
{
  _BYTE gap0;
};

/* 10279 */
struct libkern::bounded_ptr<const unsigned int,os_detail::panic_trapping_policy>;

/* 10280 */
typedef void libkern::safe_allocation<unsigned int,os_detail::IOKit_typed_allocator<unsigned int,true>,os_detail::panic_trapping_policy>::const_iterator;

/* 10281 */
typedef libkern::bounded_ptr<unsigned int,os_detail::panic_trapping_policy> libkern::safe_allocation<unsigned int,os_detail::IOKit_typed_allocator<unsigned int,true>,os_detail::panic_trapping_policy>::iterator;

/* 10282 */
typedef OSData_0 *libkern::intrusive_shared_ptr<OSData,intrusive_osobject_retainer>::pointer_0;

/* 10283 */
struct libkern::detail::copy_cv<unsigned int,char>
{
  _BYTE gap0;
};

/* 10284 */
struct libkern::detail::copy_cv<IODispatchQueue *,char>
{
  _BYTE gap0;
};

/* 10285 */
typedef libkern::bounded_ptr<IODispatchQueue *,os_detail::panic_trapping_policy> libkern::bounded_array_ref<IODispatchQueue *,os_detail::panic_trapping_policy>::iterator;

/* 10286 */
typedef IOMemoryMap_0 *libkern::intrusive_shared_ptr<IOMemoryMap,intrusive_osobject_retainer>::pointer_0;

/* 10287 */
typedef IOMemoryDescriptor_0 *libkern::intrusive_shared_ptr<IOMemoryDescriptor,intrusive_osobject_retainer>::pointer_0;

/* 10288 */
typedef OSSet_0 *libkern::intrusive_shared_ptr<OSSet,intrusive_osobject_retainer>::pointer_0;

/* 10289 */
typedef OSString_0 *libkern::intrusive_shared_ptr<OSString,intrusive_osobject_retainer>::pointer_0;

/* 10290 */
typedef OSArray_0 *libkern::intrusive_shared_ptr<OSArray,intrusive_osobject_retainer>::pointer_0;

/* 10291 */
typedef OSDictionary_0 *libkern::intrusive_shared_ptr<OSDictionary,intrusive_osobject_retainer>::pointer_0;

/* 10292 */
typedef OSObject_0 *libkern::intrusive_shared_ptr<OSObject,intrusive_osobject_retainer>::pointer_1;

/* 10293 */
typedef const OSSymbol_0 *libkern::intrusive_shared_ptr<const OSSymbol,intrusive_osobject_retainer>::pointer_0;

/* 10294 */
enum OSData::ValueAcquisition : __int32
{
  OSData::ValueAcquisition::kValueCopy = 0x0,
  OSData::ValueAcquisition::kValueNoCopy = 0x1,
};

/* 10295 */
struct __attribute__((aligned(8))) OSData::ExpansionData_1
{
  OSData::DeallocFunction_1 deallocFunction;
  bool disableSerialization;
};

/* 10296 */
typedef OSCollection_0 *OSPtr<OSCollection>;

/* 10297 */
typedef struct *IORegistryEntry::ActionBlock_0;

/* 10298 */
typedef IOReturn_0 (*IORegistryEntry::Action_2)(OSObject_0 *, void *, void *, void *, void *);

/* 10299 */
struct IORegistryEntry::ExpansionData_0
{
  IORecursiveLock_0 *fLock;
  uint64_t fRegistryEntryID;
  SInt32 fRegistryEntryGenerationCount;
  OSObject_0 **fIndexedProperties;
};

/* 10300 */
struct __cppobj IORegistryEntry::MetaClass_0 : OSMetaClass_0
{
};

/* 10301 */
struct __cppobj IOService::MetaClass_0 : OSMetaClass_0
{
};

/* 10302 */
struct mach_msg_body_t_1
{
  mach_msg_size_t msgh_descriptor_count;
};

/* 10303 */
typedef IORPCMessageMach_0 IORPCMessageMach_1;

/* 10304 */
typedef const OSMetaClassBase_0 *(*OSSerialize::Editor_2)(void *, OSSerialize_0 *, OSCollection_0 *, const OSSymbol_0 *, const OSMetaClassBase_0 *);

/* 10305 */
typedef lck_mtx_t IOLock_1;

/* 10306 */
typedef devsw_lock *devsw_lock_t;

/* 10307 */
struct uthread_0
{
  u_int64_t uu_arg[8];
  int uu_rval[2];
  char uu_cursig;
  bool uu_workq_pthread_kill_allowed;
  uint16_t syscall_code;
  int uu_exception;
  mach_exception_code_t uu_code;
  mach_exception_subcode_t uu_subcode;
  union
  {
    _select_data uus_select_data;
    kevent_ctx_s uus_kevent;
    _kevent_register uus_kevent_register;
    _kauth uus_kauth;
    ksyn_waitq_element uus_kwe;
    _waitid_data uus_waitid_data;
    _wait4_data uus_wait4_data;
    _workq_park_data uus_workq_park_data;
    _ulock_wait_data uus_ulock_wait_data;
    _bsdthread_terminate_0 uus_bsdthread_terminate;
    _exec_data uus_exec_data;
  } uu_save;
  _select uu_select;
  void *uu_userstate;
  select_set *uu_selset;
  int uu_flag;
  sigset_t uu_siglist;
  sigset_t uu_sigwait;
  sigset_t uu_sigmask;
  sigset_t uu_oldmask;
  user_addr_t_0 uu_sigreturn_token;
  uint32_t uu_sigreturn_diversifier;
  int uu_pending_sigreturn;
  struct
  {
    uthread *tqe_next;
    uthread **tqe_prev;
  } uu_list;
  kaudit_record *uu_ar;
  task *uu_aio_task;
  union
  {
    lck_mtx_t *uu_mtx;
    knote_lock_ctx *uu_knlock;
  };
  lck_spin_t uu_rethrottle_lock;
  struct
  {
    uthread *tqe_next;
    uthread **tqe_prev;
  } uu_throttlelist;
  void *uu_throttle_info;
  int8_t uu_on_throttlelist;
  bool uu_lowpri_window;
  bool uu_was_rethrottled;
  bool uu_is_throttled;
  bool uu_throttle_bc;
  bool uu_defer_reclaims;
  uint16_t uu_pri;
  caddr_t uu_wchan;
  int (*uu_continuation)(int);
  const char *uu_wmesg;
  kern_sigaltstack uu_sigstk;
  vnode_t uu_vreclaims;
  vnode_t uu_cdir;
  int uu_dupfd;
  u_int32_t uu_network_marks;
  workq_threadreq_s *uu_kqr_bound;
  struct
  {
    uthread *tqe_next;
    uthread **tqe_prev;
  } uu_workq_entry;
  vm_offset_t_0 uu_workq_stackaddr;
  mach_port_name_t uu_workq_thport;
  uu_workq_policy uu_workq_pri;
  uint16_t uu_workq_flags;
  kq_index_t uu_kqueue_override;
  int uu_proc_refcount;
  uint32_t t_dtrace_errno;
  siginfo_t t_dtrace_siginfo;
  uint64_t t_dtrace_resumepid;
  uint8_t t_dtrace_stop;
  uint8_t t_dtrace_sig;
  __tdu _tdu;
  user_addr_t_0 t_dtrace_pc;
  user_addr_t_0 t_dtrace_npc;
  user_addr_t_0 t_dtrace_scrpc;
  user_addr_t_0 t_dtrace_astpc;
  dtrace_ptss_page_entry *t_dtrace_scratch;
  uint64_t t_dtrace_regv;
  void *t_dtrace_syscall_args;
  char *pth_name;
  doc_tombstone *t_tombstone;
  uint64_t t_fs_private;
  os_reason *uu_exit_reason;
};

/* 10308 */
struct proc_2
{
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_list;
  _BYTE gap10[8];
  proc_ro_t p_proc_ro;
  pid_t p_ppid;
  pid_t p_original_ppid;
  pid_t p_pgrpid;
  uid_t p_uid;
  gid_t p_gid;
  uid_t p_ruid;
  gid_t p_rgid;
  uid_t p_svuid;
  gid_t p_svgid;
  pid_t p_sessionid;
  uint64_t p_puniqueid;
  lck_mtx_t p_mlock;
  pid_t p_pid;
  char p_stat;
  char p_shutdownstate;
  char p_kdebug;
  char p_btrace;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_pglist;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_sibling;
  struct
  {
    proc *lh_first;
  } p_children;
  struct
  {
    uthread *tqh_first;
    uthread **tqh_last;
  } p_uthlist;
  smrq_slink p_hash;
  persona *p_persona;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_persona_list;
  lck_mtx_t p_ucred_mlock;
  filedesc p_fd;
  pstats *p_stats;
  struct
  {
    plimit *volatile __smr_ptr;
  } p_limit;
  struct
  {
    _BYTE gap0[8];
  } p_pgrp;
  sigacts p_sigacts;
  lck_spin_t p_slock;
  int p_siglist;
  unsigned int p_flag;
  unsigned int p_lflag;
  unsigned int p_listflag;
  unsigned int p_ladvflag;
  os_ref_atomic_t p_refcount;
  os_ref_atomic_t p_waitref;
  int p_childrencnt;
  int p_parentref;
  pid_t p_oppid;
  u_int p_xstat;
  int p_aio_total_count;
  itimerval p_realtimer;
  timeval p_rtime;
  itimerval p_vtimer_user;
  itimerval p_vtimer_prof;
  timeval p_rlim_cpu;
  int p_debugger;
  boolean_t sigwait;
  void *sigwait_thread;
  void *exit_thread;
  pid_t si_pid;
  u_int si_status;
  u_int si_code;
  uid_t si_uid;
  void *vm_shm;
  int p_ractive;
  pid_t p_responsible_pid;
  int p_dtrace_probes;
  u_int p_dtrace_count;
  uint8_t p_dtrace_stop;
  user_addr_t_0 p_dtrace_argv;
  user_addr_t_0 p_dtrace_envp;
  lck_mtx_t p_dtrace_sprlock;
  dtrace_ptss_page *p_dtrace_ptss_pages;
  dtrace_ptss_page_entry *p_dtrace_ptss_free_list;
  dtrace_helpers *p_dtrace_helpers;
  dof_ioctl_data *p_dtrace_lazy_dofs;
  union
  {
    struct __attribute__((aligned(8)))
    {
      u_int p_argslen;
      int p_argc;
      user_addr_t_0 user_stack;
      _BYTE gap10[8];
      off_t p_textoff;
      sigset_t p_sigmask;
      sigset_t p_sigignore;
      sigset_t p_sigcatch;
      u_char p_priority;
      u_char p_resv0;
      char p_nice;
      u_char p_resv1;
      command_t p_comm;
      proc_name_t p_name;
      uint8_t p_xhighbits;
      pid_t p_contproc;
      uint32_t p_pcaction;
      uint8_t p_uuid[16];
      cpu_type_t p_cputype;
      cpu_subtype_t_0 p_cpusubtype;
    };
    proc_forkcopy_data p_forkcopy;
  };
  struct
  {
    aio_workq_entry *tqh_first;
    aio_workq_entry **tqh_last;
  } p_aio_activeq;
  struct
  {
    aio_workq_entry *tqh_first;
    aio_workq_entry **tqh_last;
  } p_aio_doneq;
  klist p_klist;
  rusage_superset *p_ru;
  thread_t_0 p_signalholder;
  thread_t_0 p_transholder;
  int p_sigwaitcnt;
  u_short p_acflag;
  volatile u_short p_vfs_iopolicy;
  user_addr_t_0 p_threadstart;
  user_addr_t_0 p_wqthread;
  int p_pthsize;
  uint32_t p_pth_tsd_offset;
  user_addr_t_0 p_stack_addr_hint;
  workqueue *p_wqptr;
  timeval p_start;
  void *p_rcall;
  void *p_pthhash;
  volatile uint64_t was_throttled;
  volatile uint64_t did_throttle;
  uint64_t p_dispatchqueue_offset;
  uint64_t p_dispatchqueue_serialno_offset;
  uint64_t p_dispatchqueue_label_offset;
  uint64_t p_return_to_kernel_offset;
  uint64_t p_mach_thread_self_offset;
  uint64_t p_pthread_wq_quantum_offset;
  timeval vm_pressure_last_notify_tstamp;
  uint8_t p_crash_behavior;
  bool p_posix_spawn_failed;
  bool p_disallow_map_with_linking;
  uint32_t p_memstat_state;
  int32_t p_memstat_effectivepriority;
  int32_t p_memstat_requestedpriority;
  int32_t p_memstat_assertionpriority;
  uint32_t p_memstat_dirty;
  struct
  {
    proc *tqe_next;
    proc **tqe_prev;
  } p_memstat_list;
  uint64_t p_memstat_userdata;
  uint64_t p_memstat_idledeadline;
  uint64_t p_memstat_idle_start;
  uint64_t p_memstat_idle_delta;
  int32_t p_memstat_memlimit;
  int32_t p_memstat_memlimit_active;
  int32_t p_memstat_memlimit_inactive;
  int32_t p_memstat_relaunch_flags;
  uint32_t p_user_faults;
  uint32_t p_memlimit_increase;
  uint64_t p_crash_behavior_deadline;
  uint32_t p_crash_count;
  uint32_t p_throttle_timeout;
  os_reason *p_exit_reason;
  uint64_t p_user_data;
  char *p_subsystem_root_path;
};

/* 10309 */
struct uthread_1
{
  u_int64_t uu_arg[8];
  int uu_rval[2];
  char uu_cursig;
  bool uu_workq_pthread_kill_allowed;
  uint16_t syscall_code;
  int uu_exception;
  mach_exception_code_t uu_code;
  mach_exception_subcode_t uu_subcode;
  union
  {
    _select_data uus_select_data;
    kevent_ctx_s uus_kevent;
    _kevent_register uus_kevent_register;
    _kauth uus_kauth;
    ksyn_waitq_element uus_kwe;
    _waitid_data uus_waitid_data;
    _wait4_data uus_wait4_data;
    _workq_park_data uus_workq_park_data;
    _ulock_wait_data uus_ulock_wait_data;
    _bsdthread_terminate_0 uus_bsdthread_terminate;
    _exec_data uus_exec_data;
  } uu_save;
  _select uu_select;
  void *uu_userstate;
  select_set *uu_selset;
  int uu_flag;
  sigset_t uu_siglist;
  sigset_t uu_sigwait;
  sigset_t uu_sigmask;
  sigset_t uu_oldmask;
  user_addr_t_0 uu_sigreturn_token;
  uint32_t uu_sigreturn_diversifier;
  int uu_pending_sigreturn;
  struct
  {
    uthread *tqe_next;
    uthread **tqe_prev;
  } uu_list;
  kaudit_record *uu_ar;
  task *uu_aio_task;
  union
  {
    lck_mtx_t *uu_mtx;
    knote_lock_ctx *uu_knlock;
  };
  lck_spin_t uu_rethrottle_lock;
  struct
  {
    uthread *tqe_next;
    uthread **tqe_prev;
  } uu_throttlelist;
  void *uu_throttle_info;
  int8_t uu_on_throttlelist;
  bool uu_lowpri_window;
  bool uu_was_rethrottled;
  bool uu_is_throttled;
  bool uu_throttle_bc;
  bool uu_defer_reclaims;
  uint16_t uu_pri;
  caddr_t uu_wchan;
  int (*uu_continuation)(int);
  const char *uu_wmesg;
  kern_sigaltstack uu_sigstk;
  vnode_t uu_vreclaims;
  vnode_t uu_cdir;
  int uu_dupfd;
  u_int32_t uu_network_marks;
  workq_threadreq_s *uu_kqr_bound;
  struct
  {
    uthread *tqe_next;
    uthread **tqe_prev;
  } uu_workq_entry;
  vm_offset_t_0 uu_workq_stackaddr;
  mach_port_name_t uu_workq_thport;
  uu_workq_policy uu_workq_pri;
  uint16_t uu_workq_flags;
  kq_index_t uu_kqueue_override;
  int uu_proc_refcount;
  uint32_t t_dtrace_errno;
  siginfo_t t_dtrace_siginfo;
  uint64_t t_dtrace_resumepid;
  uint8_t t_dtrace_stop;
  uint8_t t_dtrace_sig;
  __tdu _tdu;
  user_addr_t_0 t_dtrace_pc;
  user_addr_t_0 t_dtrace_npc;
  user_addr_t_0 t_dtrace_scrpc;
  user_addr_t_0 t_dtrace_astpc;
  dtrace_ptss_page_entry *t_dtrace_scratch;
  uint64_t t_dtrace_regv;
  void *t_dtrace_syscall_args;
  char *pth_name;
  doc_tombstone *t_tombstone;
  uint64_t t_fs_private;
  os_reason *uu_exit_reason;
};

/* 10310 */
struct lck_mtx_startup_spec_0
{
  lck_mtx_t *lck;
  lck_grp_t *lck_grp;
  lck_attr_t *lck_attr;
};

/* 10311 */
typedef host_basic_info host_basic_info_data_t;

/* 10312 */
typedef uint32_t kern_segment_idx_t;

/* 10313 */
struct llentries_0
{
  llentry *lh_first;
};

/* 10314 */
struct ifmultiaddr_0
{
  lck_mtx_t ifma_lock;
  u_int32_t ifma_refcount;
  u_int32_t ifma_anoncnt;
  u_int32_t ifma_reqcnt;
  u_int32_t ifma_debug;
  u_int32_t ifma_flags;
  struct
  {
    ifmultiaddr *le_next;
    ifmultiaddr **le_prev;
  } ifma_link;
  sockaddr *ifma_addr;
  ifmultiaddr *ifma_ll;
  ifnet *ifma_ifp;
  void *ifma_protospec;
  void (*ifma_trace)(ifmultiaddr *, int);
};

/* 10315 */
struct __attribute__((aligned(8))) ifaddr_0
{
  lck_mtx_t ifa_lock;
  uint32_t ifa_refcnt;
  uint32_t ifa_debug;
  sockaddr *ifa_addr;
  sockaddr *ifa_dstaddr;
  sockaddr *ifa_netmask;
  ifnet *ifa_ifp;
  struct
  {
    ifaddr *tqe_next;
    ifaddr **tqe_prev;
  } ifa_link;
  void (*ifa_rtrequest)(int, rtentry *, sockaddr *);
  uint32_t ifa_flags;
  int32_t ifa_metric;
  void (*ifa_free)(ifaddr *);
  void (*ifa_trace)(ifaddr *, int);
  void (*ifa_attached)(ifaddr *);
  void (*ifa_detached)(ifaddr *);
  void *ifa_del_wc;
  int ifa_del_waiters;
};

/* 10316 */
struct __attribute__((packed)) __attribute__((aligned(4))) skmem_obj_info_0
{
  void *oi_addr;
  skmem_bufctl *oi_bc;
  uint32_t oi_size;
  obj_idx_t oi_idx_reg;
  obj_idx_t oi_idx_seg;
};

/* 10317 */
typedef void (*mbuf_tx_compl_func_0)(uintptr_t, ifnet_t, u_int64_t, uintptr_t, uintptr_t, kern_return_t);

/* 10318 */
struct __attribute__((aligned(8))) __kern_packet_0
{
  __kern_quantum_0 pkt_qum;
  __packet pkt_com;
  __packet_opt *pkt_com_opt;
  uint64_t pkt_timestamp;
  __kern_packet *pkt_nextpkt;
  union
  {
    mbuf *pkt_mbuf;
    __kern_packet *pkt_pkt;
  };
  __flow *pkt_flow;
  __packet_compl *pkt_tx_compl;
  void *pkt_priv;
  uint32_t pkt_fpd_seqnum;
  uint16_t pkt_fpd_metadata;
  const uint16_t pkt_bufs_max;
  const uint16_t pkt_bufs_cnt;
  uint32_t pkt_chain_count;
  uint32_t pkt_chain_bytes;
  nexus_port_t pkt_nx_port;
  uint16_t pkt_vpna_gencnt;
  packet_trace_tag_t pkt_trace_tag;
  uint8_t pkt_qset_idx;
  uint8_t _pad[1];
};

/* 10319 */
typedef uint32_t kern_packet_idx_t;

/* 10320 */
typedef __kern_buflet *kern_buflet_t_0;

/* 10321 */
struct __attribute__((aligned(8))) __kern_packet_1
{
  __kern_quantum_1 pkt_qum;
  __packet pkt_com;
  __packet_opt *pkt_com_opt;
  uint64_t pkt_timestamp;
  __kern_packet *pkt_nextpkt;
  union
  {
    mbuf *pkt_mbuf;
    __kern_packet *pkt_pkt;
  };
  __flow *pkt_flow;
  __packet_compl *pkt_tx_compl;
  void *pkt_priv;
  uint32_t pkt_fpd_seqnum;
  uint16_t pkt_fpd_metadata;
  const uint16_t pkt_bufs_max;
  const uint16_t pkt_bufs_cnt;
  uint32_t pkt_chain_count;
  uint32_t pkt_chain_bytes;
  nexus_port_t pkt_nx_port;
  uint16_t pkt_vpna_gencnt;
  packet_trace_tag_t pkt_trace_tag;
  uint8_t pkt_qset_idx;
  uint8_t _pad[1];
};

/* 10322 */
struct __attribute__((aligned(32))) __kern_channel_ring_1
{
  __user_channel_ring *ckr_ring;
  uint32_t ckr_flags;
  slot_idx_t ckr_num_slots;
  uint32_t ckr_max_pkt_len;
  uint32_t ckr_largest;
  const slot_idx_t ckr_lim;
  txrx ckr_tx;
  volatile slot_idx_t ckr_khead;
  volatile slot_idx_t ckr_ktail;
  volatile slot_idx_t ckr_khead_pre;
  volatile slot_idx_t ckr_rhead;
  volatile slot_idx_t ckr_rtail;
  uint32_t ckr_transfer_decay;
  uint64_t ckr_ready_bytes;
  uint64_t ckr_ready_slots;
  lck_spin_t ckr_slock;
  thread *ckr_owner;
  uint32_t ckr_busy;
  uint32_t ckr_want;
  uint32_t ckr_state;
  volatile uint32_t ckr_alloc_ws;
  nexus_adapter *ckr_na;
  kern_pbufpool *ckr_pp;
  __slot_desc *ckr_usds;
  __slot_desc *ckr_ksds;
  __slot_desc *ckr_ksds_last;
  skmem_cache *ckr_ksds_cache;
  uint32_t ckr_ring_id;
  boolean_t ckr_rate_limited;
  uint64_t *ckr_scratch;
  int (*ckr_na_sync)(__kern_channel_ring *, proc *, uint32_t);
  int (*volatile ckr_na_notify)(__kern_channel_ring *, proc *, uint32_t);
  int (*ckr_prologue)(kern_channel *, __kern_channel_ring *, const slot_idx_t, uint32_t *, uint64_t *, proc *);
  void (*ckr_finalize)(kern_channel *, __kern_channel_ring *, const slot_idx_t, proc *);
  uint64_t ckr_sync_time;
  int (*ckr_save_notify)(__kern_channel_ring *, proc *, uint32_t);
  uint32_t *ckr_leases;
  slot_idx_t ckr_klease;
  slot_idx_t ckr_lease_idx;
  kern_packet_svc_class_t ckr_svc;
  uint32_t ckr_slot_ctxs_set;
  slot_ctx *ckr_slot_ctxs;
  void *ckr_ctx;
  ch_selinfo ckr_si;
  int (*ckr_netif_notify)(__kern_channel_ring *, proc *, uint32_t);
  void (*ckr_netif_mit_stats)(__kern_channel_ring *, uint64_t, uint64_t);
  nx_netif_mit *ckr_mit;
  volatile uint32_t ckr_pending_intr;
  volatile uint32_t ckr_pending_doorbell;
  mbuf **ckr_tx_pool;
  nx_mbq ckr_rx_queue;
  __kern_channel_ring *ckr_pipe;
  __user_channel_ring *ckr_save_ring;
  lck_mtx_t ckr_qlock;
  __kern_channel_ring **ckr_monitors;
  uint32_t ckr_max_monitors;
  uint32_t ckr_n_monitors;
  int (*ckr_mon_sync)(__kern_channel_ring *, proc *, uint32_t);
  int (*ckr_mon_notify)(__kern_channel_ring *, proc *, uint32_t);
  uint32_t ckr_mon_tail;
  uint32_t ckr_mon_pos;
  uint32_t ckr_users;
  int64_t ckr_tbr_token;
  int64_t ckr_tbr_depth;
  uint64_t ckr_tbr_last;
  channel_ring_error_stats ckr_err_stats;
  channel_ring_stats ckr_stats;
  uint64_t ckr_accumulated_bytes;
  uint64_t ckr_accumulated_slots;
  uint64_t ckr_accumulate_start;
  channel_ring_user_stats ckr_usr_stats;
  uint64_t ckr_user_accumulated_bytes;
  uint64_t ckr_user_accumulated_slots;
  uint64_t ckr_user_accumulated_syncs;
  uint64_t ckr_user_accumulate_start;
  lck_grp_t *ckr_qlock_group;
  lck_grp_t *ckr_slock_group;
  char ckr_name[64];
};

/* 10323 */
struct kern_channel_0
{
  lck_mtx_t ch_lock;
  nexus_adapter *ch_na;
  kern_nexus *ch_nexus;
  ch_info *ch_info;
  kern_pbufpool *ch_pp;
  uint32_t ch_refcnt;
  volatile uint32_t ch_flags;
  ring_id_t ch_first[5];
  ring_id_t ch_last[5];
  __user_channel_schema *ch_schema;
  ch_selinfo *ch_si[5];
  struct
  {
    kern_channel *stqe_next;
  } ch_link;
  struct
  {
    kern_channel *stqe_next;
  } ch_link_if_adv;
  void *ch_ctx;
  mach_vm_offset_t ch_schema_offset;
  skmem_arena_mmap_info ch_mmap;
  int ch_fd;
  pid_t ch_pid;
  char ch_name[32];
};

/* 10324 */
struct nexus_upipe_adapter_0
{
  nexus_adapter pna_up;
  uint32_t pna_id;
  ch_endpoint_t pna_role;
  nexus_adapter *pna_parent;
  nexus_upipe_adapter *pna_peer;
  boolean_t pna_peer_ref;
  uint32_t pna_parent_slot;
};

/* 10325 */
struct __attribute__((aligned(32))) __kern_channel_ring_2
{
  __user_channel_ring *ckr_ring;
  uint32_t ckr_flags;
  slot_idx_t ckr_num_slots;
  uint32_t ckr_max_pkt_len;
  uint32_t ckr_largest;
  const slot_idx_t ckr_lim;
  txrx ckr_tx;
  volatile slot_idx_t ckr_khead;
  volatile slot_idx_t ckr_ktail;
  volatile slot_idx_t ckr_khead_pre;
  volatile slot_idx_t ckr_rhead;
  volatile slot_idx_t ckr_rtail;
  uint32_t ckr_transfer_decay;
  uint64_t ckr_ready_bytes;
  uint64_t ckr_ready_slots;
  lck_spin_t ckr_slock;
  thread *ckr_owner;
  uint32_t ckr_busy;
  uint32_t ckr_want;
  uint32_t ckr_state;
  volatile uint32_t ckr_alloc_ws;
  nexus_adapter *ckr_na;
  kern_pbufpool *ckr_pp;
  __slot_desc *ckr_usds;
  __slot_desc *ckr_ksds;
  __slot_desc *ckr_ksds_last;
  skmem_cache *ckr_ksds_cache;
  uint32_t ckr_ring_id;
  boolean_t ckr_rate_limited;
  uint64_t *ckr_scratch;
  int (*ckr_na_sync)(__kern_channel_ring *, proc *, uint32_t);
  int (*volatile ckr_na_notify)(__kern_channel_ring *, proc *, uint32_t);
  int (*ckr_prologue)(kern_channel *, __kern_channel_ring *, const slot_idx_t, uint32_t *, uint64_t *, proc *);
  void (*ckr_finalize)(kern_channel *, __kern_channel_ring *, const slot_idx_t, proc *);
  uint64_t ckr_sync_time;
  int (*ckr_save_notify)(__kern_channel_ring *, proc *, uint32_t);
  uint32_t *ckr_leases;
  slot_idx_t ckr_klease;
  slot_idx_t ckr_lease_idx;
  kern_packet_svc_class_t ckr_svc;
  uint32_t ckr_slot_ctxs_set;
  slot_ctx *ckr_slot_ctxs;
  void *ckr_ctx;
  ch_selinfo ckr_si;
  int (*ckr_netif_notify)(__kern_channel_ring *, proc *, uint32_t);
  void (*ckr_netif_mit_stats)(__kern_channel_ring *, uint64_t, uint64_t);
  nx_netif_mit *ckr_mit;
  volatile uint32_t ckr_pending_intr;
  volatile uint32_t ckr_pending_doorbell;
  mbuf **ckr_tx_pool;
  nx_mbq ckr_rx_queue;
  __kern_channel_ring *ckr_pipe;
  __user_channel_ring *ckr_save_ring;
  lck_mtx_t ckr_qlock;
  __kern_channel_ring **ckr_monitors;
  uint32_t ckr_max_monitors;
  uint32_t ckr_n_monitors;
  int (*ckr_mon_sync)(__kern_channel_ring *, proc *, uint32_t);
  int (*ckr_mon_notify)(__kern_channel_ring *, proc *, uint32_t);
  uint32_t ckr_mon_tail;
  uint32_t ckr_mon_pos;
  uint32_t ckr_users;
  int64_t ckr_tbr_token;
  int64_t ckr_tbr_depth;
  uint64_t ckr_tbr_last;
  channel_ring_error_stats ckr_err_stats;
  channel_ring_stats ckr_stats;
  uint64_t ckr_accumulated_bytes;
  uint64_t ckr_accumulated_slots;
  uint64_t ckr_accumulate_start;
  channel_ring_user_stats ckr_usr_stats;
  uint64_t ckr_user_accumulated_bytes;
  uint64_t ckr_user_accumulated_slots;
  uint64_t ckr_user_accumulated_syncs;
  uint64_t ckr_user_accumulate_start;
  lck_grp_t *ckr_qlock_group;
  lck_grp_t *ckr_slock_group;
  char ckr_name[64];
};

/* 10326 */
struct kern_channel_1
{
  lck_mtx_t ch_lock;
  nexus_adapter *ch_na;
  kern_nexus *ch_nexus;
  ch_info *ch_info;
  kern_pbufpool *ch_pp;
  uint32_t ch_refcnt;
  volatile uint32_t ch_flags;
  ring_id_t ch_first[5];
  ring_id_t ch_last[5];
  __user_channel_schema *ch_schema;
  ch_selinfo *ch_si[5];
  struct
  {
    kern_channel *stqe_next;
  } ch_link;
  struct
  {
    kern_channel *stqe_next;
  } ch_link_if_adv;
  void *ch_ctx;
  mach_vm_offset_t ch_schema_offset;
  skmem_arena_mmap_info ch_mmap;
  int ch_fd;
  pid_t ch_pid;
  char ch_name[32];
};

/* 10327 */
struct lltable_0
{
  struct
  {
    lltable *sle_next;
  } llt_link;
  int llt_af;
  int llt_hsize;
  llentries *lle_head;
  ifnet *llt_ifp;
  llt_lookup_t *llt_lookup;
  llt_alloc_t *llt_alloc_entry;
  llt_delete_t *llt_delete_entry;
  llt_prefix_free_t *llt_prefix_free;
  llt_dump_entry_t *llt_dump_entry;
  llt_hash_t *llt_hash;
  llt_match_prefix_t *llt_match_prefix;
  llt_free_entry_t *llt_free_entry;
  llt_foreach_entry_t *llt_foreach_entry;
  llt_link_entry_t *llt_link_entry;
  llt_unlink_entry_t *llt_unlink_entry;
  llt_fill_sa_entry_t *llt_fill_sa_entry;
};

/* 10328 */
struct __attribute__((aligned(8))) nexus_netif_adapter_0
{
  nexus_adapter nifna_up;
  nx_netif *nifna_netif;
  nx_netif_mit *nifna_tx_mit;
  nx_netif_mit *nifna_rx_mit;
  union
  {
    netif_filter *nifna_filter;
    netif_flow *nifna_flow;
  };
  uint16_t nifna_gencnt;
};

/* 10329 */
struct dlil_threading_info_0
{
  lck_mtx_t dlth_lock;
  class_queue_t dlth_pkts;
  ifnet *dlth_ifp;
  ifnet_stat_increment_param dlth_stats;
  uint32_t dlth_flags;
  uint32_t dlth_wtot;
  errno_t (*dlth_strategy)(dlil_threading_info *, ifnet *, mbuf *, mbuf *, const ifnet_stat_increment_param *, boolean_t, thread *);
  boolean_t dlth_affinity;
  uint32_t dlth_affinity_tag;
  thread *dlth_thread;
  thread *dlth_driver_thread;
  thread *dlth_poller_thread;
  lck_grp_t *dlth_lock_grp;
  char dlth_name[32];
  uint64_t dlth_pkts_cnt;
};

/* 10330 */
struct ifmultiaddr_1
{
  lck_mtx_t ifma_lock;
  u_int32_t ifma_refcount;
  u_int32_t ifma_anoncnt;
  u_int32_t ifma_reqcnt;
  u_int32_t ifma_debug;
  u_int32_t ifma_flags;
  struct
  {
    ifmultiaddr *le_next;
    ifmultiaddr **le_prev;
  } ifma_link;
  sockaddr *ifma_addr;
  ifmultiaddr *ifma_ll;
  ifnet *ifma_ifp;
  void *ifma_protospec;
  void (*ifma_trace)(ifmultiaddr *, int);
};

/* 10331 */
struct ifclassq_0
{
  lck_mtx_t ifcq_lock;
  os_refcnt_t ifcq_refcnt;
  ifnet *ifcq_ifp;
  u_int32_t ifcq_len;
  u_int32_t ifcq_maxlen;
  pktcntr ifcq_xmitcnt;
  pktcntr ifcq_dropcnt;
  u_int32_t ifcq_type;
  u_int32_t ifcq_flags;
  u_int32_t ifcq_sflags;
  u_int32_t ifcq_target_qdelay;
  u_int32_t ifcq_bytes;
  u_int32_t ifcq_pkt_drop_limit;
  void *ifcq_disc;
  ifclassq_disc_slot ifcq_disc_slots[10];
  tb_regulator ifcq_tbr;
};

/* 10332 */
struct rtentry_0
{
  radix_node rt_nodes[2];
  lck_mtx_t rt_lock;
  uint32_t rt_refcnt;
  uint32_t rt_flags;
  uint32_t rt_genid;
  sockaddr *rt_gateway;
  ifnet *rt_ifp;
  ifaddr *rt_ifa;
  sockaddr *rt_genmask;
  void *rt_llinfo;
  void (*rt_llinfo_get_ri)(rtentry *, rt_reach_info *);
  void (*rt_llinfo_get_iflri)(rtentry *, ifnet_llreach_info *);
  void (*rt_llinfo_purge)(rtentry *);
  void (*rt_llinfo_free)(void *);
  void (*rt_llinfo_refresh)(rtentry *);
  rt_metrics rt_rmx;
  rtentry *rt_gwroute;
  rtentry *rt_parent;
  nstat_counts *rt_stats;
  void (*rt_if_ref_fn)(ifnet *, int);
  uint32_t *rt_tree_genid;
  uint64_t rt_expire;
  uint64_t base_calendartime;
  uint64_t base_uptime;
  u_int32_t rtt_hist[10];
  u_int32_t rtt_min;
  u_int32_t rtt_expire_ts;
  u_int8_t rtt_index;
  eventhandler_lists_ctxt rt_evhdlr_ctxt;
};

/* 10333 */
struct __attribute__((aligned(8))) ifaddr_1
{
  lck_mtx_t ifa_lock;
  uint32_t ifa_refcnt;
  uint32_t ifa_debug;
  sockaddr *ifa_addr;
  sockaddr *ifa_dstaddr;
  sockaddr *ifa_netmask;
  ifnet *ifa_ifp;
  struct
  {
    ifaddr *tqe_next;
    ifaddr **tqe_prev;
  } ifa_link;
  void (*ifa_rtrequest)(int, rtentry *, sockaddr *);
  uint32_t ifa_flags;
  int32_t ifa_metric;
  void (*ifa_free)(ifaddr *);
  void (*ifa_trace)(ifaddr *, int);
  void (*ifa_attached)(ifaddr *);
  void (*ifa_detached)(ifaddr *);
  void *ifa_del_wc;
  int ifa_del_waiters;
};

/* 10334 */
struct kern_nexus_provider_0
{
  uint32_t nxprov_refcnt;
  uint32_t nxprov_flags;
  struct
  {
    kern_nexus_provider *stqe_next;
  } nxprov_link;
  struct
  {
    kern_nexus *stqh_first;
    kern_nexus **stqh_last;
  } nxprov_nx_head;
  uint32_t nxprov_nx_count;
  nxctl *nxprov_ctl;
  uuid_t_1 nxprov_uuid;
  kern_nexus_domain_provider *nxprov_dom_prov;
  union
  {
    kern_nexus_provider_init_0 nxprov_ext;
    kern_nexus_netif_provider_init_0 nxprov_netif_ext;
  };
  nxprov_params *nxprov_params;
  skmem_region_params nxprov_region_params[28];
};

/* 10335 */
struct lltable_1
{
  struct
  {
    lltable *sle_next;
  } llt_link;
  int llt_af;
  int llt_hsize;
  llentries *lle_head;
  ifnet *llt_ifp;
  llt_lookup_t *llt_lookup;
  llt_alloc_t *llt_alloc_entry;
  llt_delete_t *llt_delete_entry;
  llt_prefix_free_t *llt_prefix_free;
  llt_dump_entry_t *llt_dump_entry;
  llt_hash_t *llt_hash;
  llt_match_prefix_t *llt_match_prefix;
  llt_free_entry_t *llt_free_entry;
  llt_foreach_entry_t *llt_foreach_entry;
  llt_link_entry_t *llt_link_entry;
  llt_unlink_entry_t *llt_unlink_entry;
  llt_fill_sa_entry_t *llt_fill_sa_entry;
};

/* 10336 */
struct __attribute__((aligned(8))) nx_netif_mit_0
{
  lck_spin_t mit_lock;
  volatile __kern_channel_ring *mit_ckr;
  uint32_t mit_flags;
  uint32_t mit_requests;
  uint32_t mit_interval;
  uint32_t mit_cfg_idx_max;
  uint32_t mit_cfg_idx;
  const mit_cfg_tbl *mit_cfg;
  mit_mode_t mit_mode;
  uint32_t mit_packets_avg;
  uint32_t mit_packets_min;
  uint32_t mit_packets_max;
  uint32_t mit_bytes_avg;
  uint32_t mit_bytes_min;
  uint32_t mit_bytes_max;
  pktcntr mit_sstats;
  timespec mit_mode_holdtime;
  timespec mit_mode_lasttime;
  timespec mit_sample_time;
  timespec mit_sample_lasttime;
  timespec mit_start_time;
  thread *mit_thread;
  char mit_name[64];
  const ifnet *mit_netif_ifp;
  mit_cfg_tbl mit_tbl[5];
};

/* 10337 */
struct nx_netif_0
{
  lck_rw_t nif_lock;
  kern_nexus *nif_nx;
  nxbind *nif_dev_nxb;
  nxbind *nif_host_nxb;
  uuid_t_1 nif_uuid;
  netif_stats nif_stats;
  uint32_t nif_flags;
  os_refcnt nif_refcnt;
  lck_mtx_t nif_agent_lock;
  netif_agent_flow_head nif_agent_flow_list;
  uint32_t nif_agent_flow_cnt;
  uint32_t nif_agent_flags;
  netagent_session_t nif_agent_session;
  uuid_t_1 nif_agent_uuid;
  uint32_t nif_hwassist;
  uint32_t nif_capabilities;
  uint32_t nif_capenable;
  uint64_t nif_input_rate;
  ifnet *nif_ifp;
  nx_flowswitch *nif_fsw;
  sk_nexusadv *nif_fsw_nxadv;
  netif_nexus_advisory *nif_netif_nxadv;
  pkt_copy_from_mbuf_t *nif_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *nif_pkt_copy_to_mbuf;
  pkt_copy_from_pkt_t *nif_pkt_copy_from_pkt;
  lck_mtx_t nif_filter_lock;
  uint32_t nif_filter_flags;
  uint32_t nif_filter_vp_cnt;
  uint32_t nif_filter_cnt;
  kern_pbufpool *nif_filter_pp;
  netif_filter_head nif_filter_list;
  union
  {
    nx_mbq nif_tx_processed_mbq[4];
    nx_pktq nif_tx_processed_pktq[4];
  };
  lck_mtx_t nif_flow_lock;
  uint32_t nif_vp_cnt;
  uint32_t nif_flow_flags;
  uint32_t nif_flow_cnt;
  netif_flow_head nif_flow_list;
  netif_flowtable *nif_flow_table;
  kern_channel *nif_hw_ch;
  uint32_t nif_hw_ch_refcnt;
  lck_rw_t nif_llink_lock;
  kern_nexus_netif_llink_init *nif_default_llink_params;
  netif_llink *nif_default_llink;
  struct
  {
    netif_llink *stqh_first;
    netif_llink **stqh_last;
  } nif_llink_list;
  uint16_t nif_llink_cnt;
  uint32_t nif_extended_capabilities;
  kern_nexus_capab_interface_advisory_config_fn_t nif_intf_adv_config;
  void *nif_intf_adv_prov_ctx;
  netif_qset_extensions nif_qset_extensions;
};

/* 10338 */
struct kern_channel_2
{
  lck_mtx_t ch_lock;
  nexus_adapter *ch_na;
  kern_nexus *ch_nexus;
  ch_info *ch_info;
  kern_pbufpool *ch_pp;
  uint32_t ch_refcnt;
  volatile uint32_t ch_flags;
  ring_id_t ch_first[5];
  ring_id_t ch_last[5];
  __user_channel_schema *ch_schema;
  ch_selinfo *ch_si[5];
  struct
  {
    kern_channel *stqe_next;
  } ch_link;
  struct
  {
    kern_channel *stqe_next;
  } ch_link_if_adv;
  void *ch_ctx;
  mach_vm_offset_t ch_schema_offset;
  skmem_arena_mmap_info ch_mmap;
  int ch_fd;
  pid_t ch_pid;
  char ch_name[32];
};

/* 10339 */
struct dlil_threading_info_1
{
  lck_mtx_t dlth_lock;
  class_queue_t dlth_pkts;
  ifnet *dlth_ifp;
  ifnet_stat_increment_param dlth_stats;
  uint32_t dlth_flags;
  uint32_t dlth_wtot;
  errno_t (*dlth_strategy)(dlil_threading_info *, ifnet *, mbuf *, mbuf *, const ifnet_stat_increment_param *, boolean_t, thread *);
  boolean_t dlth_affinity;
  uint32_t dlth_affinity_tag;
  thread *dlth_thread;
  thread *dlth_driver_thread;
  thread *dlth_poller_thread;
  lck_grp_t *dlth_lock_grp;
  char dlth_name[32];
  uint64_t dlth_pkts_cnt;
};

/* 10340 */
struct ifmultiaddr_2
{
  lck_mtx_t ifma_lock;
  u_int32_t ifma_refcount;
  u_int32_t ifma_anoncnt;
  u_int32_t ifma_reqcnt;
  u_int32_t ifma_debug;
  u_int32_t ifma_flags;
  struct
  {
    ifmultiaddr *le_next;
    ifmultiaddr **le_prev;
  } ifma_link;
  sockaddr *ifma_addr;
  ifmultiaddr *ifma_ll;
  ifnet *ifma_ifp;
  void *ifma_protospec;
  void (*ifma_trace)(ifmultiaddr *, int);
};

/* 10341 */
struct ifclassq_1
{
  lck_mtx_t ifcq_lock;
  os_refcnt_t ifcq_refcnt;
  ifnet *ifcq_ifp;
  u_int32_t ifcq_len;
  u_int32_t ifcq_maxlen;
  pktcntr ifcq_xmitcnt;
  pktcntr ifcq_dropcnt;
  u_int32_t ifcq_type;
  u_int32_t ifcq_flags;
  u_int32_t ifcq_sflags;
  u_int32_t ifcq_target_qdelay;
  u_int32_t ifcq_bytes;
  u_int32_t ifcq_pkt_drop_limit;
  void *ifcq_disc;
  ifclassq_disc_slot ifcq_disc_slots[10];
  tb_regulator ifcq_tbr;
};

/* 10342 */
struct rtentry_1
{
  radix_node rt_nodes[2];
  lck_mtx_t rt_lock;
  uint32_t rt_refcnt;
  uint32_t rt_flags;
  uint32_t rt_genid;
  sockaddr *rt_gateway;
  ifnet *rt_ifp;
  ifaddr *rt_ifa;
  sockaddr *rt_genmask;
  void *rt_llinfo;
  void (*rt_llinfo_get_ri)(rtentry *, rt_reach_info *);
  void (*rt_llinfo_get_iflri)(rtentry *, ifnet_llreach_info *);
  void (*rt_llinfo_purge)(rtentry *);
  void (*rt_llinfo_free)(void *);
  void (*rt_llinfo_refresh)(rtentry *);
  rt_metrics rt_rmx;
  rtentry *rt_gwroute;
  rtentry *rt_parent;
  nstat_counts *rt_stats;
  void (*rt_if_ref_fn)(ifnet *, int);
  uint32_t *rt_tree_genid;
  uint64_t rt_expire;
  uint64_t base_calendartime;
  uint64_t base_uptime;
  u_int32_t rtt_hist[10];
  u_int32_t rtt_min;
  u_int32_t rtt_expire_ts;
  u_int8_t rtt_index;
  eventhandler_lists_ctxt rt_evhdlr_ctxt;
};

/* 10343 */
struct __attribute__((aligned(8))) ifaddr_2
{
  lck_mtx_t ifa_lock;
  uint32_t ifa_refcnt;
  uint32_t ifa_debug;
  sockaddr *ifa_addr;
  sockaddr *ifa_dstaddr;
  sockaddr *ifa_netmask;
  ifnet *ifa_ifp;
  struct
  {
    ifaddr *tqe_next;
    ifaddr **tqe_prev;
  } ifa_link;
  void (*ifa_rtrequest)(int, rtentry *, sockaddr *);
  uint32_t ifa_flags;
  int32_t ifa_metric;
  void (*ifa_free)(ifaddr *);
  void (*ifa_trace)(ifaddr *, int);
  void (*ifa_attached)(ifaddr *);
  void (*ifa_detached)(ifaddr *);
  void *ifa_del_wc;
  int ifa_del_waiters;
};

/* 10344 */
struct ifnet_model_params
{
  ifnet_model_t model;
  u_int32_t reserved[3];
};

/* 10345 */
struct nx_netif_1
{
  lck_rw_t nif_lock;
  kern_nexus *nif_nx;
  nxbind *nif_dev_nxb;
  nxbind *nif_host_nxb;
  uuid_t_1 nif_uuid;
  netif_stats nif_stats;
  uint32_t nif_flags;
  os_refcnt nif_refcnt;
  lck_mtx_t nif_agent_lock;
  netif_agent_flow_head nif_agent_flow_list;
  uint32_t nif_agent_flow_cnt;
  uint32_t nif_agent_flags;
  netagent_session_t nif_agent_session;
  uuid_t_1 nif_agent_uuid;
  uint32_t nif_hwassist;
  uint32_t nif_capabilities;
  uint32_t nif_capenable;
  uint64_t nif_input_rate;
  ifnet *nif_ifp;
  nx_flowswitch *nif_fsw;
  sk_nexusadv *nif_fsw_nxadv;
  netif_nexus_advisory *nif_netif_nxadv;
  pkt_copy_from_mbuf_t *nif_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *nif_pkt_copy_to_mbuf;
  pkt_copy_from_pkt_t *nif_pkt_copy_from_pkt;
  lck_mtx_t nif_filter_lock;
  uint32_t nif_filter_flags;
  uint32_t nif_filter_vp_cnt;
  uint32_t nif_filter_cnt;
  kern_pbufpool *nif_filter_pp;
  netif_filter_head nif_filter_list;
  union
  {
    nx_mbq nif_tx_processed_mbq[4];
    nx_pktq nif_tx_processed_pktq[4];
  };
  lck_mtx_t nif_flow_lock;
  uint32_t nif_vp_cnt;
  uint32_t nif_flow_flags;
  uint32_t nif_flow_cnt;
  netif_flow_head nif_flow_list;
  netif_flowtable *nif_flow_table;
  kern_channel *nif_hw_ch;
  uint32_t nif_hw_ch_refcnt;
  lck_rw_t nif_llink_lock;
  kern_nexus_netif_llink_init *nif_default_llink_params;
  netif_llink *nif_default_llink;
  struct
  {
    netif_llink *stqh_first;
    netif_llink **stqh_last;
  } nif_llink_list;
  uint16_t nif_llink_cnt;
  uint32_t nif_extended_capabilities;
  kern_nexus_capab_interface_advisory_config_fn_t nif_intf_adv_config;
  void *nif_intf_adv_prov_ctx;
  netif_qset_extensions nif_qset_extensions;
};

/* 10346 */
struct kern_nexus_provider_1
{
  uint32_t nxprov_refcnt;
  uint32_t nxprov_flags;
  struct
  {
    kern_nexus_provider *stqe_next;
  } nxprov_link;
  struct
  {
    kern_nexus *stqh_first;
    kern_nexus **stqh_last;
  } nxprov_nx_head;
  uint32_t nxprov_nx_count;
  nxctl *nxprov_ctl;
  uuid_t_1 nxprov_uuid;
  kern_nexus_domain_provider *nxprov_dom_prov;
  union
  {
    kern_nexus_provider_init_1 nxprov_ext;
    kern_nexus_netif_provider_init_0 nxprov_netif_ext;
  };
  nxprov_params *nxprov_params;
  skmem_region_params nxprov_region_params[28];
};

/* 10347 */
struct nx_netif_2
{
  lck_rw_t nif_lock;
  kern_nexus *nif_nx;
  nxbind *nif_dev_nxb;
  nxbind *nif_host_nxb;
  uuid_t_1 nif_uuid;
  netif_stats nif_stats;
  uint32_t nif_flags;
  os_refcnt nif_refcnt;
  lck_mtx_t nif_agent_lock;
  netif_agent_flow_head nif_agent_flow_list;
  uint32_t nif_agent_flow_cnt;
  uint32_t nif_agent_flags;
  netagent_session_t nif_agent_session;
  uuid_t_1 nif_agent_uuid;
  uint32_t nif_hwassist;
  uint32_t nif_capabilities;
  uint32_t nif_capenable;
  uint64_t nif_input_rate;
  ifnet *nif_ifp;
  nx_flowswitch *nif_fsw;
  sk_nexusadv *nif_fsw_nxadv;
  netif_nexus_advisory *nif_netif_nxadv;
  pkt_copy_from_mbuf_t *nif_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *nif_pkt_copy_to_mbuf;
  pkt_copy_from_pkt_t *nif_pkt_copy_from_pkt;
  lck_mtx_t nif_filter_lock;
  uint32_t nif_filter_flags;
  uint32_t nif_filter_vp_cnt;
  uint32_t nif_filter_cnt;
  kern_pbufpool *nif_filter_pp;
  netif_filter_head nif_filter_list;
  union
  {
    nx_mbq nif_tx_processed_mbq[4];
    nx_pktq nif_tx_processed_pktq[4];
  };
  lck_mtx_t nif_flow_lock;
  uint32_t nif_vp_cnt;
  uint32_t nif_flow_flags;
  uint32_t nif_flow_cnt;
  netif_flow_head nif_flow_list;
  netif_flowtable *nif_flow_table;
  kern_channel *nif_hw_ch;
  uint32_t nif_hw_ch_refcnt;
  lck_rw_t nif_llink_lock;
  kern_nexus_netif_llink_init *nif_default_llink_params;
  netif_llink *nif_default_llink;
  struct
  {
    netif_llink *stqh_first;
    netif_llink **stqh_last;
  } nif_llink_list;
  uint16_t nif_llink_cnt;
  uint32_t nif_extended_capabilities;
  kern_nexus_capab_interface_advisory_config_fn_t nif_intf_adv_config;
  void *nif_intf_adv_prov_ctx;
  netif_qset_extensions nif_qset_extensions;
};

/* 10348 */
struct netagent_nexus_agent
{
  netagent agent;
  netagent_nexus nexus_data;
};

/* 10349 */
struct __attribute__((aligned(8))) nx_netif_mit_1
{
  lck_spin_t mit_lock;
  volatile __kern_channel_ring *mit_ckr;
  uint32_t mit_flags;
  uint32_t mit_requests;
  uint32_t mit_interval;
  uint32_t mit_cfg_idx_max;
  uint32_t mit_cfg_idx;
  const mit_cfg_tbl *mit_cfg;
  mit_mode_t mit_mode;
  uint32_t mit_packets_avg;
  uint32_t mit_packets_min;
  uint32_t mit_packets_max;
  uint32_t mit_bytes_avg;
  uint32_t mit_bytes_min;
  uint32_t mit_bytes_max;
  pktcntr mit_sstats;
  timespec mit_mode_holdtime;
  timespec mit_mode_lasttime;
  timespec mit_sample_time;
  timespec mit_sample_lasttime;
  timespec mit_start_time;
  thread *mit_thread;
  char mit_name[64];
  const ifnet *mit_netif_ifp;
  mit_cfg_tbl mit_tbl[5];
};

/* 10350 */
struct kern_nexus_provider_2
{
  uint32_t nxprov_refcnt;
  uint32_t nxprov_flags;
  struct
  {
    kern_nexus_provider *stqe_next;
  } nxprov_link;
  struct
  {
    kern_nexus *stqh_first;
    kern_nexus **stqh_last;
  } nxprov_nx_head;
  uint32_t nxprov_nx_count;
  nxctl *nxprov_ctl;
  uuid_t_1 nxprov_uuid;
  kern_nexus_domain_provider *nxprov_dom_prov;
  union
  {
    kern_nexus_provider_init nxprov_ext;
    kern_nexus_netif_provider_init nxprov_netif_ext;
  };
  nxprov_params *nxprov_params;
  skmem_region_params nxprov_region_params[28];
};

/* 10351 */
struct kern_nexus_domain_provider_1
{
  struct
  {
    kern_nexus_domain_provider *stqe_next;
  } nxdom_prov_link;
  struct
  {
    kern_nexus_domain_provider *stqe_next;
  } nxdom_prov_detaching_link;
  char nxdom_prov_name[64];
  uuid_t_1 nxdom_prov_uuid;
  uint64_t nxdom_prov_gencnt;
  uint32_t nxdom_prov_refcnt;
  uint32_t nxdom_prov_flags;
  nxdom *nxdom_prov_dom;
  kern_nexus_domain_provider_init_0 nxdom_prov_ext;
  nxdom_prov_cb nxdom_prov_cb;
};

/* 10352 */
typedef int (*channel_ring_notify_t)(__kern_channel_ring *, struct proc *, uint32_t);

/* 10353 */
struct __attribute__((aligned(8))) nx_flowswitch_0
{
  lck_rw_t fsw_lock;
  uint32_t fsw_tx_rings;
  uint32_t fsw_rx_rings;
  kern_nexus *fsw_nx;
  classq_pkt_type_t fsw_classq_enq_ptype;
  boolean_t fsw_classq_enabled;
  pkt_copy_from_pkt_t *fsw_pkt_copy_from_pkt;
  pkt_copy_from_mbuf_t *fsw_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *fsw_pkt_copy_to_mbuf;
  uint8_t fsw_frame_headroom;
  uint32_t fsw_src_lla_gencnt;
  uint32_t fsw_pending_nonviable;
  uint32_t fsw_low_power_gencnt;
  flow_mgr *fsw_flow_mgr;
  netagent_session_t fsw_agent_session;
  uuid_t_1 fsw_agent_uuid;
  ifnet *fsw_ifp;
  nexus_adapter *fsw_nifna;
  uint32_t fsw_state_flags;
  union
  {
    uint64_t _buf[1];
    uint8_t _eth_src[6];
  } __fsw_slladdr;
  int (*fsw_resolve)(nx_flowswitch *, flow_route *, __kern_packet *);
  void (*fsw_frame)(nx_flowswitch *, flow_route *, __kern_packet *);
  sa_family_t (*fsw_demux)(nx_flowswitch *, __kern_packet *);
  fsw_stats fsw_stats;
  lck_mtx_t fsw_detach_barrier_lock;
  uint32_t fsw_detach_flags;
  uint32_t fsw_detach_barriers;
  uint32_t fsw_detach_waiters;
  uint32_t fsw_ifp_dlt;
  uint32_t fsw_rx_largest_size;
  void (*fsw_ctor)(nx_flowswitch *, flow_route *);
  __nx_stats_fsw *fsw_closed_na_stats;
  fsw_ip_frag_mgr *fsw_ipfm;
  skoid fsw_skoid;
  netem *fsw_input_netem;
  kern_channel *fsw_dev_ch;
  kern_channel *fsw_host_ch;
  lck_mtx_t fsw_reap_lock;
  uint32_t fsw_reap_flags;
  uint32_t fsw_reap_requests;
  thread *fsw_reap_thread;
  char fsw_reap_name[64];
  uint64_t fsw_reap_last;
  uint64_t fsw_drain_channel_chk_last;
  uint64_t fsw_drain_netif_chk_last;
  lck_mtx_t fsw_linger_lock;
  flow_entry_linger_head fsw_linger_head;
  uint32_t fsw_linger_cnt;
};

/* 10354 */
struct __attribute__((aligned(32))) __kern_channel_ring_3
{
  __user_channel_ring *ckr_ring;
  uint32_t ckr_flags;
  slot_idx_t ckr_num_slots;
  uint32_t ckr_max_pkt_len;
  uint32_t ckr_largest;
  const slot_idx_t ckr_lim;
  txrx ckr_tx;
  volatile slot_idx_t ckr_khead;
  volatile slot_idx_t ckr_ktail;
  volatile slot_idx_t ckr_khead_pre;
  volatile slot_idx_t ckr_rhead;
  volatile slot_idx_t ckr_rtail;
  uint32_t ckr_transfer_decay;
  uint64_t ckr_ready_bytes;
  uint64_t ckr_ready_slots;
  lck_spin_t ckr_slock;
  thread *ckr_owner;
  uint32_t ckr_busy;
  uint32_t ckr_want;
  uint32_t ckr_state;
  volatile uint32_t ckr_alloc_ws;
  nexus_adapter *ckr_na;
  kern_pbufpool *ckr_pp;
  __slot_desc *ckr_usds;
  __slot_desc *ckr_ksds;
  __slot_desc *ckr_ksds_last;
  skmem_cache *ckr_ksds_cache;
  uint32_t ckr_ring_id;
  boolean_t ckr_rate_limited;
  uint64_t *ckr_scratch;
  int (*ckr_na_sync)(__kern_channel_ring *, proc *, uint32_t);
  int (*volatile ckr_na_notify)(__kern_channel_ring *, proc *, uint32_t);
  int (*ckr_prologue)(kern_channel *, __kern_channel_ring *, const slot_idx_t, uint32_t *, uint64_t *, proc *);
  void (*ckr_finalize)(kern_channel *, __kern_channel_ring *, const slot_idx_t, proc *);
  uint64_t ckr_sync_time;
  int (*ckr_save_notify)(__kern_channel_ring *, proc *, uint32_t);
  uint32_t *ckr_leases;
  slot_idx_t ckr_klease;
  slot_idx_t ckr_lease_idx;
  kern_packet_svc_class_t ckr_svc;
  uint32_t ckr_slot_ctxs_set;
  slot_ctx *ckr_slot_ctxs;
  void *ckr_ctx;
  ch_selinfo ckr_si;
  int (*ckr_netif_notify)(__kern_channel_ring *, proc *, uint32_t);
  void (*ckr_netif_mit_stats)(__kern_channel_ring *, uint64_t, uint64_t);
  nx_netif_mit *ckr_mit;
  volatile uint32_t ckr_pending_intr;
  volatile uint32_t ckr_pending_doorbell;
  mbuf **ckr_tx_pool;
  nx_mbq ckr_rx_queue;
  __kern_channel_ring *ckr_pipe;
  __user_channel_ring *ckr_save_ring;
  lck_mtx_t ckr_qlock;
  __kern_channel_ring **ckr_monitors;
  uint32_t ckr_max_monitors;
  uint32_t ckr_n_monitors;
  int (*ckr_mon_sync)(__kern_channel_ring *, proc *, uint32_t);
  int (*ckr_mon_notify)(__kern_channel_ring *, proc *, uint32_t);
  uint32_t ckr_mon_tail;
  uint32_t ckr_mon_pos;
  uint32_t ckr_users;
  int64_t ckr_tbr_token;
  int64_t ckr_tbr_depth;
  uint64_t ckr_tbr_last;
  channel_ring_error_stats ckr_err_stats;
  channel_ring_stats ckr_stats;
  uint64_t ckr_accumulated_bytes;
  uint64_t ckr_accumulated_slots;
  uint64_t ckr_accumulate_start;
  channel_ring_user_stats ckr_usr_stats;
  uint64_t ckr_user_accumulated_bytes;
  uint64_t ckr_user_accumulated_slots;
  uint64_t ckr_user_accumulated_syncs;
  uint64_t ckr_user_accumulate_start;
  lck_grp_t *ckr_qlock_group;
  lck_grp_t *ckr_slock_group;
  char ckr_name[64];
};

/* 10355 */
struct kern_channel_3
{
  lck_mtx_t ch_lock;
  nexus_adapter *ch_na;
  kern_nexus *ch_nexus;
  ch_info *ch_info;
  kern_pbufpool *ch_pp;
  uint32_t ch_refcnt;
  volatile uint32_t ch_flags;
  ring_id_t ch_first[5];
  ring_id_t ch_last[5];
  __user_channel_schema *ch_schema;
  ch_selinfo *ch_si[5];
  struct
  {
    kern_channel *stqe_next;
  } ch_link;
  struct
  {
    kern_channel *stqe_next;
  } ch_link_if_adv;
  void *ch_ctx;
  mach_vm_offset_t ch_schema_offset;
  skmem_arena_mmap_info ch_mmap;
  int ch_fd;
  pid_t ch_pid;
  char ch_name[32];
};

/* 10356 */
struct __attribute__((aligned(8))) nx_flowswitch_1
{
  lck_rw_t fsw_lock;
  uint32_t fsw_tx_rings;
  uint32_t fsw_rx_rings;
  kern_nexus *fsw_nx;
  classq_pkt_type_t fsw_classq_enq_ptype;
  boolean_t fsw_classq_enabled;
  pkt_copy_from_pkt_t *fsw_pkt_copy_from_pkt;
  pkt_copy_from_mbuf_t *fsw_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *fsw_pkt_copy_to_mbuf;
  uint8_t fsw_frame_headroom;
  uint32_t fsw_src_lla_gencnt;
  uint32_t fsw_pending_nonviable;
  uint32_t fsw_low_power_gencnt;
  flow_mgr *fsw_flow_mgr;
  netagent_session_t fsw_agent_session;
  uuid_t_1 fsw_agent_uuid;
  ifnet *fsw_ifp;
  nexus_adapter *fsw_nifna;
  uint32_t fsw_state_flags;
  union
  {
    uint64_t _buf[1];
    uint8_t _eth_src[6];
  } __fsw_slladdr;
  int (*fsw_resolve)(nx_flowswitch *, flow_route *, __kern_packet *);
  void (*fsw_frame)(nx_flowswitch *, flow_route *, __kern_packet *);
  sa_family_t (*fsw_demux)(nx_flowswitch *, __kern_packet *);
  fsw_stats fsw_stats;
  lck_mtx_t fsw_detach_barrier_lock;
  uint32_t fsw_detach_flags;
  uint32_t fsw_detach_barriers;
  uint32_t fsw_detach_waiters;
  uint32_t fsw_ifp_dlt;
  uint32_t fsw_rx_largest_size;
  void (*fsw_ctor)(nx_flowswitch *, flow_route *);
  __nx_stats_fsw *fsw_closed_na_stats;
  fsw_ip_frag_mgr *fsw_ipfm;
  skoid fsw_skoid;
  netem *fsw_input_netem;
  kern_channel *fsw_dev_ch;
  kern_channel *fsw_host_ch;
  lck_mtx_t fsw_reap_lock;
  uint32_t fsw_reap_flags;
  uint32_t fsw_reap_requests;
  thread *fsw_reap_thread;
  char fsw_reap_name[64];
  uint64_t fsw_reap_last;
  uint64_t fsw_drain_channel_chk_last;
  uint64_t fsw_drain_netif_chk_last;
  lck_mtx_t fsw_linger_lock;
  flow_entry_linger_head fsw_linger_head;
  uint32_t fsw_linger_cnt;
};

/* 10357 */
struct rtentry_2
{
  radix_node rt_nodes[2];
  lck_mtx_t rt_lock;
  uint32_t rt_refcnt;
  uint32_t rt_flags;
  uint32_t rt_genid;
  sockaddr *rt_gateway;
  ifnet *rt_ifp;
  ifaddr *rt_ifa;
  sockaddr *rt_genmask;
  void *rt_llinfo;
  void (*rt_llinfo_get_ri)(rtentry *, rt_reach_info *);
  void (*rt_llinfo_get_iflri)(rtentry *, ifnet_llreach_info *);
  void (*rt_llinfo_purge)(rtentry *);
  void (*rt_llinfo_free)(void *);
  void (*rt_llinfo_refresh)(rtentry *);
  rt_metrics rt_rmx;
  rtentry *rt_gwroute;
  rtentry *rt_parent;
  nstat_counts *rt_stats;
  void (*rt_if_ref_fn)(ifnet *, int);
  uint32_t *rt_tree_genid;
  uint64_t rt_expire;
  uint64_t base_calendartime;
  uint64_t base_uptime;
  u_int32_t rtt_hist[10];
  u_int32_t rtt_min;
  u_int32_t rtt_expire_ts;
  u_int8_t rtt_index;
  eventhandler_lists_ctxt rt_evhdlr_ctxt;
};

/* 10358 */
struct __block_literal_1_10
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(cuckoo_node *, uint32_t);
  __block_descriptor_withcopydispose *__descriptor;
  struct *flow_handler;
};

/* 10359 */
struct flow_owner_0
{
  struct
  {
    flow_owner *rbe_left;
    flow_owner *rbe_right;
    flow_owner *rbe_parent;
  } fo_link;
  flow_entry_id_tree fo_flow_entry_id_head;
  const flow_owner_bucket *fo_bucket;
  void *fo_context;
  pid_t fo_pid;
  bool fo_nx_port_pid_bound;
  bool fo_nx_port_destroyed;
  bool fo_low_latency;
  nexus_port_t fo_nx_port;
  uuid_t_1 fo_key;
  nexus_adapter *const fo_nx_port_na;
  nx_flowswitch *const fo_fsw;
  bitmap_t *fo_flowadv_bmap;
  uint32_t fo_flowadv_max;
  uint32_t fo_num_flowadv;
  char fo_name[24];
};

/* 10360 */
struct __attribute__((aligned(32))) __kern_channel_ring_4
{
  __user_channel_ring *ckr_ring;
  uint32_t ckr_flags;
  slot_idx_t ckr_num_slots;
  uint32_t ckr_max_pkt_len;
  uint32_t ckr_largest;
  const slot_idx_t ckr_lim;
  txrx ckr_tx;
  volatile slot_idx_t ckr_khead;
  volatile slot_idx_t ckr_ktail;
  volatile slot_idx_t ckr_khead_pre;
  volatile slot_idx_t ckr_rhead;
  volatile slot_idx_t ckr_rtail;
  uint32_t ckr_transfer_decay;
  uint64_t ckr_ready_bytes;
  uint64_t ckr_ready_slots;
  lck_spin_t ckr_slock;
  thread *ckr_owner;
  uint32_t ckr_busy;
  uint32_t ckr_want;
  uint32_t ckr_state;
  volatile uint32_t ckr_alloc_ws;
  nexus_adapter *ckr_na;
  kern_pbufpool *ckr_pp;
  __slot_desc *ckr_usds;
  __slot_desc *ckr_ksds;
  __slot_desc *ckr_ksds_last;
  skmem_cache *ckr_ksds_cache;
  uint32_t ckr_ring_id;
  boolean_t ckr_rate_limited;
  uint64_t *ckr_scratch;
  int (*ckr_na_sync)(__kern_channel_ring *, proc *, uint32_t);
  int (*volatile ckr_na_notify)(__kern_channel_ring *, proc *, uint32_t);
  int (*ckr_prologue)(kern_channel *, __kern_channel_ring *, const slot_idx_t, uint32_t *, uint64_t *, proc *);
  void (*ckr_finalize)(kern_channel *, __kern_channel_ring *, const slot_idx_t, proc *);
  uint64_t ckr_sync_time;
  int (*ckr_save_notify)(__kern_channel_ring *, proc *, uint32_t);
  uint32_t *ckr_leases;
  slot_idx_t ckr_klease;
  slot_idx_t ckr_lease_idx;
  kern_packet_svc_class_t ckr_svc;
  uint32_t ckr_slot_ctxs_set;
  slot_ctx *ckr_slot_ctxs;
  void *ckr_ctx;
  ch_selinfo ckr_si;
  int (*ckr_netif_notify)(__kern_channel_ring *, proc *, uint32_t);
  void (*ckr_netif_mit_stats)(__kern_channel_ring *, uint64_t, uint64_t);
  nx_netif_mit *ckr_mit;
  volatile uint32_t ckr_pending_intr;
  volatile uint32_t ckr_pending_doorbell;
  mbuf **ckr_tx_pool;
  nx_mbq ckr_rx_queue;
  __kern_channel_ring *ckr_pipe;
  __user_channel_ring *ckr_save_ring;
  lck_mtx_t ckr_qlock;
  __kern_channel_ring **ckr_monitors;
  uint32_t ckr_max_monitors;
  uint32_t ckr_n_monitors;
  int (*ckr_mon_sync)(__kern_channel_ring *, proc *, uint32_t);
  int (*ckr_mon_notify)(__kern_channel_ring *, proc *, uint32_t);
  uint32_t ckr_mon_tail;
  uint32_t ckr_mon_pos;
  uint32_t ckr_users;
  int64_t ckr_tbr_token;
  int64_t ckr_tbr_depth;
  uint64_t ckr_tbr_last;
  channel_ring_error_stats ckr_err_stats;
  channel_ring_stats ckr_stats;
  uint64_t ckr_accumulated_bytes;
  uint64_t ckr_accumulated_slots;
  uint64_t ckr_accumulate_start;
  channel_ring_user_stats ckr_usr_stats;
  uint64_t ckr_user_accumulated_bytes;
  uint64_t ckr_user_accumulated_slots;
  uint64_t ckr_user_accumulated_syncs;
  uint64_t ckr_user_accumulate_start;
  lck_grp_t *ckr_qlock_group;
  lck_grp_t *ckr_slock_group;
  char ckr_name[64];
};

/* 10361 */
struct kern_channel_4
{
  lck_mtx_t ch_lock;
  nexus_adapter *ch_na;
  kern_nexus *ch_nexus;
  ch_info *ch_info;
  kern_pbufpool *ch_pp;
  uint32_t ch_refcnt;
  volatile uint32_t ch_flags;
  ring_id_t ch_first[5];
  ring_id_t ch_last[5];
  __user_channel_schema *ch_schema;
  ch_selinfo *ch_si[5];
  struct
  {
    kern_channel *stqe_next;
  } ch_link;
  struct
  {
    kern_channel *stqe_next;
  } ch_link_if_adv;
  void *ch_ctx;
  mach_vm_offset_t ch_schema_offset;
  skmem_arena_mmap_info ch_mmap;
  int ch_fd;
  pid_t ch_pid;
  char ch_name[32];
};

/* 10362 */
struct flow_owner_1
{
  struct
  {
    flow_owner *rbe_left;
    flow_owner *rbe_right;
    flow_owner *rbe_parent;
  } fo_link;
  flow_entry_id_tree fo_flow_entry_id_head;
  const flow_owner_bucket *fo_bucket;
  void *fo_context;
  pid_t fo_pid;
  bool fo_nx_port_pid_bound;
  bool fo_nx_port_destroyed;
  bool fo_low_latency;
  nexus_port_t fo_nx_port;
  uuid_t_1 fo_key;
  nexus_adapter *const fo_nx_port_na;
  nx_flowswitch *const fo_fsw;
  bitmap_t *fo_flowadv_bmap;
  uint32_t fo_flowadv_max;
  uint32_t fo_num_flowadv;
  char fo_name[24];
};

/* 10363 */
struct __attribute__((aligned(8))) nx_flowswitch_2
{
  lck_rw_t fsw_lock;
  uint32_t fsw_tx_rings;
  uint32_t fsw_rx_rings;
  kern_nexus *fsw_nx;
  classq_pkt_type_t fsw_classq_enq_ptype;
  boolean_t fsw_classq_enabled;
  pkt_copy_from_pkt_t *fsw_pkt_copy_from_pkt;
  pkt_copy_from_mbuf_t *fsw_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *fsw_pkt_copy_to_mbuf;
  uint8_t fsw_frame_headroom;
  uint32_t fsw_src_lla_gencnt;
  uint32_t fsw_pending_nonviable;
  uint32_t fsw_low_power_gencnt;
  flow_mgr *fsw_flow_mgr;
  netagent_session_t fsw_agent_session;
  uuid_t_1 fsw_agent_uuid;
  ifnet *fsw_ifp;
  nexus_adapter *fsw_nifna;
  uint32_t fsw_state_flags;
  union
  {
    uint64_t _buf[1];
    uint8_t _eth_src[6];
  } __fsw_slladdr;
  int (*fsw_resolve)(nx_flowswitch *, flow_route *, __kern_packet *);
  void (*fsw_frame)(nx_flowswitch *, flow_route *, __kern_packet *);
  sa_family_t (*fsw_demux)(nx_flowswitch *, __kern_packet *);
  fsw_stats fsw_stats;
  lck_mtx_t fsw_detach_barrier_lock;
  uint32_t fsw_detach_flags;
  uint32_t fsw_detach_barriers;
  uint32_t fsw_detach_waiters;
  uint32_t fsw_ifp_dlt;
  uint32_t fsw_rx_largest_size;
  void (*fsw_ctor)(nx_flowswitch *, flow_route *);
  __nx_stats_fsw *fsw_closed_na_stats;
  fsw_ip_frag_mgr *fsw_ipfm;
  skoid_0 fsw_skoid;
  netem *fsw_input_netem;
  kern_channel *fsw_dev_ch;
  kern_channel *fsw_host_ch;
  lck_mtx_t fsw_reap_lock;
  uint32_t fsw_reap_flags;
  uint32_t fsw_reap_requests;
  thread *fsw_reap_thread;
  char fsw_reap_name[64];
  uint64_t fsw_reap_last;
  uint64_t fsw_drain_channel_chk_last;
  uint64_t fsw_drain_netif_chk_last;
  lck_mtx_t fsw_linger_lock;
  flow_entry_linger_head fsw_linger_head;
  uint32_t fsw_linger_cnt;
};

/* 10364 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_1_11
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(nexus_port_t);
  __block_descriptor *__descriptor;
  kern_nexus *nx;
  uint64_t now;
  boolean_t low;
};

/* 10365 */
struct __attribute__((aligned(8))) nx_flowswitch_3
{
  lck_rw_t fsw_lock;
  uint32_t fsw_tx_rings;
  uint32_t fsw_rx_rings;
  kern_nexus *fsw_nx;
  classq_pkt_type_t fsw_classq_enq_ptype;
  boolean_t fsw_classq_enabled;
  pkt_copy_from_pkt_t *fsw_pkt_copy_from_pkt;
  pkt_copy_from_mbuf_t *fsw_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *fsw_pkt_copy_to_mbuf;
  uint8_t fsw_frame_headroom;
  uint32_t fsw_src_lla_gencnt;
  uint32_t fsw_pending_nonviable;
  uint32_t fsw_low_power_gencnt;
  flow_mgr *fsw_flow_mgr;
  netagent_session_t fsw_agent_session;
  uuid_t_1 fsw_agent_uuid;
  ifnet *fsw_ifp;
  nexus_adapter *fsw_nifna;
  uint32_t fsw_state_flags;
  union
  {
    uint64_t _buf[1];
    uint8_t _eth_src[6];
  } __fsw_slladdr;
  int (*fsw_resolve)(nx_flowswitch *, flow_route *, __kern_packet *);
  void (*fsw_frame)(nx_flowswitch *, flow_route *, __kern_packet *);
  sa_family_t (*fsw_demux)(nx_flowswitch *, __kern_packet *);
  fsw_stats fsw_stats;
  lck_mtx_t fsw_detach_barrier_lock;
  uint32_t fsw_detach_flags;
  uint32_t fsw_detach_barriers;
  uint32_t fsw_detach_waiters;
  uint32_t fsw_ifp_dlt;
  uint32_t fsw_rx_largest_size;
  void (*fsw_ctor)(nx_flowswitch *, flow_route *);
  __nx_stats_fsw *fsw_closed_na_stats;
  fsw_ip_frag_mgr *fsw_ipfm;
  skoid_0 fsw_skoid;
  netem *fsw_input_netem;
  kern_channel *fsw_dev_ch;
  kern_channel *fsw_host_ch;
  lck_mtx_t fsw_reap_lock;
  uint32_t fsw_reap_flags;
  uint32_t fsw_reap_requests;
  thread *fsw_reap_thread;
  char fsw_reap_name[64];
  uint64_t fsw_reap_last;
  uint64_t fsw_drain_channel_chk_last;
  uint64_t fsw_drain_netif_chk_last;
  lck_mtx_t fsw_linger_lock;
  flow_entry_linger_head fsw_linger_head;
  uint32_t fsw_linger_cnt;
};

/* 10366 */
struct nx_netif_3
{
  lck_rw_t nif_lock;
  kern_nexus *nif_nx;
  nxbind *nif_dev_nxb;
  nxbind *nif_host_nxb;
  uuid_t_1 nif_uuid;
  netif_stats nif_stats;
  uint32_t nif_flags;
  os_refcnt nif_refcnt;
  lck_mtx_t nif_agent_lock;
  netif_agent_flow_head nif_agent_flow_list;
  uint32_t nif_agent_flow_cnt;
  uint32_t nif_agent_flags;
  netagent_session_t nif_agent_session;
  uuid_t_1 nif_agent_uuid;
  uint32_t nif_hwassist;
  uint32_t nif_capabilities;
  uint32_t nif_capenable;
  uint64_t nif_input_rate;
  ifnet *nif_ifp;
  nx_flowswitch *nif_fsw;
  sk_nexusadv *nif_fsw_nxadv;
  netif_nexus_advisory *nif_netif_nxadv;
  pkt_copy_from_mbuf_t *nif_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *nif_pkt_copy_to_mbuf;
  pkt_copy_from_pkt_t *nif_pkt_copy_from_pkt;
  lck_mtx_t nif_filter_lock;
  uint32_t nif_filter_flags;
  uint32_t nif_filter_vp_cnt;
  uint32_t nif_filter_cnt;
  kern_pbufpool *nif_filter_pp;
  netif_filter_head nif_filter_list;
  union
  {
    nx_mbq nif_tx_processed_mbq[4];
    nx_pktq nif_tx_processed_pktq[4];
  };
  lck_mtx_t nif_flow_lock;
  uint32_t nif_vp_cnt;
  uint32_t nif_flow_flags;
  uint32_t nif_flow_cnt;
  netif_flow_head nif_flow_list;
  netif_flowtable *nif_flow_table;
  kern_channel *nif_hw_ch;
  uint32_t nif_hw_ch_refcnt;
  lck_rw_t nif_llink_lock;
  kern_nexus_netif_llink_init *nif_default_llink_params;
  netif_llink *nif_default_llink;
  struct
  {
    netif_llink *stqh_first;
    netif_llink **stqh_last;
  } nif_llink_list;
  uint16_t nif_llink_cnt;
  uint32_t nif_extended_capabilities;
  kern_nexus_capab_interface_advisory_config_fn_t nif_intf_adv_config;
  void *nif_intf_adv_prov_ctx;
  netif_qset_extensions nif_qset_extensions;
};

/* 10367 */
struct __attribute__((aligned(8))) nexus_vp_adapter_0
{
  nexus_adapter vpna_up;
  nx_flowswitch *vpna_fsw;
  nexus_port_t vpna_nx_port;
  uint16_t vpna_gencnt;
  boolean_t vpna_retry;
  boolean_t vpna_pid_bound;
  boolean_t vpna_defunct;
  pid_t vpna_pid;
};

/* 10368 */
struct __attribute__((aligned(8))) nx_flowswitch_4
{
  lck_rw_t fsw_lock;
  uint32_t fsw_tx_rings;
  uint32_t fsw_rx_rings;
  kern_nexus *fsw_nx;
  classq_pkt_type_t fsw_classq_enq_ptype;
  boolean_t fsw_classq_enabled;
  pkt_copy_from_pkt_t *fsw_pkt_copy_from_pkt;
  pkt_copy_from_mbuf_t *fsw_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *fsw_pkt_copy_to_mbuf;
  uint8_t fsw_frame_headroom;
  uint32_t fsw_src_lla_gencnt;
  uint32_t fsw_pending_nonviable;
  uint32_t fsw_low_power_gencnt;
  flow_mgr *fsw_flow_mgr;
  netagent_session_t fsw_agent_session;
  uuid_t_1 fsw_agent_uuid;
  ifnet *fsw_ifp;
  nexus_adapter *fsw_nifna;
  uint32_t fsw_state_flags;
  union
  {
    uint64_t _buf[1];
    uint8_t _eth_src[6];
  } __fsw_slladdr;
  int (*fsw_resolve)(nx_flowswitch *, flow_route *, __kern_packet *);
  void (*fsw_frame)(nx_flowswitch *, flow_route *, __kern_packet *);
  sa_family_t (*fsw_demux)(nx_flowswitch *, __kern_packet *);
  fsw_stats fsw_stats;
  lck_mtx_t fsw_detach_barrier_lock;
  uint32_t fsw_detach_flags;
  uint32_t fsw_detach_barriers;
  uint32_t fsw_detach_waiters;
  uint32_t fsw_ifp_dlt;
  uint32_t fsw_rx_largest_size;
  void (*fsw_ctor)(nx_flowswitch *, flow_route *);
  __nx_stats_fsw *fsw_closed_na_stats;
  fsw_ip_frag_mgr *fsw_ipfm;
  skoid fsw_skoid;
  netem *fsw_input_netem;
  kern_channel *fsw_dev_ch;
  kern_channel *fsw_host_ch;
  lck_mtx_t fsw_reap_lock;
  uint32_t fsw_reap_flags;
  uint32_t fsw_reap_requests;
  thread *fsw_reap_thread;
  char fsw_reap_name[64];
  uint64_t fsw_reap_last;
  uint64_t fsw_drain_channel_chk_last;
  uint64_t fsw_drain_netif_chk_last;
  lck_mtx_t fsw_linger_lock;
  flow_entry_linger_head fsw_linger_head;
  uint32_t fsw_linger_cnt;
};

/* 10369 */
struct __block_literal_1_12
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(flow_entry *);
  __block_descriptor_withcopydispose *__descriptor;
  struct *actual_space;
  struct *sf;
  size_t sf_size;
  void *out;
  size_t len;
};

/* 10370 */
struct flow_owner_2
{
  struct
  {
    flow_owner *rbe_left;
    flow_owner *rbe_right;
    flow_owner *rbe_parent;
  } fo_link;
  flow_entry_id_tree fo_flow_entry_id_head;
  const flow_owner_bucket *fo_bucket;
  void *fo_context;
  pid_t fo_pid;
  bool fo_nx_port_pid_bound;
  bool fo_nx_port_destroyed;
  bool fo_low_latency;
  nexus_port_t fo_nx_port;
  uuid_t_1 fo_key;
  nexus_adapter *const fo_nx_port_na;
  nx_flowswitch *const fo_fsw;
  bitmap_t *fo_flowadv_bmap;
  uint32_t fo_flowadv_max;
  uint32_t fo_num_flowadv;
  char fo_name[24];
};

/* 10371 */
struct nx_port_info_0
{
  uintptr_t npi_nah;
  nxbind *npi_nxb;
  void *npi_info;
};

/* 10372 */
struct kern_nexus_provider_3
{
  uint32_t nxprov_refcnt;
  uint32_t nxprov_flags;
  struct
  {
    kern_nexus_provider *stqe_next;
  } nxprov_link;
  struct
  {
    kern_nexus *stqh_first;
    kern_nexus **stqh_last;
  } nxprov_nx_head;
  uint32_t nxprov_nx_count;
  nxctl *nxprov_ctl;
  uuid_t_1 nxprov_uuid;
  kern_nexus_domain_provider *nxprov_dom_prov;
  union
  {
    kern_nexus_provider_init nxprov_ext;
    kern_nexus_netif_provider_init nxprov_netif_ext;
  };
  nxprov_params *nxprov_params;
  skmem_region_params nxprov_region_params[28];
};

/* 10373 */
struct kern_nexus_provider_4
{
  uint32_t nxprov_refcnt;
  uint32_t nxprov_flags;
  struct
  {
    kern_nexus_provider *stqe_next;
  } nxprov_link;
  struct
  {
    kern_nexus *stqh_first;
    kern_nexus **stqh_last;
  } nxprov_nx_head;
  uint32_t nxprov_nx_count;
  nxctl *nxprov_ctl;
  uuid_t_1 nxprov_uuid;
  kern_nexus_domain_provider *nxprov_dom_prov;
  union
  {
    kern_nexus_provider_init_2 nxprov_ext;
    kern_nexus_netif_provider_init_1 nxprov_netif_ext;
  };
  nxprov_params *nxprov_params;
  skmem_region_params nxprov_region_params[28];
};

/* 10374 */
struct nxctl_init
{
  uint32_t ni_version;
  uint32_t __ni_align;
  guardid_t ni_guard;
};

/* 10375 */
struct __attribute__((aligned(8))) socket_0
{
  int so_zone;
  short so_type;
  u_short so_error;
  u_int32_t so_options;
  short so_linger;
  short so_state;
  void *so_pcb;
  protosw *so_proto;
  socket *so_head;
  struct
  {
    socket *tqh_first;
    socket **tqh_last;
  } so_incomp;
  struct
  {
    socket *tqh_first;
    socket **tqh_last;
  } so_comp;
  struct
  {
    socket *tqe_next;
    socket **tqe_prev;
  } so_list;
  short so_qlen;
  short so_incqlen;
  short so_qlimit;
  short so_timeo;
  pid_t so_pgid;
  u_int32_t so_oobmark;
  sockbuf so_rcv;
  sockbuf so_snd;
  caddr_t so_tpcb;
  void (*so_event)(socket *, void *, uint32_t);
  void *so_eventarg;
  kauth_cred_t so_cred;
  so_gen_t so_gencnt;
  struct
  {
    socket *stqe_next;
  } so_cache_ent;
  caddr_t so_saved_pcb;
  u_int64_t cache_timestamp;
  uint32_t so_eventmask;
  pid_t last_pid;
  u_int64_t last_upid;
  socket_filter_entry *so_filt;
  u_int32_t so_flags;
  u_int32_t so_flags1;
  uint32_t so_upcallusecount;
  int so_usecount;
  int so_retaincnt;
  uint16_t so_traffic_class;
  int8_t so_netsvctype;
  uint8_t so_restrictions;
  thread_t_0 so_send_filt_thread;
  void *lock_lr[4];
  void *unlock_lr[4];
  u_int8_t next_lock_lr;
  u_int8_t next_unlock_lr;
  u_int16_t so_pktheadroom;
  u_int32_t so_ifdenied_notifies;
  thread_t_0 so_background_thread;
  data_stats so_tc_stats[4];
  klist so_klist;
  flow_divert_pcb *so_fd_pcb;
  soflow_db *so_flow_db;
  cfil_info *so_cfil;
  u_int32_t so_state_change_cnt;
  pid_t e_pid;
  u_int64_t e_upid;
  pid_t so_rpid;
  uuid_t_1 last_uuid;
  uuid_t_1 e_uuid;
  uuid_t_1 so_vuuid;
  uuid_t_1 so_ruuid;
  int32_t so_policy_gencnt;
  u_int64_t so_extended_bk_start;
  u_int8_t so_fallback_mode;
  u_int8_t so_log_seqn;
  uint8_t so_mpkl_send_proto;
  uuid_t_1 so_mpkl_send_uuid;
};

/* 10376 */
struct vfstable_2
{
  const vfsops *vfc_vfsops;
  char vfc_name[15];
  int vfc_typenum;
  int vfc_refcount;
  int vfc_flags;
  int (*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);
  vfstable *vfc_next;
  int32_t vfc_reserved1;
  int32_t vfc_reserved2;
  int vfc_vfsflags;
  void *vfc_descptr;
  uint32_t vfc_descsize;
  sysctl_oid_0 *vfc_sysctl;
};

/* 10377 */
struct vfs_attr_0
{
  uint64_t f_supported;
  uint64_t f_active;
  uint64_t f_objcount;
  uint64_t f_filecount;
  uint64_t f_dircount;
  uint64_t f_maxobjcount;
  uint32_t f_bsize;
  __attribute__((packed)) __attribute__((aligned(1))) size_t f_iosize;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_blocks;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_bfree;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_bavail;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_bused;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_files;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_ffree;
  fsid_t f_fsid;
  uid_t f_owner;
  vol_capabilities_attr_t f_capabilities;
  vol_attributes_attr_t f_attributes;
  timespec f_create_time;
  timespec f_modify_time;
  timespec f_access_time;
  timespec f_backup_time;
  uint32_t f_fssubtype;
  __attribute__((packed)) __attribute__((aligned(1))) char *f_vol_name;
  uint16_t f_signature;
  uint16_t f_carbon_fsid;
  uuid_t_1 f_uuid;
  uint64_t f_quota;
  uint64_t f_reserved;
};

/* 10378 */
struct ifnet_init_eparams_0
{
  u_int32_t ver;
  u_int32_t len;
  u_int32_t flags;
  const void *uniqueid;
  u_int32_t uniqueid_len;
  const char *name;
  u_int32_t unit;
  ifnet_family_t family;
  u_int32_t type;
  u_int32_t sndq_maxlen;
  ifnet_output_func output;
  ifnet_pre_enqueue_func pre_enqueue;
  ifnet_start_func start;
  ifnet_ctl_func output_ctl;
  u_int32_t output_sched_model;
  u_int32_t output_target_qdelay;
  u_int64_t output_bw;
  u_int64_t output_bw_max;
  u_int64_t output_lt;
  u_int64_t output_lt_max;
  u_int16_t start_delay_qlen;
  u_int16_t start_delay_timeout;
  u_int32_t _reserved[3];
  ifnet_input_poll_func input_poll;
  ifnet_ctl_func input_ctl;
  u_int32_t rcvq_maxlen;
  u_int32_t __reserved;
  u_int64_t input_bw;
  u_int64_t input_bw_max;
  u_int64_t input_lt;
  u_int64_t input_lt_max;
  u_int64_t ___reserved[2];
  ifnet_demux_func demux;
  ifnet_add_proto_func add_proto;
  ifnet_del_proto_func del_proto;
  ifnet_check_multi check_multi;
  ifnet_framer_func_0 framer;
  void *softc;
  ifnet_ioctl_func ioctl;
  ifnet_set_bpf_tap set_bpf_tap;
  ifnet_detached_func detach;
  ifnet_event_func event;
  const void *broadcast_addr;
  u_int32_t broadcast_len;
  ifnet_framer_extended_func framer_extended;
  ifnet_subfamily_t subfamily;
  u_int16_t tx_headroom;
  u_int16_t tx_trailer;
  u_int32_t rx_mit_ival;
  u_int32_t ____reserved;
  ifnet_free_func free;
};

/* 10379 */
struct nx_netif_4
{
  lck_rw_t nif_lock;
  kern_nexus *nif_nx;
  nxbind *nif_dev_nxb;
  nxbind *nif_host_nxb;
  uuid_t_1 nif_uuid;
  netif_stats nif_stats;
  uint32_t nif_flags;
  os_refcnt nif_refcnt;
  lck_mtx_t nif_agent_lock;
  netif_agent_flow_head nif_agent_flow_list;
  uint32_t nif_agent_flow_cnt;
  uint32_t nif_agent_flags;
  netagent_session_t nif_agent_session;
  uuid_t_1 nif_agent_uuid;
  uint32_t nif_hwassist;
  uint32_t nif_capabilities;
  uint32_t nif_capenable;
  uint64_t nif_input_rate;
  ifnet *nif_ifp;
  nx_flowswitch *nif_fsw;
  sk_nexusadv *nif_fsw_nxadv;
  netif_nexus_advisory *nif_netif_nxadv;
  pkt_copy_from_mbuf_t *nif_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *nif_pkt_copy_to_mbuf;
  pkt_copy_from_pkt_t *nif_pkt_copy_from_pkt;
  lck_mtx_t nif_filter_lock;
  uint32_t nif_filter_flags;
  uint32_t nif_filter_vp_cnt;
  uint32_t nif_filter_cnt;
  kern_pbufpool *nif_filter_pp;
  netif_filter_head nif_filter_list;
  union
  {
    nx_mbq nif_tx_processed_mbq[4];
    nx_pktq nif_tx_processed_pktq[4];
  };
  lck_mtx_t nif_flow_lock;
  uint32_t nif_vp_cnt;
  uint32_t nif_flow_flags;
  uint32_t nif_flow_cnt;
  netif_flow_head nif_flow_list;
  netif_flowtable *nif_flow_table;
  kern_channel *nif_hw_ch;
  uint32_t nif_hw_ch_refcnt;
  lck_rw_t nif_llink_lock;
  kern_nexus_netif_llink_init *nif_default_llink_params;
  netif_llink *nif_default_llink;
  struct
  {
    netif_llink *stqh_first;
    netif_llink **stqh_last;
  } nif_llink_list;
  uint16_t nif_llink_cnt;
  uint32_t nif_extended_capabilities;
  kern_nexus_capab_interface_advisory_config_fn_t nif_intf_adv_config;
  void *nif_intf_adv_prov_ctx;
  netif_qset_extensions nif_qset_extensions;
};

/* 10380 */
struct ch_list_req
{
  uuid_t_1 cl_nx_uuid;
  uint32_t cl_num_ch_uuids;
  uint32_t __cl_align;
  user_addr_t_0 cl_ch_uuids;
};

/* 10381 */
struct nx_list_req
{
  uuid_t_1 nl_prov_uuid;
  uint32_t nl_num_nx_uuids;
  uint32_t __nl_align;
  user_addr_t_0 nl_nx_uuids;
};

/* 10382 */
struct nxprov_list_req
{
  uint32_t nrl_num_regs;
  uint32_t __nrl_align;
  user_addr_t_0 nrl_regs;
};

/* 10383 */
struct __block_literal_1_13
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(nexus_port_t);
  __block_descriptor *__descriptor;
  kern_nexus *nx;
};

/* 10384 */
struct __attribute__((aligned(8))) nx_flowswitch_5
{
  lck_rw_t fsw_lock;
  uint32_t fsw_tx_rings;
  uint32_t fsw_rx_rings;
  kern_nexus *fsw_nx;
  classq_pkt_type_t fsw_classq_enq_ptype;
  boolean_t fsw_classq_enabled;
  pkt_copy_from_pkt_t *fsw_pkt_copy_from_pkt;
  pkt_copy_from_mbuf_t *fsw_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *fsw_pkt_copy_to_mbuf;
  uint8_t fsw_frame_headroom;
  uint32_t fsw_src_lla_gencnt;
  uint32_t fsw_pending_nonviable;
  uint32_t fsw_low_power_gencnt;
  flow_mgr *fsw_flow_mgr;
  netagent_session_t fsw_agent_session;
  uuid_t_1 fsw_agent_uuid;
  ifnet *fsw_ifp;
  nexus_adapter *fsw_nifna;
  uint32_t fsw_state_flags;
  union
  {
    uint64_t _buf[1];
    uint8_t _eth_src[6];
  } __fsw_slladdr;
  int (*fsw_resolve)(nx_flowswitch *, flow_route *, __kern_packet *);
  void (*fsw_frame)(nx_flowswitch *, flow_route *, __kern_packet *);
  sa_family_t (*fsw_demux)(nx_flowswitch *, __kern_packet *);
  fsw_stats fsw_stats;
  lck_mtx_t fsw_detach_barrier_lock;
  uint32_t fsw_detach_flags;
  uint32_t fsw_detach_barriers;
  uint32_t fsw_detach_waiters;
  uint32_t fsw_ifp_dlt;
  uint32_t fsw_rx_largest_size;
  void (*fsw_ctor)(nx_flowswitch *, flow_route *);
  __nx_stats_fsw *fsw_closed_na_stats;
  fsw_ip_frag_mgr *fsw_ipfm;
  skoid_0 fsw_skoid;
  netem *fsw_input_netem;
  kern_channel *fsw_dev_ch;
  kern_channel *fsw_host_ch;
  lck_mtx_t fsw_reap_lock;
  uint32_t fsw_reap_flags;
  uint32_t fsw_reap_requests;
  thread *fsw_reap_thread;
  char fsw_reap_name[64];
  uint64_t fsw_reap_last;
  uint64_t fsw_drain_channel_chk_last;
  uint64_t fsw_drain_netif_chk_last;
  lck_mtx_t fsw_linger_lock;
  flow_entry_linger_head fsw_linger_head;
  uint32_t fsw_linger_cnt;
};

/* 10385 */
struct nx_netif_5
{
  lck_rw_t nif_lock;
  kern_nexus *nif_nx;
  nxbind *nif_dev_nxb;
  nxbind *nif_host_nxb;
  uuid_t_1 nif_uuid;
  netif_stats nif_stats;
  uint32_t nif_flags;
  os_refcnt nif_refcnt;
  lck_mtx_t nif_agent_lock;
  netif_agent_flow_head nif_agent_flow_list;
  uint32_t nif_agent_flow_cnt;
  uint32_t nif_agent_flags;
  netagent_session_t nif_agent_session;
  uuid_t_1 nif_agent_uuid;
  uint32_t nif_hwassist;
  uint32_t nif_capabilities;
  uint32_t nif_capenable;
  uint64_t nif_input_rate;
  ifnet *nif_ifp;
  nx_flowswitch *nif_fsw;
  sk_nexusadv *nif_fsw_nxadv;
  netif_nexus_advisory *nif_netif_nxadv;
  pkt_copy_from_mbuf_t *nif_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *nif_pkt_copy_to_mbuf;
  pkt_copy_from_pkt_t *nif_pkt_copy_from_pkt;
  lck_mtx_t nif_filter_lock;
  uint32_t nif_filter_flags;
  uint32_t nif_filter_vp_cnt;
  uint32_t nif_filter_cnt;
  kern_pbufpool *nif_filter_pp;
  netif_filter_head nif_filter_list;
  union
  {
    nx_mbq nif_tx_processed_mbq[4];
    nx_pktq nif_tx_processed_pktq[4];
  };
  lck_mtx_t nif_flow_lock;
  uint32_t nif_vp_cnt;
  uint32_t nif_flow_flags;
  uint32_t nif_flow_cnt;
  netif_flow_head nif_flow_list;
  netif_flowtable *nif_flow_table;
  kern_channel *nif_hw_ch;
  uint32_t nif_hw_ch_refcnt;
  lck_rw_t nif_llink_lock;
  kern_nexus_netif_llink_init *nif_default_llink_params;
  netif_llink *nif_default_llink;
  struct
  {
    netif_llink *stqh_first;
    netif_llink **stqh_last;
  } nif_llink_list;
  uint16_t nif_llink_cnt;
  uint32_t nif_extended_capabilities;
  kern_nexus_capab_interface_advisory_config_fn_t nif_intf_adv_config;
  void *nif_intf_adv_prov_ctx;
  netif_qset_extensions nif_qset_extensions;
};

/* 10386 */
struct kern_channel_5
{
  lck_mtx_t ch_lock;
  nexus_adapter *ch_na;
  kern_nexus *ch_nexus;
  ch_info *ch_info;
  kern_pbufpool *ch_pp;
  uint32_t ch_refcnt;
  volatile uint32_t ch_flags;
  ring_id_t ch_first[5];
  ring_id_t ch_last[5];
  __user_channel_schema *ch_schema;
  ch_selinfo *ch_si[5];
  struct
  {
    kern_channel *stqe_next;
  } ch_link;
  struct
  {
    kern_channel *stqe_next;
  } ch_link_if_adv;
  void *ch_ctx;
  mach_vm_offset_t ch_schema_offset;
  skmem_arena_mmap_info ch_mmap;
  int ch_fd;
  pid_t ch_pid;
  char ch_name[32];
};

/* 10387 */
struct skmem_mag_0
{
  struct
  {
    skmem_mag *sle_next;
  } mg_link;
  skmem_magtype *mg_magtype;
  void *mg_round[1];
};

/* 10388 */
struct skmem_cache_0
{
  uint32_t skm_mode;
  skmem_ctor_fn_t skm_ctor;
  skmem_dtor_fn_t skm_dtor;
  skmem_reclaim_fn_t skm_reclaim;
  void *skm_private;
  lck_mtx_t skm_dp_lock;
  skmem_magtype *skm_magtype;
  skmem_maglist skm_full;
  skmem_maglist skm_empty;
  lck_mtx_t skm_sl_lock;
  skmem_slab_alloc_fn_t skm_slab_alloc;
  skmem_slab_free_fn_t skm_slab_free;
  size_t skm_chunksize;
  size_t skm_objsize;
  size_t skm_slabsize;
  size_t skm_hash_initial;
  size_t skm_hash_limit;
  size_t skm_hash_shift;
  size_t skm_hash_mask;
  skmem_bufctl_bkt *skm_hash_table;
  struct
  {
    skmem_slab *tqh_first;
    skmem_slab **tqh_last;
  } skm_sl_partial_list;
  struct
  {
    skmem_slab *tqh_first;
    skmem_slab **tqh_last;
  } skm_sl_empty_list;
  skmem_region *skm_region;
  uint32_t skm_cpu_mag_size;
  uint32_t skm_cpu_mag_resize;
  uint32_t skm_cpu_mag_purge;
  uint32_t skm_cpu_mag_reap;
  uint64_t skm_depot_contention;
  uint64_t skm_depot_contention_prev;
  uint32_t skm_depot_full;
  uint32_t skm_depot_empty;
  uint32_t skm_depot_ws_zero;
  uint32_t skm_sl_rescale;
  uint32_t skm_sl_create;
  uint32_t skm_sl_destroy;
  uint32_t skm_sl_alloc;
  uint32_t skm_sl_free;
  uint32_t skm_sl_partial;
  uint32_t skm_sl_empty;
  uint64_t skm_sl_alloc_fail;
  uint64_t skm_sl_bufinuse;
  uint64_t skm_sl_bufmax;
  struct
  {
    skmem_cache *tqe_next;
    skmem_cache **tqe_prev;
  } skm_link;
  char skm_name[64];
  uuid_t_1 skm_uuid;
  size_t skm_bufsize;
  size_t skm_bufalign;
  size_t skm_objalign;
  lck_mtx_t skm_rs_lock;
  thread *skm_rs_owner;
  uint32_t skm_rs_busy;
  uint32_t skm_rs_want;
  skmem_cpu_cache skm_cpu_cache[1];
};

/* 10389 */
struct __block_literal_1_14
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(cuckoo_node *, uint32_t);
  __block_descriptor_withcopydispose *__descriptor;
  struct *add_called;
  cuckoo_hashtable *tmp_h;
};

/* 10390 */
enum sync_mode_t : __int32
{
  CHANNEL_SYNC_TX = 0x0,
  CHANNEL_SYNC_RX = 0x1,
  CHANNEL_SYNC_UPP = 0x2,
};

/* 10391 */
typedef uint32_t sync_flags_t;

/* 10392 */
typedef struct *channel_ring_user_stats_t;

/* 10393 */
typedef struct *channel_ring_stats_t;

/* 10394 */
struct __attribute__((aligned(8))) nexus_netif_adapter_1
{
  nexus_adapter_1 nifna_up;
  nx_netif *nifna_netif;
  nx_netif_mit *nifna_tx_mit;
  nx_netif_mit *nifna_rx_mit;
  union
  {
    netif_filter *nifna_filter;
    netif_flow *nifna_flow;
  };
  uint16_t nifna_gencnt;
};

/* 10395 */
struct kern_channel_6
{
  lck_mtx_t ch_lock;
  nexus_adapter *ch_na;
  kern_nexus *ch_nexus;
  ch_info *ch_info;
  kern_pbufpool *ch_pp;
  uint32_t ch_refcnt;
  volatile uint32_t ch_flags;
  ring_id_t ch_first[5];
  ring_id_t ch_last[5];
  __user_channel_schema *ch_schema;
  ch_selinfo *ch_si[5];
  struct
  {
    kern_channel *stqe_next;
  } ch_link;
  struct
  {
    kern_channel *stqe_next;
  } ch_link_if_adv;
  void *ch_ctx;
  mach_vm_offset_t ch_schema_offset;
  skmem_arena_mmap_info ch_mmap;
  int ch_fd;
  pid_t ch_pid;
  char ch_name[32];
};

/* 10396 */
struct proc_3
{
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_list;
  _BYTE gap10[8];
  proc_ro_t p_proc_ro;
  pid_t p_ppid;
  pid_t p_original_ppid;
  pid_t p_pgrpid;
  uid_t p_uid;
  gid_t p_gid;
  uid_t p_ruid;
  gid_t p_rgid;
  uid_t p_svuid;
  gid_t p_svgid;
  pid_t p_sessionid;
  uint64_t p_puniqueid;
  lck_mtx_t p_mlock;
  pid_t p_pid;
  char p_stat;
  char p_shutdownstate;
  char p_kdebug;
  char p_btrace;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_pglist;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_sibling;
  struct
  {
    proc *lh_first;
  } p_children;
  struct
  {
    uthread *tqh_first;
    uthread **tqh_last;
  } p_uthlist;
  smrq_slink p_hash;
  persona *p_persona;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_persona_list;
  lck_mtx_t p_ucred_mlock;
  filedesc_0 p_fd;
  pstats *p_stats;
  struct
  {
    plimit *volatile __smr_ptr;
  } p_limit;
  struct
  {
    _BYTE gap0[8];
  } p_pgrp;
  sigacts p_sigacts;
  lck_spin_t p_slock;
  int p_siglist;
  unsigned int p_flag;
  unsigned int p_lflag;
  unsigned int p_listflag;
  unsigned int p_ladvflag;
  os_ref_atomic_t p_refcount;
  os_ref_atomic_t p_waitref;
  int p_childrencnt;
  int p_parentref;
  pid_t p_oppid;
  u_int p_xstat;
  int p_aio_total_count;
  itimerval p_realtimer;
  timeval p_rtime;
  itimerval p_vtimer_user;
  itimerval p_vtimer_prof;
  timeval p_rlim_cpu;
  int p_debugger;
  boolean_t sigwait;
  void *sigwait_thread;
  void *exit_thread;
  pid_t si_pid;
  u_int si_status;
  u_int si_code;
  uid_t si_uid;
  void *vm_shm;
  int p_ractive;
  pid_t p_responsible_pid;
  int p_dtrace_probes;
  u_int p_dtrace_count;
  uint8_t p_dtrace_stop;
  user_addr_t_0 p_dtrace_argv;
  user_addr_t_0 p_dtrace_envp;
  lck_mtx_t p_dtrace_sprlock;
  dtrace_ptss_page *p_dtrace_ptss_pages;
  dtrace_ptss_page_entry *p_dtrace_ptss_free_list;
  dtrace_helpers *p_dtrace_helpers;
  dof_ioctl_data *p_dtrace_lazy_dofs;
  union
  {
    struct __attribute__((aligned(8)))
    {
      u_int p_argslen;
      int p_argc;
      user_addr_t_0 user_stack;
      _BYTE gap10[8];
      off_t p_textoff;
      sigset_t p_sigmask;
      sigset_t p_sigignore;
      sigset_t p_sigcatch;
      u_char p_priority;
      u_char p_resv0;
      char p_nice;
      u_char p_resv1;
      command_t p_comm;
      proc_name_t p_name;
      uint8_t p_xhighbits;
      pid_t p_contproc;
      uint32_t p_pcaction;
      uint8_t p_uuid[16];
      cpu_type_t p_cputype;
      cpu_subtype_t_0 p_cpusubtype;
    };
    proc_forkcopy_data p_forkcopy;
  };
  struct
  {
    aio_workq_entry *tqh_first;
    aio_workq_entry **tqh_last;
  } p_aio_activeq;
  struct
  {
    aio_workq_entry *tqh_first;
    aio_workq_entry **tqh_last;
  } p_aio_doneq;
  klist p_klist;
  rusage_superset *p_ru;
  thread_t_0 p_signalholder;
  thread_t_0 p_transholder;
  int p_sigwaitcnt;
  u_short p_acflag;
  volatile u_short p_vfs_iopolicy;
  user_addr_t_0 p_threadstart;
  user_addr_t_0 p_wqthread;
  int p_pthsize;
  uint32_t p_pth_tsd_offset;
  user_addr_t_0 p_stack_addr_hint;
  workqueue *p_wqptr;
  timeval p_start;
  void *p_rcall;
  void *p_pthhash;
  volatile uint64_t was_throttled;
  volatile uint64_t did_throttle;
  uint64_t p_dispatchqueue_offset;
  uint64_t p_dispatchqueue_serialno_offset;
  uint64_t p_dispatchqueue_label_offset;
  uint64_t p_return_to_kernel_offset;
  uint64_t p_mach_thread_self_offset;
  uint64_t p_pthread_wq_quantum_offset;
  timeval vm_pressure_last_notify_tstamp;
  uint8_t p_crash_behavior;
  bool p_posix_spawn_failed;
  bool p_disallow_map_with_linking;
  uint32_t p_memstat_state;
  int32_t p_memstat_effectivepriority;
  int32_t p_memstat_requestedpriority;
  int32_t p_memstat_assertionpriority;
  uint32_t p_memstat_dirty;
  struct
  {
    proc *tqe_next;
    proc **tqe_prev;
  } p_memstat_list;
  uint64_t p_memstat_userdata;
  uint64_t p_memstat_idledeadline;
  uint64_t p_memstat_idle_start;
  uint64_t p_memstat_idle_delta;
  int32_t p_memstat_memlimit;
  int32_t p_memstat_memlimit_active;
  int32_t p_memstat_memlimit_inactive;
  int32_t p_memstat_relaunch_flags;
  uint32_t p_user_faults;
  uint32_t p_memlimit_increase;
  uint64_t p_crash_behavior_deadline;
  uint32_t p_crash_count;
  uint32_t p_throttle_timeout;
  os_reason *p_exit_reason;
  uint64_t p_user_data;
  char *p_subsystem_root_path;
};

/* 10397 */
struct __attribute__((aligned(32))) sk_stats_flowidns_record
{
  union
  {
    uint32_t _addr[4];
    in_addr _v4;
    in6_addr_0 _v6;
  } sfr_laddr;
  union
  {
    uint32_t _addr[4];
    in_addr _v4;
    in6_addr_0 _v6;
  } sfr_raddr;
  union
  {
    struct
    {
      uint16_t _lport;
      uint16_t _rport;
    } sfr_ports;
    uint32_t sfr_spi;
    uint32_t sfr_protoid;
  };
  uint32_t sfr_flowid;
  uint8_t sfr_ipproto;
  uint8_t sfr_af;
};

/* 10398 */
struct sk_stats_flowidns_header
{
  uint64_t sfh_nallocs;
  uint64_t sfh_nreleases;
  uint64_t sfh_ncollisions;
  uint32_t sfh_domain;
  uint32_t sfh_nrecords;
};

/* 10399 */
struct __block_literal_1_15
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(flow_entry *);
  __block_descriptor *__descriptor;
  u_int8_t *bitfield;
  protocol_family_t protocol;
  u_int32_t flags;
};

/* 10400 */
struct __attribute__((aligned(16))) netns_ctl_dump_record
{
  in_port_t ncdr_port;
  in_port_t ncdr_port_end;
  uint32_t ncdr_skywalk_refs;
  uint32_t ncdr_bsd_refs;
  uint32_t ncdr_pf_refs;
  uint32_t ncdr_listener_refs;
};

/* 10401 */
struct __attribute__((aligned(16))) netns_ctl_dump_header
{
  union
  {
    uint32_t ncdh_addr[4];
    in_addr ncdh_inaddr;
    in6_addr_0 ncdh_in6addr;
  };
  uint8_t ncdh_addr_len;
  uint8_t ncdh_proto;
  uint32_t ncdh_n_records;
};

/* 10402 */
struct vfstable_3
{
  const vfsops *vfc_vfsops;
  char vfc_name[15];
  int vfc_typenum;
  int vfc_refcount;
  int vfc_flags;
  int (*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);
  vfstable *vfc_next;
  int32_t vfc_reserved1;
  int32_t vfc_reserved2;
  int vfc_vfsflags;
  void *vfc_descptr;
  uint32_t vfc_descsize;
  sysctl_oid_0 *vfc_sysctl;
};

/* 10403 */
struct null_mount_conf
{
  uint64_t flags;
};

/* 10404 */
struct vnode_resolve_3
{
  lck_mtx_t vr_lock;
  trigger_vnode_resolve_callback_t_3 vr_resolve_func;
  trigger_vnode_unresolve_callback_t_1 vr_unresolve_func;
  trigger_vnode_rearm_callback_t vr_rearm_func;
  trigger_vnode_reclaim_callback_t_0 vr_reclaim_func;
  void *vr_data;
  uint32_t vr_flags;
  uint32_t vr_lastseq;
};

/* 10405 */
struct vfsops_8
{
  int (*vfs_mount)(mount *, vnode_t, user_addr_t_0, vfs_context_t);
  int (*vfs_start)(mount *, int, vfs_context_t);
  int (*vfs_unmount)(mount *, int, vfs_context_t);
  int (*vfs_root)(mount *, vnode **, vfs_context_t);
  int (*vfs_quotactl)(mount *, int, uid_t, caddr_t, vfs_context_t);
  int (*vfs_getattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_sync)(mount *, int, vfs_context_t);
  int (*vfs_vget)(mount *, ino64_t, vnode **, vfs_context_t);
  int (*vfs_fhtovp)(mount *, int, unsigned __int8 *, vnode **, vfs_context_t);
  int (*vfs_vptofh)(vnode *, int *, unsigned __int8 *, vfs_context_t);
  int (*vfs_init)(vfsconf *);
  int (*vfs_sysctl)(int *, u_int, user_addr_t_0, size_t *, user_addr_t_0, size_t, vfs_context_t);
  int (*vfs_setattr)(mount *, vfs_attr *, vfs_context_t);
  int (*vfs_ioctl)(mount *, u_long, caddr_t, int, vfs_context_t);
  int (*vfs_vget_snapdir)(mount *, vnode **, vfs_context_t);
  void *vfs_reserved5;
  void *vfs_reserved4;
  void *vfs_reserved3;
  void *vfs_reserved2;
  void *vfs_reserved1;
};

/* 10406 */
enum kptimer_period_limit : __int32
{
  kptimer_period_limit::KTPL_FG = 0x0,
  kptimer_period_limit::KTPL_BG = 0x1,
  kptimer_period_limit::KTPL_FG_PET = 0x2,
  kptimer_period_limit::KTPL_BG_PET = 0x3,
  kptimer_period_limit::KTPL_MAX = 0x4,
};

/* 10407 */
enum kperf_request : __int32
{
  kperf_request::REQ_SAMPLING = 0x0,
  kperf_request::REQ_RESET = 0x1,
  kperf_request::REQ_ACTION_COUNT = 0x2,
  kperf_request::REQ_ACTION_SAMPLERS = 0x3,
  kperf_request::REQ_ACTION_USERDATA = 0x4,
  kperf_request::REQ_ACTION_FILTER_BY_TASK = 0x5,
  kperf_request::REQ_ACTION_FILTER_BY_PID = 0x6,
  kperf_request::REQ_ACTION_UCALLSTACK_DEPTH = 0x7,
  kperf_request::REQ_ACTION_KCALLSTACK_DEPTH = 0x8,
  kperf_request::REQ_TIMER_COUNT = 0x9,
  kperf_request::REQ_TIMER_PERIOD = 0xA,
  kperf_request::REQ_TIMER_PET = 0xB,
  kperf_request::REQ_TIMER_ACTION = 0xC,
  kperf_request::REQ_KDBG_CSWITCH = 0xD,
  kperf_request::REQ_BLESS = 0xE,
  kperf_request::REQ_BLESS_PREEMPT = 0xF,
  kperf_request::REQ_PET_IDLE_RATE = 0x10,
  kperf_request::REQ_LIGHTWEIGHT_PET = 0x11,
  kperf_request::REQ_KDEBUG_FILTER = 0x12,
  kperf_request::REQ_KDEBUG_ACTION = 0x13,
  kperf_request::REQ_LAZY_WAIT_TIME_THRESHOLD = 0x14,
  kperf_request::REQ_LAZY_WAIT_ACTION = 0x15,
  kperf_request::REQ_LAZY_CPU_TIME_THRESHOLD = 0x16,
  kperf_request::REQ_LAZY_CPU_ACTION = 0x17,
};

/* 10408 */
struct kmem_return_t_0
{
  kern_return_t kmr_return;
  union
  {
    vm_address_t_1 kmr_address;
    vm_size_t_0 kmr_size;
    void *kmr_ptr;
    vm_map_t_0 kmr_submap;
  };
};

/* 10409 */
struct vnode_resolve_4
{
  lck_mtx_t vr_lock;
  trigger_vnode_resolve_callback_t_4 vr_resolve_func;
  trigger_vnode_unresolve_callback_t vr_unresolve_func;
  trigger_vnode_rearm_callback_t vr_rearm_func;
  trigger_vnode_reclaim_callback_t vr_reclaim_func;
  void *vr_data;
  uint32_t vr_flags;
  uint32_t vr_lastseq;
};

/* 10410 */
struct memory_object_1
{
  mo_ipc_object_bits_t mo_ikot;
  os_ref_atomic_t mo_ref;
  const memory_object_pager_ops_2 *mo_pager_ops;
  memory_object_control_t mo_control;
};

/* 10411 */
struct domains_head
{
  domain *tqh_first;
  domain **tqh_last;
};

/* 10412 */
struct timezone
{
  int tz_minuteswest;
  int tz_dsttime;
};

/* 10413 */
struct timex
{
  unsigned int modes;
  long offset;
  long freq;
  long maxerror;
  long esterror;
  int status;
  long constant;
  long precision;
  long tolerance;
  long ppsfreq;
  long jitter;
  int shift;
  long stabil;
  long jitcnt;
  long calcnt;
  long errcnt;
  long stbcnt;
};

/* 10414 */
struct user32_timex
{
  u_int32_t modes;
  user32_long_t offset;
  user32_long_t freq;
  user32_long_t maxerror;
  user32_long_t esterror;
  __int32_t status;
  user32_long_t constant;
  user32_long_t precision;
  user32_long_t tolerance;
  user32_long_t ppsfreq;
  user32_long_t jitter;
  __int32_t shift;
  user32_long_t stabil;
  user32_long_t jitcnt;
  user32_long_t calcnt;
  user32_long_t errcnt;
  user32_long_t stbcnt;
};

/* 10415 */
struct user64_timex
{
  u_int32_t modes;
  user64_long_t offset;
  user64_long_t freq;
  user64_long_t maxerror;
  user64_long_t esterror;
  __int32_t status;
  user64_long_t constant;
  user64_long_t precision;
  user64_long_t tolerance;
  user64_long_t ppsfreq;
  user64_long_t jitter;
  __int32_t shift;
  user64_long_t stabil;
  user64_long_t jitcnt;
  user64_long_t calcnt;
  user64_long_t errcnt;
  user64_long_t stbcnt;
};

/* 10416 */
struct user32_ntptimeval
{
  user32_timespec time;
  user32_long_t maxerror;
  user32_long_t esterror;
  user32_long_t tai;
  __int32_t time_state;
};

/* 10417 */
struct user64_ntptimeval
{
  user64_timespec time;
  user64_long_t maxerror;
  user64_long_t esterror;
  user64_long_t tai;
  __int64_t time_state;
};

/* 10418 */
typedef timer_call timer_call_data_t_1;

/* 10419 */
typedef int64_t l_fp;

/* 10420 */
typedef _dk_cs_unmap _dk_cs_unmap_t;

/* 10421 */
struct dk_unmap_t
{
  dk_extent_t *extents;
  uint32_t extentsCount;
  uint32_t options;
};

/* 10422 */
struct fdt_iterator
{
  int fdti_fd;
  fileproc *fdti_fp;
};

/* 10423 */
struct ifnet_6
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func if_output_dlil;
  volatile ifnet_start_func if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func if_input_ctl;
  ifnet_ioctl_func if_ioctl;
  ifnet_set_bpf_tap if_set_bpf_tap;
  ifnet_detached_func if_free;
  ifnet_demux_func if_demux;
  ifnet_event_func_1 if_event;
  ifnet_framer_func_0 if_framer_legacy;
  ifnet_framer_extended_func if_framer;
  ifnet_add_proto_func if_add_proto;
  ifnet_del_proto_func if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route if_fwd_route;
  route if_src_route;
  route_in6 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 10424 */
struct dk_set_tier_t
{
  dk_extent_t *extents;
  uint32_t extentsCount;
  uint8_t tier;
  uint8_t reserved0104[3];
};

/* 10425 */
typedef int pager_return_t;

/* 10426 */
typedef hvg_hcall_vmcore_file hvg_hcall_vmcore_file_t;

/* 10427 */
struct rtentry_3
{
  radix_node rt_nodes[2];
  lck_mtx_t rt_lock;
  uint32_t rt_refcnt;
  uint32_t rt_flags;
  uint32_t rt_genid;
  sockaddr *rt_gateway;
  ifnet *rt_ifp;
  ifaddr *rt_ifa;
  sockaddr *rt_genmask;
  void *rt_llinfo;
  void (*rt_llinfo_get_ri)(rtentry *, rt_reach_info *);
  void (*rt_llinfo_get_iflri)(rtentry *, ifnet_llreach_info *);
  void (*rt_llinfo_purge)(rtentry *);
  void (*rt_llinfo_free)(void *);
  void (*rt_llinfo_refresh)(rtentry *);
  rt_metrics rt_rmx;
  rtentry *rt_gwroute;
  rtentry *rt_parent;
  nstat_counts *rt_stats;
  void (*rt_if_ref_fn)(ifnet *, int);
  uint32_t *rt_tree_genid;
  uint64_t rt_expire;
  uint64_t base_calendartime;
  uint64_t base_uptime;
  u_int32_t rtt_hist[10];
  u_int32_t rtt_min;
  u_int32_t rtt_expire_ts;
  u_int8_t rtt_index;
  eventhandler_lists_ctxt rt_evhdlr_ctxt;
};

/* 10428 */
struct soflow_entry_head
{
  soflow_hash_entry *tqh_first;
  soflow_hash_entry **tqh_last;
};

/* 10429 */
struct __attribute__((aligned(8))) inpcbinfo_0
{
  struct
  {
    inpcbinfo *tqe_next;
    inpcbinfo **tqe_prev;
  } ipi_entry;
  inpcb_timer_func_t ipi_gc;
  inpcb_timer_func_t ipi_timer;
  intimercount ipi_gc_req;
  intimercount ipi_timer_req;
  lck_rw_t ipi_lock;
  inpcbhead *ipi_listhead;
  uint32_t ipi_count;
  uint32_t ipi_twcount;
  uint64_t ipi_gencnt;
  uint16_t ipi_lastport;
  uint16_t ipi_lastlow;
  uint16_t ipi_lasthi;
  zone_or_view_t ipi_zone;
  inpcbhead *ipi_hashbase;
  u_long ipi_hashmask;
  inpcbporthead *ipi_porthashbase;
  u_long ipi_porthashmask;
  lck_attr_t ipi_lock_attr;
  lck_grp_t *ipi_lock_grp;
  u_int32_t ipi_flags;
};

/* 10430 */
typedef proc_policy_cpuusage_attr proc_policy_cpuusage_attr_t;

/* 10431 */
struct __block_literal_1_16
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(size_t, mach_port_name_t, fileglob *);
  __block_descriptor *__descriptor;
  size_t needfileports;
  proc_fileportinfo *pfi;
};

/* 10432 */
struct proc_regionpath
{
  uint64_t prpo_addr;
  uint64_t prpo_regionlength;
  char prpo_path[1024];
};

/* 10433 */
struct proc_vnodepathinfo
{
  vnode_info_path pvi_cdir;
  vnode_info_path pvi_rdir;
};

/* 10434 */
struct proc_regionwithpathinfo
{
  proc_regioninfo prp_prinfo;
  vnode_info_path prp_vip;
};

/* 10435 */
struct channel_fdinfo
{
  proc_fileinfo pfi;
  proc_channel_info channelinfo;
};

/* 10436 */
struct kqueue_fdinfo
{
  proc_fileinfo pfi;
  kqueue_info kqueueinfo;
};

/* 10437 */
struct psem_fdinfo
{
  proc_fileinfo pfi;
  psem_info pseminfo;
};

/* 10438 */
struct vnode_fdinfo
{
  proc_fileinfo pfi;
  vnode_info pvi;
};

/* 10439 */
struct pipe_fdinfo
{
  proc_fileinfo pfi;
  pipe_info pipeinfo;
};

/* 10440 */
struct pshm_fdinfo
{
  proc_fileinfo pfi;
  pshm_info pshminfo;
};

/* 10441 */
struct socket_fdinfo
{
  proc_fileinfo pfi;
  socket_info psi;
};

/* 10442 */
struct vnode_fdinfowithpath
{
  proc_fileinfo pfi;
  vnode_info_path pvip;
};

/* 10443 */
struct proc_originatorinfo
{
  uuid_t_1 originator_uuid;
  pid_t originator_pid;
  uint64_t p_reserve2;
  uint64_t p_reserve3;
  uint64_t p_reserve4;
};

/* 10444 */
struct proc_taskallinfo
{
  proc_bsdinfo pbsd;
  proc_taskinfo ptinfo;
};

/* 10445 */
struct proc_bsdinfowithuniqid
{
  proc_bsdinfo pbsd;
  proc_uniqidentifierinfo p_uniqidentifier;
};

/* 10446 */
typedef u_int8_t sockopt_dir;

/* 10447 */
struct socket_filter_list
{
  socket_filter *tqh_first;
  socket_filter **tqh_last;
};

/* 10448 */
typedef mach_port_t_1 mem_entry_name_port_t;

/* 10449 */
struct psemstats
{
  long goodhits;
  long neghits;
  long badhits;
  long falsehits;
  long miss;
  long longnames;
};

/* 10450 */
struct pseminfo_0
{
  unsigned int psem_flags;
  unsigned int psem_usecount;
  mode_t psem_mode;
  uid_t psem_uid;
  gid_t psem_gid;
  char psem_name[32];
  semaphore_t_0 psem_semobject;
  label *psem_label;
  pid_t psem_creator_pid;
  uint64_t psem_creator_uniqueid;
};

/* 10451 */
typedef crypt_file_data crypt_file_data_t;

/* 10452 */
typedef pager_crypt_info pager_crypt_info_t;

/* 10453 */
struct __attribute__((aligned(8))) image_params_0
{
  user_addr_t_0 ip_user_fname;
  user_addr_t_0 ip_user_argv;
  user_addr_t_0 ip_user_envv;
  int ip_seg;
  vnode *ip_vp;
  vnode_attr *ip_vattr;
  vnode_attr *ip_origvattr;
  cpu_type_t ip_origcputype;
  cpu_subtype_t_0 ip_origcpusubtype;
  char *ip_vdata;
  int ip_flags;
  int ip_argc;
  int ip_envc;
  int ip_applec;
  char *ip_startargv;
  char *ip_endargv;
  char *ip_endenvv;
  char *ip_strings;
  char *ip_strendp;
  char *ip_subsystem_root_path;
  int ip_argspace;
  int ip_strspace;
  user_size_t ip_arch_offset;
  user_size_t ip_arch_size;
  char ip_interp_buffer[512];
  int ip_interp_sugid_fd;
  vfs_context *ip_vfs_context;
  nameidata *ip_ndp;
  thread_t_0 ip_new_thread;
  label *ip_execlabelp;
  label *ip_scriptlabelp;
  vnode *ip_scriptvp;
  unsigned int ip_csflags;
  int ip_mac_return;
  void *ip_px_sa;
  void *ip_px_sfa;
  void *ip_px_spa;
  ip_px_smpx_s ip_px_smpx;
  void *ip_px_persona;
  void *ip_px_pcred_info;
  void *ip_cs_error;
  char *ip_inherited_shared_region_id;
  uint64_t ip_dyld_fsid;
  uint64_t ip_dyld_fsobjid;
  uint64_t ip_inherited_jop_pid;
  unsigned int ip_simulator_binary;
};

/* 10454 */
struct msginfo_0
{
  int msgmax;
  int msgmni;
  int msgmnb;
  int msgtql;
  int msgssz;
  int msgseg;
};

/* 10455 */
typedef user_semun user_semun_t;

/* 10456 */
struct seminfo
{
  int semmap;
  int semmni;
  int semmns;
  int semmnu;
  int semmsl;
  int semopm;
  int semume;
  int semusz;
  int semvmx;
  int semaem;
};

/* 10457 */
struct shminfo
{
  int64_t shmmax;
  int64_t shmmin;
  int64_t shmmni;
  int64_t shmseg;
  int64_t shmall;
};

/* 10458 */
struct __attribute__((aligned(8))) xvsockpcb
{
  u_int32_t xv_len;
  u_int64_t xv_vsockpp;
  u_int32_t xvp_local_cid;
  u_int32_t xvp_local_port;
  u_int32_t xvp_remote_cid;
  u_int32_t xvp_remote_port;
  u_int32_t xvp_rxcnt;
  u_int32_t xvp_txcnt;
  u_int32_t xvp_peer_rxhiwat;
  u_int32_t xvp_peer_rxcnt;
  pid_t xvp_last_pid;
  vsock_gen_t xvp_gencnt;
  xsocket xv_socket;
};

/* 10459 */
struct xvsockpgen
{
  u_int32_t xvg_len;
  u_int64_t xvg_count;
  vsock_gen_t xvg_gen;
  so_gen_t xvg_sogen;
};

/* 10460 */
struct vsock_transport_0
{
  void *provider;
  int (*get_cid)(void *, uint32_t *);
  int (*attach_socket)(void *);
  int (*detach_socket)(void *);
  int (*put_message)(void *, vsock_address, vsock_address, vsock_operation, uint32_t, uint32_t, mbuf_t);
};

/* 10461 */
struct vsockpcbinfo
{
  lck_rw_t all_lock;
  lck_rw_t bound_lock;
  struct
  {
    vsockpcb *tqh_first;
    vsockpcb **tqh_last;
  } all;
  struct
  {
    vsockpcb *lh_first;
  } bound;
  uint32_t last_port;
  lck_mtx_t port_lock;
  uint64_t all_pcb_count;
  vsock_gen_t vsock_gencnt;
};

/* 10462 */
struct recv_msg_elem_0
{
  uio *uio;
  sockaddr *psa;
  mbuf *controlp;
  int which;
  int flags;
};

/* 10463 */
struct __attribute__((aligned(8))) socket_1
{
  int so_zone;
  short so_type;
  u_short so_error;
  u_int32_t so_options;
  short so_linger;
  short so_state;
  void *so_pcb;
  protosw *so_proto;
  socket *so_head;
  struct
  {
    socket *tqh_first;
    socket **tqh_last;
  } so_incomp;
  struct
  {
    socket *tqh_first;
    socket **tqh_last;
  } so_comp;
  struct
  {
    socket *tqe_next;
    socket **tqe_prev;
  } so_list;
  short so_qlen;
  short so_incqlen;
  short so_qlimit;
  short so_timeo;
  pid_t so_pgid;
  u_int32_t so_oobmark;
  sockbuf so_rcv;
  sockbuf so_snd;
  caddr_t so_tpcb;
  void (*so_event)(socket *, void *, uint32_t);
  void *so_eventarg;
  kauth_cred_t so_cred;
  so_gen_t so_gencnt;
  struct
  {
    socket *stqe_next;
  } so_cache_ent;
  caddr_t so_saved_pcb;
  u_int64_t cache_timestamp;
  uint32_t so_eventmask;
  pid_t last_pid;
  u_int64_t last_upid;
  socket_filter_entry *so_filt;
  u_int32_t so_flags;
  u_int32_t so_flags1;
  uint32_t so_upcallusecount;
  int so_usecount;
  int so_retaincnt;
  uint16_t so_traffic_class;
  int8_t so_netsvctype;
  uint8_t so_restrictions;
  thread_t_0 so_send_filt_thread;
  void *lock_lr[4];
  void *unlock_lr[4];
  u_int8_t next_lock_lr;
  u_int8_t next_unlock_lr;
  u_int16_t so_pktheadroom;
  u_int32_t so_ifdenied_notifies;
  thread_t_0 so_background_thread;
  data_stats so_tc_stats[4];
  klist so_klist;
  flow_divert_pcb *so_fd_pcb;
  soflow_db *so_flow_db;
  cfil_info *so_cfil;
  u_int32_t so_state_change_cnt;
  pid_t e_pid;
  u_int64_t e_upid;
  pid_t so_rpid;
  uuid_t_1 last_uuid;
  uuid_t_1 e_uuid;
  uuid_t_1 so_vuuid;
  uuid_t_1 so_ruuid;
  int32_t so_policy_gencnt;
  u_int64_t so_extended_bk_start;
  u_int8_t so_fallback_mode;
  u_int8_t so_log_seqn;
  uint8_t so_mpkl_send_proto;
  uuid_t_1 so_mpkl_send_uuid;
};

/* 10464 */
struct __attribute__((packed)) __attribute__((aligned(4))) xunpcb64
{
  u_int32_t xu_len;
  u_int64_t xu_unpp;
  xunpcb64_list_entry xunp_link;
  u_int64_t xunp_socket;
  u_int64_t xunp_vnode;
  u_int64_t xunp_ino;
  u_int64_t xunp_conn;
  u_int64_t xunp_refs;
  xunpcb64_list_entry xunp_reflink;
  int xunp_cc;
  int xunp_mbcnt;
  unp_gen_t xunp_gencnt;
  int xunp_flags;
  union
  {
    sockaddr_un xuu_addr;
    char xu_dummy1[256];
  } xu_au;
  union
  {
    sockaddr_un xuu_caddr;
    char xu_dummy2[256];
  } xu_cau;
  xsocket64 xu_socket;
};

/* 10465 */
struct __attribute__((packed)) __attribute__((aligned(4))) xunpcb
{
  u_int32_t xu_len;
  u_int32_t xu_unpp;
  unpcb_compat xu_unp;
  union
  {
    sockaddr_un xuu_addr;
    char xu_dummy1[256];
  } xu_au;
  union
  {
    sockaddr_un xuu_caddr;
    char xu_dummy2[256];
  } xu_cau;
  xsocket xu_socket;
  u_quad_t xu_alignment_hack;
};

/* 10466 */
struct xunpgen
{
  u_int32_t xug_len;
  u_int xug_count;
  unp_gen_t xug_gen;
  so_gen_t xug_sogen;
};

/* 10467 */
struct __attribute__((packed)) __attribute__((aligned(4))) mdns_ipc_msg_hdr
{
  uint32_t version;
  uint32_t datalen;
  uint32_t ipc_flags;
  uint32_t op;
  union
  {
    void *context;
    uint32_t u32[2];
  };
  uint32_t reg_index;
};

/* 10468 */
struct __attribute__((aligned(8))) user_sf_hdtr
{
  user_addr_t_0 headers;
  int hdr_cnt;
  user_addr_t_0 trailers;
  int trl_cnt;
};

/* 10469 */
typedef vnode *vnode_ref_t;

/* 10470 */
struct __attribute__((aligned(8))) user64_sf_hdtr
{
  user64_addr_t headers;
  int hdr_cnt;
  user64_addr_t trailers;
  int trl_cnt;
};

/* 10471 */
struct user32_sf_hdtr
{
  user32_addr_t headers;
  int hdr_cnt;
  user32_addr_t trailers;
  int trl_cnt;
};

/* 10472 */
struct user64_msghdr
{
  user64_addr_t msg_name;
  socklen_t msg_namelen;
  user64_addr_t msg_iov;
  int msg_iovlen;
  user64_addr_t msg_control;
  socklen_t msg_controllen;
  int msg_flags;
};

/* 10473 */
struct user32_msghdr
{
  user32_addr_t msg_name;
  socklen_t msg_namelen;
  user32_addr_t msg_iov;
  int msg_iovlen;
  user32_addr_t msg_control;
  socklen_t msg_controllen;
  int msg_flags;
};

/* 10474 */
typedef fileproc *fileproc_ref_t;

/* 10475 */
struct __attribute__((aligned(8))) user_sa_endpoints
{
  unsigned int sae_srcif;
  user_addr_t_0 sae_srcaddr;
  socklen_t sae_srcaddrlen;
  user_addr_t_0 sae_dstaddr;
  socklen_t sae_dstaddrlen;
};

/* 10476 */
struct __attribute__((aligned(8))) user64_sa_endpoints
{
  unsigned int sae_srcif;
  user64_addr_t sae_srcaddr;
  socklen_t sae_srcaddrlen;
  user64_addr_t sae_dstaddr;
  socklen_t sae_dstaddrlen;
};

/* 10477 */
struct user32_sa_endpoints
{
  unsigned int sae_srcif;
  user32_addr_t sae_srcaddr;
  socklen_t sae_srcaddrlen;
  user32_addr_t sae_dstaddr;
  socklen_t sae_dstaddrlen;
};

/* 10478 */
struct __attribute__((aligned(8))) kev_netpolicy_ifdenied
{
  netpolicy_event_data ev_data;
  __uint32_t ev_if_functional_type;
};

/* 10479 */
struct mptses_0
{
  mppcb *mpte_mppcb;
  mptcb *mpte_mptcb;
  struct
  {
    mptopt *tqh_first;
    mptopt **tqh_last;
  } mpte_sopts;
  struct
  {
    mptsub *tqh_first;
    mptsub **tqh_last;
  } mpte_subflows;
  uint16_t mpte_numflows;
  uint16_t mpte_nummpcapflows;
  sae_associd_t mpte_associd;
  sae_connid_t mpte_connid_last;
  uint64_t mpte_time_target;
  thread_call_t mpte_time_thread;
  thread_call_t mpte_stop_urgency;
  uint32_t mpte_last_cellicon_set;
  uint32_t mpte_cellicon_increments;
  union
  {
    sockaddr _mpte_src;
    sockaddr_in _mpte_src_v4;
    sockaddr_in6 _mpte_src_v6;
  } mpte_u_src;
  union
  {
    sockaddr _mpte_dst;
    sockaddr_in _mpte_dst_v4;
    sockaddr_in6 _mpte_dst_v6;
  } mpte_u_dst;
  sockaddr_in mpte_sub_dst_v4;
  sockaddr_in6 mpte_sub_dst_v6;
  uint8_t sub_dst_addr_id_v4;
  uint8_t sub_dst_addr_id_v6;
  uint16_t mpte_alternate_port;
  int mpte_epid;
  uuid_t_1 mpte_euuid;
  mptsub *mpte_active_sub;
  uint16_t mpte_flags;
  uint8_t mpte_svctype;
  uint8_t mpte_lost_aid;
  uint8_t mpte_addrid_last;
  uint32_t mpte_itfinfo_size;
  __attribute__((packed)) __attribute__((aligned(1))) mpt_itf_info _mpte_itfinfo[4];
  mpt_itf_info *mpte_itfinfo;
  mbuf *mpte_reinjectq;
  uint32_t mpte_subflow_switches;
  __attribute__((aligned(8))) uint32_t mpte_triggered_cell;
  mptcp_itf_stats mpte_itfstats[4];
  uint64_t mpte_init_txbytes;
  uint64_t mpte_init_rxbytes;
};

/* 10480 */
struct unpcb_0
{
  struct
  {
    unpcb *le_next;
    unpcb **le_prev;
  } unp_link;
  socket *unp_socket;
  vnode *unp_vnode;
  ino_t unp_ino;
  unpcb *unp_conn;
  unp_head unp_refs;
  struct
  {
    unpcb *le_next;
    unpcb **le_prev;
  } unp_reflink;
  sockaddr_un *unp_addr;
  unp_gen_t unp_gencnt;
  int unp_cc;
  int unp_mbcnt;
  uint32_t unp_flags;
  uint32_t rw_thrcount;
  xucred unp_peercred;
  lck_mtx_t unp_mtx;
};

/* 10481 */
struct kev_socket_closed
{
  kev_socket_event_data ev_data;
};

/* 10482 */
struct so_mark_cellfallback_uuid_args
{
  uuid_t_1 flow_uuid;
  int flow_cellfallback;
};

/* 10483 */
struct so_np_extensions
{
  u_int32_t npx_flags;
  u_int32_t npx_mask;
};

/* 10484 */
struct so_nke
{
  unsigned int nke_handle;
  unsigned int nke_where;
  int nke_flags;
  u_int32_t reserved[4];
};

/* 10485 */
struct linger
{
  int l_onoff;
  int l_linger;
};

/* 10486 */
struct soextbkidlestat
{
  u_int32_t so_xbkidle_maxperproc;
  u_int32_t so_xbkidle_time;
  u_int32_t so_xbkidle_rcvhiwat;
  int32_t so_xbkidle_notsupp;
  int32_t so_xbkidle_toomany;
  int32_t so_xbkidle_wantok;
  int32_t so_xbkidle_active;
  int32_t so_xbkidle_nocell;
  int32_t so_xbkidle_notime;
  int32_t so_xbkidle_forced;
  int32_t so_xbkidle_resumed;
  int32_t so_xbkidle_expired;
  int32_t so_xbkidle_resched;
  int32_t so_xbkidle_nodlgtd;
  int32_t so_xbkidle_drained;
};

/* 10487 */
struct mbstat
{
  u_int32_t m_mbufs;
  u_int32_t m_clusters;
  u_int32_t m_spare;
  u_int32_t m_clfree;
  u_int32_t m_drops;
  u_int32_t m_wait;
  u_int32_t m_drain;
  u_short m_mtypes[256];
  u_int32_t m_mcfail;
  u_int32_t m_mpfail;
  u_int32_t m_msize;
  u_int32_t m_mclbytes;
  u_int32_t m_minclsize;
  u_int32_t m_mlen;
  u_int32_t m_mhlen;
  u_int32_t m_bigclusters;
  u_int32_t m_bigclfree;
  u_int32_t m_bigmclbytes;
  u_int32_t m_forcedefunct;
};

/* 10488 */
struct mleak_table
{
  u_int32_t mleak_capture;
  u_int32_t mleak_sample_factor;
  u_int64_t alloc_collisions;
  u_int64_t trace_collisions;
  u_int64_t alloc_overwrites;
  u_int64_t trace_overwrites;
  u_int64_t alloc_recorded;
  u_int64_t trace_recorded;
  u_int64_t outstanding_allocs;
  u_int64_t total_conflicts;
};

/* 10489 */
union cs_hash_union
{
  SHA1_CTX sha1ctxt;
  SHA256_CTX sha256ctx;
  SHA384_CTX sha384ctx;
};

/* 10490 */
typedef size_t atomic_size_t;

/* 10491 */
typedef uint_fast32_t atomic_uint_fast32_t;

/* 10492 */
struct __attribute__((aligned(8))) session_0
{
  lck_mtx_t s_mlock;
  struct
  {
    session *le_next;
    session **le_prev;
  } s_hash;
  proc *s_leader;
  vnode *s_ttyvp;
  tty *s_ttyp;
  uint32_t s_ttyvid;
  pid_t s_ttypgrpid;
  dev_t s_ttydev;
  pid_t s_sid;
  os_ref_atomic_t s_refcount;
  char s_login[255];
};

/* 10493 */
struct nameidata_0
{
  user_addr_t_0 ni_dirp;
  uio_seg ni_segflg;
  path_operation ni_op;
  vnode *ni_startdir;
  vnode *ni_rootdir;
  vnode *ni_usedvp;
  vnode *ni_vp;
  vnode *ni_dvp;
  u_int ni_pathlen;
  char *ni_next;
  char ni_pathbuf[256];
  u_long ni_loopcnt;
  componentname ni_cnd;
  int32_t ni_flag;
  int ni_ncgeneration;
};

/* 10494 */
struct ubc_info_0
{
  memory_object_t ui_pager;
  memory_object_control_t ui_control;
  _BYTE gap10[8];
  kauth_cred_t ui_ucred;
  off_t ui_size;
  uint32_t ui_flags;
  uint32_t cs_add_gen;
  cl_readahead *cl_rahead;
  cl_writebehind *cl_wbehind;
  timespec cs_mtime;
  _BYTE gap50[8];
  cs_blob *cs_blob_supplement;
};

/* 10495 */
struct _ptmx_ioctl_state
{
  ptmx_ioctl **pis_ioctl_list;
  int pis_total;
  int pis_free;
};

/* 10496 */
typedef devnode_0 devnode_t_0;

/* 10497 */
struct __block_literal_1_17
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(selinfo *);
  __block_descriptor *__descriptor;
  knote *kn;
};

/* 10498 */
typedef struct *selspec_record_hook_t;

/* 10499 */
typedef thread_basic_info thread_basic_info_data_t;

/* 10500 */
struct __attribute__((aligned(8))) work_interval_instance
{
  uint64_t wi_interval_id;
  uint64_t wi_instance_id;
  uint64_t wi_start;
  uint64_t wi_finish;
  uint64_t wi_deadline;
  uint64_t wi_complexity;
  uint32_t wi_create_flags;
};

/* 10501 */
struct work_interval_workload_id_params
{
  uint32_t wlidp_flags;
  uint32_t wlidp_wicreate_flags;
  uint64_t wlidp_name;
  uint64_t wlidp_syscall_mask[2];
};

/* 10502 */
struct work_interval_create_params
{
  uint64_t wicp_id;
  mach_port_name_t wicp_port;
  uint32_t wicp_create_flags;
};

/* 10503 */
struct work_interval_notification
{
  uint64_t start;
  uint64_t finish;
  uint64_t deadline;
  uint64_t next_start;
  uint32_t notify_flags;
  uint32_t create_flags;
};

/* 10504 */
typedef vm_page_info_basic vm_page_info_basic_data_t;

/* 10505 */
struct sysctl_req_1
{
  proc *p;
  int lock;
  user_addr_t_0 oldptr;
  size_t oldlen;
  size_t oldidx;
  int (*oldfunc)(sysctl_req_0 *, const void *, size_t);
  user_addr_t_0 newptr;
  size_t newlen;
  size_t newidx;
  int (*newfunc)(sysctl_req_0 *, void *, size_t);
};

/* 10506 */
typedef firehose_buffer_map_info_s firehose_buffer_map_info_t;

/* 10507 */
struct __attribute__((aligned(8))) oslogsoftc
{
  int sc_state;
  selinfo sc_selp;
  int sc_pgid;
};

/* 10508 */
struct logsoftc
{
  int sc_state;
  selinfo sc_selp;
  int sc_pgid;
  msgbuf *sc_mbp;
};

/* 10509 */
typedef struct proc *proc_t_0;

/* 10510 */
typedef stackshot_stats stackshot_stats_t;

/* 10511 */
struct workqueue_0
{
  thread_call_t wq_delayed_call;
  thread_call_t wq_immediate_call;
  thread_call_t wq_death_call;
  union
  {
    turnstile *wq_turnstile;
    mpsc_queue_chain wq_destroy_link;
  };
  lck_ticket_t wq_lock;
  uint64_t wq_thread_call_last_run;
  os_refcnt wq_refcnt;
  __attribute__((aligned(8))) uint32_t wq_fulfilled;
  uint32_t wq_creations;
  uint32_t wq_timer_interval;
  uint32_t wq_event_manager_priority;
  uint32_t wq_reqcount;
  uint16_t wq_thdying_count;
  uint16_t wq_threads_scheduled;
  uint16_t wq_constrained_threads_scheduled;
  uint16_t wq_nthreads;
  uint16_t wq_thidlecount;
  uint16_t wq_thscheduled_count[7];
  workq_threadreq_t wq_event_manager_threadreq;
  wq_thactive_t wq_thactive;
  uint64_t wq_lastblocked_ts[6];
  proc *wq_proc;
  uthread *wq_creator;
  turnstile_inheritor_t wq_inheritor;
  thread_t_0 wq_turnstile_updater;
  workq_uthread_head wq_thrunlist;
  workq_uthread_head wq_thnewlist;
  workq_uthread_head wq_thidlelist;
  priority_queue_sched_max wq_overcommit_queue;
  priority_queue_sched_max wq_constrained_queue;
  priority_queue_sched_max wq_special_queue;
  uint8_t wq_cooperative_queue_scheduled_count[6];
  workq_threadreq_tailq wq_cooperative_queue[6];
};

/* 10512 */
struct __attribute__((aligned(8))) session_1
{
  lck_mtx_t s_mlock;
  struct
  {
    session *le_next;
    session **le_prev;
  } s_hash;
  proc *s_leader;
  vnode *s_ttyvp;
  tty *s_ttyp;
  uint32_t s_ttyvid;
  pid_t s_ttypgrpid;
  dev_t s_ttydev;
  pid_t s_sid;
  os_ref_atomic_t s_refcount;
  char s_login[255];
};

/* 10513 */
struct proc_ro_1
{
  proc *pr_proc;
  task *pr_task;
  union
  {
    struct __attribute__((aligned(8)))
    {
      uint64_t p_uniqueid;
      int p_idversion;
      uint32_t p_csflags;
      ucred *p_ucred;
      uint8_t *syscall_filter_mask;
      proc_platform_ro_data p_platform_data;
    };
    proc_ro_data proc_data;
  };
  union
  {
    struct
    {
      task_token_ro_data task_tokens;
      task_filter_ro_data task_filters;
      uint32_t t_flags_ro;
      uint32_t task_control_port_options;
    };
    task_ro_data task_data;
  };
};

/* 10514 */
struct sysctl_req_2
{
  proc *p;
  int lock;
  user_addr_t_0 oldptr;
  size_t oldlen;
  size_t oldidx;
  int (*oldfunc)(sysctl_req_0 *, const void *, size_t);
  user_addr_t_0 newptr;
  size_t newlen;
  size_t newidx;
  int (*newfunc)(sysctl_req_0 *, void *, size_t);
};

/* 10515 */
typedef mcache_0 mcache_t_0;

/* 10516 */
typedef _img4_cstr_0 img4_cstr_t_0;

/* 10517 */
typedef _img4_dgst_0 img4_dgst_t_0;

/* 10518 */
struct _img4_nonce_domain;

/* 10519 */
struct _img4_runtime_object_spec;

/* 10520 */
struct _img4_chip;

/* 10521 */
typedef memorystatus_memlimit_properties2 memorystatus_memlimit_properties2_t;

/* 10522 */
typedef memorystatus_priority_properties memorystatus_priority_properties_t;

/* 10523 */
typedef vm_statistics64 vm_statistics64_data_t;

/* 10524 */
enum memorystatus_log_level_t : __int32
{
  MEMORYSTATUS_LOG_LEVEL_DEFAULT = 0x0,
  MEMORYSTATUS_LOG_LEVEL_INFO = 0x1,
  MEMORYSTATUS_LOG_LEVEL_DEBUG = 0x2,
};

/* 10525 */
typedef int (*sysctl_handler_t)(sysctl_oid_0 *, void *, int, sysctl_req_0 *);

/* 10526 */
struct xsw_usage
{
  u_int64_t xsu_total;
  u_int64_t xsu_avail;
  u_int64_t xsu_used;
  u_int32_t xsu_pagesize;
  boolean_t xsu_encrypted;
};

/* 10527 */
struct user32_iovec
{
  uint32_t iov_base;
  uint32_t iov_len;
};

/* 10528 */
struct user64_iovec
{
  uint64_t iov_base;
  uint64_t iov_len;
};

/* 10529 */
struct __block_literal_2_6
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(proc_t);
  __block_descriptor *__descriptor;
};

/* 10530 */
struct __block_literal_1_18
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(proc_t);
  __block_descriptor *__descriptor;
};

/* 10531 */
struct user_timespec
{
  user_time_t tv_sec;
  user_long_t tv_nsec;
};

/* 10532 */
struct proc_rlimit_control_wakeupmon
{
  uint32_t wm_flags;
  int32_t wm_rate;
};

/* 10533 */
struct __block_literal_1_19
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(plimit *);
  __block_descriptor *__descriptor;
  rlim_t value;
};

/* 10534 */
typedef task_events_info task_events_info_data_t;

/* 10535 */
typedef task_thread_times_info task_thread_times_info_data_t;

/* 10536 */
typedef mach_task_basic_info mach_task_basic_info_data_t;

/* 10537 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_2_7
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(plimit *);
  __block_descriptor *__descriptor;
  rlimit *newrlim;
  u_int which;
};

/* 10538 */
typedef task_absolutetime_info task_absolutetime_info_data_t;

/* 10539 */
struct __block_literal_7_2
{
  void *__isa;
  int __flags;
  int __reserved;
  kauth_cred_t (*__FuncPtr)(kauth_cred_t);
  __block_descriptor *__descriptor;
  gid_t *newgroups;
  u_int ngrp;
  uid_t gmuid;
};

/* 10540 */
struct __block_literal_6_4
{
  void *__isa;
  int __flags;
  int __reserved;
  kauth_cred_t (*__FuncPtr)(kauth_cred_t);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(4))) {void *__isa;void *__forwarding;int __flags;int __size;int error;}; *error;
  proc_t p;
  gid_t want_rgid;
  gid_t want_egid;
};

/* 10541 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_5_7
{
  void *__isa;
  int __flags;
  int __reserved;
  kauth_cred_t (*__FuncPtr)(kauth_cred_t);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(4))) {void *__isa;void *__forwarding;int __flags;int __size;int error;}; *error;
  proc_t p;
  gid_t want_egid;
};

/* 10542 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_4_7
{
  void *__isa;
  int __flags;
  int __reserved;
  kauth_cred_t (*__FuncPtr)(kauth_cred_t);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(4))) {void *__isa;void *__forwarding;int __flags;int __size;int error;}; *error;
  proc_t p;
  gid_t want_gid;
};

/* 10543 */
struct __block_literal_3_6
{
  void *__isa;
  int __flags;
  int __reserved;
  kauth_cred_t (*__FuncPtr)(kauth_cred_t);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(4))) {void *__isa;void *__forwarding;int __flags;int __size;int error;}; *error;
  struct *old_ruid;
  proc_t p;
  setreuid_args *uap;
  uid_t want_ruid;
  uid_t want_euid;
};

/* 10544 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_2_8
{
  void *__isa;
  int __flags;
  int __reserved;
  kauth_cred_t (*__FuncPtr)(kauth_cred_t);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(4))) {void *__isa;void *__forwarding;int __flags;int __size;int error;}; *error;
  proc_t p;
  uid_t want_euid;
};

/* 10545 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_1_20
{
  void *__isa;
  int __flags;
  int __reserved;
  kauth_cred_t (*__FuncPtr)(kauth_cred_t);
  __block_descriptor_withcopydispose *__descriptor;
  struct *ruid;
  struct *old_ruid;
  struct __attribute__((packed)) __attribute__((aligned(4))) {void *__isa;void *__forwarding;int __flags;int __size;int error;}; *error;
  proc_t p;
  uid_t want_uid;
};

/* 10546 */
struct __attribute__((aligned(8))) tty_1
{
  lck_mtx_t t_lock;
  clist t_rawq;
  long t_rawcc;
  clist t_canq;
  long t_cancc;
  clist t_outq;
  long t_outcc;
  int t_line;
  dev_t t_dev;
  int t_state;
  int t_flags;
  int t_timeout;
  pgrp *t_pgrp;
  session *t_session;
  selinfo t_rsel;
  selinfo t_wsel;
  termios t_termios;
  winsize t_winsize;
  void (*t_oproc)(tty *);
  void (*t_stop)(tty *, int);
  int (*t_param)(tty *, termios *);
  void *t_sc;
  int t_column;
  int t_rocount;
  int t_rocol;
  int t_hiwat;
  int t_lowat;
  int t_gen;
  void *t_iokit;
  os_ref_atomic_t t_refcnt;
};

/* 10547 */
struct proclist_0
{
  proc *lh_first;
};

/* 10548 */
struct buf_0
{
  struct
  {
    buf *le_next;
    buf **le_prev;
  } b_hash;
  struct
  {
    buf *le_next;
    buf **le_prev;
  } b_vnbufs;
  struct
  {
    buf *tqe_next;
    buf **tqe_prev;
  } b_freelist;
  int b_timestamp;
  timeval b_timestamp_tv;
  int b_whichq;
  volatile uint32_t b_flags;
  volatile uint32_t b_lflags;
  int b_error;
  int b_bufsize;
  int b_bcount;
  int b_resid;
  dev_t b_dev;
  uintptr_t b_datap;
  daddr64_t b_lblkno;
  daddr64_t b_blkno;
  void (*b_iodone)(buf_t, void *);
  vnode_t b_vp;
  kauth_cred_t b_rcred;
  kauth_cred_t b_wcred;
  void *b_upl;
  buf_t b_real_bp;
  struct
  {
    buf *tqe_next;
    buf **tqe_prev;
  } b_act;
  void *b_drvdata;
  void *b_fsprivate;
  void *b_transaction;
  int b_dirtyoff;
  int b_dirtyend;
  int b_validoff;
  int b_validend;
  uint32_t b_redundancy_flags;
  proc_t b_proc;
  bufattr b_attr;
  uint32_t b_lblksize;
  vnode_t b_vnop_vp;
};

/* 10549 */
struct __block_literal_1_21
{
  void *__isa;
  int __flags;
  int __reserved;
  kauth_cred_t (*__FuncPtr)(kauth_cred_t);
  __block_descriptor_withcopydispose *__descriptor;
  struct *old_uid;
  kauth_cred_t new_cred;
};

/* 10550 */
struct personalist
{
  persona *lh_first;
};

/* 10551 */
typedef vm_page_info_basic *vm_page_info_basic_t;

/* 10552 */
typedef queue_entry_0 queue_head_t_1;

/* 10553 */
enum overlap_t : __int32
{
  OVERLAP_NONE = 0x0,
  OVERLAP_EQUALS_LOCK = 0x1,
  OVERLAP_CONTAINS_LOCK = 0x2,
  OVERLAP_CONTAINED_BY_LOCK = 0x3,
  OVERLAP_STARTS_BEFORE_LOCK = 0x4,
  OVERLAP_ENDS_AFTER_LOCK = 0x5,
};

/* 10554 */
struct vnode_2
{
  lck_mtx_t v_lock;
  struct
  {
    vnode *tqe_next;
    vnode **tqe_prev;
  } v_freelist;
  struct
  {
    vnode *tqe_next;
    vnode **tqe_prev;
  } v_mntvnodes;
  struct
  {
    namecache *tqh_first;
    namecache **tqh_last;
  } v_ncchildren;
  struct
  {
    namecache *lh_first;
  } v_nclinks;
  vnode_t v_defer_reclaimlist;
  uint32_t v_listflag;
  uint32_t v_flag;
  uint16_t v_lflag;
  uint8_t v_iterblkflags;
  uint8_t v_references;
  int32_t v_kusecount;
  int32_t v_usecount;
  int32_t v_iocount;
  _BYTE gap68[8];
  uint16_t v_type;
  uint16_t v_tag;
  uint32_t v_id;
  _BYTE gap78[8];
  buflists v_cleanblkhd;
  buflists v_dirtyblkhd;
  klist v_knotes;
  _BYTE gap98[8];
  kauth_action_t v_authorized_actions;
  int v_cred_timestamp;
  int v_nc_generation;
  int32_t v_numoutput;
  int32_t v_writecount;
  uint32_t v_holdcount;
  const char *v_name;
  _BYTE gapC0[8];
  lockf *v_lockf;
  int (**v_op)(void *);
  _BYTE gapD8[8];
  void *v_data;
  label *v_label;
  vnode_resolve_t v_resolve;
  vnode_t v_fmlink;
  fl_head v_leases;
};

/* 10555 */
enum ktrace_state_t : __int32
{
  KTRACE_STATE_OFF = 0x0,
  KTRACE_STATE_FG = 0x1,
  KTRACE_STATE_BG = 0x2,
};

/* 10556 */
struct btinfo_sc_load_info
{
  uint32_t sharedCacheSlide;
  uuid_t_1 sharedCacheUUID;
  uint32_t sharedCacheBaseAddress;
};

/* 10557 */
struct btinfo_sc_load_info64
{
  uint64_t sharedCacheSlide;
  uuid_t_1 sharedCacheUUID;
  uint64_t sharedCacheBaseAddress;
};

/* 10558 */
typedef thread_identifier_info thread_identifier_info_data_t;

/* 10559 */
struct __attribute__((packed)) __attribute__((aligned(4))) exit_reason_snapshot
{
  uint32_t ers_namespace;
  uint64_t ers_code;
  uint64_t ers_flags;
};

/* 10560 */
struct os_reason_0
{
  lck_mtx_t osr_lock;
  os_refcnt_t osr_refcount;
  uint32_t osr_namespace;
  uint64_t osr_code;
  uint64_t osr_flags;
  uint32_t osr_bufsize;
  kcdata_descriptor_0 osr_kcd_descriptor;
  char *osr_kcd_buf;
};

/* 10561 */
struct vfstable_4
{
  const vfsops *vfc_vfsops;
  char vfc_name[15];
  int vfc_typenum;
  int vfc_refcount;
  int vfc_flags;
  int (*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);
  vfstable *vfc_next;
  int32_t vfc_reserved1;
  int32_t vfc_reserved2;
  int vfc_vfsflags;
  void *vfc_descptr;
  uint32_t vfc_descsize;
  sysctl_oid_0 *vfc_sysctl;
};

/* 10562 */
struct vfs_attr_1
{
  uint64_t f_supported;
  uint64_t f_active;
  uint64_t f_objcount;
  uint64_t f_filecount;
  uint64_t f_dircount;
  uint64_t f_maxobjcount;
  uint32_t f_bsize;
  __attribute__((packed)) __attribute__((aligned(1))) size_t f_iosize;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_blocks;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_bfree;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_bavail;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_bused;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_files;
  __attribute__((packed)) __attribute__((aligned(1))) uint64_t f_ffree;
  fsid_t f_fsid;
  uid_t f_owner;
  vol_capabilities_attr_t f_capabilities;
  vol_attributes_attr_t f_attributes;
  timespec f_create_time;
  timespec f_modify_time;
  timespec f_access_time;
  timespec f_backup_time;
  uint32_t f_fssubtype;
  __attribute__((packed)) __attribute__((aligned(1))) char *f_vol_name;
  uint16_t f_signature;
  uint16_t f_carbon_fsid;
  uuid_t_1 f_uuid;
  uint64_t f_quota;
  uint64_t f_reserved;
};

/* 10563 */
struct mount_0
{
  struct
  {
    mount *tqe_next;
    mount **tqe_prev;
  } mnt_list;
  int32_t mnt_count;
  lck_mtx_t mnt_mlock;
  __attribute__((aligned(32))) vnodelst mnt_vnodelist;
  vnodelst mnt_workerqueue;
  vnodelst mnt_newvnodes;
  uint32_t mnt_flag;
  uint32_t mnt_kern_flag;
  uint32_t mnt_compound_ops;
  uint32_t mnt_lflag;
  uint32_t mnt_maxsymlinklen;
  vfsstatfs_0 mnt_vfsstat;
  qaddr_t mnt_data;
  uint32_t mnt_maxreadcnt;
  uint32_t mnt_maxwritecnt;
  uint32_t mnt_segreadcnt;
  uint32_t mnt_segwritecnt;
  uint32_t mnt_maxsegreadsize;
  uint32_t mnt_maxsegwritesize;
  uint32_t mnt_alignmentmask;
  uint32_t mnt_devblocksize;
  uint32_t mnt_ioqueue_depth;
  uint32_t mnt_ioscale;
  uint32_t mnt_ioflags;
  uint32_t mnt_minsaturationbytecount;
  pending_io_t mnt_pending_write_size;
  pending_io_t mnt_pending_read_size;
  timeval mnt_last_write_issued_timestamp;
  timeval mnt_last_write_completed_timestamp;
  int64_t mnt_max_swappin_available;
  lck_rw_t mnt_rwlock;
  lck_mtx_t mnt_renamelock;
  vnode_t mnt_devvp;
  uint32_t mnt_devbsdunit;
  uint64_t mnt_throttle_mask;
  void *mnt_throttle_info;
  int32_t mnt_crossref;
  int32_t mnt_iterref;
  int32_t mnt_numtriggers;
  vfs_trigger_callback_t *mnt_triggercallback;
  void *mnt_triggerdata;
  uid_t mnt_fsowner;
  gid_t mnt_fsgroup;
  label *mnt_mntlabel;
  vnode_t mnt_realrootvp;
  uint32_t mnt_realrootvp_vid;
  uint32_t mnt_generation;
  int mnt_authcache_ttl;
  char fstypename_override[16];
  uint32_t mnt_iobufinuse;
  void *mnt_disk_conditioner_info;
  lck_mtx_t mnt_iter_lock;
  uint64_t mnt_mount_id;
  uint32_t mnt_supl_kern_flag;
};

/* 10564 */
struct __attribute__((aligned(8))) fd_vn_data_0
{
  lck_mtx_t fv_lock;
  off_t fv_offset;
  void *fv_dircookie;
  caddr_t fv_buf;
  size_t fv_bufsiz;
  size_t fv_bufdone;
  size_t fv_bufallocsiz;
  off_t fv_soff;
  off_t fv_eoff;
  int fv_eofflag;
};

/* 10565 */
struct __block_literal_1_22
{
  void *__isa;
  int __flags;
  int __reserved;
  kauth_cred_t (*__FuncPtr)(kauth_cred_t);
  __block_descriptor *__descriptor;
};

/* 10566 */
struct user32__posix_spawn_args_desc
{
  uint32_t attr_size;
  uint32_t attrp;
  uint32_t file_actions_size;
  uint32_t file_actions;
  uint32_t port_actions_size;
  uint32_t port_actions;
  uint32_t mac_extensions_size;
  uint32_t mac_extensions;
  uint32_t coal_info_size;
  uint32_t coal_info;
  uint32_t persona_info_size;
  uint32_t persona_info;
  uint32_t posix_cred_info_size;
  uint32_t posix_cred_info;
  uint32_t subsystem_root_path_size;
  uint32_t subsystem_root_path;
};

/* 10567 */
struct __block_literal_4_8
{
  void *__isa;
  int __flags;
  int __reserved;
  kauth_cred_t (*__FuncPtr)(kauth_cred_t);
  __block_descriptor *__descriptor;
};

/* 10568 */
struct __block_literal_3_7
{
  void *__isa;
  int __flags;
  int __reserved;
  kauth_cred_t (*__FuncPtr)(kauth_cred_t);
  __block_descriptor *__descriptor;
  image_params *imgp;
};

/* 10569 */
struct __block_literal_2_9
{
  void *__isa;
  int __flags;
  int __reserved;
  kauth_cred_t (*__FuncPtr)(kauth_cred_t);
  __block_descriptor *__descriptor;
  image_params *imgp;
};

/* 10570 */
typedef _posix_spawn_file_actions *_posix_spawn_file_actions_t;

/* 10571 */
struct _posix_spawn_port_actions_0
{
  int pspa_alloc;
  int pspa_count;
  _ps_port_action_t pspa_actions[];
};

/* 10572 */
struct ctl_info
{
  u_int32_t ctl_id;
  char ctl_name[96];
};

/* 10573 */
struct xsystmgen
{
  u_int32_t xg_len;
  u_int64_t xg_count;
  u_int64_t xg_gen;
  u_int64_t xg_sogen;
};

/* 10574 */
struct ctl_event_data
{
  u_int32_t ctl_id;
  u_int32_t ctl_unit;
};

/* 10575 */
struct kctlstat
{
  u_int64_t kcs_reg_total;
  u_int64_t kcs_reg_count;
  u_int64_t kcs_pcbcount;
  u_int64_t kcs_gencnt;
  u_int64_t kcs_connections;
  u_int64_t kcs_conn_fail;
  u_int64_t kcs_send_fail;
  u_int64_t kcs_send_list_fail;
  u_int64_t kcs_enqueue_fail;
  u_int64_t kcs_enqueue_fullsock;
  u_int64_t kcs_bad_kctlref;
  u_int64_t kcs_tbl_size_too_big;
  u_int64_t kcs_enqdata_mb_alloc_fail;
  u_int64_t kcs_enqdata_sbappend_fail;
};

/* 10576 */
struct kctl_list
{
  kctl *tqh_first;
  kctl **tqh_last;
};

/* 10577 */
struct kevent64_s
{
  uint64_t ident;
  int16_t filter;
  uint16_t flags;
  uint32_t fflags;
  int64_t data;
  uint64_t udata;
  uint64_t ext[2];
};

/* 10578 */
struct user64_kevent
{
  uint64_t ident;
  int16_t filter;
  uint16_t flags;
  uint32_t fflags;
  int64_t data;
  user_addr_t_0 udata;
};

/* 10579 */
struct user32_kevent
{
  uint32_t ident;
  int16_t filter;
  uint16_t flags;
  uint32_t fflags;
  int32_t data;
  user32_addr_t udata;
};

/* 10580 */
struct kern_event_head
{
  kern_event_pcb *lh_first;
};

/* 10581 */
struct kevtstat
{
  u_int64_t kes_pcbcount;
  u_int64_t kes_gencnt;
  u_int64_t kes_badvendor;
  u_int64_t kes_toobig;
  u_int64_t kes_nomem;
  u_int64_t kes_fullsock;
  u_int64_t kes_posted;
};

/* 10582 */
struct sockopt_0
{
  sopt_dir sopt_dir;
  int sopt_level;
  int sopt_name;
  user_addr_t_0 sopt_val;
  size_t sopt_valsize;
  proc *sopt_p;
};

/* 10583 */
struct protosw_old_0
{
  short pr_type;
  __attribute__((packed)) __attribute__((aligned(4))) domain *pr_domain;
  short pr_protocol;
  unsigned int pr_flags;
  __attribute__((packed)) void (*pr_input)(mbuf *, int) __attribute__((aligned(1)));
  __attribute__((packed)) int (*pr_output)(mbuf *, socket *) __attribute__((aligned(1)));
  __attribute__((packed)) void (*pr_ctlinput)(int, sockaddr *, void *, ifnet *) __attribute__((aligned(1)));
  __attribute__((packed)) int (*pr_ctloutput)(socket *, sockopt *) __attribute__((aligned(1)));
  __attribute__((packed)) __attribute__((aligned(1))) void *pr_ousrreq;
  __attribute__((packed)) void (*pr_init)(void) __attribute__((aligned(1)));
  __attribute__((packed)) void (*pr_unused)(void) __attribute__((aligned(1)));
  __attribute__((packed)) void (*pr_unused2)(void) __attribute__((aligned(1)));
  __attribute__((packed)) void (*pr_drain)(void) __attribute__((aligned(1)));
  __attribute__((packed)) int (*pr_sysctl)(int *, u_int, void *, size_t *, void *, size_t) __attribute__((aligned(1)));
  __attribute__((packed)) __attribute__((aligned(1))) pr_usrreqs_old *pr_usrreqs;
  __attribute__((packed)) int (*pr_lock)(socket *, int, void *) __attribute__((aligned(1)));
  __attribute__((packed)) int (*pr_unlock)(socket *, int, void *) __attribute__((aligned(1)));
  __attribute__((packed)) lck_mtx_t *(*pr_getlock)(socket *, int) __attribute__((aligned(1)));
  struct
  {
    socket_filter *tqh_first;
    __attribute__((packed)) __attribute__((aligned(1))) socket_filter **tqh_last;
  } pr_filter_head;
  __attribute__((packed)) __attribute__((aligned(1))) protosw_old *pr_next;
  u_int32_t reserved[1];
};

/* 10584 */
struct __attribute__((aligned(8))) socket_2
{
  int so_zone;
  short so_type;
  u_short so_error;
  u_int32_t so_options;
  short so_linger;
  short so_state;
  void *so_pcb;
  protosw *so_proto;
  socket *so_head;
  struct
  {
    socket *tqh_first;
    socket **tqh_last;
  } so_incomp;
  struct
  {
    socket *tqh_first;
    socket **tqh_last;
  } so_comp;
  struct
  {
    socket *tqe_next;
    socket **tqe_prev;
  } so_list;
  short so_qlen;
  short so_incqlen;
  short so_qlimit;
  short so_timeo;
  pid_t so_pgid;
  u_int32_t so_oobmark;
  sockbuf so_rcv;
  sockbuf so_snd;
  caddr_t so_tpcb;
  void (*so_event)(socket *, void *, uint32_t);
  void *so_eventarg;
  kauth_cred_t so_cred;
  so_gen_t so_gencnt;
  struct
  {
    socket *stqe_next;
  } so_cache_ent;
  caddr_t so_saved_pcb;
  u_int64_t cache_timestamp;
  uint32_t so_eventmask;
  pid_t last_pid;
  u_int64_t last_upid;
  socket_filter_entry *so_filt;
  u_int32_t so_flags;
  u_int32_t so_flags1;
  uint32_t so_upcallusecount;
  int so_usecount;
  int so_retaincnt;
  uint16_t so_traffic_class;
  int8_t so_netsvctype;
  uint8_t so_restrictions;
  thread_t_0 so_send_filt_thread;
  void *lock_lr[4];
  void *unlock_lr[4];
  u_int8_t next_lock_lr;
  u_int8_t next_unlock_lr;
  u_int16_t so_pktheadroom;
  u_int32_t so_ifdenied_notifies;
  thread_t_0 so_background_thread;
  data_stats so_tc_stats[4];
  klist so_klist;
  flow_divert_pcb *so_fd_pcb;
  soflow_db *so_flow_db;
  cfil_info *so_cfil;
  u_int32_t so_state_change_cnt;
  pid_t e_pid;
  u_int64_t e_upid;
  pid_t so_rpid;
  uuid_t_1 last_uuid;
  uuid_t_1 e_uuid;
  uuid_t_1 so_vuuid;
  uuid_t_1 so_ruuid;
  int32_t so_policy_gencnt;
  u_int64_t so_extended_bk_start;
  u_int8_t so_fallback_mode;
  u_int8_t so_log_seqn;
  uint8_t so_mpkl_send_proto;
  uuid_t_1 so_mpkl_send_uuid;
};

/* 10585 */
struct vfstable_5
{
  const vfsops *vfc_vfsops;
  char vfc_name[15];
  int vfc_typenum;
  int vfc_refcount;
  int vfc_flags;
  int (*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);
  vfstable *vfc_next;
  int32_t vfc_reserved1;
  int32_t vfc_reserved2;
  int vfc_vfsflags;
  void *vfc_descptr;
  uint32_t vfc_descsize;
  sysctl_oid_0 *vfc_sysctl;
};

/* 10586 */
struct knote_lock_ctx_0
{
  knote *knlc_knote;
  thread_t_0 knlc_thread;
  uintptr_t knlc_waiters;
  struct
  {
    knote_lock_ctx *le_next;
    knote_lock_ctx **le_prev;
  } knlc_link;
};

/* 10587 */
struct user32_fopenfrom
{
  unsigned int o_flags;
  mode_t o_mode;
  user32_addr_t o_pathname;
};

/* 10588 */
struct user_fopenfrom
{
  unsigned int o_flags;
  mode_t o_mode;
  user_addr_t_0 o_pathname;
};

/* 10589 */
typedef fassertbgaccess fassertbgaccess_t;

/* 10590 */
typedef cp_key cp_key_t;

/* 10591 */
typedef fgetsigsinfo fgetsigsinfo_t;

/* 10592 */
struct user32_fchecklv
{
  user32_off_t lv_file_start;
  user32_size_t lv_error_message_size;
  user32_addr_t lv_error_message;
};

/* 10593 */
typedef fchecklv fchecklv_t;

/* 10594 */
struct __attribute__((aligned(8))) user_fsupplement
{
  off_t fs_file_start;
  off_t fs_blob_start;
  size_t fs_blob_size;
  int fs_orig_fd;
};

/* 10595 */
struct user32_fsignatures
{
  off_t fs_file_start;
  user32_addr_t fs_blob_start;
  user32_size_t fs_blob_size;
};

/* 10596 */
struct user_fsignatures
{
  off_t fs_file_start;
  user_addr_t_0 fs_blob_start;
  user_size_t fs_blob_size;
  user_size_t fs_fsignatures_size;
  char fs_cdhash[20];
  int fs_hash_type;
};

/* 10597 */
struct __attribute__((packed)) __attribute__((aligned(4))) log2phys
{
  unsigned int l2p_flags;
  off_t l2p_contigbytes;
  off_t l2p_devoffset;
};

/* 10598 */
struct __attribute__((packed)) __attribute__((aligned(4))) radvisory
{
  off_t ra_offset;
  int ra_count;
};

/* 10599 */
typedef fspecread fspecread_t;

/* 10600 */
typedef ftrimactivefile ftrimactivefile_t;

/* 10601 */
typedef fpunchhole fpunchhole_t;

/* 10602 */
typedef fstore fstore_t;

/* 10603 */
struct flocktimeout
{
  flock fl;
  timespec timeout;
};

/* 10604 */
struct dk_physical_extent_t
{
  uint64_t offset;
  uint64_t length;
  uint8_t reserved0128[12];
  dev_t dev;
};

/* 10605 */
struct dk_corestorage_info_t
{
  uint64_t flags;
  uint64_t hotfile_size;
  uint64_t hibernate_minsize;
  uint64_t swapfile_pinning;
  uint64_t padding[4];
};

/* 10606 */
typedef dk_apfs_wbc_range dk_apfs_wbc_range_t;

/* 10607 */
typedef _dk_cs_pin _dk_cs_pin_t;

/* 10608 */
struct __block_literal_3_8
{
  void *__isa;
  int __flags;
  int __reserved;
  kauth_cred_t (*__FuncPtr)(kauth_cred_t);
  __block_descriptor *__descriptor;
  vfs_context_t ctx;
  vnode *vp;
  off_t offset;
  vnode *scriptvp;
  label *scriptl;
  label *execl;
  unsigned int *csflags;
  void *macextensions;
  int *disjoint;
  int *update_return;
};

/* 10609 */
struct __block_literal_2_10
{
  void *__isa;
  int __flags;
  int __reserved;
  kauth_cred_t (*__FuncPtr)(kauth_cred_t);
  __block_descriptor *__descriptor;
  label *label;
};

/* 10610 */
struct __block_literal_4_9
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(kauth_cred_t);
  __block_descriptor *__descriptor;
  kauth_cred_t cred;
};

/* 10611 */
struct kauth_cache_sizes
{
  u_int32_t kcs_group_size;
  u_int32_t kcs_id_size;
};

/* 10612 */
struct __block_literal_1_23
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(kauth_cred_t);
  __block_descriptor *__descriptor;
  posix_cred_t pcred;
  kauth_cred_t cred;
};

/* 10613 */
struct thread_ro_0
{
  thread *tro_owner;
  ucred *tro_cred;
  proc *tro_proc;
  proc_ro *tro_proc_ro;
  task *tro_task;
  __attribute__((aligned(16))) ipc_port *tro_self_port;
  ipc_port *tro_settable_self_port;
  ipc_port *tro_ports[3];
  exception_action *tro_exc_actions;
};

/* 10614 */
struct kauth_identity_head
{
  kauth_identity *tqh_first;
  kauth_identity **tqh_last;
};

/* 10615 */
struct kauth_groups_head
{
  kauth_group_membership *tqh_first;
  kauth_group_membership **tqh_last;
};

/* 10616 */
struct kauth_resolver_done_head
{
  kauth_resolver_work *tqh_first;
  kauth_resolver_work **tqh_last;
};

/* 10617 */
struct kauth_resolver_submitted_head
{
  kauth_resolver_work *tqh_first;
  kauth_resolver_work **tqh_last;
};

/* 10618 */
struct kauth_resolver_unsubmitted_head
{
  kauth_resolver_work *tqh_first;
  kauth_resolver_work **tqh_last;
};

/* 10619 */
typedef addrable_bits_note addrable_bits_note_t;

/* 10620 */
struct clockinfo
{
  int hz;
  int tick;
  int tickadj;
  int stathz;
  int profhz;
};

/* 10621 */
struct __attribute__((aligned(4))) acct
{
  char ac_comm[10];
  comp_t ac_utime;
  comp_t ac_stime;
  comp_t ac_etime;
  u_int32_t ac_btime;
  uid_t ac_uid;
  gid_t ac_gid;
  u_int16_t ac_mem;
  comp_t ac_io;
  dev_t ac_tty;
  u_int8_t ac_flag;
};

/* 10622 */
struct event_chunk_header
{
  uint32_t tag;
  uint32_t sub_tag;
  uint64_t length;
  uint64_t future_events_timestamp;
};

/* 10623 */
typedef ml_topology_cluster_1 ml_topology_cluster_t_1;

/* 10624 */
typedef ml_topology_cpu_1 ml_topology_cpu_t_1;

/* 10625 */
struct __attribute__((aligned(8))) RAW_header
{
  int version_no;
  int thread_count;
  uint64_t TOD_secs;
  uint32_t TOD_usecs;
};

/* 10626 */
struct kbufinfo_t
{
  int nkdbufs;
  int nolog;
  unsigned int flags;
  int nkdthreads;
  int bufid;
};

/* 10627 */
struct __block_literal_1_24
{
  void *__isa;
  int __flags;
  int __reserved;
  vm_map_size_t (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
};

/* 10628 */
struct vnode_resolve_5
{
  lck_mtx_t vr_lock;
  trigger_vnode_resolve_callback_t_5 vr_resolve_func;
  trigger_vnode_unresolve_callback_t_2 vr_unresolve_func;
  trigger_vnode_rearm_callback_t vr_rearm_func;
  trigger_vnode_reclaim_callback_t_0 vr_reclaim_func;
  void *vr_data;
  uint32_t vr_flags;
  uint32_t vr_lastseq;
};

/* 10629 */
struct vfstable_6
{
  const vfsops *vfc_vfsops;
  char vfc_name[15];
  int vfc_typenum;
  int vfc_refcount;
  int vfc_flags;
  int (*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);
  vfstable *vfc_next;
  int32_t vfc_reserved1;
  int32_t vfc_reserved2;
  int vfc_vfsflags;
  void *vfc_descptr;
  uint32_t vfc_descsize;
  sysctl_oid_0 *vfc_sysctl;
};

/* 10630 */
struct workq_dispatch_config
{
  uint32_t wdc_version;
  uint32_t wdc_flags;
  uint64_t wdc_queue_serialno_offs;
  uint64_t wdc_queue_label_offs;
};

/* 10631 */
struct __block_literal_3_9
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(workq_threadreq_t);
  __block_descriptor *__descriptor;
  proc *p;
};

/* 10632 */
struct __block_literal_2_11
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(workq_threadreq_t);
  __block_descriptor *__descriptor;
  proc *p;
};

/* 10633 */
struct __block_literal_1_25
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(workq_threadreq_t);
  __block_descriptor *__descriptor;
  proc *p;
};

/* 10634 */
struct __block_literal_8_1
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  turnstile *req_ts;
  workqueue *wq;
};

/* 10635 */
struct __attribute__((packed)) __attribute__((aligned(1))) __block_literal_5_8
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  turnstile *wl_ts;
  turnstile_inheritor_t inheritor;
  turnstile_update_flags_t flags;
};

/* 10636 */
struct __block_literal_4_10
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  turnstile *workloop_ts;
  workqueue *wq;
};

/* 10637 */
typedef thread_extended_policy thread_extended_policy_data_t;

/* 10638 */
struct __block_literal_7_3
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  turnstile *req_ts;
  uthread *uth;
};

/* 10639 */
struct __attribute__((packed)) __attribute__((aligned(1))) __block_literal_6_5
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  workqueue *wq;
  turnstile_inheritor_t inheritor;
  turnstile_update_flags_t flags;
};

/* 10640 */
typedef unsigned int pthread_priority_compact_t;

/* 10641 */
struct kaudit_queue
{
  kaudit_record *tqh_first;
  kaudit_record **tqh_last;
};

/* 10642 */
struct vnode_resolve_6
{
  lck_mtx_t vr_lock;
  trigger_vnode_resolve_callback_t_6 vr_resolve_func;
  trigger_vnode_unresolve_callback_t_3 vr_unresolve_func;
  trigger_vnode_rearm_callback_t vr_rearm_func;
  trigger_vnode_reclaim_callback_t vr_reclaim_func;
  void *vr_data;
  uint32_t vr_flags;
  uint32_t vr_lastseq;
};

/* 10643 */
struct vfstable_7
{
  const vfsops *vfc_vfsops;
  char vfc_name[15];
  int vfc_typenum;
  int vfc_refcount;
  int vfc_flags;
  int (*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);
  vfstable *vfc_next;
  int32_t vfc_reserved1;
  int32_t vfc_reserved2;
  int vfc_vfsflags;
  void *vfc_descptr;
  uint32_t vfc_descsize;
  sysctl_oid_0 *vfc_sysctl;
};

/* 10644 */
struct slck_0
{
  lck_mtx_t *sl_mtx;
  int sl_locked;
  int sl_waiting;
};

/* 10645 */
struct rwlock_0
{
  lck_rw_t *rw_lock;
};

/* 10646 */
struct mtx_0
{
  lck_mtx_t *mtx_lock;
};

/* 10647 */
struct pfkeystat
{
  u_quad_t out_total;
  u_quad_t out_bytes;
  u_quad_t out_msgtype[256];
  u_quad_t out_invlen;
  u_quad_t out_invver;
  u_quad_t out_invmsgtype;
  u_quad_t out_tooshort;
  u_quad_t out_nomem;
  u_quad_t out_dupext;
  u_quad_t out_invexttype;
  u_quad_t out_invsatype;
  u_quad_t out_invaddr;
  u_quad_t in_total;
  u_quad_t in_bytes;
  u_quad_t in_msgtype[256];
  u_quad_t in_msgtarget[3];
  u_quad_t in_nomem;
  u_quad_t sockerr;
};

/* 10648 */
struct in6_multistep
{
  in6_ifaddr *i_ia;
  in6_multi *i_in6m;
};

/* 10649 */
struct _keystat
{
  u_int32_t getspi_count;
};

/* 10650 */
struct key_cb
{
  int key_count;
  int any_count;
};

/* 10651 */
struct _spacqtree
{
  secspacq *lh_first;
};

/* 10652 */
struct _acqtree
{
  secacq *lh_first;
};

/* 10653 */
struct _custom_sahtree
{
  secashead *lh_first;
};

/* 10654 */
struct __attribute__((aligned(4))) secasvar_0
{
  struct
  {
    secasvar *le_next;
    secasvar **le_prev;
  } chain;
  struct
  {
    secasvar *le_next;
    secasvar **le_prev;
  } spihash;
  int refcnt;
  u_int8_t state;
  u_int8_t alg_auth;
  u_int8_t alg_enc;
  u_int32_t spi;
  u_int32_t flags;
  u_int16_t flags2;
  sadb_key *key_auth;
  sadb_key *key_enc;
  caddr_t iv;
  u_int ivlen;
  void *sched;
  size_t schedlen;
  secreplay *replay[4];
  u_int64_t created;
  sadb_lifetime *lft_c;
  sadb_lifetime *lft_h;
  sadb_lifetime *lft_s;
  socket *so;
  u_int32_t seq;
  pid_t pid;
  secashead *sah;
  u_int64_t natt_last_activity;
  u_int16_t remote_ike_port;
  u_int16_t natt_encapsulated_src_port;
  u_int16_t natt_interval;
  u_int16_t natt_offload_interval;
  uint32_t flowid;
  u_int8_t always_expire;
};

/* 10655 */
struct _sahtree
{
  secashead *lh_first;
};

/* 10656 */
struct ifnet_7
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func_1 if_output_dlil;
  volatile ifnet_start_func_0 if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func_0 if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func_0 if_input_ctl;
  ifnet_ioctl_func_0 if_ioctl;
  ifnet_set_bpf_tap_0 if_set_bpf_tap;
  ifnet_detached_func_0 if_free;
  ifnet_demux_func_1 if_demux;
  ifnet_event_func_0 if_event;
  ifnet_framer_func_1 if_framer_legacy;
  ifnet_framer_extended_func_0 if_framer;
  ifnet_add_proto_func_0 if_add_proto;
  ifnet_del_proto_func_0 if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func_0 if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func_0 if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route_0 if_fwd_route;
  route_0 if_src_route;
  route_in6 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 10657 */
struct rip6stat
{
  u_quad_t rip6s_ipackets;
  u_quad_t rip6s_isum;
  u_quad_t rip6s_badsum;
  u_quad_t rip6s_nosock;
  u_quad_t rip6s_nosockmcast;
  u_quad_t rip6s_fullsock;
  u_quad_t rip6s_opackets;
};

/* 10658 */
struct nd_pfxrouter_0
{
  struct
  {
    nd_pfxrouter *le_next;
    nd_pfxrouter **le_prev;
  } pfr_entry;
  nd_defrouter *router;
};

/* 10659 */
struct kev_nd6_ndalive
{
  net_event_data link_data;
};

/* 10660 */
struct dadq_head
{
  dadq *tqh_first;
  dadq **tqh_last;
};

/* 10661 */
struct __attribute__((aligned(8))) in6_nbrinfo_64
{
  char ifname[16];
  in6_addr_0 addr;
  long asked;
  int isrouter;
  int state;
  int expire;
};

/* 10662 */
struct in6_nbrinfo_32
{
  char ifname[16];
  in6_addr_0 addr;
  u_int32_t asked;
  int isrouter;
  int state;
  int expire;
};

/* 10663 */
struct __attribute__((aligned(8))) kev_nd6_ra_data
{
  u_int32_t mtu;
  u_int32_t list_index;
  u_int32_t list_length;
  u_int32_t flags;
  nd6_ra_prefix prefix;
  u_int32_t pad;
};

/* 10664 */
struct in6_prefix_32
{
  sockaddr_in6 prefix;
  prf_ra raflags;
  u_char prefixlen;
  u_char origin;
  u_int32_t vltime;
  u_int32_t pltime;
  u_int32_t expire;
  u_int32_t flags;
  int refcnt;
  u_short if_index;
  u_short advrtrs;
};

/* 10665 */
struct __attribute__((aligned(8))) in6_prefix_64
{
  sockaddr_in6 prefix;
  prf_ra raflags;
  u_char prefixlen;
  u_char origin;
  u_long vltime;
  u_long pltime;
  u_long expire;
  u_int32_t flags;
  int refcnt;
  u_short if_index;
  u_short advrtrs;
};

/* 10666 */
struct kev_nd6_ndfailure
{
  net_event_data link_data;
};

/* 10667 */
struct in6_ifaddr_0
{
  ifaddr ia_ifa;
  sockaddr_in6 ia_addr;
  sockaddr_in6 ia_net;
  sockaddr_in6 ia_dstaddr;
  sockaddr_in6 ia_prefixmask;
  u_int32_t ia_plen;
  struct
  {
    in6_ifaddr *tqe_next;
    in6_ifaddr **tqe_prev;
  } ia6_link;
  struct
  {
    in6_ifaddr *tqe_next;
    in6_ifaddr **tqe_prev;
  } ia6_hash;
  int ia6_flags;
  uint8_t ia6_cga_collision_count;
  in6_addrlifetime_i ia6_lifetime;
  u_int64_t ia6_createtime;
  u_int64_t ia6_updatetime;
  nd_prefix *ia6_ndpr;
  struct
  {
    in6_multi_mship *lh_first;
  } ia6_memberships;
};

/* 10668 */
struct nd_rtihead
{
  nd_route_info *tqh_first;
  nd_route_info **tqh_last;
};

/* 10669 */
struct nd_prhead
{
  nd_prefix *lh_first;
};

/* 10670 */
struct ip6_moptions_0
{
  lck_mtx_t im6o_lock;
  uint32_t im6o_refcnt;
  uint32_t im6o_debug;
  ifnet *im6o_multicast_ifp;
  u_char im6o_multicast_hlim;
  u_char im6o_multicast_loop;
  u_short im6o_num_memberships;
  u_short im6o_max_memberships;
  in6_multi **im6o_membership;
  in6_mfilter *im6o_mfilters;
  void (*im6o_trace)(ip6_moptions *, int);
};

/* 10671 */
struct mld_ifinfo_u
{
  uint32_t mli_ifindex;
  uint32_t mli_version;
  uint32_t mli_v1_timer;
  uint32_t mli_v2_timer;
  uint32_t mli_flags;
  uint32_t mli_rv;
  uint32_t mli_qi;
  uint32_t mli_qri;
  uint32_t mli_uri;
  uint32_t _pad;
};

/* 10672 */
enum rectype_t : __int32
{
  REC_NONE = 0x0,
  REC_ALLOW = 0x1,
  REC_BLOCK = 0x2,
  REC_FULL = 0x3,
};

/* 10673 */
struct ip6_pktopts_0
{
  mbuf *ip6po_m;
  int ip6po_hlim;
  in6_pktinfo *ip6po_pktinfo;
  ip6po_nhinfo ip6po_nhinfo;
  ip6_hbh *ip6po_hbh;
  ip6_dest *ip6po_dest1;
  ip6po_rhinfo ip6po_rhinfo;
  ip6_dest *ip6po_dest2;
  int ip6po_tclass;
  int ip6po_minmtu;
  int ip6po_prefer_tempaddr;
  int ip6po_flags;
};

/* 10674 */
struct mld_raopt
{
  ip6_hbh hbh;
  ip6_opt pad;
  ip6_opt_router ra;
};

/* 10675 */
struct in6_multi_0
{
  lck_mtx_t in6m_lock;
  u_int32_t in6m_refcount;
  u_int32_t in6m_reqcnt;
  u_int32_t in6m_debug;
  struct
  {
    in6_multi *le_next;
    in6_multi **le_prev;
  } in6m_entry;
  in6_addr_0 in6m_addr;
  uint32_t ifscope;
  ifnet *in6m_ifp;
  ifmultiaddr *in6m_ifma;
  u_int in6m_state;
  u_int in6m_timer;
  mld_ifinfo *in6m_mli;
  struct
  {
    in6_multi *sle_next;
  } in6m_dtle;
  struct
  {
    in6_multi *sle_next;
  } in6m_nrele;
  u_int32_t in6m_nrelecnt;
  ip6_msource_tree in6m_srcs;
  u_long in6m_nsrc;
  ifqueue in6m_scq;
  timeval in6m_lastgsrtv;
  uint16_t in6m_sctimer;
  uint16_t in6m_scrv;
  in6m_st in6m_st[2];
  void (*in6m_trace)(in6_multi *, int);
};

/* 10676 */
struct lltable_2
{
  struct
  {
    lltable *sle_next;
  } llt_link;
  int llt_af;
  int llt_hsize;
  llentries *lle_head;
  ifnet *llt_ifp;
  llt_lookup_t *llt_lookup;
  llt_alloc_t *llt_alloc_entry;
  llt_delete_t *llt_delete_entry;
  llt_prefix_free_t *llt_prefix_free;
  llt_dump_entry_t *llt_dump_entry;
  llt_hash_t *llt_hash;
  llt_match_prefix_t *llt_match_prefix;
  llt_free_entry_t *llt_free_entry;
  llt_foreach_entry_t *llt_foreach_entry;
  llt_link_entry_t *llt_link_entry;
  llt_unlink_entry_t *llt_unlink_entry;
  llt_fill_sa_entry_t *llt_fill_sa_entry;
};

/* 10677 */
struct in_multi_0
{
  lck_mtx_t inm_lock;
  u_int32_t inm_refcount;
  u_int32_t inm_reqcnt;
  u_int32_t inm_debug;
  struct
  {
    in_multi *le_next;
    in_multi **le_prev;
  } inm_link;
  in_addr inm_addr;
  ifnet *inm_ifp;
  ifmultiaddr *inm_ifma;
  u_int inm_timer;
  u_int inm_state;
  void *inm_rti;
  igmp_ifinfo *inm_igi;
  struct
  {
    in_multi *sle_next;
  } inm_dtle;
  struct
  {
    in_multi *sle_next;
  } inm_nrele;
  u_int32_t inm_nrelecnt;
  ip_msource_tree inm_srcs;
  u_long inm_nsrc;
  ifqueue inm_scq;
  timeval inm_lastgsrtv;
  uint16_t inm_sctimer;
  uint16_t inm_scrv;
  inm_st inm_st[2];
  void (*inm_trace)(in_multi *, int);
};

/* 10678 */
struct ifmultiaddr_3
{
  lck_mtx_t ifma_lock;
  u_int32_t ifma_refcount;
  u_int32_t ifma_anoncnt;
  u_int32_t ifma_reqcnt;
  u_int32_t ifma_debug;
  u_int32_t ifma_flags;
  struct
  {
    ifmultiaddr *le_next;
    ifmultiaddr **le_prev;
  } ifma_link;
  sockaddr *ifma_addr;
  ifmultiaddr *ifma_ll;
  ifnet *ifma_ifp;
  void *ifma_protospec;
  void (*ifma_trace)(ifmultiaddr *, int);
};

/* 10679 */
struct ifclassq_2
{
  lck_mtx_t ifcq_lock;
  os_refcnt_t ifcq_refcnt;
  ifnet *ifcq_ifp;
  u_int32_t ifcq_len;
  u_int32_t ifcq_maxlen;
  pktcntr ifcq_xmitcnt;
  pktcntr ifcq_dropcnt;
  u_int32_t ifcq_type;
  u_int32_t ifcq_flags;
  u_int32_t ifcq_sflags;
  u_int32_t ifcq_target_qdelay;
  u_int32_t ifcq_bytes;
  u_int32_t ifcq_pkt_drop_limit;
  void *ifcq_disc;
  ifclassq_disc_slot ifcq_disc_slots[10];
  tb_regulator ifcq_tbr;
};

/* 10680 */
struct rtentry_4
{
  radix_node rt_nodes[2];
  lck_mtx_t rt_lock;
  uint32_t rt_refcnt;
  uint32_t rt_flags;
  uint32_t rt_genid;
  sockaddr *rt_gateway;
  ifnet *rt_ifp;
  ifaddr *rt_ifa;
  sockaddr *rt_genmask;
  void *rt_llinfo;
  void (*rt_llinfo_get_ri)(rtentry *, rt_reach_info *);
  void (*rt_llinfo_get_iflri)(rtentry *, ifnet_llreach_info *);
  void (*rt_llinfo_purge)(rtentry *);
  void (*rt_llinfo_free)(void *);
  void (*rt_llinfo_refresh)(rtentry *);
  rt_metrics rt_rmx;
  rtentry *rt_gwroute;
  rtentry *rt_parent;
  nstat_counts *rt_stats;
  void (*rt_if_ref_fn)(ifnet *, int);
  uint32_t *rt_tree_genid;
  uint64_t rt_expire;
  uint64_t base_calendartime;
  uint64_t base_uptime;
  u_int32_t rtt_hist[10];
  u_int32_t rtt_min;
  u_int32_t rtt_expire_ts;
  u_int8_t rtt_index;
  eventhandler_lists_ctxt rt_evhdlr_ctxt;
};

/* 10681 */
struct mld_ifinfo_0
{
  lck_mtx_t mli_lock;
  uint32_t mli_refcnt;
  uint32_t mli_debug;
  struct
  {
    mld_ifinfo *le_next;
    mld_ifinfo **le_prev;
  } mli_link;
  ifnet *mli_ifp;
  uint32_t mli_version;
  uint32_t mli_v1_timer;
  uint32_t mli_v2_timer;
  uint32_t mli_flags;
  uint32_t mli_rv;
  uint32_t mli_qi;
  uint32_t mli_qri;
  uint32_t mli_uri;
  struct
  {
    in6_multi *slh_first;
  } mli_relinmhead;
  ifqueue mli_gq;
  ifqueue mli_v1q;
};

/* 10682 */
struct __attribute__((packed)) __attribute__((aligned(4))) group_source_req
{
  uint32_t gsr_interface;
  sockaddr_storage gsr_group;
  sockaddr_storage gsr_source;
};

/* 10683 */
struct __attribute__((packed)) __attribute__((aligned(4))) __msfilterreq32
{
  uint32_t msfr_ifindex;
  uint32_t msfr_fmode;
  uint32_t msfr_nsrcs;
  uint32_t __msfr_align;
  sockaddr_storage msfr_group;
  user32_addr_t msfr_srcs;
};

/* 10684 */
struct __msfilterreq64
{
  uint32_t msfr_ifindex;
  uint32_t msfr_fmode;
  uint32_t msfr_nsrcs;
  uint32_t __msfr_align;
  sockaddr_storage msfr_group;
  user64_addr_t msfr_srcs;
};

/* 10685 */
struct ip_moptions_0
{
  lck_mtx_t imo_lock;
  uint32_t imo_refcnt;
  uint32_t imo_debug;
  ifnet *imo_multicast_ifp;
  u_char imo_multicast_ttl;
  u_char imo_multicast_loop;
  u_short imo_num_memberships;
  u_short imo_max_memberships;
  in_multi **imo_membership;
  in_mfilter *imo_mfilters;
  u_int32_t imo_multicast_vif;
  in_addr imo_multicast_addr;
  void (*imo_trace)(ip_moptions *, int);
};

/* 10686 */
struct nd_defrouter_0
{
  lck_mtx_t nddr_lock;
  lck_mtx_t nddr_ref_lock;
  struct
  {
    nd_defrouter *tqe_next;
    nd_defrouter **tqe_prev;
  } dr_entry;
  in6_addr_0 rtaddr;
  u_int32_t nddr_refcount;
  u_int32_t nddr_debug;
  u_int64_t expire;
  u_int64_t base_calendartime;
  u_int64_t base_uptime;
  u_char flags;
  u_char stateflags;
  u_int32_t rtlifetime;
  int err;
  ifnet *ifp;
  in6_addr_0 rtaddr_mapped;
  boolean_t is_reachable;
  void (*nddr_trace)(nd_defrouter *, int);
};

/* 10687 */
struct nd_prefix_0
{
  lck_mtx_t ndpr_lock;
  lck_mtx_t ndpr_ref_lock;
  u_int32_t ndpr_refcount;
  u_int32_t ndpr_debug;
  ifnet *ndpr_ifp;
  rtentry *ndpr_rt;
  struct
  {
    nd_prefix *le_next;
    nd_prefix **le_prev;
  } ndpr_entry;
  sockaddr_in6 ndpr_prefix;
  in6_addr_0 ndpr_mask;
  in6_addr_0 ndpr_addr;
  u_int32_t ndpr_vltime;
  u_int32_t ndpr_pltime;
  u_int64_t ndpr_preferred;
  u_int64_t ndpr_expire;
  u_int64_t ndpr_lastupdate;
  u_int64_t ndpr_base_calendartime;
  u_int64_t ndpr_base_uptime;
  prf_ra ndpr_flags;
  unsigned int ndpr_genid;
  u_int32_t ndpr_stateflags;
  pr_rtrhead ndpr_advrtrs;
  u_char ndpr_plen;
  int ndpr_addrcnt;
  int ndpr_manual_addrcnt;
  u_int32_t ndpr_allmulti_cnt;
  u_int32_t ndpr_prproxy_sols_cnt;
  prproxy_sols_tree ndpr_prproxy_sols;
  void (*ndpr_trace)(nd_prefix *, int);
};

/* 10688 */
struct in6_multistep_0
{
  in6_ifaddr *i_ia;
  in6_multi *i_in6m;
};

/* 10689 */
struct in6_multi_mship_0
{
  in6_multi *i6mm_maddr;
  struct
  {
    in6_multi_mship *le_next;
    in6_multi_mship **le_prev;
  } i6mm_chain;
};

/* 10690 */
struct in6_multihead
{
  in6_multi *lh_first;
};

/* 10691 */
struct addrsel_policyhead
{
  addrsel_policyent *tqh_first;
  addrsel_policyent **tqh_last;
};

/* 10692 */
struct ip6_mtuinfo
{
  sockaddr_in6 ip6m_addr;
  uint32_t ip6m_mtu;
};

/* 10693 */
struct __attribute__((aligned(8))) ip_fw_args_0
{
  mbuf *fwa_m;
  ifnet *fwa_oif;
  pf_rule *fwa_pf_rule;
  ether_header *fwa_eh;
  int fwa_flags;
  int fwa_oflags;
  union
  {
    ip_out_args *_fwa_ipoa;
    ip6_out_args *_fwa_ip6oa;
  } fwa_ipoa_;
  union
  {
    route *_fwa_ro;
    route_in6 *_fwa_ro6;
  } fwa_ro_;
  union
  {
    sockaddr_in *_fwa_dst;
    sockaddr_in6 *_fwa_dst6;
  } fwa_dst_;
  route_in6 *fwa_ro6_pmtu;
  ifnet *fwa_origifp;
  u_int32_t fwa_mtu;
  u_int32_t fwa_unfragpartlen;
  ip6_exthdrs *fwa_exthdrs;
  ip_flow_id fwa_id;
  u_int32_t fwa_cookie;
};

/* 10694 */
typedef ip6_check_if_result ip6_check_if_result_t;

/* 10695 */
struct __attribute__((aligned(8))) ipfilter_0
{
  struct
  {
    ipfilter *tqe_next;
    ipfilter **tqe_prev;
  } ipf_link;
  ipf_filter_0 ipf_filter;
  ipfilter_list *ipf_head;
  struct
  {
    ipfilter *tqe_next;
    ipfilter **tqe_prev;
  } ipf_tbr;
  uint32_t ipf_flags;
};

/* 10696 */
struct ip6stat
{
  u_quad_t ip6s_total;
  u_quad_t ip6s_tooshort;
  u_quad_t ip6s_toosmall;
  u_quad_t ip6s_fragments;
  u_quad_t ip6s_fragdropped;
  u_quad_t ip6s_fragtimeout;
  u_quad_t ip6s_fragoverflow;
  u_quad_t ip6s_forward;
  u_quad_t ip6s_cantforward;
  u_quad_t ip6s_redirectsent;
  u_quad_t ip6s_delivered;
  u_quad_t ip6s_localout;
  u_quad_t ip6s_odropped;
  u_quad_t ip6s_reassembled;
  u_quad_t ip6s_atmfrag_rcvd;
  u_quad_t ip6s_fragmented;
  u_quad_t ip6s_ofragments;
  u_quad_t ip6s_cantfrag;
  u_quad_t ip6s_badoptions;
  u_quad_t ip6s_noroute;
  u_quad_t ip6s_badvers;
  u_quad_t ip6s_rawout;
  u_quad_t ip6s_badscope;
  u_quad_t ip6s_notmember;
  u_quad_t ip6s_nxthist[256];
  u_quad_t ip6s_m1;
  u_quad_t ip6s_m2m[32];
  u_quad_t ip6s_mext1;
  u_quad_t ip6s_mext2m;
  u_quad_t ip6s_exthdrtoolong;
  u_quad_t ip6s_nogif;
  u_quad_t ip6s_toomanyhdr;
  u_quad_t ip6s_sources_none;
  u_quad_t ip6s_sources_sameif[16];
  u_quad_t ip6s_sources_otherif[16];
  u_quad_t ip6s_sources_samescope[16];
  u_quad_t ip6s_sources_otherscope[16];
  u_quad_t ip6s_sources_deprecated[16];
  u_quad_t ip6s_forward_cachehit;
  u_quad_t ip6s_forward_cachemiss;
  u_quad_t ip6s_sources_rule[16];
  u_quad_t ip6s_sources_skip_expensive_secondary_if;
  u_quad_t ip6s_pktdropcntrl;
  u_quad_t ip6s_adj;
  u_quad_t ip6s_adj_hwcsum_clr;
  u_quad_t ip6s_dad_collide;
  u_quad_t ip6s_dad_loopcount;
  u_quad_t ip6s_necp_policy_drop;
  u_quad_t ip6s_clat464_in_tooshort_drop;
  u_quad_t ip6s_clat464_in_nov6addr_drop;
  u_quad_t ip6s_clat464_in_nov4addr_drop;
  u_quad_t ip6s_clat464_in_v4synthfail_drop;
  u_quad_t ip6s_clat464_in_64transfail_drop;
  u_quad_t ip6s_clat464_in_64proto_transfail_drop;
  u_quad_t ip6s_clat464_in_64frag_transfail_drop;
  u_quad_t ip6s_clat464_in_invalpbuf_drop;
  u_quad_t ip6s_clat464_in_success;
  u_quad_t ip6s_clat464_in_drop;
  u_quad_t ip6s_clat464_in_v4_drop;
  u_quad_t ip6s_clat464_out_nov6addr_drop;
  u_quad_t ip6s_clat464_out_v6synthfail_drop;
  u_quad_t ip6s_clat464_out_46transfail_drop;
  u_quad_t ip6s_clat464_out_46proto_transfail_drop;
  u_quad_t ip6s_clat464_out_46frag_transfail_drop;
  u_quad_t ip6s_clat464_out_invalpbuf_drop;
  u_quad_t ip6s_clat464_out_success;
  u_quad_t ip6s_clat464_out_drop;
  u_quad_t ip6s_clat464_v6addr_conffail;
  u_quad_t ip6s_clat464_plat64_pfx_setfail;
  u_quad_t ip6s_clat464_plat64_pfx_getfail;
  u_quad_t ip6s_overlap_frag_drop;
  u_quad_t ip6s_rcv_if_weak_match;
  u_quad_t ip6s_rcv_if_no_match;
};

/* 10697 */
struct in6_ifaddrhead
{
  in6_ifaddr *tqh_first;
  in6_ifaddr **tqh_last;
};

/* 10698 */
struct in6_aliasreq_0
{
  char ifra_name[16];
  sockaddr_in6 ifra_addr;
  sockaddr_in6 ifra_broadaddr;
  sockaddr_in6 ifra_prefixmask;
  int ifra_flags;
  in6_addrlifetime ifra_lifetime;
};

/* 10699 */
struct lltable_3
{
  struct
  {
    lltable *sle_next;
  } llt_link;
  int llt_af;
  int llt_hsize;
  llentries *lle_head;
  ifnet *llt_ifp;
  llt_lookup_t *llt_lookup;
  llt_alloc_t *llt_alloc_entry;
  llt_delete_t *llt_delete_entry;
  llt_prefix_free_t *llt_prefix_free;
  llt_dump_entry_t *llt_dump_entry;
  llt_hash_t *llt_hash;
  llt_match_prefix_t *llt_match_prefix;
  llt_free_entry_t *llt_free_entry;
  llt_foreach_entry_t *llt_foreach_entry;
  llt_link_entry_t *llt_link_entry;
  llt_unlink_entry_t *llt_unlink_entry;
  llt_fill_sa_entry_t *llt_fill_sa_entry;
};

/* 10700 */
struct __attribute__((aligned(8))) ip_fw_args_1
{
  mbuf *fwa_m;
  ifnet *fwa_oif;
  pf_rule *fwa_pf_rule;
  ether_header *fwa_eh;
  int fwa_flags;
  int fwa_oflags;
  union
  {
    ip_out_args *_fwa_ipoa;
    ip6_out_args *_fwa_ip6oa;
  } fwa_ipoa_;
  union
  {
    route *_fwa_ro;
    route_in6 *_fwa_ro6;
  } fwa_ro_;
  union
  {
    sockaddr_in *_fwa_dst;
    sockaddr_in6 *_fwa_dst6;
  } fwa_dst_;
  route_in6 *fwa_ro6_pmtu;
  ifnet *fwa_origifp;
  u_int32_t fwa_mtu;
  u_int32_t fwa_unfragpartlen;
  ip6_exthdrs *fwa_exthdrs;
  ip_flow_id fwa_id;
  u_int32_t fwa_cookie;
};

/* 10701 */
struct ipsec_output_state_0
{
  int tunneled;
  mbuf *m;
  route_in6_0 ro;
  sockaddr *dst;
  u_int outgoing_if;
  u_int32_t dscp_mapping;
};

/* 10702 */
struct ifnet_8
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func_0 if_output_dlil;
  volatile ifnet_start_func if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func if_input_ctl;
  ifnet_ioctl_func if_ioctl;
  ifnet_set_bpf_tap if_set_bpf_tap;
  ifnet_detached_func if_free;
  ifnet_demux_func_0 if_demux;
  ifnet_event_func if_event;
  ifnet_framer_func_1 if_framer_legacy;
  ifnet_framer_extended_func_0 if_framer;
  ifnet_add_proto_func if_add_proto;
  ifnet_del_proto_func if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route_0 if_fwd_route;
  route_0 if_src_route;
  route_in6_0 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 10703 */
struct recv_msg_elem_1
{
  uio *uio;
  sockaddr *psa;
  mbuf *controlp;
  int which;
  int flags;
};

/* 10704 */
struct ext_ref_0
{
  mbuf *paired;
  u_int16_t minref;
  u_int16_t refcnt;
  u_int16_t prefcnt;
  u_int16_t flags;
  u_int32_t priv;
  uintptr_t ext_token;
};

/* 10705 */
struct in6_cga_singleton
{
  boolean_t cga_initialized;
  lck_mtx_t cga_mutex;
  in6_cga_prepare cga_prepare;
  iovec cga_pubkey;
  iovec cga_privkey;
};

/* 10706 */
struct kev_nd6_event
{
  net_event_data link_data;
  in6_addr_0 in6_address;
  uint32_t val;
};

/* 10707 */
struct __attribute__((aligned(4))) kev_in6_data
{
  net_event_data link_data;
  sockaddr_in6 ia_addr;
  sockaddr_in6 ia_net;
  sockaddr_in6 ia_dstaddr;
  sockaddr_in6 ia_prefixmask;
  u_int32_t ia_plen;
  u_int32_t ia6_flags;
  kev_in6_addrlifetime ia_lifetime;
  uint8_t ia_mac[6];
};

/* 10708 */
struct ip6_pktopts_1
{
  mbuf *ip6po_m;
  int ip6po_hlim;
  in6_pktinfo *ip6po_pktinfo;
  ip6po_nhinfo_0 ip6po_nhinfo;
  ip6_hbh *ip6po_hbh;
  ip6_dest *ip6po_dest1;
  ip6po_rhinfo_0 ip6po_rhinfo;
  ip6_dest *ip6po_dest2;
  int ip6po_tclass;
  int ip6po_minmtu;
  int ip6po_prefer_tempaddr;
  int ip6po_flags;
};

/* 10709 */
struct __attribute__((aligned(8))) inpcb_0
{
  lck_mtx_t inpcb_mtx;
  struct
  {
    inpcb *le_next;
    inpcb **le_prev;
  } inp_hash;
  struct
  {
    inpcb *le_next;
    inpcb **le_prev;
  } inp_list;
  void *inp_ppcb;
  inpcbinfo *inp_pcbinfo;
  socket *inp_socket;
  struct
  {
    inpcb *le_next;
    inpcb **le_prev;
  } inp_portlist;
  struct
  {
    inpcb *rbe_left;
    inpcb *rbe_right;
    inpcb *rbe_parent;
  } infc_link;
  inpcbport *inp_phd;
  inp_gen_t inp_gencnt;
  int inp_hash_element;
  int inp_wantcnt;
  int inp_state;
  u_short inp_fport;
  u_short inp_lport;
  u_int32_t inp_flags;
  u_int32_t inp_flags2;
  u_int32_t inp_flow;
  uint32_t inp_lifscope;
  uint32_t inp_fifscope;
  u_char inp_sndinprog_cnt;
  uint32_t inp_sndingprog_waiters;
  u_char inp_vflag;
  u_char inp_ip_ttl;
  u_char inp_ip_p;
  ifnet *inp_boundifp;
  ifnet *inp_last_outifp;
  u_int32_t inp_flowhash;
  union
  {
    in_addr_4in6 inp46_foreign;
    in6_addr_0 inp6_foreign;
  } inp_dependfaddr;
  union
  {
    in_addr_4in6 inp46_local;
    in6_addr_0 inp6_local;
  } inp_dependladdr;
  union
  {
    route_0 inp4_route;
    route_in6_1 inp6_route;
  } inp_dependroute;
  struct
  {
    u_char inp4_ip_tos;
    mbuf *inp4_options;
    ip_moptions *inp4_moptions;
  } inp_depend4;
  struct __attribute__((aligned(4)))
  {
    mbuf *inp6_options;
    ip6_pktopts *inp6_outputopts;
    ip6_moptions *inp6_moptions;
    icmp6_filter *inp6_icmp6filt;
    int inp6_cksum;
    short inp6_hops;
  } inp_depend6;
  uint64_t inp_fadv_flow_ctrl_cnt;
  uint64_t inp_fadv_suspended_cnt;
  caddr_t inp_saved_ppcb;
  inpcbpolicy *inp_sp;
  inp_necp_attributes inp_necp_attributes;
  necp_inpcb_result inp_policyresult;
  uuid_t_1 necp_client_uuid;
  necp_client_flow_cb necp_cb;
  u_int8_t *inp_resolver_signature;
  size_t inp_resolver_signature_length;
  netns_token inp_netns_token;
  netns_token inp_wildcard_netns_token;
  u_char *inp_keepalive_data;
  u_int8_t inp_keepalive_datalen;
  u_int8_t inp_keepalive_type;
  u_int16_t inp_keepalive_interval;
  uint32_t inp_nstat_refcnt;
  inp_stat *inp_stat;
  inp_stat *inp_cstat;
  inp_stat *inp_wstat;
  inp_stat *inp_Wstat;
  u_int8_t inp_stat_store[40];
  u_int8_t inp_cstat_store[40];
  u_int8_t inp_wstat_store[40];
  u_int8_t inp_Wstat_store[40];
  activity_bitmap_t inp_nw_activity;
  u_int64_t inp_start_timestamp;
  char inp_last_proc_name[17];
  char inp_e_proc_name[17];
};

/* 10710 */
struct __attribute__((aligned(8))) ip6ctlparam_0
{
  mbuf *ip6c_m;
  icmp6_hdr *ip6c_icmp6;
  ip6_hdr *ip6c_ip6;
  int ip6c_off;
  sockaddr_in6 *ip6c_src;
  sockaddr_in6 *ip6c_dst;
  in6_addr_0 *ip6c_finaldst;
  void *ip6c_cmdarg;
  u_int8_t ip6c_nxt;
};

/* 10711 */
struct ifnet_9
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func if_output_dlil;
  volatile ifnet_start_func if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func if_input_ctl;
  ifnet_ioctl_func if_ioctl;
  ifnet_set_bpf_tap if_set_bpf_tap;
  ifnet_detached_func if_free;
  ifnet_demux_func if_demux;
  ifnet_event_func if_event;
  ifnet_framer_func_0 if_framer_legacy;
  ifnet_framer_extended_func if_framer;
  ifnet_add_proto_func if_add_proto;
  ifnet_del_proto_func if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route_0 if_fwd_route;
  route_0 if_src_route;
  route_in6_1 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 10712 */
struct icmp6stat
{
  u_quad_t icp6s_error;
  u_quad_t icp6s_canterror;
  u_quad_t icp6s_toofreq;
  u_quad_t icp6s_outhist[256];
  u_quad_t icp6s_badcode;
  u_quad_t icp6s_tooshort;
  u_quad_t icp6s_checksum;
  u_quad_t icp6s_badlen;
  u_quad_t icp6s_reflect;
  u_quad_t icp6s_inhist[256];
  u_quad_t icp6s_nd_toomanyopt;
  icmp6errstat icp6s_outerrhist;
  u_quad_t icp6s_pmtuchg;
  u_quad_t icp6s_nd_badopt;
  u_quad_t icp6s_badns;
  u_quad_t icp6s_badna;
  u_quad_t icp6s_badrs;
  u_quad_t icp6s_badra;
  u_quad_t icp6s_badredirect;
  u_quad_t icp6s_rfc6980_drop;
  u_quad_t icp6s_badpkttoobig;
};

/* 10713 */
struct ipsec_wake_pkt_event_data
{
  uuid_string_t wake_uuid;
};

/* 10714 */
struct __attribute__((aligned(8))) inpcb_1
{
  lck_mtx_t inpcb_mtx;
  struct
  {
    inpcb *le_next;
    inpcb **le_prev;
  } inp_hash;
  struct
  {
    inpcb *le_next;
    inpcb **le_prev;
  } inp_list;
  void *inp_ppcb;
  inpcbinfo *inp_pcbinfo;
  socket *inp_socket;
  struct
  {
    inpcb *le_next;
    inpcb **le_prev;
  } inp_portlist;
  struct
  {
    inpcb *rbe_left;
    inpcb *rbe_right;
    inpcb *rbe_parent;
  } infc_link;
  inpcbport *inp_phd;
  inp_gen_t inp_gencnt;
  int inp_hash_element;
  int inp_wantcnt;
  int inp_state;
  u_short inp_fport;
  u_short inp_lport;
  u_int32_t inp_flags;
  u_int32_t inp_flags2;
  u_int32_t inp_flow;
  uint32_t inp_lifscope;
  uint32_t inp_fifscope;
  u_char inp_sndinprog_cnt;
  uint32_t inp_sndingprog_waiters;
  u_char inp_vflag;
  u_char inp_ip_ttl;
  u_char inp_ip_p;
  ifnet *inp_boundifp;
  ifnet *inp_last_outifp;
  u_int32_t inp_flowhash;
  union
  {
    in_addr_4in6 inp46_foreign;
    in6_addr_0 inp6_foreign;
  } inp_dependfaddr;
  union
  {
    in_addr_4in6 inp46_local;
    in6_addr_0 inp6_local;
  } inp_dependladdr;
  union
  {
    route_0 inp4_route;
    route_in6 inp6_route;
  } inp_dependroute;
  struct
  {
    u_char inp4_ip_tos;
    mbuf *inp4_options;
    ip_moptions *inp4_moptions;
  } inp_depend4;
  struct __attribute__((aligned(4)))
  {
    mbuf *inp6_options;
    ip6_pktopts *inp6_outputopts;
    ip6_moptions *inp6_moptions;
    icmp6_filter *inp6_icmp6filt;
    int inp6_cksum;
    short inp6_hops;
  } inp_depend6;
  uint64_t inp_fadv_flow_ctrl_cnt;
  uint64_t inp_fadv_suspended_cnt;
  caddr_t inp_saved_ppcb;
  inpcbpolicy *inp_sp;
  inp_necp_attributes inp_necp_attributes;
  necp_inpcb_result inp_policyresult;
  uuid_t_1 necp_client_uuid;
  necp_client_flow_cb necp_cb;
  u_int8_t *inp_resolver_signature;
  size_t inp_resolver_signature_length;
  netns_token inp_netns_token;
  netns_token inp_wildcard_netns_token;
  u_char *inp_keepalive_data;
  u_int8_t inp_keepalive_datalen;
  u_int8_t inp_keepalive_type;
  u_int16_t inp_keepalive_interval;
  uint32_t inp_nstat_refcnt;
  inp_stat *inp_stat;
  inp_stat *inp_cstat;
  inp_stat *inp_wstat;
  inp_stat *inp_Wstat;
  u_int8_t inp_stat_store[40];
  u_int8_t inp_cstat_store[40];
  u_int8_t inp_wstat_store[40];
  u_int8_t inp_Wstat_store[40];
  activity_bitmap_t inp_nw_activity;
  u_int64_t inp_start_timestamp;
  char inp_last_proc_name[17];
  char inp_e_proc_name[17];
};

/* 10715 */
struct __attribute__((aligned(4))) ipsec_wake_pkt_info
{
  u_int8_t wake_pkt[100];
  uuid_string_t wake_uuid;
  u_int32_t wake_pkt_spi;
  u_int32_t wake_pkt_seq;
  u_int16_t wake_pkt_len;
};

/* 10716 */
typedef _esp_chachapoly_ctx *esp_chachapoly_ctx_t;

/* 10717 */
struct __attribute__((packed)) __attribute__((aligned(1))) mptcp_add_addr_hmac_msg_v6
{
  uint8_t maddr_addrid;
  in6_addr_0 maddr_addr;
  uint16_t maddr_port;
};

/* 10718 */
struct __attribute__((packed)) __attribute__((aligned(1))) mptcp_add_addr_hmac_msg_v4
{
  uint8_t maddr_addrid;
  in_addr maddr_addr;
  uint16_t maddr_port;
};

/* 10719 */
struct mptcp_mpprio_addr_opt
{
  uint8_t mpprio_kind;
  uint8_t mpprio_len;
  _BYTE gap2;
  uint8_t mpprio_addrid;
};

/* 10720 */
struct mptcp_mpcapable_opt_rsp2
{
  mptcp_mpcapable_opt_rsp1 mmc_rsp1;
  uint16_t data_len;
  uint16_t csum;
};

/* 10721 */
struct mptcp_mpjoin_opt_rsp2
{
  uint8_t mmjo_kind;
  uint8_t mmjo_len;
  _BYTE gap2;
  uint8_t mmjo_reserved2;
  uint8_t mmjo_mac[20];
};

/* 10722 */
struct mptcp_mpjoin_opt_req
{
  uint8_t mmjo_kind;
  uint8_t mmjo_len;
  uint8_t mmjo_subtype_bkp;
  uint8_t mmjo_addr_id;
  uint32_t mmjo_peer_token;
  uint32_t mmjo_rand;
};

/* 10723 */
struct __attribute__((aligned(8))) conninfo_multipathtcp
{
  uint32_t mptcpci_subflow_count;
  uint32_t mptcpci_switch_count;
  sae_connid_t mptcpci_subflow_connids[4];
  uint64_t mptcpci_init_rxbytes;
  uint64_t mptcpci_init_txbytes;
  mptcp_itf_stats mptcpci_itfstats[4];
  uint32_t mptcpci_flags;
};

/* 10724 */
struct tcpcb_0
{
  tsegqe_head t_segq;
  uint32_t t_dupacks;
  int t_state;
  uint32_t t_timer[9];
  tcptimerentry tentry;
  inpcb *t_inpcb;
  uint32_t t_flags;
  tcp_seq snd_una;
  tcp_seq snd_max;
  tcp_seq snd_nxt;
  tcp_seq snd_up;
  tcp_seq snd_wl1;
  tcp_seq snd_wl2;
  tcp_seq iss;
  tcp_seq irs;
  tcp_seq rcv_nxt;
  tcp_seq rcv_adv;
  uint32_t rcv_wnd;
  uint32_t t_last_recwin;
  tcp_seq rcv_up;
  uint32_t snd_wnd;
  uint32_t snd_cwnd;
  uint32_t snd_ssthresh;
  tcp_seq snd_recover;
  uint32_t t_maxopd;
  uint32_t t_rcvtime;
  uint32_t t_sndtime;
  uint32_t t_starttime;
  int t_rtttime;
  tcp_seq t_rtseq;
  uint32_t rfbuf_ts;
  uint32_t rfbuf_cnt;
  uint32_t rfbuf_space;
  int t_rxtcur;
  unsigned int t_maxseg;
  int t_srtt;
  int t_rttvar;
  uint64_t t_accsleep_ms;
  uint32_t t_reassqlen;
  uint32_t t_reassq_mbcnt;
  uint16_t t_rxtshift;
  uint32_t t_rttmin;
  uint32_t t_rttbest;
  uint32_t t_rttcur;
  uint32_t t_rttupdated;
  uint32_t t_rxt_conndroptime;
  uint32_t t_rxtstart;
  uint32_t max_sndwnd;
  int t_softerror;
  char t_oobflags;
  char t_iobc;
  u_int8_t snd_scale;
  u_int8_t rcv_scale;
  u_int8_t request_r_scale;
  u_int8_t requested_s_scale;
  u_int8_t tcp_cc_index;
  u_int8_t t_adaptive_rtimo;
  u_int8_t t_adaptive_wtimo;
  u_int8_t t_stretchack_delayed;
  u_int16_t t_early_rexmt_count;
  u_int32_t t_early_rexmt_win;
  u_int32_t ts_recent;
  u_int32_t ts_recent_age;
  tcp_seq last_ack_sent;
  u_int32_t t_bytes_acked;
  int t_lastchain;
  uint16_t t_unacksegs;
  uint16_t t_forced_acks;
  uint8_t t_rexmtthresh;
  uint8_t t_rtimo_probes;
  uint32_t t_persist_timeout;
  uint32_t t_persist_stop;
  uint32_t t_notsent_lowat;
  u_int32_t rcv_unackwin;
  u_int32_t rcv_by_unackwin;
  u_int32_t rcv_by_unackhalfwin;
  u_int32_t rcv_nostrack_ts;
  u_int32_t rcv_nostrack_pkts;
  u_int16_t rcv_waitforss;
  u_int32_t ecn_flags;
  u_int32_t t_ecn_recv_ce;
  u_int32_t t_ecn_recv_cwr;
  uint32_t t_rcv_ce_packets;
  uint32_t t_snd_ce_packets;
  uint32_t t_delta_ce_packets;
  uint64_t t_rcv_ect1_bytes;
  uint64_t t_rcv_ect0_bytes;
  uint64_t t_rcv_ce_bytes;
  uint64_t t_snd_ect1_bytes;
  uint64_t t_snd_ect0_bytes;
  uint64_t t_snd_ce_bytes;
  u_int32_t snd_cwnd_prev;
  u_int32_t snd_ssthresh_prev;
  tcp_seq snd_recover_prev;
  int t_srtt_prev;
  int t_rttvar_prev;
  u_int32_t t_badrexmt_time;
  u_int32_t t_reorderwin;
  int16_t snd_numholes;
  tcp_seq sack_newdata;
  sackhole_head snd_holes;
  tcp_seq snd_fack;
  int rcv_numsacks;
  sackblk sackblks[6];
  sackhint sackhint;
  tcp_seq send_highest_sack;
  int t_new_dupacks;
  mbuf *t_pktlist_head;
  mbuf *t_pktlist_tail;
  u_int32_t t_pktlist_sentlen;
  u_int32_t t_keepidle;
  u_int32_t t_keepinit;
  u_int32_t t_keepintvl;
  u_int32_t t_keepcnt;
  u_int32_t tso_max_segment_size;
  u_int16_t t_pmtud_lastseg_size;
  u_int32_t t_pmtud_saved_maxopd;
  u_int32_t t_pmtud_start_ts;
  struct
  {
    u_int32_t rxduplicatebytes;
    u_int32_t rxoutoforderbytes;
    u_int32_t txretransmitbytes;
    u_int16_t synrxtshift;
    u_int16_t rxmitsyns;
    u_int16_t unused_pad_to_8;
    u_int32_t rxmitpkts;
    uint32_t delayed_acks_sent;
    uint32_t acks_delayed;
  } t_stat;
  u_int8_t t_syn_sent;
  u_int8_t t_syn_rcvd;
  u_int8_t t_notify_ack_count;
  u_int8_t t_ecn_recv_ce_pkt;
  u_int32_t t_cached_maxopd;
  uint32_t bg_ssthresh;
  uint32_t t_flagsext;
  uint32_t iaj_rcv_ts;
  int iaj_size;
  uint8_t iaj_small_pkt;
  uint8_t t_pipeack_ind;
  uint16_t iaj_pktcnt;
  uint32_t acc_iaj;
  uint32_t avg_iaj;
  uint32_t std_dev_iaj;
  bwmeas *t_bwmeas;
  tcp_seq t_idleat;
  uint8_t t_fin_sent;
  uint8_t t_fin_rcvd;
  uint8_t t_rst_sent;
  uint8_t t_rst_rcvd;
  struct
  {
    tcpcb *tqe_next;
    tcpcb **tqe_prev;
  } t_twentry;
  tcp_ccstate *t_ccstate;
  tcp_ccstate _t_ccstate;
  tcp_seq t_tlphighrxt;
  u_int32_t t_tlpstart;
  tcp_seq t_dsack_lseq;
  tcp_seq t_dsack_rseq;
  tcp_rxt_seghead t_rxt_segments;
  uint32_t t_rxt_seg_count;
  uint32_t t_rxt_seg_drop;
  tcp_seq t_dsack_lastuna;
  u_int32_t t_pipeack_sample[3];
  tcp_seq t_pipeack_lastuna;
  u_int32_t t_pipeack;
  u_int32_t t_lossflightsize;
  u_int32_t t_mpflags;
  tcp_seq t_mpuna;
  mptcb *t_mptcb;
  mptsub *t_mpsub;
  mpt_dsn_map t_rcv_map;
  u_int8_t t_local_aid;
  u_int8_t t_rem_aid;
  u_int8_t t_mprxtshift;
  u_int8_t t_tfo_flags;
  u_int16_t t_tfo_stats;
  u_int8_t t_tfo_probes;
  u_int8_t t_tfo_probe_state;
  u_int32_t t_rcvoopack;
  u_int32_t t_pawsdrop;
  u_int32_t t_sack_recovery_episode;
  u_int32_t t_reordered_pkts;
  u_int32_t t_dsack_sent;
  u_int32_t t_dsack_recvd;
  struct
  {
    tcp_notify_ack_marker *slh_first;
  } t_notify_ack;
  u_int32_t t_recv_throttle_ts;
  u_int32_t t_rxt_minimum_timeout;
  uint32_t t_challengeack_last;
  uint32_t t_challengeack_count;
  u_int32_t t_log_flags;
  u_int32_t t_connect_time;
  uint32_t t_comp_gencnt;
  uint32_t t_comp_lastinc;
  uint32_t t_ts_offset;
  uint32_t curr_rtt_hist[4];
  uint32_t curr_rtt_min;
  uint32_t curr_rtt_index;
  tcp_seq rcv_high;
  uint32_t tsv_high;
  tcp_rledbat_state t_rlstate;
  uint32_t rcv_srtt;
  uint32_t rcv_rtt_est_ts;
  uint32_t rcv_rtt_est_seq;
  uuid_t_1 t_fsw_uuid;
  uuid_t_1 t_flow_uuid;
};

/* 10725 */
struct in6_multi_1
{
  lck_mtx_t in6m_lock;
  u_int32_t in6m_refcount;
  u_int32_t in6m_reqcnt;
  u_int32_t in6m_debug;
  struct
  {
    in6_multi *le_next;
    in6_multi **le_prev;
  } in6m_entry;
  in6_addr_0 in6m_addr;
  uint32_t ifscope;
  ifnet *in6m_ifp;
  ifmultiaddr *in6m_ifma;
  u_int in6m_state;
  u_int in6m_timer;
  mld_ifinfo *in6m_mli;
  struct
  {
    in6_multi *sle_next;
  } in6m_dtle;
  struct
  {
    in6_multi *sle_next;
  } in6m_nrele;
  u_int32_t in6m_nrelecnt;
  ip6_msource_tree in6m_srcs;
  u_long in6m_nsrc;
  ifqueue in6m_scq;
  timeval in6m_lastgsrtv;
  uint16_t in6m_sctimer;
  uint16_t in6m_scrv;
  in6m_st in6m_st[2];
  void (*in6m_trace)(in6_multi *, int);
};

/* 10726 */
struct ip6_moptions_1
{
  lck_mtx_t im6o_lock;
  uint32_t im6o_refcnt;
  uint32_t im6o_debug;
  ifnet *im6o_multicast_ifp;
  u_char im6o_multicast_hlim;
  u_char im6o_multicast_loop;
  u_short im6o_num_memberships;
  u_short im6o_max_memberships;
  in6_multi **im6o_membership;
  in6_mfilter *im6o_mfilters;
  void (*im6o_trace)(ip6_moptions *, int);
};

/* 10727 */
struct ip_moptions_1
{
  lck_mtx_t imo_lock;
  uint32_t imo_refcnt;
  uint32_t imo_debug;
  ifnet *imo_multicast_ifp;
  u_char imo_multicast_ttl;
  u_char imo_multicast_loop;
  u_short imo_num_memberships;
  u_short imo_max_memberships;
  in_multi **imo_membership;
  in_mfilter *imo_mfilters;
  u_int32_t imo_multicast_vif;
  in_addr imo_multicast_addr;
  void (*imo_trace)(ip_moptions *, int);
};

/* 10728 */
struct mptses_1
{
  mppcb *mpte_mppcb;
  mptcb *mpte_mptcb;
  struct
  {
    mptopt *tqh_first;
    mptopt **tqh_last;
  } mpte_sopts;
  struct
  {
    mptsub *tqh_first;
    mptsub **tqh_last;
  } mpte_subflows;
  uint16_t mpte_numflows;
  uint16_t mpte_nummpcapflows;
  sae_associd_t mpte_associd;
  sae_connid_t mpte_connid_last;
  uint64_t mpte_time_target;
  thread_call_t mpte_time_thread;
  thread_call_t mpte_stop_urgency;
  uint32_t mpte_last_cellicon_set;
  uint32_t mpte_cellicon_increments;
  union
  {
    sockaddr _mpte_src;
    sockaddr_in _mpte_src_v4;
    sockaddr_in6 _mpte_src_v6;
  } mpte_u_src;
  union
  {
    sockaddr _mpte_dst;
    sockaddr_in _mpte_dst_v4;
    sockaddr_in6 _mpte_dst_v6;
  } mpte_u_dst;
  sockaddr_in mpte_sub_dst_v4;
  sockaddr_in6 mpte_sub_dst_v6;
  uint8_t sub_dst_addr_id_v4;
  uint8_t sub_dst_addr_id_v6;
  uint16_t mpte_alternate_port;
  int mpte_epid;
  uuid_t_1 mpte_euuid;
  mptsub *mpte_active_sub;
  uint16_t mpte_flags;
  uint8_t mpte_svctype;
  uint8_t mpte_lost_aid;
  uint8_t mpte_addrid_last;
  uint32_t mpte_itfinfo_size;
  __attribute__((packed)) __attribute__((aligned(1))) mpt_itf_info _mpte_itfinfo[4];
  mpt_itf_info *mpte_itfinfo;
  mbuf *mpte_reinjectq;
  uint32_t mpte_subflow_switches;
  __attribute__((aligned(8))) uint32_t mpte_triggered_cell;
  mptcp_itf_stats mpte_itfstats[4];
  uint64_t mpte_init_txbytes;
  uint64_t mpte_init_rxbytes;
};

/* 10729 */
struct in_multi_1
{
  lck_mtx_t inm_lock;
  u_int32_t inm_refcount;
  u_int32_t inm_reqcnt;
  u_int32_t inm_debug;
  struct
  {
    in_multi *le_next;
    in_multi **le_prev;
  } inm_link;
  in_addr inm_addr;
  ifnet *inm_ifp;
  ifmultiaddr *inm_ifma;
  u_int inm_timer;
  u_int inm_state;
  void *inm_rti;
  igmp_ifinfo *inm_igi;
  struct
  {
    in_multi *sle_next;
  } inm_dtle;
  struct
  {
    in_multi *sle_next;
  } inm_nrele;
  u_int32_t inm_nrelecnt;
  ip_msource_tree inm_srcs;
  u_long inm_nsrc;
  ifqueue inm_scq;
  timeval inm_lastgsrtv;
  uint16_t inm_sctimer;
  uint16_t inm_scrv;
  inm_st inm_st[2];
  void (*inm_trace)(in_multi *, int);
};

/* 10730 */
struct mptcp_symptoms_answer
{
  symptoms_advisory advisory;
  uuid_t_1 uuid;
  int32_t rssi;
};

/* 10731 */
struct mptcp_symptoms_ask_uuid
{
  uint32_t cmd;
  uuid_t_1 uuid;
  uint32_t priority;
};

/* 10732 */
typedef conninfo_mptcp conninfo_mptcp_t;

/* 10733 */
struct kern_ctl_reg_0
{
  char ctl_name[96];
  u_int32_t ctl_id;
  u_int32_t ctl_unit;
  u_int32_t ctl_flags;
  u_int32_t ctl_sendsize;
  u_int32_t ctl_recvsize;
  ctl_connect_func ctl_connect;
  ctl_disconnect_func ctl_disconnect;
  ctl_send_func_0 ctl_send;
  ctl_setopt_func ctl_setopt;
  ctl_getopt_func ctl_getopt;
  ctl_rcvd_func ctl_rcvd;
  ctl_send_list_func ctl_send_list;
  ctl_bind_func ctl_bind;
  ctl_setup_func ctl_setup;
};

/* 10734 */
struct kev_mptcp_data
{
  int value;
};

/* 10735 */
typedef mptcp_wifi_quality mptcp_wifi_quality_t;

/* 10736 */
struct tcpcb_1
{
  tsegqe_head t_segq;
  uint32_t t_dupacks;
  int t_state;
  uint32_t t_timer[9];
  tcptimerentry tentry;
  inpcb *t_inpcb;
  uint32_t t_flags;
  tcp_seq snd_una;
  tcp_seq snd_max;
  tcp_seq snd_nxt;
  tcp_seq snd_up;
  tcp_seq snd_wl1;
  tcp_seq snd_wl2;
  tcp_seq iss;
  tcp_seq irs;
  tcp_seq rcv_nxt;
  tcp_seq rcv_adv;
  uint32_t rcv_wnd;
  uint32_t t_last_recwin;
  tcp_seq rcv_up;
  uint32_t snd_wnd;
  uint32_t snd_cwnd;
  uint32_t snd_ssthresh;
  tcp_seq snd_recover;
  uint32_t t_maxopd;
  uint32_t t_rcvtime;
  uint32_t t_sndtime;
  uint32_t t_starttime;
  int t_rtttime;
  tcp_seq t_rtseq;
  uint32_t rfbuf_ts;
  uint32_t rfbuf_cnt;
  uint32_t rfbuf_space;
  int t_rxtcur;
  unsigned int t_maxseg;
  int t_srtt;
  int t_rttvar;
  uint64_t t_accsleep_ms;
  uint32_t t_reassqlen;
  uint32_t t_reassq_mbcnt;
  uint16_t t_rxtshift;
  uint32_t t_rttmin;
  uint32_t t_rttbest;
  uint32_t t_rttcur;
  uint32_t t_rttupdated;
  uint32_t t_rxt_conndroptime;
  uint32_t t_rxtstart;
  uint32_t max_sndwnd;
  int t_softerror;
  char t_oobflags;
  char t_iobc;
  u_int8_t snd_scale;
  u_int8_t rcv_scale;
  u_int8_t request_r_scale;
  u_int8_t requested_s_scale;
  u_int8_t tcp_cc_index;
  u_int8_t t_adaptive_rtimo;
  u_int8_t t_adaptive_wtimo;
  u_int8_t t_stretchack_delayed;
  u_int16_t t_early_rexmt_count;
  u_int32_t t_early_rexmt_win;
  u_int32_t ts_recent;
  u_int32_t ts_recent_age;
  tcp_seq last_ack_sent;
  u_int32_t t_bytes_acked;
  int t_lastchain;
  uint16_t t_unacksegs;
  uint16_t t_forced_acks;
  uint8_t t_rexmtthresh;
  uint8_t t_rtimo_probes;
  uint32_t t_persist_timeout;
  uint32_t t_persist_stop;
  uint32_t t_notsent_lowat;
  u_int32_t rcv_unackwin;
  u_int32_t rcv_by_unackwin;
  u_int32_t rcv_by_unackhalfwin;
  u_int32_t rcv_nostrack_ts;
  u_int32_t rcv_nostrack_pkts;
  u_int16_t rcv_waitforss;
  u_int32_t ecn_flags;
  u_int32_t t_ecn_recv_ce;
  u_int32_t t_ecn_recv_cwr;
  uint32_t t_rcv_ce_packets;
  uint32_t t_snd_ce_packets;
  uint32_t t_delta_ce_packets;
  uint64_t t_rcv_ect1_bytes;
  uint64_t t_rcv_ect0_bytes;
  uint64_t t_rcv_ce_bytes;
  uint64_t t_snd_ect1_bytes;
  uint64_t t_snd_ect0_bytes;
  uint64_t t_snd_ce_bytes;
  u_int32_t snd_cwnd_prev;
  u_int32_t snd_ssthresh_prev;
  tcp_seq snd_recover_prev;
  int t_srtt_prev;
  int t_rttvar_prev;
  u_int32_t t_badrexmt_time;
  u_int32_t t_reorderwin;
  int16_t snd_numholes;
  tcp_seq sack_newdata;
  sackhole_head snd_holes;
  tcp_seq snd_fack;
  int rcv_numsacks;
  sackblk sackblks[6];
  sackhint sackhint;
  tcp_seq send_highest_sack;
  int t_new_dupacks;
  mbuf *t_pktlist_head;
  mbuf *t_pktlist_tail;
  u_int32_t t_pktlist_sentlen;
  u_int32_t t_keepidle;
  u_int32_t t_keepinit;
  u_int32_t t_keepintvl;
  u_int32_t t_keepcnt;
  u_int32_t tso_max_segment_size;
  u_int16_t t_pmtud_lastseg_size;
  u_int32_t t_pmtud_saved_maxopd;
  u_int32_t t_pmtud_start_ts;
  struct
  {
    u_int32_t rxduplicatebytes;
    u_int32_t rxoutoforderbytes;
    u_int32_t txretransmitbytes;
    u_int16_t synrxtshift;
    u_int16_t rxmitsyns;
    u_int16_t unused_pad_to_8;
    u_int32_t rxmitpkts;
    uint32_t delayed_acks_sent;
    uint32_t acks_delayed;
  } t_stat;
  u_int8_t t_syn_sent;
  u_int8_t t_syn_rcvd;
  u_int8_t t_notify_ack_count;
  u_int8_t t_ecn_recv_ce_pkt;
  u_int32_t t_cached_maxopd;
  uint32_t bg_ssthresh;
  uint32_t t_flagsext;
  uint32_t iaj_rcv_ts;
  int iaj_size;
  uint8_t iaj_small_pkt;
  uint8_t t_pipeack_ind;
  uint16_t iaj_pktcnt;
  uint32_t acc_iaj;
  uint32_t avg_iaj;
  uint32_t std_dev_iaj;
  bwmeas *t_bwmeas;
  tcp_seq t_idleat;
  uint8_t t_fin_sent;
  uint8_t t_fin_rcvd;
  uint8_t t_rst_sent;
  uint8_t t_rst_rcvd;
  struct
  {
    tcpcb *tqe_next;
    tcpcb **tqe_prev;
  } t_twentry;
  tcp_ccstate *t_ccstate;
  tcp_ccstate _t_ccstate;
  tcp_seq t_tlphighrxt;
  u_int32_t t_tlpstart;
  tcp_seq t_dsack_lseq;
  tcp_seq t_dsack_rseq;
  tcp_rxt_seghead t_rxt_segments;
  uint32_t t_rxt_seg_count;
  uint32_t t_rxt_seg_drop;
  tcp_seq t_dsack_lastuna;
  u_int32_t t_pipeack_sample[3];
  tcp_seq t_pipeack_lastuna;
  u_int32_t t_pipeack;
  u_int32_t t_lossflightsize;
  u_int32_t t_mpflags;
  tcp_seq t_mpuna;
  mptcb *t_mptcb;
  mptsub *t_mpsub;
  mpt_dsn_map t_rcv_map;
  u_int8_t t_local_aid;
  u_int8_t t_rem_aid;
  u_int8_t t_mprxtshift;
  u_int8_t t_tfo_flags;
  u_int16_t t_tfo_stats;
  u_int8_t t_tfo_probes;
  u_int8_t t_tfo_probe_state;
  u_int32_t t_rcvoopack;
  u_int32_t t_pawsdrop;
  u_int32_t t_sack_recovery_episode;
  u_int32_t t_reordered_pkts;
  u_int32_t t_dsack_sent;
  u_int32_t t_dsack_recvd;
  struct
  {
    tcp_notify_ack_marker *slh_first;
  } t_notify_ack;
  u_int32_t t_recv_throttle_ts;
  u_int32_t t_rxt_minimum_timeout;
  uint32_t t_challengeack_last;
  uint32_t t_challengeack_count;
  u_int32_t t_log_flags;
  u_int32_t t_connect_time;
  uint32_t t_comp_gencnt;
  uint32_t t_comp_lastinc;
  uint32_t t_ts_offset;
  uint32_t curr_rtt_hist[4];
  uint32_t curr_rtt_min;
  uint32_t curr_rtt_index;
  tcp_seq rcv_high;
  uint32_t tsv_high;
  tcp_rledbat_state t_rlstate;
  uint32_t rcv_srtt;
  uint32_t rcv_rtt_est_ts;
  uint32_t rcv_rtt_est_seq;
  uuid_t_1 t_fsw_uuid;
  uuid_t_1 t_flow_uuid;
};

/* 10737 */
struct tseg_qent_0
{
  struct
  {
    tseg_qent *le_next;
    tseg_qent **le_prev;
  } tqe_q;
  int tqe_len;
  tcphdr *tqe_th;
  mbuf *tqe_m;
};

/* 10738 */
struct flow_divert_packet_header
{
  uint8_t packet_type;
  uint32_t conn_id;
};

/* 10739 */
struct __attribute__((aligned(8))) socket_3
{
  int so_zone;
  short so_type;
  u_short so_error;
  u_int32_t so_options;
  short so_linger;
  short so_state;
  void *so_pcb;
  protosw *so_proto;
  socket *so_head;
  struct
  {
    socket *tqh_first;
    socket **tqh_last;
  } so_incomp;
  struct
  {
    socket *tqh_first;
    socket **tqh_last;
  } so_comp;
  struct
  {
    socket *tqe_next;
    socket **tqe_prev;
  } so_list;
  short so_qlen;
  short so_incqlen;
  short so_qlimit;
  short so_timeo;
  pid_t so_pgid;
  u_int32_t so_oobmark;
  sockbuf so_rcv;
  sockbuf so_snd;
  caddr_t so_tpcb;
  void (*so_event)(socket *, void *, uint32_t);
  void *so_eventarg;
  kauth_cred_t so_cred;
  so_gen_t so_gencnt;
  struct
  {
    socket *stqe_next;
  } so_cache_ent;
  caddr_t so_saved_pcb;
  u_int64_t cache_timestamp;
  uint32_t so_eventmask;
  pid_t last_pid;
  u_int64_t last_upid;
  socket_filter_entry *so_filt;
  u_int32_t so_flags;
  u_int32_t so_flags1;
  uint32_t so_upcallusecount;
  int so_usecount;
  int so_retaincnt;
  uint16_t so_traffic_class;
  int8_t so_netsvctype;
  uint8_t so_restrictions;
  thread_t_0 so_send_filt_thread;
  void *lock_lr[4];
  void *unlock_lr[4];
  u_int8_t next_lock_lr;
  u_int8_t next_unlock_lr;
  u_int16_t so_pktheadroom;
  u_int32_t so_ifdenied_notifies;
  thread_t_0 so_background_thread;
  data_stats so_tc_stats[4];
  klist so_klist;
  flow_divert_pcb *so_fd_pcb;
  soflow_db *so_flow_db;
  cfil_info *so_cfil;
  u_int32_t so_state_change_cnt;
  pid_t e_pid;
  u_int64_t e_upid;
  pid_t so_rpid;
  uuid_t_1 last_uuid;
  uuid_t_1 e_uuid;
  uuid_t_1 so_vuuid;
  uuid_t_1 so_ruuid;
  int32_t so_policy_gencnt;
  u_int64_t so_extended_bk_start;
  u_int8_t so_fallback_mode;
  u_int8_t so_log_seqn;
  uint8_t so_mpkl_send_proto;
  uuid_t_1 so_mpkl_send_uuid;
};

/* 10740 */
struct ifnet_10
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func_0 if_output_dlil;
  volatile ifnet_start_func if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func if_input_ctl;
  ifnet_ioctl_func if_ioctl;
  ifnet_set_bpf_tap if_set_bpf_tap;
  ifnet_detached_func if_free;
  ifnet_demux_func_0 if_demux;
  ifnet_event_func if_event;
  ifnet_framer_func if_framer_legacy;
  ifnet_framer_extended_func_0 if_framer;
  ifnet_add_proto_func if_add_proto;
  ifnet_del_proto_func if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route_0 if_fwd_route;
  route_0 if_src_route;
  route_in6 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 10741 */
struct ifnet_11
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func_0 if_input_dlil;
  volatile dlil_output_func if_output_dlil;
  volatile ifnet_start_func if_start;
  ifnet_output_func_0 if_output;
  ifnet_pre_enqueue_func_0 if_pre_enqueue;
  ifnet_ctl_func if_output_ctl;
  ifnet_input_poll_func_0 if_input_poll;
  ifnet_ctl_func if_input_ctl;
  ifnet_ioctl_func if_ioctl;
  ifnet_set_bpf_tap if_set_bpf_tap;
  ifnet_detached_func if_free;
  ifnet_demux_func if_demux;
  ifnet_event_func_1 if_event;
  ifnet_framer_func_0 if_framer_legacy;
  ifnet_framer_extended_func if_framer;
  ifnet_add_proto_func if_add_proto;
  ifnet_del_proto_func if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func if_save_start;
  ifnet_output_func_0 if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route if_fwd_route;
  route if_src_route;
  route_in6 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 10742 */
struct gif_softc_0
{
  ifnet_t gif_if;
  sockaddr *gif_psrc;
  sockaddr *gif_pdst;
  protocol_family_t gif_proto;
  union
  {
    route_0 gifscr_ro;
    route_in6 gifscr_ro6;
  } gifsc_gifscr;
  int gif_flags;
  int gif_called;
  const encaptab *encap_cookie4;
  const encaptab *encap_cookie6;
  struct
  {
    gif_softc *tqe_next;
    gif_softc **tqe_prev;
  } gif_link;
  bpf_tap_mode tap_mode;
  bpf_packet_func_1 tap_callback;
  char gif_ifname[16];
  lck_mtx_t gif_lock;
};

/* 10743 */
struct udp_keepalive_offload
{
  u_char ka_data[32];
  u_int16_t ka_interval;
  u_int8_t ka_data_len;
  u_int8_t ka_type;
};

/* 10744 */
struct xinpcb
{
  u_int32_t xi_len;
  inpcb_compat xi_inp;
  xsocket xi_socket;
  u_quad_t xi_alignment_hack;
};

/* 10745 */
struct xinpgen
{
  u_int32_t xig_len;
  u_int xig_count;
  inp_gen_t xig_gen;
  so_gen_t xig_sogen;
};

/* 10746 */
struct udpstat
{
  u_int32_t udps_ipackets;
  u_int32_t udps_hdrops;
  u_int32_t udps_badsum;
  u_int32_t udps_badlen;
  u_int32_t udps_noport;
  u_int32_t udps_noportbcast;
  u_int32_t udps_fullsock;
  u_int32_t udpps_pcbcachemiss;
  u_int32_t udpps_pcbhashmiss;
  u_int32_t udps_opackets;
  u_int32_t udps_fastout;
  u_int32_t udps_nosum;
  u_int32_t udps_noportmcast;
  u_int32_t udps_filtermcast;
  u_int32_t udps_rcv_swcsum;
  u_int32_t udps_rcv_swcsum_bytes;
  u_int32_t udps_rcv6_swcsum;
  u_int32_t udps_rcv6_swcsum_bytes;
  u_int32_t udps_snd_swcsum;
  u_int32_t udps_snd_swcsum_bytes;
  u_int32_t udps_snd6_swcsum;
  u_int32_t udps_snd6_swcsum_bytes;
};

/* 10747 */
struct __attribute__((aligned(8))) tcp_cc_debug_state
{
  u_int64_t ccd_tsns;
  char ccd_srcaddr[46];
  uint16_t ccd_srcport;
  char ccd_destaddr[46];
  uint16_t ccd_destport;
  uint32_t ccd_snd_cwnd;
  uint32_t ccd_snd_wnd;
  uint32_t ccd_snd_ssthresh;
  uint32_t ccd_pipeack;
  uint32_t ccd_rttcur;
  uint32_t ccd_rxtcur;
  uint32_t ccd_srtt;
  uint32_t ccd_event;
  uint32_t ccd_sndcc;
  uint32_t ccd_sndhiwat;
  uint32_t ccd_bytes_acked;
  u_int8_t ccd_cc_index;
  u_int8_t ccd_unused_1__;
  u_int16_t ccd_unused_2__;
  union
  {
    struct
    {
      uint32_t ccd_last_max;
      uint32_t ccd_tcp_win;
      uint32_t ccd_target_win;
      uint32_t ccd_avg_lastmax;
      uint32_t ccd_mean_deviation;
    } cubic_state;
    struct
    {
      u_int32_t led_base_rtt;
    } ledbat_state;
  } u;
};

/* 10748 */
struct tcp_rcv_cc_algo
{
  char name[16];
  uint32_t num_sockets;
  uint32_t flags;
  void (*init)(tcpcb *);
  void (*cleanup)(tcpcb *);
  void (*rwnd_init)(tcpcb *);
  void (*data_rcvd)(tcpcb *, tcphdr *, tcpopt *, uint32_t);
  uint32_t (*get_rlwin)(tcpcb *);
  void (*after_idle)(tcpcb *);
  void (*switch_to)(tcpcb *);
};

/* 10749 */
union floatdata
{
  float f;
  int32_t x;
};

/* 10750 */
struct tcp_measure_bw_burst
{
  u_int32_t min_burst_size;
  u_int32_t max_burst_size;
};

/* 10751 */
struct tcptailq
{
  tcpcb *tqh_first;
  tcpcb **tqh_last;
};

/* 10752 */
struct tcp_last_report_stats
{
  u_int32_t tcps_connattempt;
  u_int32_t tcps_accepts;
  u_int32_t tcps_ecn_client_setup;
  u_int32_t tcps_ecn_server_setup;
  u_int32_t tcps_ecn_client_success;
  u_int32_t tcps_ecn_server_success;
  u_int32_t tcps_ecn_not_supported;
  u_int32_t tcps_ecn_lost_syn;
  u_int32_t tcps_ecn_lost_synack;
  u_int32_t tcps_ecn_recv_ce;
  u_int32_t tcps_ecn_recv_ece;
  u_int32_t tcps_ecn_sent_ece;
  u_int32_t tcps_ecn_conn_recv_ce;
  u_int32_t tcps_ecn_conn_recv_ece;
  u_int32_t tcps_ecn_conn_plnoce;
  u_int32_t tcps_ecn_conn_pl_ce;
  u_int32_t tcps_ecn_conn_nopl_ce;
  u_int32_t tcps_ecn_fallback_synloss;
  u_int32_t tcps_ecn_fallback_reorder;
  u_int32_t tcps_ecn_fallback_ce;
  u_int32_t tcps_tfo_syn_data_rcv;
  u_int32_t tcps_tfo_cookie_req_rcv;
  u_int32_t tcps_tfo_cookie_sent;
  u_int32_t tcps_tfo_cookie_invalid;
  u_int32_t tcps_tfo_cookie_req;
  u_int32_t tcps_tfo_cookie_rcv;
  u_int32_t tcps_tfo_syn_data_sent;
  u_int32_t tcps_tfo_syn_data_acked;
  u_int32_t tcps_tfo_syn_loss;
  u_int32_t tcps_tfo_blackhole;
  u_int32_t tcps_tfo_cookie_wrong;
  u_int32_t tcps_tfo_no_cookie_rcv;
  u_int32_t tcps_tfo_heuristics_disable;
  u_int32_t tcps_tfo_sndblackhole;
  u_int32_t tcps_mptcp_handover_attempt;
  u_int32_t tcps_mptcp_interactive_attempt;
  u_int32_t tcps_mptcp_aggregate_attempt;
  u_int32_t tcps_mptcp_fp_handover_attempt;
  u_int32_t tcps_mptcp_fp_interactive_attempt;
  u_int32_t tcps_mptcp_fp_aggregate_attempt;
  u_int32_t tcps_mptcp_heuristic_fallback;
  u_int32_t tcps_mptcp_fp_heuristic_fallback;
  u_int32_t tcps_mptcp_handover_success_wifi;
  u_int32_t tcps_mptcp_handover_success_cell;
  u_int32_t tcps_mptcp_interactive_success;
  u_int32_t tcps_mptcp_aggregate_success;
  u_int32_t tcps_mptcp_fp_handover_success_wifi;
  u_int32_t tcps_mptcp_fp_handover_success_cell;
  u_int32_t tcps_mptcp_fp_interactive_success;
  u_int32_t tcps_mptcp_fp_aggregate_success;
  u_int32_t tcps_mptcp_handover_cell_from_wifi;
  u_int32_t tcps_mptcp_handover_wifi_from_cell;
  u_int32_t tcps_mptcp_interactive_cell_from_wifi;
  u_int64_t tcps_mptcp_handover_cell_bytes;
  u_int64_t tcps_mptcp_interactive_cell_bytes;
  u_int64_t tcps_mptcp_aggregate_cell_bytes;
  u_int64_t tcps_mptcp_handover_all_bytes;
  u_int64_t tcps_mptcp_interactive_all_bytes;
  u_int64_t tcps_mptcp_aggregate_all_bytes;
  u_int32_t tcps_mptcp_back_to_wifi;
  u_int32_t tcps_mptcp_wifi_proxy;
  u_int32_t tcps_mptcp_cell_proxy;
  u_int32_t tcps_mptcp_triggered_cell;
};

/* 10753 */
struct ipctlparam_0
{
  ip *ipc_icmp_ip;
  mbuf *ipc_m;
  icmp *ipc_icmp;
  size_t ipc_off;
};

/* 10754 */
struct __attribute__((packed)) __attribute__((aligned(4))) xtcpcb
{
  u_int32_t xt_len;
  inpcb_compat xt_inp;
  otcpcb xt_tp;
  xsocket xt_socket;
  u_quad_t xt_alignment_hack;
};

/* 10755 */
struct tcp6_ctlinput::tcp_ports
{
  uint16_t th_sport;
  uint16_t th_dport;
};

/* 10756 */
struct icmp_0
{
  u_char icmp_type;
  u_char icmp_code;
  u_short icmp_cksum;
  union
  {
    u_char ih_pptr;
    in_addr ih_gwaddr;
    ih_idseq ih_idseq;
    int ih_void;
    ih_pmtu ih_pmtu;
    ih_rtradv ih_rtradv;
  } icmp_hun;
  union
  {
    id_ts id_ts;
    id_ip id_ip;
    icmp_ra_addr id_radv;
    u_int32_t id_mask;
    char id_data[1];
  } icmp_dun;
};

/* 10757 */
struct in_multistep
{
  in_multi *i_inm;
};

/* 10758 */
struct fq_head
{
  mbuf *mq_first;
  mbuf **mq_last;
};

/* 10759 */
typedef ip_check_if_result ip_check_if_result_t;

/* 10760 */
enum ipinput_chain_ret_t : __int32
{
  IPINPUT_DOCHAIN = 0x0,
  IPINPUT_DONTCHAIN = 0x1,
  IPINPUT_FREED = 0x2,
  IPINPUT_DONE = 0x3,
};

/* 10761 */
struct ip_srcrt
{
  in_addr dst;
  char nop;
  char srcopt[3];
  in_addr route[10];
};

/* 10762 */
struct ip_linklocal_stat
{
  u_int32_t iplls_in_total;
  u_int32_t iplls_in_badttl;
  u_int32_t iplls_out_total;
  u_int32_t iplls_out_badttl;
};

/* 10763 */
struct ipstat
{
  u_int32_t ips_total;
  u_int32_t ips_badsum;
  u_int32_t ips_tooshort;
  u_int32_t ips_toosmall;
  u_int32_t ips_badhlen;
  u_int32_t ips_badlen;
  u_int32_t ips_fragments;
  u_int32_t ips_fragdropped;
  u_int32_t ips_fragtimeout;
  u_int32_t ips_forward;
  u_int32_t ips_fastforward;
  u_int32_t ips_cantforward;
  u_int32_t ips_redirectsent;
  u_int32_t ips_noproto;
  u_int32_t ips_delivered;
  u_int32_t ips_localout;
  u_int32_t ips_odropped;
  u_int32_t ips_reassembled;
  u_int32_t ips_fragmented;
  u_int32_t ips_ofragments;
  u_int32_t ips_cantfrag;
  u_int32_t ips_badoptions;
  u_int32_t ips_noroute;
  u_int32_t ips_badvers;
  u_int32_t ips_rawout;
  u_int32_t ips_toolong;
  u_int32_t ips_notmember;
  u_int32_t ips_nogif;
  u_int32_t ips_badaddr;
  u_int32_t ips_pktdropcntrl;
  u_int32_t ips_rcv_swcsum;
  u_int32_t ips_rcv_swcsum_bytes;
  u_int32_t ips_snd_swcsum;
  u_int32_t ips_snd_swcsum_bytes;
  u_int32_t ips_adj;
  u_int32_t ips_adj_hwcsum_clr;
  u_int32_t ips_rxc_collisions;
  u_int32_t ips_rxc_chained;
  u_int32_t ips_rxc_notchain;
  u_int32_t ips_rxc_chainsz_gt2;
  u_int32_t ips_rxc_chainsz_gt4;
  u_int32_t ips_rxc_notlist;
  u_int32_t ips_raw_sappend_fail;
  u_int32_t ips_necp_policy_drop;
  u_int32_t ips_rcv_if_weak_match;
  u_int32_t ips_rcv_if_no_match;
};

/* 10764 */
struct in_ifaddrhead
{
  in_ifaddr *tqh_first;
  in_ifaddr **tqh_last;
};

/* 10765 */
struct icmpstat
{
  u_int32_t icps_error;
  u_int32_t icps_oldshort;
  u_int32_t icps_oldicmp;
  u_int32_t icps_outhist[41];
  u_int32_t icps_badcode;
  u_int32_t icps_tooshort;
  u_int32_t icps_checksum;
  u_int32_t icps_badlen;
  u_int32_t icps_reflect;
  u_int32_t icps_inhist[41];
  u_int32_t icps_bmcastecho;
  u_int32_t icps_bmcasttstamp;
};

/* 10766 */
struct net_qos_param
{
  u_int64_t nq_transfer_size;
  _BYTE gap8[4];
  u_int32_t nq_unused;
};

/* 10767 */
struct kev_in_portinuse
{
  u_int16_t port;
  u_int32_t req_pid;
  u_int32_t reserved[2];
};

/* 10768 */
struct ip_mreqn
{
  in_addr imr_multiaddr;
  in_addr imr_address;
  int imr_ifindex;
};

/* 10769 */
struct ip_mreq_source
{
  in_addr imr_multiaddr;
  in_addr imr_sourceaddr;
  in_addr imr_interface;
};

/* 10770 */
struct in_multistep_0
{
  in_multi *i_inm;
};

/* 10771 */
struct in_multihead
{
  in_multi *lh_first;
};

/* 10772 */
struct igmp_ifinfo_0
{
  lck_mtx_t igi_lock;
  uint32_t igi_refcnt;
  uint32_t igi_debug;
  struct
  {
    igmp_ifinfo *le_next;
    igmp_ifinfo **le_prev;
  } igi_link;
  ifnet *igi_ifp;
  uint32_t igi_version;
  uint32_t igi_v1_timer;
  uint32_t igi_v2_timer;
  uint32_t igi_v3_timer;
  uint32_t igi_flags;
  uint32_t igi_rv;
  uint32_t igi_qi;
  uint32_t igi_qri;
  uint32_t igi_uri;
  struct
  {
    in_multi *slh_first;
  } igi_relinmhead;
  ifqueue igi_gq;
  ifqueue igi_v2q;
};

/* 10773 */
struct kev_in_arpalive
{
  net_event_data link_data;
};

/* 10774 */
struct kev_in_arpfailure
{
  net_event_data link_data;
};

/* 10775 */
struct arpstat
{
  uint32_t txrequests;
  uint32_t txreplies;
  uint32_t txannounces;
  uint32_t rxrequests;
  uint32_t rxreplies;
  uint32_t received;
  uint32_t txconflicts;
  uint32_t invalidreqs;
  uint32_t reqnobufs;
  uint32_t dropped;
  uint32_t purged;
  uint32_t timeouts;
  uint32_t dupips;
  uint32_t inuse;
  uint32_t txurequests;
  uint32_t held;
};

/* 10776 */
struct kev_in_data
{
  net_event_data link_data;
  in_addr ia_addr;
  u_int32_t ia_net;
  u_int32_t ia_netmask;
  u_int32_t ia_subnet;
  u_int32_t ia_subnetmask;
  in_addr ia_netbroadcast;
  in_addr ia_dstaddr;
};

/* 10777 */
struct ip_moptions_2
{
  lck_mtx_t imo_lock;
  uint32_t imo_refcnt;
  uint32_t imo_debug;
  ifnet *imo_multicast_ifp;
  u_char imo_multicast_ttl;
  u_char imo_multicast_loop;
  u_short imo_num_memberships;
  u_short imo_max_memberships;
  in_multi **imo_membership;
  in_mfilter *imo_mfilters;
  u_int32_t imo_multicast_vif;
  in_addr imo_multicast_addr;
  void (*imo_trace)(ip_moptions *, int);
};

/* 10778 */
struct igmp_ifinfo_u
{
  uint32_t igi_ifindex;
  uint32_t igi_version;
  uint32_t igi_v1_timer;
  uint32_t igi_v2_timer;
  uint32_t igi_v3_timer;
  uint32_t igi_flags;
  uint32_t igi_rv;
  uint32_t igi_qi;
  uint32_t igi_qri;
  uint32_t igi_uri;
};

/* 10779 */
typedef const net_thread_marks *net_thread_marks_t_0;

/* 10780 */
struct igmpstat_v3
{
  uint32_t igps_version;
  uint32_t igps_len;
  uint64_t igps_rcv_total;
  uint64_t igps_rcv_tooshort;
  uint64_t igps_rcv_badttl;
  uint64_t igps_rcv_badsum;
  uint64_t igps_rcv_v1v2_queries;
  uint64_t igps_rcv_v3_queries;
  uint64_t igps_rcv_badqueries;
  uint64_t igps_rcv_gen_queries;
  uint64_t igps_rcv_group_queries;
  uint64_t igps_rcv_gsr_queries;
  uint64_t igps_drop_gsr_queries;
  uint64_t igps_rcv_reports;
  uint64_t igps_rcv_badreports;
  uint64_t igps_rcv_ourreports;
  uint64_t igps_rcv_nora;
  uint64_t igps_snd_reports;
  uint64_t __igps_pad[4];
};

/* 10781 */
struct igmpstat
{
  u_int igps_rcv_total;
  u_int igps_rcv_tooshort;
  u_int igps_rcv_badsum;
  u_int igps_rcv_queries;
  u_int igps_rcv_badqueries;
  u_int igps_rcv_reports;
  u_int igps_rcv_badreports;
  u_int igps_rcv_ourreports;
  u_int igps_snd_reports;
};

/* 10782 */
struct lltable_4
{
  struct
  {
    lltable *sle_next;
  } llt_link;
  int llt_af;
  int llt_hsize;
  llentries *lle_head;
  ifnet *llt_ifp;
  llt_lookup_t *llt_lookup;
  llt_alloc_t *llt_alloc_entry;
  llt_delete_t *llt_delete_entry;
  llt_prefix_free_t *llt_prefix_free;
  llt_dump_entry_t *llt_dump_entry;
  llt_hash_t *llt_hash;
  llt_match_prefix_t *llt_match_prefix;
  llt_free_entry_t *llt_free_entry;
  llt_foreach_entry_t *llt_foreach_entry;
  llt_link_entry_t *llt_link_entry;
  llt_unlink_entry_t *llt_unlink_entry;
  llt_fill_sa_entry_t *llt_fill_sa_entry;
};

/* 10783 */
struct dlil_threading_info_2
{
  lck_mtx_t dlth_lock;
  class_queue_t dlth_pkts;
  ifnet *dlth_ifp;
  ifnet_stat_increment_param dlth_stats;
  uint32_t dlth_flags;
  uint32_t dlth_wtot;
  errno_t (*dlth_strategy)(dlil_threading_info *, ifnet *, mbuf *, mbuf *, const ifnet_stat_increment_param *, boolean_t, thread *);
  boolean_t dlth_affinity;
  uint32_t dlth_affinity_tag;
  thread *dlth_thread;
  thread *dlth_driver_thread;
  thread *dlth_poller_thread;
  lck_grp_t *dlth_lock_grp;
  char dlth_name[32];
  uint64_t dlth_pkts_cnt;
};

/* 10784 */
struct igmp_ifinfo_1
{
  lck_mtx_t igi_lock;
  uint32_t igi_refcnt;
  uint32_t igi_debug;
  struct
  {
    igmp_ifinfo *le_next;
    igmp_ifinfo **le_prev;
  } igi_link;
  ifnet *igi_ifp;
  uint32_t igi_version;
  uint32_t igi_v1_timer;
  uint32_t igi_v2_timer;
  uint32_t igi_v3_timer;
  uint32_t igi_flags;
  uint32_t igi_rv;
  uint32_t igi_qi;
  uint32_t igi_qri;
  uint32_t igi_uri;
  struct
  {
    in_multi *slh_first;
  } igi_relinmhead;
  ifqueue igi_gq;
  ifqueue igi_v2q;
};

/* 10785 */
struct in_multi_2
{
  lck_mtx_t inm_lock;
  u_int32_t inm_refcount;
  u_int32_t inm_reqcnt;
  u_int32_t inm_debug;
  struct
  {
    in_multi *le_next;
    in_multi **le_prev;
  } inm_link;
  in_addr inm_addr;
  ifnet *inm_ifp;
  ifmultiaddr *inm_ifma;
  u_int inm_timer;
  u_int inm_state;
  void *inm_rti;
  igmp_ifinfo *inm_igi;
  struct
  {
    in_multi *sle_next;
  } inm_dtle;
  struct
  {
    in_multi *sle_next;
  } inm_nrele;
  u_int32_t inm_nrelecnt;
  ip_msource_tree inm_srcs;
  u_long inm_nsrc;
  ifqueue inm_scq;
  timeval inm_lastgsrtv;
  uint16_t inm_sctimer;
  uint16_t inm_scrv;
  inm_st inm_st[2];
  void (*inm_trace)(in_multi *, int);
};

/* 10786 */
struct ifmultiaddr_4
{
  lck_mtx_t ifma_lock;
  u_int32_t ifma_refcount;
  u_int32_t ifma_anoncnt;
  u_int32_t ifma_reqcnt;
  u_int32_t ifma_debug;
  u_int32_t ifma_flags;
  struct
  {
    ifmultiaddr *le_next;
    ifmultiaddr **le_prev;
  } ifma_link;
  sockaddr *ifma_addr;
  ifmultiaddr *ifma_ll;
  ifnet *ifma_ifp;
  void *ifma_protospec;
  void (*ifma_trace)(ifmultiaddr *, int);
};

/* 10787 */
struct ifclassq_3
{
  lck_mtx_t ifcq_lock;
  os_refcnt_t ifcq_refcnt;
  ifnet *ifcq_ifp;
  u_int32_t ifcq_len;
  u_int32_t ifcq_maxlen;
  pktcntr ifcq_xmitcnt;
  pktcntr ifcq_dropcnt;
  u_int32_t ifcq_type;
  u_int32_t ifcq_flags;
  u_int32_t ifcq_sflags;
  u_int32_t ifcq_target_qdelay;
  u_int32_t ifcq_bytes;
  u_int32_t ifcq_pkt_drop_limit;
  void *ifcq_disc;
  ifclassq_disc_slot ifcq_disc_slots[10];
  tb_regulator ifcq_tbr;
};

/* 10788 */
struct rtentry_5
{
  radix_node rt_nodes[2];
  lck_mtx_t rt_lock;
  uint32_t rt_refcnt;
  uint32_t rt_flags;
  uint32_t rt_genid;
  sockaddr *rt_gateway;
  ifnet *rt_ifp;
  ifaddr *rt_ifa;
  sockaddr *rt_genmask;
  void *rt_llinfo;
  void (*rt_llinfo_get_ri)(rtentry *, rt_reach_info *);
  void (*rt_llinfo_get_iflri)(rtentry *, ifnet_llreach_info *);
  void (*rt_llinfo_purge)(rtentry *);
  void (*rt_llinfo_free)(void *);
  void (*rt_llinfo_refresh)(rtentry *);
  rt_metrics rt_rmx;
  rtentry *rt_gwroute;
  rtentry *rt_parent;
  nstat_counts *rt_stats;
  void (*rt_if_ref_fn)(ifnet *, int);
  uint32_t *rt_tree_genid;
  uint64_t rt_expire;
  uint64_t base_calendartime;
  uint64_t base_uptime;
  u_int32_t rtt_hist[10];
  u_int32_t rtt_min;
  u_int32_t rtt_expire_ts;
  u_int8_t rtt_index;
  eventhandler_lists_ctxt rt_evhdlr_ctxt;
};

/* 10789 */
union q_util
{
  uint16_t s[4];
  uint32_t l[2];
  uint64_t q;
};

/* 10790 */
union l_util
{
  uint16_t s[2];
  uint32_t l;
};

/* 10791 */
typedef boolean_t (*fq_getq_flow_t)(fq_if_t *, fq_if_classq_t *, fq_t *, int64_t, uint32_t, classq_pkt_t *, classq_pkt_t *, uint32_t *, uint32_t *, boolean_t *, uint32_t, uint64_t);

/* 10792 */
typedef void (*fq_if_append_pkt_t)(classq_pkt_t *, classq_pkt_t *);

/* 10793 */
struct flowadv_fcentry_0
{
  struct
  {
    flowadv_fcentry *stqe_next;
  } fce_link;
  u_int32_t fce_flowsrc_type;
  u_int32_t fce_flowid;
  flowadv_token_t fce_flowsrc_token;
  flowadv_idx_t fce_flowsrc_fidx;
  ifnet *fce_ifp;
};

/* 10794 */
typedef fq_if_bitmap_ops_0 bitmap_ops_t_0;

/* 10795 */
struct __attribute__((aligned(8))) pq_freeq
{
  __kern_packet *kq_first;
  __kern_packet **kq_last;
  uint32_t kq_len;
};

/* 10796 */
struct mq_freeq
{
  mbuf *mq_first;
  mbuf **mq_last;
};

/* 10797 */
struct __attribute__((aligned(8))) ifnet_init_params_0
{
  const void *uniqueid;
  u_int32_t uniqueid_len;
  const char *name;
  u_int32_t unit;
  ifnet_family_t family;
  u_int32_t type;
  ifnet_output_func output;
  ifnet_demux_func_1 demux;
  ifnet_add_proto_func_0 add_proto;
  ifnet_del_proto_func_0 del_proto;
  ifnet_check_multi check_multi;
  ifnet_framer_func_1 framer;
  void *softc;
  ifnet_ioctl_func_0 ioctl;
  ifnet_set_bpf_tap_0 set_bpf_tap;
  ifnet_detached_func_0 detach;
  ifnet_event_func_2 event;
  const void *broadcast_addr;
  u_int32_t broadcast_len;
};

/* 10798 */
struct ifnet_12
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func_1 if_output_dlil;
  volatile ifnet_start_func_0 if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func_0 if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func_0 if_input_ctl;
  ifnet_ioctl_func_0 if_ioctl;
  ifnet_set_bpf_tap_0 if_set_bpf_tap;
  ifnet_detached_func_0 if_free;
  ifnet_demux_func_1 if_demux;
  ifnet_event_func_2 if_event;
  ifnet_framer_func_1 if_framer_legacy;
  ifnet_framer_extended_func_0 if_framer;
  ifnet_add_proto_func_0 if_add_proto;
  ifnet_del_proto_func_0 if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func_0 if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func_0 if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route if_fwd_route;
  route if_src_route;
  route_in6 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 10799 */
struct cfil_sock_stat
{
  uint32_t cfs_len;
  int cfs_sock_family;
  int cfs_sock_type;
  int cfs_sock_protocol;
  cfil_sock_id_t cfs_sock_id;
  uint64_t cfs_flags;
  pid_t cfs_pid;
  pid_t cfs_e_pid;
  uuid_t_1 cfs_uuid;
  uuid_t_1 cfs_e_uuid;
  cfi_buf_stat cfs_snd;
  cfi_buf_stat cfs_rcv;
  cfil_entry_stat ces_entries[8];
};

/* 10800 */
struct cfil_filter_stat
{
  uint32_t cfs_len;
  uint32_t cfs_filter_id;
  uint32_t cfs_flags;
  uint32_t cfs_sock_count;
  uint32_t cfs_necp_control_unit;
};

/* 10801 */
struct cfil_stats
{
  int32_t cfs_ctl_connect_ok;
  int32_t cfs_ctl_connect_fail;
  int32_t cfs_ctl_disconnect_ok;
  int32_t cfs_ctl_disconnect_fail;
  int32_t cfs_ctl_send_ok;
  int32_t cfs_ctl_send_bad;
  int32_t cfs_ctl_rcvd_ok;
  int32_t cfs_ctl_rcvd_bad;
  int32_t cfs_ctl_rcvd_flow_lift;
  int32_t cfs_ctl_action_data_update;
  int32_t cfs_ctl_action_drop;
  int32_t cfs_ctl_action_bad_op;
  int32_t cfs_ctl_action_bad_len;
  int32_t cfs_sock_id_not_found;
  int32_t cfs_cfi_alloc_ok;
  int32_t cfs_cfi_alloc_fail;
  int32_t cfs_sock_userspace_only;
  int32_t cfs_sock_attach_in_vain;
  int32_t cfs_sock_attach_already;
  int32_t cfs_sock_attach_no_mem;
  int32_t cfs_sock_attach_failed;
  int32_t cfs_sock_attached;
  int32_t cfs_sock_detached;
  int32_t cfs_attach_event_ok;
  int32_t cfs_attach_event_flow_control;
  int32_t cfs_attach_event_fail;
  int32_t cfs_closed_event_ok;
  int32_t cfs_closed_event_flow_control;
  int32_t cfs_closed_event_fail;
  int32_t cfs_data_event_ok;
  int32_t cfs_data_event_flow_control;
  int32_t cfs_data_event_fail;
  int32_t cfs_stats_event_ok;
  int32_t cfs_stats_event_flow_control;
  int32_t cfs_stats_event_fail;
  int32_t cfs_disconnect_in_event_ok;
  int32_t cfs_disconnect_out_event_ok;
  int32_t cfs_disconnect_event_flow_control;
  int32_t cfs_disconnect_event_fail;
  int32_t cfs_ctl_q_not_started;
  int32_t cfs_close_wait;
  int32_t cfs_close_wait_timeout;
  int32_t cfs_flush_in_drop;
  int32_t cfs_flush_out_drop;
  int32_t cfs_flush_in_close;
  int32_t cfs_flush_out_close;
  int32_t cfs_flush_in_free;
  int32_t cfs_flush_out_free;
  int32_t cfs_inject_q_nomem;
  int32_t cfs_inject_q_nobufs;
  int32_t cfs_inject_q_detached;
  int32_t cfs_inject_q_in_fail;
  int32_t cfs_inject_q_out_fail;
  int32_t cfs_inject_q_in_retry;
  int32_t cfs_inject_q_out_retry;
  int32_t cfs_data_in_control;
  int32_t cfs_data_in_oob;
  int32_t cfs_data_out_control;
  int32_t cfs_data_out_oob;
  int64_t cfs_ctl_q_in_enqueued;
  int64_t cfs_ctl_q_out_enqueued;
  int64_t cfs_ctl_q_in_peeked;
  int64_t cfs_ctl_q_out_peeked;
  int64_t cfs_pending_q_in_enqueued;
  int64_t cfs_pending_q_out_enqueued;
  int64_t cfs_inject_q_in_enqueued;
  int64_t cfs_inject_q_out_enqueued;
  int64_t cfs_inject_q_in_passed;
  int64_t cfs_inject_q_out_passed;
};

/* 10802 */
struct cfil_sock_head_stats
{
  cfil_info *tqh_first;
  cfil_info **tqh_last;
};

/* 10803 */
struct cfil_sock_head
{
  cfil_info *tqh_first;
  cfil_info **tqh_last;
};

/* 10804 */
struct fadv_head
{
  flowadv_fcentry *stqh_first;
  flowadv_fcentry **stqh_last;
};

/* 10805 */
struct pktap_buffer_v2_hdr_extra
{
  pktap_v2_hdr_space hdr_space;
  pktap_header_extra extra;
};

/* 10806 */
struct pktap_list
{
  pktap_softc *lh_first;
};

/* 10807 */
struct iptap_list
{
  iptap_softc *lh_first;
};

/* 10808 */
struct pfr_astats
{
  pfr_addr pfras_a;
  uint64_t pfras_packets[2][2];
  uint64_t pfras_bytes[2][2];
  uint64_t pfras_tzero;
};

/* 10809 */
struct ip6_opt_jumbo
{
  u_int8_t ip6oj_type;
  u_int8_t ip6oj_len;
  u_int8_t ip6oj_jumbo_len[4];
};

/* 10810 */
typedef pbuf_0 pbuf_t_0;

/* 10811 */
struct pf_cachequeue
{
  pf_fragment *tqh_first;
  pf_fragment **tqh_last;
};

/* 10812 */
struct pf_fragqueue
{
  pf_fragment *tqh_first;
  pf_fragment **tqh_last;
};

/* 10813 */
struct __attribute__((aligned(8))) ip_fw_args_2
{
  mbuf *fwa_m;
  ifnet *fwa_oif;
  pf_rule *fwa_pf_rule;
  ether_header *fwa_eh;
  int fwa_flags;
  int fwa_oflags;
  union
  {
    ip_out_args *_fwa_ipoa;
    ip6_out_args *_fwa_ip6oa;
  } fwa_ipoa_;
  union
  {
    route *_fwa_ro;
    route_in6 *_fwa_ro6;
  } fwa_ro_;
  union
  {
    sockaddr_in *_fwa_dst;
    sockaddr_in6 *_fwa_dst6;
  } fwa_dst_;
  route_in6 *fwa_ro6_pmtu;
  ifnet *fwa_origifp;
  u_int32_t fwa_mtu;
  u_int32_t fwa_unfragpartlen;
  ip6_exthdrs *fwa_exthdrs;
  ip_flow_id fwa_id;
  u_int32_t fwa_cookie;
};

/* 10814 */
struct __attribute__((aligned(8))) pf_pdesc_0
{
  struct
  {
    int done;
    uid_t uid;
    gid_t gid;
    pid_t pid;
  } lookup;
  u_int64_t tot_len;
  union
  {
    tcphdr *tcp;
    udphdr *udp;
    icmp *icmp;
    icmp6_hdr *icmp6;
    pf_grev1_hdr *grev1;
    pf_esp_hdr *esp;
    void *any;
  } hdr;
  pf_addr baddr;
  pf_addr bdaddr;
  pf_addr naddr;
  pf_addr ndaddr;
  pf_rule *nat_rule;
  pf_addr *src;
  pf_addr *dst;
  ether_header *eh;
  pbuf_t *mp;
  int lmw;
  pf_mtag *pf_mtag;
  u_int16_t *ip_sum;
  u_int32_t off;
  u_int32_t hdrlen;
  u_int32_t p_len;
  u_int16_t flags;
  sa_family_t af;
  sa_family_t naf;
  u_int8_t proto;
  u_int8_t tos;
  u_int8_t ttl;
  u_int8_t proto_variant;
  mbuf_svc_class_t sc;
  u_int32_t pktflags;
  u_int32_t flowsrc;
  u_int32_t flowhash;
};

/* 10815 */
struct list_head_1
{
  pfioc_kernel_token *slh_first;
};

/* 10816 */
struct __attribute__((aligned(8))) pfi_uif
{
  char pfik_name[16];
  u_int64_t pfik_packets[2][2][2];
  u_int64_t pfik_bytes[2][2][2];
  u_int64_t pfik_tzero;
  int pfik_flags;
  int pfik_states;
  int pfik_rules;
};

/* 10817 */
struct pf_pptp_ctrl_msg
{
  pf_pptp_hdr hdr;
  pf_pptp_ctrl_hdr ctrl;
  pf_pptp_ctrl_msg_union msg;
};

/* 10818 */
struct __attribute__((aligned(8))) pf_ike_hdr
{
  u_int64_t initiator_cookie;
  u_int64_t responder_cookie;
  u_int8_t next_payload;
  u_int8_t version;
  u_int8_t exchange_type;
  u_int8_t flags;
  u_int32_t message_id;
  u_int32_t length;
};

/* 10819 */
struct __attribute__((aligned(8))) inpcbinfo_1
{
  struct
  {
    inpcbinfo *tqe_next;
    inpcbinfo **tqe_prev;
  } ipi_entry;
  inpcb_timer_func_t ipi_gc;
  inpcb_timer_func_t ipi_timer;
  intimercount ipi_gc_req;
  intimercount ipi_timer_req;
  lck_rw_t ipi_lock;
  inpcbhead *ipi_listhead;
  uint32_t ipi_count;
  uint32_t ipi_twcount;
  uint64_t ipi_gencnt;
  uint16_t ipi_lastport;
  uint16_t ipi_lastlow;
  uint16_t ipi_lasthi;
  zone_or_view_t_0 ipi_zone;
  inpcbhead *ipi_hashbase;
  u_long ipi_hashmask;
  inpcbporthead *ipi_porthashbase;
  u_long ipi_porthashmask;
  lck_attr_t ipi_lock_attr;
  lck_grp_t *ipi_lock_grp;
  u_int32_t ipi_flags;
};

/* 10820 */
struct pf_state_queue
{
  pf_state *tqh_first;
  pf_state **tqh_last;
};

/* 10821 */
struct pfloghdr
{
  u_int8_t length;
  sa_family_t af;
  u_int8_t action;
  u_int8_t reason;
  char ifname[16];
  char ruleset[16];
  u_int32_t rulenr;
  u_int32_t subrulenr;
  uid_t uid;
  pid_t pid;
  uid_t rule_uid;
  pid_t rule_pid;
  u_int8_t dir;
  u_int8_t pad[3];
};

/* 10822 */
struct kev_netagent_data
{
  uuid_t_1 netagent_uuid;
};

/* 10823 */
struct netagent_message_header
{
  u_int8_t message_type;
  u_int8_t message_flags;
  u_int32_t message_id;
  u_int32_t message_error;
  u_int32_t message_payload_length;
};

/* 10824 */
struct _netagent_list
{
  netagent_wrapper *lh_first;
};

/* 10825 */
struct necp_client_result_estimated_throughput
{
  u_int8_t up;
  u_int8_t down;
};

/* 10826 */
struct __attribute__((packed)) __attribute__((aligned(1))) necp_client_flow_protoctl_event_header
{
  necp_tlv_header protoctl_tlv_header;
  necp_client_flow_protoctl_event protoctl_event;
};

/* 10827 */
struct __attribute__((packed)) __attribute__((aligned(2))) necp_client_nexus_flow_header
{
  necp_client_flow_header flow_header;
  necp_tlv_header agent_tlv_header;
  necp_client_result_netagent agent_value;
  necp_tlv_header tfo_cookie_tlv_header;
  u_int8_t tfo_cookie_value[16];
};

/* 10828 */
struct necp_client_validatable_default
{
  necp_client_signature signature;
  necp_client_signable_default signable;
};

/* 10829 */
struct __attribute__((aligned(4))) necp_interface_details
{
  char name[24];
  u_int32_t index;
  u_int32_t generation;
  u_int32_t functional_type;
  u_int32_t delegate_index;
  u_int32_t flags;
  u_int32_t mtu;
  necp_interface_signature ipv4_signature;
  necp_interface_signature ipv6_signature;
  u_int32_t ipv4_netmask;
  u_int32_t ipv4_broadcast;
  u_int32_t tso_max_segment_size_v4;
  u_int32_t tso_max_segment_size_v6;
  u_int8_t radio_type;
  u_int8_t radio_channel;
};

/* 10830 */
struct necp_agent_use_parameters
{
  uuid_t_1 agent_uuid;
  uint64_t out_use_count;
};

/* 10831 */
struct __attribute__((packed)) __attribute__((aligned(4))) necp_client_add_flow_default
{
  uuid_t_1 agent_uuid;
  uuid_t_1 registration_id;
  u_int16_t flags;
  u_int16_t stats_request_count;
  necp_client_flow_stats stats_requests[1];
};

/* 10832 */
struct __attribute__((aligned(4))) ns_flow_info_0
{
  uuid_t_1 nfi_flow_uuid;
  ifnet *nfi_ifp;
  sockaddr_in_4_6 nfi_laddr;
  sockaddr_in_4_6 nfi_faddr;
  uint8_t nfi_protocol;
  uint8_t nfi_pad[3];
  pid_t nfi_owner_pid;
  pid_t nfi_effective_pid;
  char nfi_owner_name[17];
  char nfi_effective_name[17];
};

/* 10833 */
struct in6_multi_2
{
  lck_mtx_t in6m_lock;
  u_int32_t in6m_refcount;
  u_int32_t in6m_reqcnt;
  u_int32_t in6m_debug;
  struct
  {
    in6_multi *le_next;
    in6_multi **le_prev;
  } in6m_entry;
  in6_addr_0 in6m_addr;
  uint32_t ifscope;
  ifnet *in6m_ifp;
  ifmultiaddr *in6m_ifma;
  u_int in6m_state;
  u_int in6m_timer;
  mld_ifinfo *in6m_mli;
  struct
  {
    in6_multi *sle_next;
  } in6m_dtle;
  struct
  {
    in6_multi *sle_next;
  } in6m_nrele;
  u_int32_t in6m_nrelecnt;
  ip6_msource_tree in6m_srcs;
  u_long in6m_nsrc;
  ifqueue in6m_scq;
  timeval in6m_lastgsrtv;
  uint16_t in6m_sctimer;
  uint16_t in6m_scrv;
  in6m_st in6m_st[2];
  void (*in6m_trace)(in6_multi *, int);
};

/* 10834 */
struct ip6_moptions_2
{
  lck_mtx_t im6o_lock;
  uint32_t im6o_refcnt;
  uint32_t im6o_debug;
  ifnet *im6o_multicast_ifp;
  u_char im6o_multicast_hlim;
  u_char im6o_multicast_loop;
  u_short im6o_num_memberships;
  u_short im6o_max_memberships;
  in6_multi **im6o_membership;
  in6_mfilter *im6o_mfilters;
  void (*im6o_trace)(ip6_moptions *, int);
};

/* 10835 */
struct ip_moptions_3
{
  lck_mtx_t imo_lock;
  uint32_t imo_refcnt;
  uint32_t imo_debug;
  ifnet *imo_multicast_ifp;
  u_char imo_multicast_ttl;
  u_char imo_multicast_loop;
  u_short imo_num_memberships;
  u_short imo_max_memberships;
  in_multi **imo_membership;
  in_mfilter *imo_mfilters;
  u_int32_t imo_multicast_vif;
  in_addr imo_multicast_addr;
  void (*imo_trace)(ip_moptions *, int);
};

/* 10836 */
struct _necp_fd_observer_list
{
  necp_fd_data *lh_first;
};

/* 10837 */
struct _necp_fd_list
{
  necp_fd_data *lh_first;
};

/* 10838 */
struct in_multi_3
{
  lck_mtx_t inm_lock;
  u_int32_t inm_refcount;
  u_int32_t inm_reqcnt;
  u_int32_t inm_debug;
  struct
  {
    in_multi *le_next;
    in_multi **le_prev;
  } inm_link;
  in_addr inm_addr;
  ifnet *inm_ifp;
  ifmultiaddr *inm_ifma;
  u_int inm_timer;
  u_int inm_state;
  void *inm_rti;
  igmp_ifinfo *inm_igi;
  struct
  {
    in_multi *sle_next;
  } inm_dtle;
  struct
  {
    in_multi *sle_next;
  } inm_nrele;
  u_int32_t inm_nrelecnt;
  ip_msource_tree inm_srcs;
  u_long inm_nsrc;
  ifqueue inm_scq;
  timeval inm_lastgsrtv;
  uint16_t inm_sctimer;
  uint16_t inm_scrv;
  inm_st inm_st[2];
  void (*inm_trace)(in_multi *, int);
};

/* 10839 */
struct rtentry_6
{
  radix_node rt_nodes[2];
  lck_mtx_t rt_lock;
  uint32_t rt_refcnt;
  uint32_t rt_flags;
  uint32_t rt_genid;
  sockaddr *rt_gateway;
  ifnet *rt_ifp;
  ifaddr *rt_ifa;
  sockaddr *rt_genmask;
  void *rt_llinfo;
  void (*rt_llinfo_get_ri)(rtentry *, rt_reach_info *);
  void (*rt_llinfo_get_iflri)(rtentry *, ifnet_llreach_info *);
  void (*rt_llinfo_purge)(rtentry *);
  void (*rt_llinfo_free)(void *);
  void (*rt_llinfo_refresh)(rtentry *);
  rt_metrics rt_rmx;
  rtentry *rt_gwroute;
  rtentry *rt_parent;
  nstat_counts *rt_stats;
  void (*rt_if_ref_fn)(ifnet *, int);
  uint32_t *rt_tree_genid;
  uint64_t rt_expire;
  uint64_t base_calendartime;
  uint64_t base_uptime;
  u_int32_t rtt_hist[10];
  u_int32_t rtt_min;
  u_int32_t rtt_expire_ts;
  u_int8_t rtt_index;
  eventhandler_lists_ctxt rt_evhdlr_ctxt;
};

/* 10840 */
struct _necp_flow_registration_list
{
  necp_client_flow_registration *lh_first;
};

/* 10841 */
typedef u_int32_t necp_session_priority;

/* 10842 */
struct necp_policy_result_ip_tunnel
{
  u_int32_t secondary_result;
  char interface_name[24];
};

/* 10843 */
enum necp_socket_bypass_type_t : __int32
{
  NECP_BYPASS_TYPE_NONE = 0x0,
  NECP_BYPASS_TYPE_INTCOPROC = 0x1,
  NECP_BYPASS_TYPE_LOOPBACK = 0x2,
};

/* 10844 */
struct __attribute__((aligned(8))) kev_netpolicy_netdenied
{
  netpolicy_event_data ev_data;
  __uint32_t ev_network_type;
};

/* 10845 */
struct necp_resolver_key_state
{
  const ccdigest_info_0 *digest_info;
  uint8_t key[32];
};

/* 10846 */
struct necp_drop_dest_policy
{
  u_int32_t entry_count;
  necp_drop_dest_entry entries[8];
};

/* 10847 */
struct necp_aggregate_route_rule_list
{
  necp_aggregate_route_rule *lh_first;
};

/* 10848 */
struct _necp_kernel_service_list
{
  necp_service_registration *lh_first;
};

/* 10849 */
struct _necpkernelipoutputpolicies
{
  necp_kernel_ip_output_policy *lh_first;
};

/* 10850 */
struct _necpkernelsocketconnectpolicies
{
  necp_kernel_socket_policy *lh_first;
};

/* 10851 */
struct _necp_session_list
{
  necp_session *tqh_first;
  necp_session **tqh_last;
};

/* 10852 */
struct ifnet_attach_proto_param_0
{
  ifnet_demux_desc *demux_array;
  u_int32_t demux_count;
  proto_media_input input;
  proto_media_preout pre_output;
  proto_media_event event;
  proto_media_ioctl ioctl;
  proto_media_detached detached;
  proto_media_resolve_multi resolve;
  proto_media_send_arp send_arp;
};

/* 10853 */
typedef ipsec_nx *ipsec_nx_t;

/* 10854 */
struct kern_nexus_net_init_0
{
  uint32_t nxneti_version;
  uint32_t nxneti_flags;
  ifnet_init_eparams *nxneti_eparams;
  sockaddr_dl *nxneti_lladdr;
  nxnet_prepare_fn_t_0 nxneti_prepare;
  kern_pbufpool_t nxneti_tx_pbufpool;
  kern_pbufpool_t nxneti_rx_pbufpool;
  kern_nexus_netif_llink_init *nxneti_llink;
};

/* 10855 */
struct ifnet_init_eparams_1
{
  u_int32_t ver;
  u_int32_t len;
  u_int32_t flags;
  const void *uniqueid;
  u_int32_t uniqueid_len;
  const char *name;
  u_int32_t unit;
  ifnet_family_t family;
  u_int32_t type;
  u_int32_t sndq_maxlen;
  ifnet_output_func output;
  ifnet_pre_enqueue_func pre_enqueue;
  ifnet_start_func_0 start;
  ifnet_ctl_func_0 output_ctl;
  u_int32_t output_sched_model;
  u_int32_t output_target_qdelay;
  u_int64_t output_bw;
  u_int64_t output_bw_max;
  u_int64_t output_lt;
  u_int64_t output_lt_max;
  u_int16_t start_delay_qlen;
  u_int16_t start_delay_timeout;
  u_int32_t _reserved[3];
  ifnet_input_poll_func input_poll;
  ifnet_ctl_func_0 input_ctl;
  u_int32_t rcvq_maxlen;
  u_int32_t __reserved;
  u_int64_t input_bw;
  u_int64_t input_bw_max;
  u_int64_t input_lt;
  u_int64_t input_lt_max;
  u_int64_t ___reserved[2];
  ifnet_demux_func_1 demux;
  ifnet_add_proto_func_0 add_proto;
  ifnet_del_proto_func_0 del_proto;
  ifnet_check_multi check_multi;
  ifnet_framer_func_1 framer;
  void *softc;
  ifnet_ioctl_func_0 ioctl;
  ifnet_set_bpf_tap_0 set_bpf_tap;
  ifnet_detached_func_0 detach;
  ifnet_event_func_0 event;
  const void *broadcast_addr;
  u_int32_t broadcast_len;
  ifnet_framer_extended_func_0 framer_extended;
  ifnet_subfamily_t subfamily;
  u_int16_t tx_headroom;
  u_int16_t tx_trailer;
  u_int32_t rx_mit_ival;
  u_int32_t ____reserved;
  ifnet_free_func_0 free;
};

/* 10856 */
struct lltable_5
{
  struct
  {
    lltable *sle_next;
  } llt_link;
  int llt_af;
  int llt_hsize;
  llentries *lle_head;
  ifnet *llt_ifp;
  llt_lookup_t *llt_lookup;
  llt_alloc_t *llt_alloc_entry;
  llt_delete_t *llt_delete_entry;
  llt_prefix_free_t *llt_prefix_free;
  llt_dump_entry_t *llt_dump_entry;
  llt_hash_t *llt_hash;
  llt_match_prefix_t *llt_match_prefix;
  llt_free_entry_t *llt_free_entry;
  llt_foreach_entry_t *llt_foreach_entry;
  llt_link_entry_t *llt_link_entry;
  llt_unlink_entry_t *llt_unlink_entry;
  llt_fill_sa_entry_t *llt_fill_sa_entry;
};

/* 10857 */
struct __attribute__((aligned(8))) nx_netif_mit_2
{
  lck_spin_t mit_lock;
  volatile __kern_channel_ring *mit_ckr;
  uint32_t mit_flags;
  uint32_t mit_requests;
  uint32_t mit_interval;
  uint32_t mit_cfg_idx_max;
  uint32_t mit_cfg_idx;
  const mit_cfg_tbl *mit_cfg;
  mit_mode_t mit_mode;
  uint32_t mit_packets_avg;
  uint32_t mit_packets_min;
  uint32_t mit_packets_max;
  uint32_t mit_bytes_avg;
  uint32_t mit_bytes_min;
  uint32_t mit_bytes_max;
  pktcntr mit_sstats;
  timespec mit_mode_holdtime;
  timespec mit_mode_lasttime;
  timespec mit_sample_time;
  timespec mit_sample_lasttime;
  timespec mit_start_time;
  thread *mit_thread;
  char mit_name[64];
  const ifnet *mit_netif_ifp;
  mit_cfg_tbl mit_tbl[5];
};

/* 10858 */
struct __attribute__((aligned(8))) nx_flowswitch_6
{
  lck_rw_t fsw_lock;
  uint32_t fsw_tx_rings;
  uint32_t fsw_rx_rings;
  kern_nexus *fsw_nx;
  classq_pkt_type_t fsw_classq_enq_ptype;
  boolean_t fsw_classq_enabled;
  pkt_copy_from_pkt_t *fsw_pkt_copy_from_pkt;
  pkt_copy_from_mbuf_t *fsw_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *fsw_pkt_copy_to_mbuf;
  uint8_t fsw_frame_headroom;
  uint32_t fsw_src_lla_gencnt;
  uint32_t fsw_pending_nonviable;
  uint32_t fsw_low_power_gencnt;
  flow_mgr *fsw_flow_mgr;
  netagent_session_t fsw_agent_session;
  uuid_t_1 fsw_agent_uuid;
  ifnet *fsw_ifp;
  nexus_adapter *fsw_nifna;
  uint32_t fsw_state_flags;
  union
  {
    uint64_t _buf[1];
    uint8_t _eth_src[6];
  } __fsw_slladdr;
  int (*fsw_resolve)(nx_flowswitch *, flow_route *, __kern_packet *);
  void (*fsw_frame)(nx_flowswitch *, flow_route *, __kern_packet *);
  sa_family_t (*fsw_demux)(nx_flowswitch *, __kern_packet *);
  fsw_stats fsw_stats;
  lck_mtx_t fsw_detach_barrier_lock;
  uint32_t fsw_detach_flags;
  uint32_t fsw_detach_barriers;
  uint32_t fsw_detach_waiters;
  uint32_t fsw_ifp_dlt;
  uint32_t fsw_rx_largest_size;
  void (*fsw_ctor)(nx_flowswitch *, flow_route *);
  __nx_stats_fsw *fsw_closed_na_stats;
  fsw_ip_frag_mgr *fsw_ipfm;
  skoid_0 fsw_skoid;
  netem *fsw_input_netem;
  kern_channel *fsw_dev_ch;
  kern_channel *fsw_host_ch;
  lck_mtx_t fsw_reap_lock;
  uint32_t fsw_reap_flags;
  uint32_t fsw_reap_requests;
  thread *fsw_reap_thread;
  char fsw_reap_name[64];
  uint64_t fsw_reap_last;
  uint64_t fsw_drain_channel_chk_last;
  uint64_t fsw_drain_netif_chk_last;
  lck_mtx_t fsw_linger_lock;
  flow_entry_linger_head fsw_linger_head;
  uint32_t fsw_linger_cnt;
};

/* 10859 */
struct nx_netif_6
{
  lck_rw_t nif_lock;
  kern_nexus *nif_nx;
  nxbind *nif_dev_nxb;
  nxbind *nif_host_nxb;
  uuid_t_1 nif_uuid;
  netif_stats nif_stats;
  uint32_t nif_flags;
  os_refcnt nif_refcnt;
  lck_mtx_t nif_agent_lock;
  netif_agent_flow_head nif_agent_flow_list;
  uint32_t nif_agent_flow_cnt;
  uint32_t nif_agent_flags;
  netagent_session_t nif_agent_session;
  uuid_t_1 nif_agent_uuid;
  uint32_t nif_hwassist;
  uint32_t nif_capabilities;
  uint32_t nif_capenable;
  uint64_t nif_input_rate;
  ifnet *nif_ifp;
  nx_flowswitch *nif_fsw;
  sk_nexusadv *nif_fsw_nxadv;
  netif_nexus_advisory *nif_netif_nxadv;
  pkt_copy_from_mbuf_t *nif_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *nif_pkt_copy_to_mbuf;
  pkt_copy_from_pkt_t *nif_pkt_copy_from_pkt;
  lck_mtx_t nif_filter_lock;
  uint32_t nif_filter_flags;
  uint32_t nif_filter_vp_cnt;
  uint32_t nif_filter_cnt;
  kern_pbufpool *nif_filter_pp;
  netif_filter_head nif_filter_list;
  union
  {
    nx_mbq nif_tx_processed_mbq[4];
    nx_pktq nif_tx_processed_pktq[4];
  };
  lck_mtx_t nif_flow_lock;
  uint32_t nif_vp_cnt;
  uint32_t nif_flow_flags;
  uint32_t nif_flow_cnt;
  netif_flow_head nif_flow_list;
  netif_flowtable *nif_flow_table;
  kern_channel *nif_hw_ch;
  uint32_t nif_hw_ch_refcnt;
  lck_rw_t nif_llink_lock;
  kern_nexus_netif_llink_init *nif_default_llink_params;
  netif_llink *nif_default_llink;
  struct
  {
    netif_llink *stqh_first;
    netif_llink **stqh_last;
  } nif_llink_list;
  uint16_t nif_llink_cnt;
  uint32_t nif_extended_capabilities;
  kern_nexus_capab_interface_advisory_config_fn_t nif_intf_adv_config;
  void *nif_intf_adv_prov_ctx;
  netif_qset_extensions nif_qset_extensions;
};

/* 10860 */
struct dlil_threading_info_3
{
  lck_mtx_t dlth_lock;
  class_queue_t dlth_pkts;
  ifnet *dlth_ifp;
  ifnet_stat_increment_param dlth_stats;
  uint32_t dlth_flags;
  uint32_t dlth_wtot;
  errno_t (*dlth_strategy)(dlil_threading_info *, ifnet *, mbuf *, mbuf *, const ifnet_stat_increment_param *, boolean_t, thread *);
  boolean_t dlth_affinity;
  uint32_t dlth_affinity_tag;
  thread *dlth_thread;
  thread *dlth_driver_thread;
  thread *dlth_poller_thread;
  lck_grp_t *dlth_lock_grp;
  char dlth_name[32];
  uint64_t dlth_pkts_cnt;
};

/* 10861 */
struct in_multi_4
{
  lck_mtx_t inm_lock;
  u_int32_t inm_refcount;
  u_int32_t inm_reqcnt;
  u_int32_t inm_debug;
  struct
  {
    in_multi *le_next;
    in_multi **le_prev;
  } inm_link;
  in_addr inm_addr;
  ifnet *inm_ifp;
  ifmultiaddr *inm_ifma;
  u_int inm_timer;
  u_int inm_state;
  void *inm_rti;
  igmp_ifinfo *inm_igi;
  struct
  {
    in_multi *sle_next;
  } inm_dtle;
  struct
  {
    in_multi *sle_next;
  } inm_nrele;
  u_int32_t inm_nrelecnt;
  ip_msource_tree inm_srcs;
  u_long inm_nsrc;
  ifqueue inm_scq;
  timeval inm_lastgsrtv;
  uint16_t inm_sctimer;
  uint16_t inm_scrv;
  inm_st inm_st[2];
  void (*inm_trace)(in_multi *, int);
};

/* 10862 */
struct ifmultiaddr_5
{
  lck_mtx_t ifma_lock;
  u_int32_t ifma_refcount;
  u_int32_t ifma_anoncnt;
  u_int32_t ifma_reqcnt;
  u_int32_t ifma_debug;
  u_int32_t ifma_flags;
  struct
  {
    ifmultiaddr *le_next;
    ifmultiaddr **le_prev;
  } ifma_link;
  sockaddr *ifma_addr;
  ifmultiaddr *ifma_ll;
  ifnet *ifma_ifp;
  void *ifma_protospec;
  void (*ifma_trace)(ifmultiaddr *, int);
};

/* 10863 */
struct ifclassq_4
{
  lck_mtx_t ifcq_lock;
  os_refcnt_t ifcq_refcnt;
  ifnet *ifcq_ifp;
  u_int32_t ifcq_len;
  u_int32_t ifcq_maxlen;
  pktcntr ifcq_xmitcnt;
  pktcntr ifcq_dropcnt;
  u_int32_t ifcq_type;
  u_int32_t ifcq_flags;
  u_int32_t ifcq_sflags;
  u_int32_t ifcq_target_qdelay;
  u_int32_t ifcq_bytes;
  u_int32_t ifcq_pkt_drop_limit;
  void *ifcq_disc;
  ifclassq_disc_slot ifcq_disc_slots[10];
  tb_regulator ifcq_tbr;
};

/* 10864 */
struct rtentry_7
{
  radix_node rt_nodes[2];
  lck_mtx_t rt_lock;
  uint32_t rt_refcnt;
  uint32_t rt_flags;
  uint32_t rt_genid;
  sockaddr *rt_gateway;
  ifnet *rt_ifp;
  ifaddr *rt_ifa;
  sockaddr *rt_genmask;
  void *rt_llinfo;
  void (*rt_llinfo_get_ri)(rtentry *, rt_reach_info *);
  void (*rt_llinfo_get_iflri)(rtentry *, ifnet_llreach_info *);
  void (*rt_llinfo_purge)(rtentry *);
  void (*rt_llinfo_free)(void *);
  void (*rt_llinfo_refresh)(rtentry *);
  rt_metrics rt_rmx;
  rtentry *rt_gwroute;
  rtentry *rt_parent;
  nstat_counts *rt_stats;
  void (*rt_if_ref_fn)(ifnet *, int);
  uint32_t *rt_tree_genid;
  uint64_t rt_expire;
  uint64_t base_calendartime;
  uint64_t base_uptime;
  u_int32_t rtt_hist[10];
  u_int32_t rtt_min;
  u_int32_t rtt_expire_ts;
  u_int8_t rtt_index;
  eventhandler_lists_ctxt rt_evhdlr_ctxt;
};

/* 10865 */
struct __attribute__((aligned(8))) ifaddr_3
{
  lck_mtx_t ifa_lock;
  uint32_t ifa_refcnt;
  uint32_t ifa_debug;
  sockaddr *ifa_addr;
  sockaddr *ifa_dstaddr;
  sockaddr *ifa_netmask;
  ifnet *ifa_ifp;
  struct
  {
    ifaddr *tqe_next;
    ifaddr **tqe_prev;
  } ifa_link;
  void (*ifa_rtrequest)(int, rtentry *, sockaddr *);
  uint32_t ifa_flags;
  int32_t ifa_metric;
  void (*ifa_free)(ifaddr *);
  void (*ifa_trace)(ifaddr *, int);
  void (*ifa_attached)(ifaddr *);
  void (*ifa_detached)(ifaddr *);
  void *ifa_del_wc;
  int ifa_del_waiters;
};

/* 10866 */
struct ipsec_list
{
  ipsec_pcb *tqh_first;
  ipsec_pcb **tqh_last;
};

/* 10867 */
typedef utun_nx *utun_nx_t;

/* 10868 */
struct utun_kpipe_sync_tx::mbufq
{
  mbuf *mq_first;
  mbuf **mq_last;
};

/* 10869 */
struct utun_list
{
  utun_pcb *tqh_first;
  utun_pcb **tqh_last;
};

/* 10870 */
struct mld_ifinfo_1
{
  lck_mtx_t mli_lock;
  uint32_t mli_refcnt;
  uint32_t mli_debug;
  struct
  {
    mld_ifinfo *le_next;
    mld_ifinfo **le_prev;
  } mli_link;
  ifnet *mli_ifp;
  uint32_t mli_version;
  uint32_t mli_v1_timer;
  uint32_t mli_v2_timer;
  uint32_t mli_flags;
  uint32_t mli_rv;
  uint32_t mli_qi;
  uint32_t mli_qri;
  uint32_t mli_uri;
  struct
  {
    in6_multi *slh_first;
  } mli_relinmhead;
  ifqueue mli_gq;
  ifqueue mli_v1q;
};

/* 10871 */
struct __attribute__((aligned(8))) if_llreach_0
{
  lck_mtx_t lr_lock;
  struct
  {
    if_llreach *rbe_left;
    if_llreach *rbe_right;
    if_llreach *rbe_parent;
  } lr_link;
  ifnet *lr_ifp;
  u_int32_t lr_refcnt;
  u_int32_t lr_reqcnt;
  u_int32_t lr_debug;
  u_int32_t lr_probes;
  u_int64_t lr_basecal;
  u_int64_t lr_baseup;
  u_int64_t lr_lastrcvd;
  u_int32_t lr_basereachable;
  u_int32_t lr_reachable;
  lr_key_s lr_key;
  int32_t lr_rssi;
  int32_t lr_lqm;
  int32_t lr_npm;
};

/* 10872 */
struct igmp_ifinfo_2
{
  lck_mtx_t igi_lock;
  uint32_t igi_refcnt;
  uint32_t igi_debug;
  struct
  {
    igmp_ifinfo *le_next;
    igmp_ifinfo **le_prev;
  } igi_link;
  ifnet *igi_ifp;
  uint32_t igi_version;
  uint32_t igi_v1_timer;
  uint32_t igi_v2_timer;
  uint32_t igi_v3_timer;
  uint32_t igi_flags;
  uint32_t igi_rv;
  uint32_t igi_qi;
  uint32_t igi_qri;
  uint32_t igi_uri;
  struct
  {
    in_multi *slh_first;
  } igi_relinmhead;
  ifqueue igi_gq;
  ifqueue igi_v2q;
};

/* 10873 */
struct kev_dl_low_power_mode
{
  net_event_data link_data;
  int low_power_event;
};

/* 10874 */
struct net_port_info_una_wake_event
{
  uuid_t_1 una_wake_uuid;
  timeval32 una_wake_pkt_timestamp;
  uint16_t una_wake_pkt_if_index;
  uint16_t una_wake_pkt_flags;
  uint16_t _una_wake_pkt_reserved;
  uint16_t una_wake_ptk_len;
  uint8_t una_wake_pkt[102];
  in_port_t una_wake_pkt_local_port;
  in_port_t una_wake_pkt_foreign_port;
  in_addr_4_6 una_wake_pkt_local_addr_;
  in_addr_4_6 una_wake_pkt_foreign_addr_;
  char una_wake_pkt_ifname[16];
  uint32_t una_wake_pkt_total_len;
  uint32_t una_wake_pkt_data_len;
  uint16_t una_wake_pkt_control_flags;
  uint16_t una_wake_pkt_proto;
};

/* 10875 */
struct xnpigen
{
  uint32_t xng_len;
  uint32_t xng_gen;
  uint32_t xng_npi_count;
  uint32_t xng_npi_size;
  uuid_t_1 xng_wakeuuid;
};

/* 10876 */
struct tcpcb_2
{
  tsegqe_head t_segq;
  uint32_t t_dupacks;
  int t_state;
  uint32_t t_timer[9];
  tcptimerentry tentry;
  inpcb *t_inpcb;
  uint32_t t_flags;
  tcp_seq snd_una;
  tcp_seq snd_max;
  tcp_seq snd_nxt;
  tcp_seq snd_up;
  tcp_seq snd_wl1;
  tcp_seq snd_wl2;
  tcp_seq iss;
  tcp_seq irs;
  tcp_seq rcv_nxt;
  tcp_seq rcv_adv;
  uint32_t rcv_wnd;
  uint32_t t_last_recwin;
  tcp_seq rcv_up;
  uint32_t snd_wnd;
  uint32_t snd_cwnd;
  uint32_t snd_ssthresh;
  tcp_seq snd_recover;
  uint32_t t_maxopd;
  uint32_t t_rcvtime;
  uint32_t t_sndtime;
  uint32_t t_starttime;
  int t_rtttime;
  tcp_seq t_rtseq;
  uint32_t rfbuf_ts;
  uint32_t rfbuf_cnt;
  uint32_t rfbuf_space;
  int t_rxtcur;
  unsigned int t_maxseg;
  int t_srtt;
  int t_rttvar;
  uint64_t t_accsleep_ms;
  uint32_t t_reassqlen;
  uint32_t t_reassq_mbcnt;
  uint16_t t_rxtshift;
  uint32_t t_rttmin;
  uint32_t t_rttbest;
  uint32_t t_rttcur;
  uint32_t t_rttupdated;
  uint32_t t_rxt_conndroptime;
  uint32_t t_rxtstart;
  uint32_t max_sndwnd;
  int t_softerror;
  char t_oobflags;
  char t_iobc;
  u_int8_t snd_scale;
  u_int8_t rcv_scale;
  u_int8_t request_r_scale;
  u_int8_t requested_s_scale;
  u_int8_t tcp_cc_index;
  u_int8_t t_adaptive_rtimo;
  u_int8_t t_adaptive_wtimo;
  u_int8_t t_stretchack_delayed;
  u_int16_t t_early_rexmt_count;
  u_int32_t t_early_rexmt_win;
  u_int32_t ts_recent;
  u_int32_t ts_recent_age;
  tcp_seq last_ack_sent;
  u_int32_t t_bytes_acked;
  int t_lastchain;
  uint16_t t_unacksegs;
  uint16_t t_forced_acks;
  uint8_t t_rexmtthresh;
  uint8_t t_rtimo_probes;
  uint32_t t_persist_timeout;
  uint32_t t_persist_stop;
  uint32_t t_notsent_lowat;
  u_int32_t rcv_unackwin;
  u_int32_t rcv_by_unackwin;
  u_int32_t rcv_by_unackhalfwin;
  u_int32_t rcv_nostrack_ts;
  u_int32_t rcv_nostrack_pkts;
  u_int16_t rcv_waitforss;
  u_int32_t ecn_flags;
  u_int32_t t_ecn_recv_ce;
  u_int32_t t_ecn_recv_cwr;
  uint32_t t_rcv_ce_packets;
  uint32_t t_snd_ce_packets;
  uint32_t t_delta_ce_packets;
  uint64_t t_rcv_ect1_bytes;
  uint64_t t_rcv_ect0_bytes;
  uint64_t t_rcv_ce_bytes;
  uint64_t t_snd_ect1_bytes;
  uint64_t t_snd_ect0_bytes;
  uint64_t t_snd_ce_bytes;
  u_int32_t snd_cwnd_prev;
  u_int32_t snd_ssthresh_prev;
  tcp_seq snd_recover_prev;
  int t_srtt_prev;
  int t_rttvar_prev;
  u_int32_t t_badrexmt_time;
  u_int32_t t_reorderwin;
  int16_t snd_numholes;
  tcp_seq sack_newdata;
  sackhole_head snd_holes;
  tcp_seq snd_fack;
  int rcv_numsacks;
  sackblk sackblks[6];
  sackhint sackhint;
  tcp_seq send_highest_sack;
  int t_new_dupacks;
  mbuf *t_pktlist_head;
  mbuf *t_pktlist_tail;
  u_int32_t t_pktlist_sentlen;
  u_int32_t t_keepidle;
  u_int32_t t_keepinit;
  u_int32_t t_keepintvl;
  u_int32_t t_keepcnt;
  u_int32_t tso_max_segment_size;
  u_int16_t t_pmtud_lastseg_size;
  u_int32_t t_pmtud_saved_maxopd;
  u_int32_t t_pmtud_start_ts;
  struct
  {
    u_int32_t rxduplicatebytes;
    u_int32_t rxoutoforderbytes;
    u_int32_t txretransmitbytes;
    u_int16_t synrxtshift;
    u_int16_t rxmitsyns;
    u_int16_t unused_pad_to_8;
    u_int32_t rxmitpkts;
    uint32_t delayed_acks_sent;
    uint32_t acks_delayed;
  } t_stat;
  u_int8_t t_syn_sent;
  u_int8_t t_syn_rcvd;
  u_int8_t t_notify_ack_count;
  u_int8_t t_ecn_recv_ce_pkt;
  u_int32_t t_cached_maxopd;
  uint32_t bg_ssthresh;
  uint32_t t_flagsext;
  uint32_t iaj_rcv_ts;
  int iaj_size;
  uint8_t iaj_small_pkt;
  uint8_t t_pipeack_ind;
  uint16_t iaj_pktcnt;
  uint32_t acc_iaj;
  uint32_t avg_iaj;
  uint32_t std_dev_iaj;
  bwmeas *t_bwmeas;
  tcp_seq t_idleat;
  uint8_t t_fin_sent;
  uint8_t t_fin_rcvd;
  uint8_t t_rst_sent;
  uint8_t t_rst_rcvd;
  struct
  {
    tcpcb *tqe_next;
    tcpcb **tqe_prev;
  } t_twentry;
  tcp_ccstate *t_ccstate;
  tcp_ccstate _t_ccstate;
  tcp_seq t_tlphighrxt;
  u_int32_t t_tlpstart;
  tcp_seq t_dsack_lseq;
  tcp_seq t_dsack_rseq;
  tcp_rxt_seghead t_rxt_segments;
  uint32_t t_rxt_seg_count;
  uint32_t t_rxt_seg_drop;
  tcp_seq t_dsack_lastuna;
  u_int32_t t_pipeack_sample[3];
  tcp_seq t_pipeack_lastuna;
  u_int32_t t_pipeack;
  u_int32_t t_lossflightsize;
  u_int32_t t_mpflags;
  tcp_seq t_mpuna;
  mptcb *t_mptcb;
  mptsub *t_mpsub;
  mpt_dsn_map t_rcv_map;
  u_int8_t t_local_aid;
  u_int8_t t_rem_aid;
  u_int8_t t_mprxtshift;
  u_int8_t t_tfo_flags;
  u_int16_t t_tfo_stats;
  u_int8_t t_tfo_probes;
  u_int8_t t_tfo_probe_state;
  u_int32_t t_rcvoopack;
  u_int32_t t_pawsdrop;
  u_int32_t t_sack_recovery_episode;
  u_int32_t t_reordered_pkts;
  u_int32_t t_dsack_sent;
  u_int32_t t_dsack_recvd;
  struct
  {
    tcp_notify_ack_marker *slh_first;
  } t_notify_ack;
  u_int32_t t_recv_throttle_ts;
  u_int32_t t_rxt_minimum_timeout;
  uint32_t t_challengeack_last;
  uint32_t t_challengeack_count;
  u_int32_t t_log_flags;
  u_int32_t t_connect_time;
  uint32_t t_comp_gencnt;
  uint32_t t_comp_lastinc;
  uint32_t t_ts_offset;
  uint32_t curr_rtt_hist[4];
  uint32_t curr_rtt_min;
  uint32_t curr_rtt_index;
  tcp_seq rcv_high;
  uint32_t tsv_high;
  tcp_rledbat_state t_rlstate;
  uint32_t rcv_srtt;
  uint32_t rcv_rtt_est_ts;
  uint32_t rcv_rtt_est_seq;
  uuid_t_1 t_fsw_uuid;
  uuid_t_1 t_flow_uuid;
};

/* 10877 */
struct net_port_entry_list
{
  net_port_entry *slh_first;
};

/* 10878 */
struct __attribute__((aligned(4))) net_port_info_wake_event
{
  uuid_t_1 wake_uuid;
  timeval32 wake_pkt_timestamp;
  uint16_t wake_pkt_if_index;
  in_port_t wake_pkt_port;
  uint16_t wake_pkt_flags;
  pid_t wake_pkt_owner_pid;
  pid_t wake_pkt_effective_pid;
  char wake_pkt_owner_pname[17];
  char wake_pkt_effective_pname[17];
  uuid_t_1 wake_pkt_owner_uuid;
  uuid_t_1 wake_pkt_effective_uuid;
  in_port_t wake_pkt_foreign_port;
  in_addr_4_6 wake_pkt_local_addr_;
  in_addr_4_6 wake_pkt_foreign_addr_;
  char wake_pkt_ifname[16];
  uint32_t wake_pkt_total_len;
  uint32_t wake_pkt_data_len;
  uint16_t wake_pkt_control_flags;
};

/* 10879 */
struct if_ports_used_stats
{
  uint64_t ifpu_wakeuid_gen;
  uint64_t ifpu_wakeuuid_not_set_count;
  uint64_t ifpu_npe_total;
  uint64_t ifpu_npe_count;
  uint64_t ifpu_npe_max;
  uint64_t ifpu_npe_dup;
  uint64_t ifpu_npi_hash_search_total;
  uint64_t ifpu_npi_hash_search_max;
  uint64_t ifpu_so_match_wake_pkt;
  uint64_t ifpu_ch_match_wake_pkt;
  uint64_t ifpu_ipv4_wake_pkt;
  uint64_t ifpu_ipv6_wake_pkt;
  uint64_t ifpu_tcp_wake_pkt;
  uint64_t ifpu_udp_wake_pkt;
  uint64_t ifpu_isakmp_natt_wake_pkt;
  uint64_t ifpu_esp_wake_pkt;
  uint64_t ifpu_bad_proto_wake_pkt;
  uint64_t ifpu_bad_family_wake_pkt;
  uint64_t ifpu_wake_pkt_event;
  uint64_t ifpu_dup_wake_pkt_event;
  uint64_t ifpu_wake_pkt_event_error;
  uint64_t ifpu_unattributed_wake_event;
  uint64_t ifpu_dup_unattributed_wake_event;
  uint64_t ifpu_unattributed_wake_event_error;
  uint64_t ifpu_unattributed_null_recvif;
  uint64_t ifpu_match_wake_pkt_no_flag;
  uint64_t ifpu_frag_wake_pkt;
  uint64_t ifpu_incomplete_tcp_hdr_pkt;
  uint64_t ifpu_incomplete_udp_hdr_pkt;
  uint64_t ifpu_npi_not_added_no_wakeuuid;
  uint64_t ifpu_deferred_isakmp_natt_wake_pkt;
};

/* 10880 */
struct ifnet_attach_proto_param_1
{
  ifnet_demux_desc *demux_array;
  u_int32_t demux_count;
  proto_media_input_0 input;
  proto_media_preout_0 pre_output;
  proto_media_event_0 event;
  proto_media_ioctl_0 ioctl;
  proto_media_detached_0 detached;
  proto_media_resolve_multi_0 resolve;
  proto_media_send_arp send_arp;
};

/* 10881 */
struct ifnet_attach_proto_param_2
{
  ifnet_demux_desc *demux_array;
  u_int32_t demux_count;
  proto_media_input input;
  proto_media_preout pre_output;
  proto_media_event event;
  proto_media_ioctl ioctl;
  proto_media_detached detached;
  proto_media_resolve_multi_0 resolve;
  proto_media_send_arp send_arp;
};

/* 10882 */
struct ip6protosw_0
{
  struct
  {
    ip6protosw *tqe_next;
    ip6protosw **tqe_prev;
  } pr_entry;
  domain *pr_domain;
  protosw *pr_protosw;
  u_int16_t pr_type;
  u_int16_t pr_protocol;
  u_int32_t pr_flags;
  int (*pr_input)(mbuf **, int *, int);
  int (*pr_output)(mbuf *, socket *, sockaddr_in6 *, mbuf *);
  void (*pr_ctlinput)(int, sockaddr *, void *, ifnet *);
  int (*pr_ctloutput)(socket *, sockopt *);
  pr_usrreqs *pr_usrreqs;
  void (*pr_init)(ip6protosw *, domain *);
  void (*pr_drain)(void);
  int (*pr_sysctl)(void);
  int (*pr_lock)(socket *, int, void *);
  int (*pr_unlock)(socket *, int, void *);
  lck_mtx_t *(*pr_getlock)(socket *, int);
  struct
  {
    socket_filter *tqh_first;
    socket_filter **tqh_last;
  } pr_filter_head;
  protosw_old *pr_old;
  void (*pr_update_last_owner)(socket *, proc *, proc *);
  void (*pr_copy_last_owner)(socket *, socket *);
};

/* 10883 */
struct gifhead
{
  gif_softc *tqh_first;
  gif_softc **tqh_last;
};

/* 10884 */
struct tcpprobereq
{
  u_int64_t ifindex;
  u_int64_t enable;
  u_int64_t filter_flags;
  u_int32_t reserved;
  u_int32_t reserved2;
};

/* 10885 */
struct tcpprogressreq
{
  u_int64_t ifindex;
  u_int64_t recentflow_maxduration;
  u_int64_t filter_flags;
  u_int64_t xp_reserved2;
};

/* 10886 */
struct nstat_msg_error
{
  nstat_msg_hdr hdr;
  u_int32_t error;
  u_int8_t reserved[4];
};

/* 10887 */
typedef nstat_msg_query_src nstat_msg_query_src_req;

/* 10888 */
struct tailq_head_generic_shadow
{
  nstat_generic_shadow *tqh_first;
  nstat_generic_shadow **tqh_last;
};

/* 10889 */
struct tailq_head_tu_shadow
{
  nstat_tu_shadow *tqh_first;
  nstat_tu_shadow **tqh_last;
};

/* 10890 */
struct tailq_head_procdetails
{
  nstat_procdetails *tqh_first;
  nstat_procdetails **tqh_last;
};

/* 10891 */
struct nstat_stats
{
  u_int32_t nstat_successmsgfailures;
  u_int32_t nstat_sendcountfailures;
  u_int32_t nstat_sysinfofailures;
  u_int32_t nstat_srcupatefailures;
  u_int32_t nstat_descriptionfailures;
  u_int32_t nstat_msgremovedfailures;
  u_int32_t nstat_srcaddedfailures;
  u_int32_t nstat_msgerrorfailures;
  u_int32_t nstat_copy_descriptor_failures;
  u_int32_t nstat_provider_counts_failures;
  u_int32_t nstat_control_send_description_failures;
  u_int32_t nstat_control_send_goodbye_failures;
  u_int32_t nstat_flush_accumulated_msgs_failures;
  u_int32_t nstat_accumulate_msg_failures;
  u_int32_t nstat_control_cleanup_source_failures;
  u_int32_t nstat_handle_msg_failures;
};

/* 10892 */
struct netsrc_repv1
{
  union
  {
    sockaddr_in_4_6 nrp_src;
    sockaddr_in_4_6 _usa;
  };
  uint16_t nrp_flags;
  uint16_t nrp_label;
  uint16_t nrp_precedence;
  uint16_t nrp_dstlabel;
  uint16_t nrp_dstprecedence;
  uint16_t nrp_unused;
};

/* 10893 */
struct walkarg_0
{
  int w_tmemsize;
  int w_op;
  int w_arg;
  caddr_t w_tmem;
  sysctl_req_0 *w_req;
};

/* 10894 */
struct route_cb
{
  u_int32_t ip_count;
  u_int32_t ip6_count;
  u_int32_t any_count;
};

/* 10895 */
struct rtstat
{
  short rts_badredirect;
  short rts_dynamic;
  short rts_newgateway;
  short rts_unreach;
  short rts_wildcard;
  short rts_badrtgwroute;
};

/* 10896 */
struct rawcb_list_head
{
  rawcb *lh_first;
};

/* 10897 */
struct ndrv_protocol_desc64
{
  u_int32_t version;
  u_int32_t protocol_family;
  u_int32_t demux_count;
  user64_addr_t demux_array;
};

/* 10898 */
struct ndrv_protocol_desc32
{
  u_int32_t version;
  u_int32_t protocol_family;
  u_int32_t demux_count;
  user32_addr_t demux_array;
};

/* 10899 */
struct ndrv_protocol_desc
{
  u_int32_t version;
  u_int32_t protocol_family;
  u_int32_t demux_count;
  ndrv_demux_desc *demux_array;
};

/* 10900 */
struct pr_usrreqs_0
{
  uint32_t pru_flags;
  int (*pru_abort)(socket *);
  int (*pru_accept)(socket *, sockaddr **);
  int (*pru_attach)(socket *, int, proc *);
  int (*pru_bind)(socket *, sockaddr *, proc *);
  int (*pru_connect)(socket *, sockaddr *, proc *);
  int (*pru_connect2)(socket *, socket *);
  int (*pru_connectx)(socket *, sockaddr *, sockaddr *, proc *, uint32_t, sae_associd_t, sae_connid_t *, uint32_t, void *, uint32_t, uio *, user_ssize_t *);
  int (*pru_control)(socket *, u_long, caddr_t, ifnet *, proc *);
  int (*pru_detach)(socket *);
  int (*pru_disconnect)(socket *);
  int (*pru_disconnectx)(socket *, sae_associd_t, sae_connid_t);
  int (*pru_listen)(socket *, proc *);
  int (*pru_peeraddr)(socket *, sockaddr **);
  int (*pru_rcvd)(socket *, int);
  int (*pru_rcvoob)(socket *, mbuf *, int);
  int (*pru_send)(socket *, int, mbuf *, sockaddr *, mbuf *, proc *);
  int (*pru_send_list)(socket *, int, mbuf *, sockaddr *, mbuf *, proc *);
  int (*pru_sense)(socket *, void *, int);
  int (*pru_shutdown)(socket *);
  int (*pru_sockaddr)(socket *, sockaddr **);
  int (*pru_sopoll)(socket *, int, ucred *, void *);
  int (*pru_soreceive)(socket *, sockaddr **, uio *, mbuf **, mbuf **, int *);
  int (*pru_soreceive_list)(socket *, recv_msg_elem *, u_int, int *);
  int (*pru_sosend)(socket *, sockaddr *, uio *, mbuf *, mbuf *, int);
  int (*pru_sosend_list)(socket *, uio **, u_int, int);
  int (*pru_socheckopt)(socket *, sockopt *);
  int (*pru_preconnect)(socket *);
  int (*pru_defunct)(socket *);
};

/* 10901 */
struct iff_filter_1
{
  void *iff_cookie;
  const char *iff_name;
  protocol_family_t iff_protocol;
  iff_input_func iff_input;
  iff_output_func iff_output;
  iff_event_func_0 iff_event;
  iff_ioctl_func_0 iff_ioctl;
  iff_detached_func_0 iff_detached;
};

/* 10902 */
struct ifnet_attach_proto_param_3
{
  ifnet_demux_desc *demux_array;
  u_int32_t demux_count;
  proto_media_input_1 input;
  proto_media_preout pre_output;
  proto_media_event_0 event;
  proto_media_ioctl_0 ioctl;
  proto_media_detached_0 detached;
  proto_media_resolve_multi resolve;
  proto_media_send_arp send_arp;
};

/* 10903 */
struct if_bond_status
{
  char ibs_if_name[16];
  lacp_port_priority ibs_port_priority;
  lacp_actor_partner_state ibs_state;
  u_char ibs_selected_state;
  if_bond_partner_state ibs_partner_state;
  u_int32_t ibs_reserved[8];
};

/* 10904 */
typedef LAG_info_s *LAG_info_ref;

/* 10905 */
typedef partner_state_s *partner_state_ref;

/* 10906 */
typedef lacp_collector_tlv_s *lacp_collector_tlv_ref;

/* 10907 */
typedef la_marker_pdu_s *la_marker_pdu_ref;

/* 10908 */
struct ifnet_13
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func_0 if_output_dlil;
  volatile ifnet_start_func if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func if_input_ctl;
  ifnet_ioctl_func if_ioctl;
  ifnet_set_bpf_tap if_set_bpf_tap;
  ifnet_detached_func if_free;
  ifnet_demux_func_0 if_demux;
  ifnet_event_func_1 if_event;
  ifnet_framer_func_1 if_framer_legacy;
  ifnet_framer_extended_func_0 if_framer;
  ifnet_add_proto_func if_add_proto;
  ifnet_del_proto_func if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route if_fwd_route;
  route if_src_route;
  route_in6 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 10909 */
union ifdrvu
{
  ifdrv32 *ifdrvu_32;
  ifdrv64 *ifdrvu_64;
  void *ifdrvu_p;
};

/* 10910 */
typedef struct *fake_nx_t;

/* 10911 */
struct kern_nexus_netif_llink_init_0
{
  uint32_t nli_flags;
  uint8_t nli_num_qsets;
  void *nli_ctx;
  kern_nexus_netif_llink_id_t nli_link_id;
  kern_nexus_netif_llink_qset_init *nli_qsets;
};

/* 10912 */
struct kern_nexus_domain_provider_2
{
  struct
  {
    kern_nexus_domain_provider *stqe_next;
  } nxdom_prov_link;
  struct
  {
    kern_nexus_domain_provider *stqe_next;
  } nxdom_prov_detaching_link;
  char nxdom_prov_name[64];
  uuid_t_1 nxdom_prov_uuid;
  uint64_t nxdom_prov_gencnt;
  uint32_t nxdom_prov_refcnt;
  uint32_t nxdom_prov_flags;
  nxdom *nxdom_prov_dom;
  kern_nexus_domain_provider_init_1 nxdom_prov_ext;
  nxdom_prov_cb_0 nxdom_prov_cb;
};

/* 10913 */
struct vlanreq
{
  char vlr_parent[16];
  u_short vlr_tag;
};

/* 10914 */
struct __attribute__((packed)) __attribute__((aligned(4))) ifmibdata
{
  char ifmd_name[16];
  unsigned int ifmd_pcount;
  unsigned int ifmd_flags;
  unsigned int ifmd_snd_len;
  unsigned int ifmd_snd_maxlen;
  unsigned int ifmd_snd_drops;
  unsigned int ifmd_filler[4];
  if_data64 ifmd_data;
};

/* 10915 */
struct ifnet_attach_proto_param_v2_0
{
  ifnet_demux_desc *demux_array;
  u_int32_t demux_count;
  proto_media_input_v2 input;
  proto_media_preout pre_output;
  proto_media_event_0 event;
  proto_media_ioctl_0 ioctl;
  proto_media_detached_0 detached;
  proto_media_resolve_multi_0 resolve;
  proto_media_send_arp send_arp;
};

/* 10916 */
struct ifnet_attach_proto_param_4
{
  ifnet_demux_desc *demux_array;
  u_int32_t demux_count;
  proto_media_input_1 input;
  proto_media_preout pre_output;
  proto_media_event_0 event;
  proto_media_ioctl_0 ioctl;
  proto_media_detached_0 detached;
  proto_media_resolve_multi_0 resolve;
  proto_media_send_arp send_arp;
};

/* 10917 */
struct ifnet_attach_proto_param_v2_1
{
  ifnet_demux_desc *demux_array;
  u_int32_t demux_count;
  proto_media_input_v2 input;
  proto_media_preout pre_output;
  proto_media_event_0 event;
  proto_media_ioctl_0 ioctl;
  proto_media_detached_0 detached;
  proto_media_resolve_multi resolve;
  proto_media_send_arp send_arp;
};

/* 10918 */
struct ifnet_log_params
{
  ifnet_log_level_t level;
  ifnet_log_flags_t flags;
  ifnet_log_category_t category;
  ifnet_log_subcategory_t subcategory;
};

/* 10919 */
struct __attribute__((aligned(8))) kev_dl_issues
{
  net_event_data link_data;
  u_int8_t modid[20];
  u_int64_t timestamp;
  u_int8_t info[12];
};

/* 10920 */
struct kev_dl_node_absence
{
  net_event_data link_data;
  sockaddr_in6 sin6_node_address;
  sockaddr_dl sdl_node_address;
};

/* 10921 */
struct kev_dl_node_presence
{
  net_event_data link_data;
  sockaddr_in6 sin6_node_address;
  sockaddr_dl sdl_node_address;
  int32_t rssi;
  int link_quality_metric;
  int node_proximity_metric;
  u_int8_t node_service_info[48];
};

/* 10922 */
struct kev_dl_link_quality_metric_data
{
  net_event_data link_data;
  int link_quality_metric;
};

/* 10923 */
typedef ifaddr *ifaddr_t_0;

/* 10924 */
struct kev_dl_proto_data
{
  net_event_data link_data;
  u_int32_t proto_family;
  u_int32_t proto_remaining_count;
};

/* 10925 */
struct ifnet_notify_address_params
{
  sa_family_t address_family;
  u_int32_t reserved[3];
};

/* 10926 */
struct kev_dl_rrc_state
{
  net_event_data link_data;
  u_int32_t rrc_state;
};

/* 10927 */
struct ifnet_flowhash_key
{
  char ifk_name[16];
  uint32_t ifk_unit;
  uint32_t ifk_flags;
  uint32_t ifk_eflags;
  uint32_t ifk_capabilities;
  uint32_t ifk_capenable;
  uint32_t ifk_output_sched_model;
  uint32_t ifk_rand1;
  uint32_t ifk_rand2;
};

/* 10928 */
struct nd_defrouter_1
{
  lck_mtx_t nddr_lock;
  lck_mtx_t nddr_ref_lock;
  struct
  {
    nd_defrouter *tqe_next;
    nd_defrouter **tqe_prev;
  } dr_entry;
  in6_addr_0 rtaddr;
  u_int32_t nddr_refcount;
  u_int32_t nddr_debug;
  u_int64_t expire;
  u_int64_t base_calendartime;
  u_int64_t base_uptime;
  u_char flags;
  u_char stateflags;
  u_int32_t rtlifetime;
  int err;
  ifnet *ifp;
  in6_addr_0 rtaddr_mapped;
  boolean_t is_reachable;
  void (*nddr_trace)(nd_defrouter *, int);
};

/* 10929 */
struct nd_prefix_1
{
  lck_mtx_t ndpr_lock;
  lck_mtx_t ndpr_ref_lock;
  u_int32_t ndpr_refcount;
  u_int32_t ndpr_debug;
  ifnet *ndpr_ifp;
  rtentry *ndpr_rt;
  struct
  {
    nd_prefix *le_next;
    nd_prefix **le_prev;
  } ndpr_entry;
  sockaddr_in6 ndpr_prefix;
  in6_addr_0 ndpr_mask;
  in6_addr_0 ndpr_addr;
  u_int32_t ndpr_vltime;
  u_int32_t ndpr_pltime;
  u_int64_t ndpr_preferred;
  u_int64_t ndpr_expire;
  u_int64_t ndpr_lastupdate;
  u_int64_t ndpr_base_calendartime;
  u_int64_t ndpr_base_uptime;
  prf_ra ndpr_flags;
  unsigned int ndpr_genid;
  u_int32_t ndpr_stateflags;
  pr_rtrhead ndpr_advrtrs;
  u_char ndpr_plen;
  int ndpr_addrcnt;
  int ndpr_manual_addrcnt;
  u_int32_t ndpr_allmulti_cnt;
  u_int32_t ndpr_prproxy_sols_cnt;
  prproxy_sols_tree ndpr_prproxy_sols;
  void (*ndpr_trace)(nd_prefix *, int);
};

/* 10930 */
typedef thread_affinity_policy thread_affinity_policy_data_t;

/* 10931 */
struct in6_multi_3
{
  lck_mtx_t in6m_lock;
  u_int32_t in6m_refcount;
  u_int32_t in6m_reqcnt;
  u_int32_t in6m_debug;
  struct
  {
    in6_multi *le_next;
    in6_multi **le_prev;
  } in6m_entry;
  in6_addr_0 in6m_addr;
  uint32_t ifscope;
  ifnet *in6m_ifp;
  ifmultiaddr *in6m_ifma;
  u_int in6m_state;
  u_int in6m_timer;
  mld_ifinfo *in6m_mli;
  struct
  {
    in6_multi *sle_next;
  } in6m_dtle;
  struct
  {
    in6_multi *sle_next;
  } in6m_nrele;
  u_int32_t in6m_nrelecnt;
  ip6_msource_tree in6m_srcs;
  u_long in6m_nsrc;
  ifqueue in6m_scq;
  timeval in6m_lastgsrtv;
  uint16_t in6m_sctimer;
  uint16_t in6m_scrv;
  in6m_st in6m_st[2];
  void (*in6m_trace)(in6_multi *, int);
};

/* 10932 */
struct mld_ifinfo_2
{
  lck_mtx_t mli_lock;
  uint32_t mli_refcnt;
  uint32_t mli_debug;
  struct
  {
    mld_ifinfo *le_next;
    mld_ifinfo **le_prev;
  } mli_link;
  ifnet *mli_ifp;
  uint32_t mli_version;
  uint32_t mli_v1_timer;
  uint32_t mli_v2_timer;
  uint32_t mli_flags;
  uint32_t mli_rv;
  uint32_t mli_qi;
  uint32_t mli_qri;
  uint32_t mli_uri;
  struct
  {
    in6_multi *slh_first;
  } mli_relinmhead;
  ifqueue mli_gq;
  ifqueue mli_v1q;
};

/* 10933 */
struct __attribute__((aligned(8))) if_llreach_1
{
  lck_mtx_t lr_lock;
  struct
  {
    if_llreach *rbe_left;
    if_llreach *rbe_right;
    if_llreach *rbe_parent;
  } lr_link;
  ifnet *lr_ifp;
  u_int32_t lr_refcnt;
  u_int32_t lr_reqcnt;
  u_int32_t lr_debug;
  u_int32_t lr_probes;
  u_int64_t lr_basecal;
  u_int64_t lr_baseup;
  u_int64_t lr_lastrcvd;
  u_int32_t lr_basereachable;
  u_int32_t lr_reachable;
  lr_key_s lr_key;
  int32_t lr_rssi;
  int32_t lr_lqm;
  int32_t lr_npm;
};

/* 10934 */
struct lltable_6
{
  struct
  {
    lltable *sle_next;
  } llt_link;
  int llt_af;
  int llt_hsize;
  llentries *lle_head;
  ifnet *llt_ifp;
  llt_lookup_t *llt_lookup;
  llt_alloc_t *llt_alloc_entry;
  llt_delete_t *llt_delete_entry;
  llt_prefix_free_t *llt_prefix_free;
  llt_dump_entry_t *llt_dump_entry;
  llt_hash_t *llt_hash;
  llt_match_prefix_t *llt_match_prefix;
  llt_free_entry_t *llt_free_entry;
  llt_foreach_entry_t *llt_foreach_entry;
  llt_link_entry_t *llt_link_entry;
  llt_unlink_entry_t *llt_unlink_entry;
  llt_fill_sa_entry_t *llt_fill_sa_entry;
};

/* 10935 */
struct __attribute__((aligned(8))) nx_netif_mit_3
{
  lck_spin_t mit_lock;
  volatile __kern_channel_ring *mit_ckr;
  uint32_t mit_flags;
  uint32_t mit_requests;
  uint32_t mit_interval;
  uint32_t mit_cfg_idx_max;
  uint32_t mit_cfg_idx;
  const mit_cfg_tbl *mit_cfg;
  mit_mode_t mit_mode;
  uint32_t mit_packets_avg;
  uint32_t mit_packets_min;
  uint32_t mit_packets_max;
  uint32_t mit_bytes_avg;
  uint32_t mit_bytes_min;
  uint32_t mit_bytes_max;
  pktcntr mit_sstats;
  timespec mit_mode_holdtime;
  timespec mit_mode_lasttime;
  timespec mit_sample_time;
  timespec mit_sample_lasttime;
  timespec mit_start_time;
  thread *mit_thread;
  char mit_name[64];
  const ifnet *mit_netif_ifp;
  mit_cfg_tbl mit_tbl[5];
};

/* 10936 */
struct skmem_arena_0
{
  lck_mtx_t ar_lock;
  uint32_t ar_refcnt;
  struct
  {
    skmem_arena *tqe_next;
    skmem_arena **tqe_prev;
  } ar_link;
  char ar_name[64];
  skmem_arena_type_t ar_type;
  uint32_t ar_flags;
  size_t ar_zsize;
  IOSKArenaRef ar_ar;
  skmem_region *ar_regions[28];
  mach_vm_size_t_0 ar_mapsize;
  uint32_t ar_mapcnt;
  uint32_t ar_maprdrcnt;
  struct
  {
    skmem_arena_mmap_info *slh_first;
  } ar_map_head;
};

/* 10937 */
struct flow_route_0
{
  struct
  {
    flow_route *rbe_left;
    flow_route *rbe_right;
    flow_route *rbe_parent;
  } fr_link;
  struct
  {
    flow_route *rbe_left;
    flow_route *rbe_right;
    flow_route *rbe_parent;
  } fr_id_link;
  sockaddr_in_4_6 fr_laddr;
  sockaddr_in_4_6 fr_faddr;
  sockaddr_in_4_6 fr_gaddr;
  flow_llhdr fr_llhdr;
  void *fr_addr_key;
  uuid_t_1 fr_uuid;
  lck_spin_t fr_reflock;
  uint64_t fr_expire;
  volatile uint32_t fr_usecnt;
  uint32_t fr_flags;
  uint32_t fr_laddr_gencnt;
  uint32_t fr_addr_len;
  volatile uint32_t fr_want_configure;
  volatile uint32_t fr_want_probe;
  lck_mtx_t fr_lock;
  eventhandler_tag fr_rt_evhdlr_tag;
  rtentry *fr_rt_dst;
  rtentry *fr_rt_gw;
  uuid_t_1 fr_nx_uuid;
  const flow_mgr_0 *fr_mgr;
  const flow_route_bucket *fr_frb;
  const flow_route_id_bucket *fr_frib;
};

/* 10938 */
struct __attribute__((aligned(8))) nx_flowswitch_7
{
  lck_rw_t fsw_lock;
  uint32_t fsw_tx_rings;
  uint32_t fsw_rx_rings;
  kern_nexus *fsw_nx;
  classq_pkt_type_t fsw_classq_enq_ptype;
  boolean_t fsw_classq_enabled;
  pkt_copy_from_pkt_t *fsw_pkt_copy_from_pkt;
  pkt_copy_from_mbuf_t *fsw_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *fsw_pkt_copy_to_mbuf;
  uint8_t fsw_frame_headroom;
  uint32_t fsw_src_lla_gencnt;
  uint32_t fsw_pending_nonviable;
  uint32_t fsw_low_power_gencnt;
  flow_mgr *fsw_flow_mgr;
  netagent_session_t fsw_agent_session;
  uuid_t_1 fsw_agent_uuid;
  ifnet *fsw_ifp;
  nexus_adapter *fsw_nifna;
  uint32_t fsw_state_flags;
  union
  {
    uint64_t _buf[1];
    uint8_t _eth_src[6];
  } __fsw_slladdr;
  int (*fsw_resolve)(nx_flowswitch *, flow_route *, __kern_packet *);
  void (*fsw_frame)(nx_flowswitch *, flow_route *, __kern_packet *);
  sa_family_t (*fsw_demux)(nx_flowswitch *, __kern_packet *);
  fsw_stats fsw_stats;
  lck_mtx_t fsw_detach_barrier_lock;
  uint32_t fsw_detach_flags;
  uint32_t fsw_detach_barriers;
  uint32_t fsw_detach_waiters;
  uint32_t fsw_ifp_dlt;
  uint32_t fsw_rx_largest_size;
  void (*fsw_ctor)(nx_flowswitch *, flow_route *);
  __nx_stats_fsw *fsw_closed_na_stats;
  fsw_ip_frag_mgr *fsw_ipfm;
  skoid fsw_skoid;
  netem *fsw_input_netem;
  kern_channel *fsw_dev_ch;
  kern_channel *fsw_host_ch;
  lck_mtx_t fsw_reap_lock;
  uint32_t fsw_reap_flags;
  uint32_t fsw_reap_requests;
  thread *fsw_reap_thread;
  char fsw_reap_name[64];
  uint64_t fsw_reap_last;
  uint64_t fsw_drain_channel_chk_last;
  uint64_t fsw_drain_netif_chk_last;
  lck_mtx_t fsw_linger_lock;
  flow_entry_linger_head fsw_linger_head;
  uint32_t fsw_linger_cnt;
};

/* 10939 */
struct nx_netif_7
{
  lck_rw_t nif_lock;
  kern_nexus *nif_nx;
  nxbind *nif_dev_nxb;
  nxbind *nif_host_nxb;
  uuid_t_1 nif_uuid;
  netif_stats nif_stats;
  uint32_t nif_flags;
  os_refcnt nif_refcnt;
  lck_mtx_t nif_agent_lock;
  netif_agent_flow_head nif_agent_flow_list;
  uint32_t nif_agent_flow_cnt;
  uint32_t nif_agent_flags;
  netagent_session_t nif_agent_session;
  uuid_t_1 nif_agent_uuid;
  uint32_t nif_hwassist;
  uint32_t nif_capabilities;
  uint32_t nif_capenable;
  uint64_t nif_input_rate;
  ifnet *nif_ifp;
  nx_flowswitch *nif_fsw;
  sk_nexusadv *nif_fsw_nxadv;
  netif_nexus_advisory *nif_netif_nxadv;
  pkt_copy_from_mbuf_t *nif_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *nif_pkt_copy_to_mbuf;
  pkt_copy_from_pkt_t *nif_pkt_copy_from_pkt;
  lck_mtx_t nif_filter_lock;
  uint32_t nif_filter_flags;
  uint32_t nif_filter_vp_cnt;
  uint32_t nif_filter_cnt;
  kern_pbufpool *nif_filter_pp;
  netif_filter_head nif_filter_list;
  union
  {
    nx_mbq nif_tx_processed_mbq[4];
    nx_pktq nif_tx_processed_pktq[4];
  };
  lck_mtx_t nif_flow_lock;
  uint32_t nif_vp_cnt;
  uint32_t nif_flow_flags;
  uint32_t nif_flow_cnt;
  netif_flow_head nif_flow_list;
  netif_flowtable *nif_flow_table;
  kern_channel *nif_hw_ch;
  uint32_t nif_hw_ch_refcnt;
  lck_rw_t nif_llink_lock;
  kern_nexus_netif_llink_init *nif_default_llink_params;
  netif_llink *nif_default_llink;
  struct
  {
    netif_llink *stqh_first;
    netif_llink **stqh_last;
  } nif_llink_list;
  uint16_t nif_llink_cnt;
  uint32_t nif_extended_capabilities;
  kern_nexus_capab_interface_advisory_config_fn_t nif_intf_adv_config;
  void *nif_intf_adv_prov_ctx;
  netif_qset_extensions nif_qset_extensions;
};

/* 10940 */
struct nxdom_0
{
  struct
  {
    nxdom *stqe_next;
  } nxdom_link;
  struct
  {
    kern_nexus_domain_provider *stqh_first;
    kern_nexus_domain_provider **stqh_last;
  } nxdom_prov_head;
  nexus_type_t nxdom_type;
  nexus_meta_type_t nxdom_md_type;
  nexus_meta_subtype_t nxdom_md_subtype;
  uint32_t nxdom_flags;
  nxp_bounds nxdom_ports;
  nxp_bounds nxdom_tx_rings;
  nxp_bounds nxdom_rx_rings;
  nxp_bounds nxdom_tx_slots;
  nxp_bounds nxdom_rx_slots;
  nxp_bounds nxdom_buf_size;
  nxp_bounds nxdom_large_buf_size;
  nxp_bounds nxdom_meta_size;
  nxp_bounds nxdom_stats_size;
  nxp_bounds nxdom_pipes;
  nxp_bounds nxdom_extensions;
  nxp_bounds nxdom_mhints;
  nxp_bounds nxdom_flowadv_max;
  nxp_bounds nxdom_nexusadv_size;
  nxp_bounds nxdom_capabilities;
  nxp_bounds nxdom_qmap;
  nxp_bounds nxdom_max_frags;
  skmem_region_params_0 nxdom_region_params[28];
  const char *nxdom_name;
  void (*nxdom_init)(nxdom *);
  void (*nxdom_terminate)(nxdom *);
  void (*nxdom_fini)(nxdom *);
  int (*nxdom_find_port)(kern_nexus *, boolean_t, nexus_port_t *);
  boolean_t (*nxdom_port_is_reserved)(kern_nexus *, nexus_port_t);
  int (*nxdom_bind_port)(kern_nexus *, nexus_port_t *, nxbind *, void *);
  int (*nxdom_unbind_port)(kern_nexus *, nexus_port_t);
  int (*nxdom_connect)(kern_nexus_domain_provider *, kern_nexus *, kern_channel *, chreq *, kern_channel *, nxbind *, proc *);
  void (*nxdom_disconnect)(kern_nexus_domain_provider *, kern_nexus *, kern_channel *);
  void (*nxdom_defunct)(kern_nexus_domain_provider *, kern_nexus *, kern_channel *, proc *);
  void (*nxdom_defunct_finalize)(kern_nexus_domain_provider *, kern_nexus *, kern_channel *, boolean_t);
};

/* 10941 */
struct kern_nexus_domain_provider_3
{
  struct
  {
    kern_nexus_domain_provider *stqe_next;
  } nxdom_prov_link;
  struct
  {
    kern_nexus_domain_provider *stqe_next;
  } nxdom_prov_detaching_link;
  char nxdom_prov_name[64];
  uuid_t_1 nxdom_prov_uuid;
  uint64_t nxdom_prov_gencnt;
  uint32_t nxdom_prov_refcnt;
  uint32_t nxdom_prov_flags;
  nxdom *nxdom_prov_dom;
  kern_nexus_domain_provider_init nxdom_prov_ext;
  nxdom_prov_cb_1 nxdom_prov_cb;
};

/* 10942 */
struct kern_nexus_provider_5
{
  uint32_t nxprov_refcnt;
  uint32_t nxprov_flags;
  struct
  {
    kern_nexus_provider *stqe_next;
  } nxprov_link;
  struct
  {
    kern_nexus *stqh_first;
    kern_nexus **stqh_last;
  } nxprov_nx_head;
  uint32_t nxprov_nx_count;
  nxctl *nxprov_ctl;
  uuid_t_1 nxprov_uuid;
  kern_nexus_domain_provider *nxprov_dom_prov;
  union
  {
    kern_nexus_provider_init_0 nxprov_ext;
    kern_nexus_netif_provider_init_0 nxprov_netif_ext;
  };
  nxprov_params *nxprov_params;
  skmem_region_params_0 nxprov_region_params[28];
};

/* 10943 */
struct skmem_region_0
{
  lck_mtx_t skr_lock;
  uint64_t skr_meminuse;
  uint64_t skr_w_meminuse;
  uint64_t skr_memtotal;
  uint64_t skr_alloc;
  uint64_t skr_free;
  uint32_t skr_seginuse;
  uint32_t skr_rescale;
  skmem_region_params_0 skr_params;
  struct
  {
    skmem_region *tqe_next;
    skmem_region **tqe_prev;
  } skr_link;
  char skr_name[64];
  uuid_t_1 skr_uuid;
  uint32_t skr_mode;
  uint32_t skr_size;
  IOSKMemoryBufferSpec skr_bufspec;
  IOSKRegionSpec skr_regspec;
  IOSKRegionRef skr_reg;
  zone *skr_zreg;
  void *skr_private;
  skmem_cache *skr_cache[3];
  sksegment_ctor_fn_t skr_seg_ctor;
  sksegment_dtor_fn_t skr_seg_dtor;
  uint32_t skr_seg_objs;
  uint32_t skr_seg_bmap_len;
  bitmap_t *skr_seg_bmap;
  uint32_t skr_seg_free_cnt;
  uint32_t skr_hash_initial;
  uint32_t skr_hash_limit;
  uint32_t skr_hash_shift;
  uint32_t skr_hash_mask;
  sksegment_bkt *skr_hash_table;
  segfreehead skr_seg_free;
  segtfreehead skr_seg_tfree;
  uint32_t skr_seg_waiters;
  uint32_t skr_refcnt;
  skmem_region *skr_mirror;
};

/* 10944 */
struct pfi_kif_0
{
  char pfik_name[16];
  struct
  {
    pfi_kif *rbe_left;
    pfi_kif *rbe_right;
    pfi_kif *rbe_parent;
  } pfik_tree;
  u_int64_t pfik_packets[2][2][2];
  u_int64_t pfik_bytes[2][2][2];
  u_int64_t pfik_tzero;
  int pfik_flags;
  void *pfik_ah_cookie;
  ifnet *pfik_ifp;
  int pfik_states;
  int pfik_rules;
  struct
  {
    pfi_dynaddr *tqh_first;
    pfi_dynaddr **tqh_last;
  } pfik_dynaddrs;
};

/* 10945 */
struct igmp_ifinfo_3
{
  lck_mtx_t igi_lock;
  uint32_t igi_refcnt;
  uint32_t igi_debug;
  struct
  {
    igmp_ifinfo *le_next;
    igmp_ifinfo **le_prev;
  } igi_link;
  ifnet *igi_ifp;
  uint32_t igi_version;
  uint32_t igi_v1_timer;
  uint32_t igi_v2_timer;
  uint32_t igi_v3_timer;
  uint32_t igi_flags;
  uint32_t igi_rv;
  uint32_t igi_qi;
  uint32_t igi_qri;
  uint32_t igi_uri;
  struct
  {
    in_multi *slh_first;
  } igi_relinmhead;
  ifqueue igi_gq;
  ifqueue igi_v2q;
};

/* 10946 */
struct in_multi_5
{
  lck_mtx_t inm_lock;
  u_int32_t inm_refcount;
  u_int32_t inm_reqcnt;
  u_int32_t inm_debug;
  struct
  {
    in_multi *le_next;
    in_multi **le_prev;
  } inm_link;
  in_addr inm_addr;
  ifnet *inm_ifp;
  ifmultiaddr *inm_ifma;
  u_int inm_timer;
  u_int inm_state;
  void *inm_rti;
  igmp_ifinfo *inm_igi;
  struct
  {
    in_multi *sle_next;
  } inm_dtle;
  struct
  {
    in_multi *sle_next;
  } inm_nrele;
  u_int32_t inm_nrelecnt;
  ip_msource_tree inm_srcs;
  u_long inm_nsrc;
  ifqueue inm_scq;
  timeval inm_lastgsrtv;
  uint16_t inm_sctimer;
  uint16_t inm_scrv;
  inm_st inm_st[2];
  void (*inm_trace)(in_multi *, int);
};

/* 10947 */
struct ifmultiaddr_6
{
  lck_mtx_t ifma_lock;
  u_int32_t ifma_refcount;
  u_int32_t ifma_anoncnt;
  u_int32_t ifma_reqcnt;
  u_int32_t ifma_debug;
  u_int32_t ifma_flags;
  struct
  {
    ifmultiaddr *le_next;
    ifmultiaddr **le_prev;
  } ifma_link;
  sockaddr *ifma_addr;
  ifmultiaddr *ifma_ll;
  ifnet *ifma_ifp;
  void *ifma_protospec;
  void (*ifma_trace)(ifmultiaddr *, int);
};

/* 10948 */
struct ifclassq_5
{
  lck_mtx_t ifcq_lock;
  os_refcnt_t ifcq_refcnt;
  ifnet *ifcq_ifp;
  u_int32_t ifcq_len;
  u_int32_t ifcq_maxlen;
  pktcntr ifcq_xmitcnt;
  pktcntr ifcq_dropcnt;
  u_int32_t ifcq_type;
  u_int32_t ifcq_flags;
  u_int32_t ifcq_sflags;
  u_int32_t ifcq_target_qdelay;
  u_int32_t ifcq_bytes;
  u_int32_t ifcq_pkt_drop_limit;
  void *ifcq_disc;
  ifclassq_disc_slot ifcq_disc_slots[10];
  tb_regulator ifcq_tbr;
};

/* 10949 */
struct rtentry_8
{
  radix_node rt_nodes[2];
  lck_mtx_t rt_lock;
  uint32_t rt_refcnt;
  uint32_t rt_flags;
  uint32_t rt_genid;
  sockaddr *rt_gateway;
  ifnet *rt_ifp;
  ifaddr *rt_ifa;
  sockaddr *rt_genmask;
  void *rt_llinfo;
  void (*rt_llinfo_get_ri)(rtentry *, rt_reach_info *);
  void (*rt_llinfo_get_iflri)(rtentry *, ifnet_llreach_info *);
  void (*rt_llinfo_purge)(rtentry *);
  void (*rt_llinfo_free)(void *);
  void (*rt_llinfo_refresh)(rtentry *);
  rt_metrics rt_rmx;
  rtentry *rt_gwroute;
  rtentry *rt_parent;
  nstat_counts *rt_stats;
  void (*rt_if_ref_fn)(ifnet *, int);
  uint32_t *rt_tree_genid;
  uint64_t rt_expire;
  uint64_t base_calendartime;
  uint64_t base_uptime;
  u_int32_t rtt_hist[10];
  u_int32_t rtt_min;
  u_int32_t rtt_expire_ts;
  u_int8_t rtt_index;
  eventhandler_lists_ctxt rt_evhdlr_ctxt;
};

/* 10950 */
struct if_protolistreq64
{
  char ifpl_name[16];
  u_int32_t ifpl_count;
  u_int32_t ifpl_reserved;
  user64_addr_t ifpl_list;
};

/* 10951 */
struct if_protolistreq32
{
  char ifpl_name[16];
  u_int32_t ifpl_count;
  u_int32_t ifpl_reserved;
  user32_addr_t ifpl_list;
};

/* 10952 */
struct if_clonereq64
{
  int ifcr_total;
  int ifcr_count;
  user64_addr_t ifcru_buffer;
};

/* 10953 */
struct if_clonereq32
{
  int ifcr_total;
  int ifcr_count;
  user32_addr_t ifcru_buffer;
};

/* 10954 */
struct ifconf32
{
  int ifc_len;
  struct
  {
    user32_addr_t ifcu_req;
  } ifc_ifcu;
};

/* 10955 */
struct __attribute__((packed)) __attribute__((aligned(4))) ifconf64
{
  int ifc_len;
  struct
  {
    user64_addr_t ifcu_req;
  } ifc_ifcu;
};

/* 10956 */
struct pr_usrreqs_1
{
  uint32_t pru_flags;
  int (*pru_abort)(socket *);
  int (*pru_accept)(socket *, sockaddr **);
  int (*pru_attach)(socket *, int, proc *);
  int (*pru_bind)(socket *, sockaddr *, proc *);
  int (*pru_connect)(socket *, sockaddr *, proc *);
  int (*pru_connect2)(socket *, socket *);
  int (*pru_connectx)(socket *, sockaddr *, sockaddr *, proc *, uint32_t, sae_associd_t, sae_connid_t *, uint32_t, void *, uint32_t, uio *, user_ssize_t *);
  int (*pru_control)(socket *, u_long, caddr_t, ifnet *, proc *);
  int (*pru_detach)(socket *);
  int (*pru_disconnect)(socket *);
  int (*pru_disconnectx)(socket *, sae_associd_t, sae_connid_t);
  int (*pru_listen)(socket *, proc *);
  int (*pru_peeraddr)(socket *, sockaddr **);
  int (*pru_rcvd)(socket *, int);
  int (*pru_rcvoob)(socket *, mbuf *, int);
  int (*pru_send)(socket *, int, mbuf *, sockaddr *, mbuf *, proc *);
  int (*pru_send_list)(socket *, int, mbuf *, sockaddr *, mbuf *, proc *);
  int (*pru_sense)(socket *, void *, int);
  int (*pru_shutdown)(socket *);
  int (*pru_sockaddr)(socket *, sockaddr **);
  int (*pru_sopoll)(socket *, int, ucred *, void *);
  int (*pru_soreceive)(socket *, sockaddr **, uio *, mbuf **, mbuf **, int *);
  int (*pru_soreceive_list)(socket *, recv_msg_elem *, u_int, int *);
  int (*pru_sosend)(socket *, sockaddr *, uio *, mbuf *, mbuf *, int);
  int (*pru_sosend_list)(socket *, uio **, u_int, int);
  int (*pru_socheckopt)(socket *, sockopt *);
  int (*pru_preconnect)(socket *);
  int (*pru_defunct)(socket *);
};

/* 10957 */
struct in6_multi_4
{
  lck_mtx_t in6m_lock;
  u_int32_t in6m_refcount;
  u_int32_t in6m_reqcnt;
  u_int32_t in6m_debug;
  struct
  {
    in6_multi *le_next;
    in6_multi **le_prev;
  } in6m_entry;
  in6_addr_0 in6m_addr;
  uint32_t ifscope;
  ifnet *in6m_ifp;
  ifmultiaddr *in6m_ifma;
  u_int in6m_state;
  u_int in6m_timer;
  mld_ifinfo *in6m_mli;
  struct
  {
    in6_multi *sle_next;
  } in6m_dtle;
  struct
  {
    in6_multi *sle_next;
  } in6m_nrele;
  u_int32_t in6m_nrelecnt;
  ip6_msource_tree in6m_srcs;
  u_long in6m_nsrc;
  ifqueue in6m_scq;
  timeval in6m_lastgsrtv;
  uint16_t in6m_sctimer;
  uint16_t in6m_scrv;
  in6m_st in6m_st[2];
  void (*in6m_trace)(in6_multi *, int);
};

/* 10958 */
struct nd_defrouter_2
{
  lck_mtx_t nddr_lock;
  lck_mtx_t nddr_ref_lock;
  struct
  {
    nd_defrouter *tqe_next;
    nd_defrouter **tqe_prev;
  } dr_entry;
  in6_addr_0 rtaddr;
  u_int32_t nddr_refcount;
  u_int32_t nddr_debug;
  u_int64_t expire;
  u_int64_t base_calendartime;
  u_int64_t base_uptime;
  u_char flags;
  u_char stateflags;
  u_int32_t rtlifetime;
  int err;
  ifnet *ifp;
  in6_addr_0 rtaddr_mapped;
  boolean_t is_reachable;
  void (*nddr_trace)(nd_defrouter *, int);
};

/* 10959 */
struct nd_prefix_2
{
  lck_mtx_t ndpr_lock;
  lck_mtx_t ndpr_ref_lock;
  u_int32_t ndpr_refcount;
  u_int32_t ndpr_debug;
  ifnet *ndpr_ifp;
  rtentry *ndpr_rt;
  struct
  {
    nd_prefix *le_next;
    nd_prefix **le_prev;
  } ndpr_entry;
  sockaddr_in6 ndpr_prefix;
  in6_addr_0 ndpr_mask;
  in6_addr_0 ndpr_addr;
  u_int32_t ndpr_vltime;
  u_int32_t ndpr_pltime;
  u_int64_t ndpr_preferred;
  u_int64_t ndpr_expire;
  u_int64_t ndpr_lastupdate;
  u_int64_t ndpr_base_calendartime;
  u_int64_t ndpr_base_uptime;
  prf_ra ndpr_flags;
  unsigned int ndpr_genid;
  u_int32_t ndpr_stateflags;
  pr_rtrhead ndpr_advrtrs;
  u_char ndpr_plen;
  int ndpr_addrcnt;
  int ndpr_manual_addrcnt;
  u_int32_t ndpr_allmulti_cnt;
  u_int32_t ndpr_prproxy_sols_cnt;
  prproxy_sols_tree ndpr_prproxy_sols;
  void (*ndpr_trace)(nd_prefix *, int);
};

/* 10960 */
struct lltable_7
{
  struct
  {
    lltable *sle_next;
  } llt_link;
  int llt_af;
  int llt_hsize;
  llentries *lle_head;
  ifnet *llt_ifp;
  llt_lookup_t *llt_lookup;
  llt_alloc_t *llt_alloc_entry;
  llt_delete_t *llt_delete_entry;
  llt_prefix_free_t *llt_prefix_free;
  llt_dump_entry_t *llt_dump_entry;
  llt_hash_t *llt_hash;
  llt_match_prefix_t *llt_match_prefix;
  llt_free_entry_t *llt_free_entry;
  llt_foreach_entry_t *llt_foreach_entry;
  llt_link_entry_t *llt_link_entry;
  llt_unlink_entry_t *llt_unlink_entry;
  llt_fill_sa_entry_t *llt_fill_sa_entry;
};

/* 10961 */
struct __attribute__((aligned(8))) nx_netif_mit_4
{
  lck_spin_t mit_lock;
  volatile __kern_channel_ring *mit_ckr;
  uint32_t mit_flags;
  uint32_t mit_requests;
  uint32_t mit_interval;
  uint32_t mit_cfg_idx_max;
  uint32_t mit_cfg_idx;
  const mit_cfg_tbl *mit_cfg;
  mit_mode_t mit_mode;
  uint32_t mit_packets_avg;
  uint32_t mit_packets_min;
  uint32_t mit_packets_max;
  uint32_t mit_bytes_avg;
  uint32_t mit_bytes_min;
  uint32_t mit_bytes_max;
  pktcntr mit_sstats;
  timespec mit_mode_holdtime;
  timespec mit_mode_lasttime;
  timespec mit_sample_time;
  timespec mit_sample_lasttime;
  timespec mit_start_time;
  thread *mit_thread;
  char mit_name[64];
  const ifnet *mit_netif_ifp;
  mit_cfg_tbl mit_tbl[5];
};

/* 10962 */
struct nx_netif_8
{
  lck_rw_t nif_lock;
  kern_nexus *nif_nx;
  nxbind *nif_dev_nxb;
  nxbind *nif_host_nxb;
  uuid_t_1 nif_uuid;
  netif_stats nif_stats;
  uint32_t nif_flags;
  os_refcnt nif_refcnt;
  lck_mtx_t nif_agent_lock;
  netif_agent_flow_head nif_agent_flow_list;
  uint32_t nif_agent_flow_cnt;
  uint32_t nif_agent_flags;
  netagent_session_t nif_agent_session;
  uuid_t_1 nif_agent_uuid;
  uint32_t nif_hwassist;
  uint32_t nif_capabilities;
  uint32_t nif_capenable;
  uint64_t nif_input_rate;
  ifnet *nif_ifp;
  nx_flowswitch *nif_fsw;
  sk_nexusadv *nif_fsw_nxadv;
  netif_nexus_advisory *nif_netif_nxadv;
  pkt_copy_from_mbuf_t *nif_pkt_copy_from_mbuf;
  pkt_copy_to_mbuf_t *nif_pkt_copy_to_mbuf;
  pkt_copy_from_pkt_t *nif_pkt_copy_from_pkt;
  lck_mtx_t nif_filter_lock;
  uint32_t nif_filter_flags;
  uint32_t nif_filter_vp_cnt;
  uint32_t nif_filter_cnt;
  kern_pbufpool *nif_filter_pp;
  netif_filter_head nif_filter_list;
  union
  {
    nx_mbq nif_tx_processed_mbq[4];
    nx_pktq nif_tx_processed_pktq[4];
  };
  lck_mtx_t nif_flow_lock;
  uint32_t nif_vp_cnt;
  uint32_t nif_flow_flags;
  uint32_t nif_flow_cnt;
  netif_flow_head nif_flow_list;
  netif_flowtable *nif_flow_table;
  kern_channel *nif_hw_ch;
  uint32_t nif_hw_ch_refcnt;
  lck_rw_t nif_llink_lock;
  kern_nexus_netif_llink_init *nif_default_llink_params;
  netif_llink *nif_default_llink;
  struct
  {
    netif_llink *stqh_first;
    netif_llink **stqh_last;
  } nif_llink_list;
  uint16_t nif_llink_cnt;
  uint32_t nif_extended_capabilities;
  kern_nexus_capab_interface_advisory_config_fn_t nif_intf_adv_config;
  void *nif_intf_adv_prov_ctx;
  netif_qset_extensions nif_qset_extensions;
};

/* 10963 */
struct dlil_threading_info_4
{
  lck_mtx_t dlth_lock;
  class_queue_t dlth_pkts;
  ifnet *dlth_ifp;
  ifnet_stat_increment_param dlth_stats;
  uint32_t dlth_flags;
  uint32_t dlth_wtot;
  errno_t (*dlth_strategy)(dlil_threading_info *, ifnet *, mbuf *, mbuf *, const ifnet_stat_increment_param *, boolean_t, thread *);
  boolean_t dlth_affinity;
  uint32_t dlth_affinity_tag;
  thread *dlth_thread;
  thread *dlth_driver_thread;
  thread *dlth_poller_thread;
  lck_grp_t *dlth_lock_grp;
  char dlth_name[32];
  uint64_t dlth_pkts_cnt;
};

/* 10964 */
struct in_multi_6
{
  lck_mtx_t inm_lock;
  u_int32_t inm_refcount;
  u_int32_t inm_reqcnt;
  u_int32_t inm_debug;
  struct
  {
    in_multi *le_next;
    in_multi **le_prev;
  } inm_link;
  in_addr inm_addr;
  ifnet *inm_ifp;
  ifmultiaddr *inm_ifma;
  u_int inm_timer;
  u_int inm_state;
  void *inm_rti;
  igmp_ifinfo *inm_igi;
  struct
  {
    in_multi *sle_next;
  } inm_dtle;
  struct
  {
    in_multi *sle_next;
  } inm_nrele;
  u_int32_t inm_nrelecnt;
  ip_msource_tree inm_srcs;
  u_long inm_nsrc;
  ifqueue inm_scq;
  timeval inm_lastgsrtv;
  uint16_t inm_sctimer;
  uint16_t inm_scrv;
  inm_st inm_st[2];
  void (*inm_trace)(in_multi *, int);
};

/* 10965 */
struct ifclassq_6
{
  lck_mtx_t ifcq_lock;
  os_refcnt_t ifcq_refcnt;
  ifnet *ifcq_ifp;
  u_int32_t ifcq_len;
  u_int32_t ifcq_maxlen;
  pktcntr ifcq_xmitcnt;
  pktcntr ifcq_dropcnt;
  u_int32_t ifcq_type;
  u_int32_t ifcq_flags;
  u_int32_t ifcq_sflags;
  u_int32_t ifcq_target_qdelay;
  u_int32_t ifcq_bytes;
  u_int32_t ifcq_pkt_drop_limit;
  void *ifcq_disc;
  ifclassq_disc_slot ifcq_disc_slots[10];
  tb_regulator ifcq_tbr;
};

/* 10966 */
struct rtentry_9
{
  radix_node rt_nodes[2];
  lck_mtx_t rt_lock;
  uint32_t rt_refcnt;
  uint32_t rt_flags;
  uint32_t rt_genid;
  sockaddr *rt_gateway;
  ifnet *rt_ifp;
  ifaddr *rt_ifa;
  sockaddr *rt_genmask;
  void *rt_llinfo;
  void (*rt_llinfo_get_ri)(rtentry *, rt_reach_info *);
  void (*rt_llinfo_get_iflri)(rtentry *, ifnet_llreach_info *);
  void (*rt_llinfo_purge)(rtentry *);
  void (*rt_llinfo_free)(void *);
  void (*rt_llinfo_refresh)(rtentry *);
  rt_metrics rt_rmx;
  rtentry *rt_gwroute;
  rtentry *rt_parent;
  nstat_counts *rt_stats;
  void (*rt_if_ref_fn)(ifnet *, int);
  uint32_t *rt_tree_genid;
  uint64_t rt_expire;
  uint64_t base_calendartime;
  uint64_t base_uptime;
  u_int32_t rtt_hist[10];
  u_int32_t rtt_min;
  u_int32_t rtt_expire_ts;
  u_int8_t rtt_index;
  eventhandler_lists_ctxt rt_evhdlr_ctxt;
};

/* 10967 */
struct ifnethead
{
  ifnet *tqh_first;
  ifnet **tqh_last;
};

/* 10968 */
struct in6_multi_5
{
  lck_mtx_t in6m_lock;
  u_int32_t in6m_refcount;
  u_int32_t in6m_reqcnt;
  u_int32_t in6m_debug;
  struct
  {
    in6_multi *le_next;
    in6_multi **le_prev;
  } in6m_entry;
  in6_addr_0 in6m_addr;
  uint32_t ifscope;
  ifnet *in6m_ifp;
  ifmultiaddr *in6m_ifma;
  u_int in6m_state;
  u_int in6m_timer;
  mld_ifinfo *in6m_mli;
  struct
  {
    in6_multi *sle_next;
  } in6m_dtle;
  struct
  {
    in6_multi *sle_next;
  } in6m_nrele;
  u_int32_t in6m_nrelecnt;
  ip6_msource_tree in6m_srcs;
  u_long in6m_nsrc;
  ifqueue in6m_scq;
  timeval in6m_lastgsrtv;
  uint16_t in6m_sctimer;
  uint16_t in6m_scrv;
  in6m_st in6m_st[2];
  void (*in6m_trace)(in6_multi *, int);
};

/* 10969 */
struct ifbpstpreq
{
  uint8_t ifbp_portno;
  uint32_t ifbp_fwd_trans;
  uint32_t ifbp_design_cost;
  uint32_t ifbp_design_port;
  uint64_t ifbp_design_bridge;
  uint64_t ifbp_design_root;
};

/* 10970 */
struct ifbrmne
{
  char ifbmne_ifname[16];
  uint64_t ifbmne_expire;
  uint8_t ifbmne_mac[6];
  uint8_t ifbmne_reserved;
  uint8_t ifbmne_af;
  ifbrip ifbmne_ip;
};

/* 10971 */
struct kern_nexus_domain_provider_4
{
  struct
  {
    kern_nexus_domain_provider *stqe_next;
  } nxdom_prov_link;
  struct
  {
    kern_nexus_domain_provider *stqe_next;
  } nxdom_prov_detaching_link;
  char nxdom_prov_name[64];
  uuid_t_1 nxdom_prov_uuid;
  uint64_t nxdom_prov_gencnt;
  uint32_t nxdom_prov_refcnt;
  uint32_t nxdom_prov_flags;
  nxdom *nxdom_prov_dom;
  kern_nexus_domain_provider_init nxdom_prov_ext;
  nxdom_prov_cb_2 nxdom_prov_cb;
};

/* 10972 */
struct pfi_kif_1
{
  char pfik_name[16];
  struct
  {
    pfi_kif *rbe_left;
    pfi_kif *rbe_right;
    pfi_kif *rbe_parent;
  } pfik_tree;
  u_int64_t pfik_packets[2][2][2];
  u_int64_t pfik_bytes[2][2][2];
  u_int64_t pfik_tzero;
  int pfik_flags;
  void *pfik_ah_cookie;
  ifnet *pfik_ifp;
  int pfik_states;
  int pfik_rules;
  struct
  {
    pfi_dynaddr *tqh_first;
    pfi_dynaddr **tqh_last;
  } pfik_dynaddrs;
};

/* 10973 */
struct in_multi_7
{
  lck_mtx_t inm_lock;
  u_int32_t inm_refcount;
  u_int32_t inm_reqcnt;
  u_int32_t inm_debug;
  struct
  {
    in_multi *le_next;
    in_multi **le_prev;
  } inm_link;
  in_addr inm_addr;
  ifnet *inm_ifp;
  ifmultiaddr *inm_ifma;
  u_int inm_timer;
  u_int inm_state;
  void *inm_rti;
  igmp_ifinfo *inm_igi;
  struct
  {
    in_multi *sle_next;
  } inm_dtle;
  struct
  {
    in_multi *sle_next;
  } inm_nrele;
  u_int32_t inm_nrelecnt;
  ip_msource_tree inm_srcs;
  u_long inm_nsrc;
  ifqueue inm_scq;
  timeval inm_lastgsrtv;
  uint16_t inm_sctimer;
  uint16_t inm_scrv;
  inm_st inm_st[2];
  void (*inm_trace)(in_multi *, int);
};

/* 10974 */
struct ifmultiaddr_7
{
  lck_mtx_t ifma_lock;
  u_int32_t ifma_refcount;
  u_int32_t ifma_anoncnt;
  u_int32_t ifma_reqcnt;
  u_int32_t ifma_debug;
  u_int32_t ifma_flags;
  struct
  {
    ifmultiaddr *le_next;
    ifmultiaddr **le_prev;
  } ifma_link;
  sockaddr *ifma_addr;
  ifmultiaddr *ifma_ll;
  ifnet *ifma_ifp;
  void *ifma_protospec;
  void (*ifma_trace)(ifmultiaddr *, int);
};

/* 10975 */
struct bridge_hostfilter_stats
{
  uint64_t brhf_bad_ether_type;
  uint64_t brhf_bad_ether_srchw_addr;
  uint64_t brhf_ether_too_small;
  uint64_t brhf_ether_pullup_failed;
  uint64_t brhf_arp_ok;
  uint64_t brhf_arp_too_small;
  uint64_t brhf_arp_pullup_failed;
  uint64_t brhf_arp_bad_hw_type;
  uint64_t brhf_arp_bad_pro_type;
  uint64_t brhf_arp_bad_hw_len;
  uint64_t brhf_arp_bad_pro_len;
  uint64_t brhf_arp_bad_op;
  uint64_t brhf_arp_bad_sha;
  uint64_t brhf_arp_bad_spa;
  uint64_t brhf_ip_ok;
  uint64_t brhf_ip_too_small;
  uint64_t brhf_ip_pullup_failed;
  uint64_t brhf_ip_bad_srcaddr;
  uint64_t brhf_ip_bad_proto;
  uint64_t brhf_dhcp_too_small;
  uint64_t brhf_dhcp_bad_op;
  uint64_t brhf_dhcp_bad_htype;
  uint64_t brhf_dhcp_bad_hlen;
  uint64_t brhf_dhcp_bad_chaddr;
  uint64_t brhf_dhcp_bad_ciaddr;
};

/* 10976 */
struct pktap_header_buffer
{
  pktap_header pkth;
  pktap_header_extra extra;
};

/* 10977 */
struct __attribute__((packed)) __attribute__((aligned(4))) bpf_dltlist
{
  u_int32_t bfl_len;
  union
  {
    u_int32_t *bflu_list;
    u_int64_t bflu_pad;
  } bfl_u;
};

/* 10978 */
struct bpf_version
{
  u_short bv_major;
  u_short bv_minor;
};

/* 10979 */
struct bpf_program64
{
  u_int bf_len;
  user64_addr_t bf_insns;
};

/* 10980 */
struct bpf_stat
{
  u_int bs_recv;
  u_int bs_drop;
};

/* 10981 */
struct bpf_program32
{
  u_int bf_len;
  user32_addr_t bf_insns;
};

/* 10982 */
struct bpf_setup_args
{
  uuid_t_1 bsa_uuid;
  char bsa_ifname[16];
};

/* 10983 */
typedef __kern_buflet *kern_buflet_t_1;

/* 10984 */
struct __attribute__((packed)) __attribute__((aligned(4))) __kern_buflet_ext_0
{
  __kern_buflet kbe_overlay;
  const __user_buflet *kbe_buf_user;
  struct
  {
    __kern_buflet_ext *sle_next;
  } kbe_buf_upp_link;
  pid_t kbe_buf_pid;
};

/* 10985 */
struct __attribute__((aligned(8))) __kern_packet_2
{
  __kern_quantum pkt_qum;
  __packet pkt_com;
  __packet_opt *pkt_com_opt;
  uint64_t pkt_timestamp;
  __kern_packet *pkt_nextpkt;
  union
  {
    mbuf *pkt_mbuf;
    __kern_packet *pkt_pkt;
  };
  __flow *pkt_flow;
  __packet_compl *pkt_tx_compl;
  void *pkt_priv;
  uint32_t pkt_fpd_seqnum;
  uint16_t pkt_fpd_metadata;
  const uint16_t pkt_bufs_max;
  const uint16_t pkt_bufs_cnt;
  uint32_t pkt_chain_count;
  uint32_t pkt_chain_bytes;
  nexus_port_t pkt_nx_port;
  uint16_t pkt_vpna_gencnt;
  packet_trace_tag_t pkt_trace_tag;
  uint8_t pkt_qset_idx;
  uint8_t _pad[1];
};

/* 10986 */
struct ifnet_14
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func_0 if_output_dlil;
  volatile ifnet_start_func if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func_1 if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func_1 if_input_ctl;
  ifnet_ioctl_func if_ioctl;
  ifnet_set_bpf_tap_1 if_set_bpf_tap;
  ifnet_detached_func if_free;
  ifnet_demux_func_0 if_demux;
  ifnet_event_func if_event;
  ifnet_framer_func_1 if_framer_legacy;
  ifnet_framer_extended_func_0 if_framer;
  ifnet_add_proto_func if_add_proto;
  ifnet_del_proto_func if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route_0 if_fwd_route;
  route_0 if_src_route;
  route_in6 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 10987 */
struct vfstable_8
{
  const vfsops *vfc_vfsops;
  char vfc_name[15];
  int vfc_typenum;
  int vfc_refcount;
  int vfc_flags;
  int (*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);
  vfstable *vfc_next;
  int32_t vfc_reserved1;
  int32_t vfc_reserved2;
  int vfc_vfsflags;
  void *vfc_descptr;
  uint32_t vfc_descsize;
  sysctl_oid_0 *vfc_sysctl;
};

/* 10988 */
typedef devnode_1 devnode_t_1;

/* 10989 */
struct __attribute__((aligned(8))) vnode_fsparam_0
{
  mount *vnfs_mp;
  vtype_0 vnfs_vtype;
  const char *vnfs_str;
  vnode *vnfs_dvp;
  void *vnfs_fsnode;
  int (**vnfs_vops)(void *);
  int vnfs_markroot;
  int vnfs_marksystem;
  dev_t vnfs_rdev;
  off_t vnfs_filesize;
  componentname *vnfs_cnp;
  uint32_t vnfs_flags;
};

/* 10990 */
struct devfs_stats
{
  int nodes;
  int entries;
  int mounts;
  int stringspace;
};

/* 10991 */
struct __block_literal_1_26
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(selinfo *);
  __block_descriptor_withcopydispose *__descriptor;
  struct __attribute__((packed)) __attribute__((aligned(1))) {void *__isa;void *__forwarding;int __flags;int __size;bool selrecorded;}; *selrecorded;
  knote *kn;
};

/* 10992 */
typedef int spec_strategy::strategy_fcn_ret_t(buf *);

/* 10993 */
struct vfstable_9
{
  const vfsops *vfc_vfsops;
  char vfc_name[15];
  int vfc_typenum;
  int vfc_refcount;
  int vfc_flags;
  int (*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);
  vfstable *vfc_next;
  int32_t vfc_reserved1;
  int32_t vfc_reserved2;
  int vfc_vfsflags;
  void *vfc_descptr;
  uint32_t vfc_descsize;
  sysctl_oid_0 *vfc_sysctl;
};

/* 10994 */
typedef uint32_t cp_key_os_version_t;

/* 10995 */
struct __block_literal_1_27
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(zone_t);
  __block_descriptor *__descriptor;
};

/* 10996 */
struct kfse_list
{
  kfs_event *lh_first;
};

/* 10997 */
struct vnop_kqfilt_remove_args
{
  vnodeop_desc *a_desc;
  vnode *a_vp;
  uintptr_t a_ident;
  vfs_context_t a_context;
};

/* 10998 */
struct vnop_kqfilt_add_args
{
  vnodeop_desc *a_desc;
  vnode *a_vp;
  knote *a_kn;
  vfs_context_t a_context;
};

/* 10999 */
struct vnop_setxattr_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  const char *a_name;
  uio_t a_uio;
  int a_options;
  vfs_context_t a_context;
};

/* 11000 */
struct vnop_clonefile_args
{
  vnodeop_desc *a_desc;
  vnode_t a_fvp;
  vnode_t a_dvp;
  vnode_t *a_vpp;
  componentname *a_cnp;
  vnode_attr *a_vap;
  uint32_t a_flags;
  vfs_context_t a_context;
  int (*a_dir_clone_authorizer)(vnode_attr *, kauth_action_t, vnode_attr *, vnode_t, mount_t, dir_clone_authorizer_op_t, uint32_t, vfs_context_t, void *);
  void *a_reserved;
};

/* 11001 */
struct vnop_compound_rmdir_args
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t *a_vpp;
  componentname *a_cnp;
  vnode_attr *a_vap;
  uint32_t a_flags;
  vfs_context_t a_context;
  int (*a_rmdir_authorizer)(vnode_t, vnode_t, componentname *, vfs_context_t, void *);
  void *a_reserved;
};

/* 11002 */
struct vnop_compound_mkdir_args
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t *a_vpp;
  componentname *a_cnp;
  vnode_attr *a_vap;
  uint32_t a_flags;
  vfs_context_t a_context;
  void *a_reserved;
};

/* 11003 */
struct vnop_compound_rename_args
{
  vnodeop_desc *a_desc;
  vnode_t a_fdvp;
  vnode_t *a_fvpp;
  componentname *a_fcnp;
  vnode_attr *a_fvap;
  vnode_t a_tdvp;
  vnode_t *a_tvpp;
  componentname *a_tcnp;
  vnode_attr *a_tvap;
  uint32_t a_flags;
  vfs_context_t a_context;
  int (*a_rename_authorizer)(vnode_t, vnode_t, componentname *, vnode_t, vnode_t, componentname *, vfs_context_t, void *);
  void *a_reserved;
};

/* 11004 */
struct vnop_compound_remove_args
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t *a_vpp;
  componentname *a_cnp;
  vnode_attr *a_vap;
  uint32_t a_flags;
  vfs_context_t a_context;
  int (*a_remove_authorizer)(vnode_t, vnode_t, componentname *, vfs_context_t, void *);
  void *a_reserved;
};

/* 11005 */
struct vnop_compound_open_args
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t *a_vpp;
  int a_fmode;
  componentname *a_cnp;
  vnode_attr *a_vap;
  uint32_t a_flags;
  uint32_t *a_status;
  vfs_context_t a_context;
  int (*a_open_create_authorizer)(vnode_t, componentname *, vnode_attr *, vfs_context_t, void *);
  int (*a_open_existing_authorizer)(vnode_t, componentname *, int, vfs_context_t, void *);
  void *a_reserved;
};

/* 11006 */
struct vnop_mmap_check_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  int a_flags;
  vfs_context_t a_context;
};

/* 11007 */
struct vnop_renamex_args
{
  vnodeop_desc *a_desc;
  vnode_t a_fdvp;
  vnode_t a_fvp;
  componentname *a_fcnp;
  vnode_t a_tdvp;
  vnode_t a_tvp;
  componentname *a_tcnp;
  vnode_attr *a_vap;
  vfs_rename_flags_t a_flags;
  vfs_context_t a_context;
};

/* 11008 */
struct vnop_removenamedstream_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  vnode_t a_svp;
  const char *a_name;
  int a_flags;
  vfs_context_t a_context;
};

/* 11009 */
struct vnop_makenamedstream_args
{
  vnodeop_desc *a_desc;
  vnode_t *a_svpp;
  vnode_t a_vp;
  const char *a_name;
  int a_flags;
  vfs_context_t a_context;
};

/* 11010 */
struct vnop_getnamedstream_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  vnode_t *a_svpp;
  const char *a_name;
  nsoperation a_operation;
  int a_flags;
  vfs_context_t a_context;
};

/* 11011 */
struct vnop_removexattr_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  const char *a_name;
  int a_options;
  vfs_context_t a_context;
};

/* 11012 */
struct vnop_advlock_args_0
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  caddr_t a_id;
  int a_op;
  flock *a_fl;
  int a_flags;
  vfs_context_t a_context;
  timespec *a_timeout;
};

/* 11013 */
struct vnop_monitor_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  uint32_t a_events;
  uint32_t a_flags;
  void *a_handle;
  vfs_context_t a_context;
};

/* 11014 */
struct vnop_verify_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  off_t a_foffset;
  uint8_t *a_buf;
  size_t a_bufsize;
  size_t *a_verifyblksize;
  void **a_verify_ctxp;
  _BYTE gap38[8];
  vfs_context_t a_context;
};

/* 11015 */
struct vnop_getattrlistbulk_args
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  attrlist *a_alist;
  vnode_attr *a_vap;
  uio *a_uio;
  void *a_private;
  uint64_t a_options;
  int32_t *a_eofflag;
  int32_t *a_actualcount;
  vfs_context_t a_context;
};

/* 11016 */
typedef fsioc_auth_fs fsioc_auth_fs_t;

/* 11017 */
struct vnop_copyfile_args_0
{
  vnodeop_desc *a_desc;
  vnode_t a_fvp;
  vnode_t a_tdvp;
  vnode_t a_tvp;
  componentname *a_tcnp;
  int a_mode;
  int a_flags;
  vfs_context_t a_context;
};

/* 11018 */
struct vnop_symlink_args_0
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t *a_vpp;
  componentname *a_cnp;
  vnode_attr *a_vap;
  char *a_target;
  vfs_context_t a_context;
};

/* 11019 */
struct vnop_rmdir_args_0
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t a_vp;
  componentname *a_cnp;
  vfs_context_t a_context;
};

/* 11020 */
struct vnop_mkdir_args_0
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t *a_vpp;
  componentname *a_cnp;
  vnode_attr *a_vap;
  vfs_context_t a_context;
};

/* 11021 */
struct vnop_link_args_0
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  vnode_t a_tdvp;
  componentname *a_cnp;
  vfs_context_t a_context;
};

/* 11022 */
struct vnop_remove_args_0
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t a_vp;
  componentname *a_cnp;
  int a_flags;
  vfs_context_t a_context;
};

/* 11023 */
struct vnop_mknod_args_0
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t *a_vpp;
  componentname *a_cnp;
  vnode_attr *a_vap;
  vfs_context_t a_context;
};

/* 11024 */
struct vnop_create_args_0
{
  vnodeop_desc *a_desc;
  vnode_t a_dvp;
  vnode_t *a_vpp;
  componentname *a_cnp;
  vnode_attr *a_vap;
  vfs_context_t a_context;
};

/* 11025 */
struct vnop_searchfs_args_0
{
  vnodeop_desc *a_desc;
  vnode_t a_vp;
  void *a_searchparams1;
  void *a_searchparams2;
  attrlist *a_searchattrs;
  uint32_t a_maxmatches;
  timeval *a_timelimit;
  attrlist *a_returnattrs;
  uint32_t *a_nummatches;
  uint32_t a_scriptcode;
  uint32_t a_options;
  uio *a_uio;
  searchstate *a_searchstate;
  vfs_context_t a_context;
};

/* 11026 */
struct fs_snapshot_root_args
{
  componentname *sr_cnp;
};

/* 11027 */
struct fs_snapshot_revert_args
{
  componentname *sr_cnp;
};

/* 11028 */
struct fs_snapshot_mount_args
{
  mount_t sm_mp;
  componentname *sm_cnp;
};

/* 11029 */
struct user32_fssearchblock
{
  user32_addr_t returnattrs;
  user32_addr_t returnbuffer;
  user32_size_t returnbuffersize;
  user32_ulong_t maxmatches;
  user32_timeval timelimit;
  user32_addr_t searchparams1;
  user32_size_t sizeofsearchparams1;
  user32_addr_t searchparams2;
  user32_size_t sizeofsearchparams2;
  attrlist searchattrs;
};

/* 11030 */
struct user64_fssearchblock
{
  user64_addr_t returnattrs;
  user64_addr_t returnbuffer;
  user64_size_t returnbuffersize;
  user64_ulong_t maxmatches;
  user64_timeval timelimit;
  user64_addr_t searchparams1;
  user64_size_t sizeofsearchparams1;
  user64_addr_t searchparams2;
  user64_size_t sizeofsearchparams2;
  attrlist searchattrs;
};

/* 11031 */
enum getdirentries64_flags_t : __int32
{
  GETDIRENTRIES64_EOF = 0x1,
};

/* 11032 */
typedef fsioc_ungraft_fs fsioc_ungraft_fs_t;

/* 11033 */
typedef graft_args graftdmg_args_un;

/* 11034 */
typedef fs_role_mount_args fs_role_mount_args_t;

/* 11035 */
struct user64_mnt_imgsrc_args
{
  uint32_t mi_height;
  uint32_t mi_flags;
  user64_addr_t mi_devpath;
};

/* 11036 */
struct user32_mnt_imgsrc_args
{
  uint32_t mi_height;
  uint32_t mi_flags;
  user32_addr_t mi_devpath;
};

/* 11037 */
enum sync_type_t : __int32
{
  SYNC_ALL = 0x0,
  SYNC_ONLY_RELIABLE_MEDIA = 0x1,
  SYNC_ONLY_UNRELIABLE_MEDIA = 0x2,
};

/* 11038 */
enum dk_apfs_flavour_t : __int32
{
  DK_APFS_ONE_DEVICE = 0x1,
  DK_APFS_FUSION = 0x2,
};

/* 11039 */
union union_vfsidctl
{
  user32_vfsidctl vc32;
  user_vfsidctl vc64;
};

/* 11040 */
struct __attribute__((packed)) __attribute__((aligned(1))) _ca_event_freeable_vnodes
{
  unsigned __int64 numvnodes_min;
  unsigned __int64 numvnodes_max;
  unsigned __int64 desiredvnodes;
  unsigned __int64 numvnodes;
  unsigned __int64 freevnodes;
  unsigned __int64 deadvnodes;
  unsigned __int64 freeablevnodes;
  unsigned __int64 busyvnodes;
  bool threshold_crossed;
};

/* 11041 */
struct mntlist
{
  mount *tqh_first;
  mount **tqh_last;
};

/* 11042 */
struct deadlst
{
  vnode *tqh_first;
  vnode **tqh_last;
};

/* 11043 */
struct dqfilehdr
{
  u_int32_t dqh_magic;
  u_int32_t dqh_version;
  u_int32_t dqh_maxentries;
  u_int32_t dqh_entrycnt;
  u_int32_t dqh_flags;
  u_int32_t dqh_chktime;
  u_int32_t dqh_btime;
  u_int32_t dqh_itime;
  char dqh_string[16];
  u_int32_t dqh_spare[4];
};

/* 11044 */
struct dqdirtylist
{
  dquot *tqh_first;
  dquot **tqh_last;
};

/* 11045 */
struct dqfreelist
{
  dquot *tqh_first;
  dquot **tqh_last;
};

/* 11046 */
struct dk_error_description_t
{
  uint64_t options;
  uint64_t reserved;
  uint64_t description_size;
  char *description;
};

/* 11047 */
struct ioqueue
{
  buf *tqh_first;
  buf **tqh_last;
};

/* 11048 */
struct delayqueue
{
  buf *tqh_first;
  buf **tqh_last;
};

/* 11049 */
struct bufstats
{
  long bufs_incore;
  long bufs_busyincore;
  long bufs_vmhits;
  long bufs_miss;
  long bufs_sleeps;
  long bufs_eblk;
  uint32_t bufs_iobufmax;
  uint32_t bufs_iobufinuse;
  long bufs_iobufsleeps;
  long bufs_iobufinuse_vdev;
};

/* 11050 */
struct memory_object_2
{
  mo_ipc_object_bits_t mo_ikot;
  os_ref_atomic_t mo_ref;
  const memory_object_pager_ops *mo_pager_ops;
  memory_object_control_t mo_control;
};

/* 11051 */
struct __block_literal_2_12
{
  void *__isa;
  int __flags;
  int __reserved;
  vm_map_size_t (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
};

/* 11052 */
typedef ucred *kauth_cred_t_0;

/* 11053 */
typedef fasttrap_instr_query fasttrap_instr_query_t;

/* 11054 */
typedef fasttrap_hash fasttrap_hash_t;

/* 11055 */
typedef kern_return_t (*mach_call_t)(void *);

/* 11056 */
struct modctl_0
{
  modctl *mod_next;
  modctl *mod_stale;
  uint32_t mod_id;
  char mod_modname[64];
  int mod_loadcnt;
  char mod_loaded;
  uint16_t mod_flags;
  int mod_nenabled;
  vm_address_t_1 mod_address;
  vm_size_t_0 mod_size;
  UUID mod_uuid;
  dtrace_module_symbols *mod_user_symbols;
  int mod_sdtprobecnt;
  void *mod_sdtdesc;
};

/* 11057 */
typedef sdt_probe_0 sdt_probe_t_0;

/* 11058 */
typedef uint_t_0 major_t;

/* 11059 */
struct __attribute__((packed)) __attribute__((aligned(4))) kmod_info_3
{
  kmod_info_0 *next;
  int32_t info_version;
  uint32_t id;
  char name[64];
  char version[64];
  int32_t reference_count;
  kmod_reference_t_0 *reference_list;
  vm_address_t_1 address;
  vm_size_t_0 size;
  vm_size_t_0 hdr_size;
  kmod_start_func_t_0 *start;
  kmod_stop_func_t_0 *stop;
};

/* 11060 */
struct listhead
{
  dtrace_proc_awaited_entry *lh_first;
};

/* 11061 */
typedef dtrace_json_state dtrace_json_state_t;

/* 11062 */
struct in6_addr_1
{
  union
  {
    __uint8_t __u6_addr8[16];
    __uint16_t __u6_addr16[8];
    __uint32_t __u6_addr32[4];
  } __u6_addr;
};

/* 11063 */
typedef dtrace_repldesc dtrace_repldesc_t;

/* 11064 */
typedef dtrace_fmtdesc dtrace_fmtdesc_t;

/* 11065 */
typedef dtrace_aggdesc dtrace_aggdesc_t;

/* 11066 */
typedef dtrace_status dtrace_status_t;

/* 11067 */
typedef dtrace_conf dtrace_conf_t;

/* 11068 */
typedef dtrace_eprobedesc dtrace_eprobedesc_t;

/* 11069 */
typedef dtrace_providerdesc dtrace_providerdesc_t;

/* 11070 */
typedef dtrace_bufdesc dtrace_bufdesc_t;

/* 11071 */
struct _kthread;

/* 11072 */
typedef dtrace_anon dtrace_anon_t;

/* 11073 */
struct vmem;

/* 11074 */
typedef dtrace_difo_0 dtrace_difo_t_0;

/* 11075 */
struct proc_4
{
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_list;
  _BYTE gap10[8];
  proc_ro_t p_proc_ro;
  pid_t p_ppid;
  pid_t p_original_ppid;
  pid_t p_pgrpid;
  uid_t p_uid;
  gid_t p_gid;
  uid_t p_ruid;
  gid_t p_rgid;
  uid_t p_svuid;
  gid_t p_svgid;
  pid_t p_sessionid;
  uint64_t p_puniqueid;
  lck_mtx_t p_mlock;
  pid_t p_pid;
  char p_stat;
  char p_shutdownstate;
  char p_kdebug;
  char p_btrace;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_pglist;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_sibling;
  struct
  {
    proc *lh_first;
  } p_children;
  struct
  {
    uthread *tqh_first;
    uthread **tqh_last;
  } p_uthlist;
  smrq_slink p_hash;
  persona *p_persona;
  struct
  {
    proc *le_next;
    proc **le_prev;
  } p_persona_list;
  lck_mtx_t p_ucred_mlock;
  filedesc p_fd;
  pstats *p_stats;
  struct
  {
    plimit *volatile __smr_ptr;
  } p_limit;
  struct
  {
    _BYTE gap0[8];
  } p_pgrp;
  sigacts p_sigacts;
  lck_spin_t p_slock;
  int p_siglist;
  unsigned int p_flag;
  unsigned int p_lflag;
  unsigned int p_listflag;
  unsigned int p_ladvflag;
  os_ref_atomic_t p_refcount;
  os_ref_atomic_t p_waitref;
  int p_childrencnt;
  int p_parentref;
  pid_t p_oppid;
  u_int p_xstat;
  int p_aio_total_count;
  itimerval p_realtimer;
  timeval p_rtime;
  itimerval p_vtimer_user;
  itimerval p_vtimer_prof;
  timeval p_rlim_cpu;
  int p_debugger;
  boolean_t sigwait;
  void *sigwait_thread;
  void *exit_thread;
  pid_t si_pid;
  u_int si_status;
  u_int si_code;
  uid_t si_uid;
  void *vm_shm;
  int p_ractive;
  pid_t p_responsible_pid;
  int p_dtrace_probes;
  u_int p_dtrace_count;
  uint8_t p_dtrace_stop;
  user_addr_t_0 p_dtrace_argv;
  user_addr_t_0 p_dtrace_envp;
  lck_mtx_t p_dtrace_sprlock;
  dtrace_ptss_page *p_dtrace_ptss_pages;
  dtrace_ptss_page_entry *p_dtrace_ptss_free_list;
  dtrace_helpers *p_dtrace_helpers;
  dof_ioctl_data *p_dtrace_lazy_dofs;
  union
  {
    struct __attribute__((aligned(8)))
    {
      u_int p_argslen;
      int p_argc;
      user_addr_t_0 user_stack;
      _BYTE gap10[8];
      off_t p_textoff;
      sigset_t p_sigmask;
      sigset_t p_sigignore;
      sigset_t p_sigcatch;
      u_char p_priority;
      u_char p_resv0;
      char p_nice;
      u_char p_resv1;
      command_t p_comm;
      proc_name_t p_name;
      uint8_t p_xhighbits;
      pid_t p_contproc;
      uint32_t p_pcaction;
      uint8_t p_uuid[16];
      cpu_type_t p_cputype;
      cpu_subtype_t_0 p_cpusubtype;
    };
    proc_forkcopy_data p_forkcopy;
  };
  struct
  {
    aio_workq_entry *tqh_first;
    aio_workq_entry **tqh_last;
  } p_aio_activeq;
  struct
  {
    aio_workq_entry *tqh_first;
    aio_workq_entry **tqh_last;
  } p_aio_doneq;
  klist p_klist;
  rusage_superset *p_ru;
  thread_t_0 p_signalholder;
  thread_t_0 p_transholder;
  int p_sigwaitcnt;
  u_short p_acflag;
  volatile u_short p_vfs_iopolicy;
  user_addr_t_0 p_threadstart;
  user_addr_t_0 p_wqthread;
  int p_pthsize;
  uint32_t p_pth_tsd_offset;
  user_addr_t_0 p_stack_addr_hint;
  workqueue *p_wqptr;
  timeval p_start;
  void *p_rcall;
  void *p_pthhash;
  volatile uint64_t was_throttled;
  volatile uint64_t did_throttle;
  uint64_t p_dispatchqueue_offset;
  uint64_t p_dispatchqueue_serialno_offset;
  uint64_t p_dispatchqueue_label_offset;
  uint64_t p_return_to_kernel_offset;
  uint64_t p_mach_thread_self_offset;
  uint64_t p_pthread_wq_quantum_offset;
  timeval vm_pressure_last_notify_tstamp;
  uint8_t p_crash_behavior;
  bool p_posix_spawn_failed;
  bool p_disallow_map_with_linking;
  uint32_t p_memstat_state;
  int32_t p_memstat_effectivepriority;
  int32_t p_memstat_requestedpriority;
  int32_t p_memstat_assertionpriority;
  uint32_t p_memstat_dirty;
  struct
  {
    proc *tqe_next;
    proc **tqe_prev;
  } p_memstat_list;
  uint64_t p_memstat_userdata;
  uint64_t p_memstat_idledeadline;
  uint64_t p_memstat_idle_start;
  uint64_t p_memstat_idle_delta;
  int32_t p_memstat_memlimit;
  int32_t p_memstat_memlimit_active;
  int32_t p_memstat_memlimit_inactive;
  int32_t p_memstat_relaunch_flags;
  uint32_t p_user_faults;
  uint32_t p_memlimit_increase;
  uint64_t p_crash_behavior_deadline;
  uint32_t p_crash_count;
  uint32_t p_throttle_timeout;
  os_reason *p_exit_reason;
  uint64_t p_user_data;
  char *p_subsystem_root_path;
};

/* 11076 */
struct ifaliasreq
{
  char ifra_name[16];
  sockaddr ifra_addr;
  sockaddr ifra_broadaddr;
  sockaddr ifra_mask;
};

/* 11077 */
struct ifnet_15
{
  lck_rw_t if_lock;
  void *if_softc;
  const char *if_name;
  const char *if_xname;
  if_description if_desc;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_detaching_link;
  struct
  {
    ifnet *tqe_next;
    ifnet **tqe_prev;
  } if_ordered_link;
  lck_mtx_t if_ref_lock;
  u_int32_t if_refflags;
  u_int32_t if_refio;
  u_int32_t if_threads_pending;
  u_int32_t if_datamov;
  u_int32_t if_drainers;
  u_int32_t if_suspend;
  ifaddrhead if_addrhead;
  ifaddr *if_lladdr;
  u_int32_t if_qosmarking_mode;
  int if_pcount;
  bpf_if *if_bpf;
  u_short if_index;
  short if_unit;
  short if_timer;
  short if_flags;
  u_int32_t if_eflags;
  u_int32_t if_xflags;
  int if_capabilities;
  int if_capenable;
  void *if_linkmib;
  uint32_t if_linkmiblen;
  if_data_internal if_data;
  ifnet_family_t if_family;
  ifnet_subfamily_t if_subfamily;
  uintptr_t if_family_cookie;
  volatile dlil_input_func if_input_dlil;
  volatile dlil_output_func_0 if_output_dlil;
  volatile ifnet_start_func if_start;
  ifnet_output_func if_output;
  ifnet_pre_enqueue_func if_pre_enqueue;
  ifnet_ctl_func_1 if_output_ctl;
  ifnet_input_poll_func if_input_poll;
  ifnet_ctl_func_1 if_input_ctl;
  ifnet_ioctl_func if_ioctl;
  ifnet_set_bpf_tap_1 if_set_bpf_tap;
  ifnet_detached_func if_free;
  ifnet_demux_func_0 if_demux;
  ifnet_event_func_1 if_event;
  ifnet_framer_func_1 if_framer_legacy;
  ifnet_framer_extended_func_0 if_framer;
  ifnet_add_proto_func_1 if_add_proto;
  ifnet_del_proto_func_1 if_del_proto;
  ifnet_check_multi if_check_multi;
  proto_hash_entry *if_proto_hash;
  ifnet_detached_func if_detach;
  u_int32_t if_flowhash;
  lck_mtx_t if_start_lock;
  u_int32_t if_start_flags;
  u_int32_t if_start_req;
  u_int8_t if_start_embryonic;
  u_int8_t if_start_active;
  u_int16_t if_start_delayed;
  u_int16_t if_start_delay_qlen;
  u_int16_t if_start_delay_idle;
  u_int64_t if_start_delay_swin;
  u_int32_t if_start_delay_cnt;
  u_int32_t if_start_delay_timeout;
  timespec if_start_cycle;
  thread *if_start_thread;
  ifclassq *if_snd;
  u_int32_t if_output_sched_model;
  if_bandwidths if_output_bw;
  if_bandwidths if_input_bw;
  if_latencies if_output_lt;
  if_latencies if_input_lt;
  lck_mtx_t if_flt_lock;
  u_int32_t if_flt_busy;
  u_int32_t if_flt_waiters;
  ifnet_filter_head if_flt_head;
  uint32_t if_flt_non_os_count;
  uint32_t if_flt_no_tso_count;
  ifmultihead if_multiaddrs;
  u_int32_t if_updatemcasts;
  int if_amcount;
  lck_mtx_t if_addrconfig_lock;
  in_multi *if_allhostsinm;
  lck_mtx_t if_poll_lock;
  if_poll_params rxpoll_params;
  dlil_threading_info *if_inp;
  thread_call_t if_dt_tcall;
  struct
  {
    u_int32_t length;
    union
    {
      u_char buffer[8];
      u_char *ptr;
    } u;
  } if_broadcast;
  pfi_kif *if_pf_kif;
  nexus_ifnet_ops *if_na_ops;
  nexus_netif_adapter *if_na;
  if_nexus_netif if_nx_netif;
  if_nexus_flowswitch if_nx_flowswitch;
  uint16_t if_tx_headroom;
  uint16_t if_tx_trailer;
  uint32_t if_rx_mit_ival;
  ifnet_start_func if_save_start;
  ifnet_output_func if_save_output;
  uint32_t if_start_waiters;
  lck_mtx_t if_cached_route_lock;
  u_int32_t if_fwd_cacheok;
  route_0 if_fwd_route;
  route_0 if_src_route;
  route_in6 if_src_route6;
  lck_rw_t if_llreach_lock;
  ll_reach_tree if_ll_srcs;
  void *if_bridge;
  u_int32_t if_idle_flags;
  u_int32_t if_idle_new_flags;
  u_int32_t if_idle_new_flags_mask;
  u_int32_t if_route_refcnt;
  u_int32_t if_rt_sendts;
  if_traffic_class if_tc;
  igmp_ifinfo *if_igi;
  mld_ifinfo *if_mli;
  tcpstat_local *if_tcp_stat;
  udpstat_local *if_udp_stat;
  struct
  {
    int32_t level;
    u_int32_t flags;
    int32_t category;
    int32_t subcategory;
  } if_log;
  struct __attribute__((aligned(8)))
  {
    ifnet *ifp;
    u_int32_t type;
    u_int32_t family;
    u_int32_t subfamily;
  } if_delegated;
  uuid_t_1 *if_agentids;
  u_int32_t if_agentcount;
  volatile uint32_t if_low_power_gencnt;
  u_int32_t if_generation;
  u_int32_t if_fg_sendts;
  u_int64_t if_data_threshold;
  int64_t if_sndbyte_total;
  int64_t if_sndbyte_unsent;
  uint32_t if_unsent_data_cnt;
  lck_rw_t if_inetdata_lock;
  in_ifextra *if_inetdata;
  lck_mtx_t if_inet6_ioctl_lock;
  boolean_t if_inet6_ioctl_busy;
  lck_rw_t if_inet6data_lock;
  in6_ifextra *if_inet6data;
  lck_rw_t if_link_status_lock;
  if_link_status *if_link_status;
  if_interface_state if_interface_state;
  if_tcp_ecn_stat *if_ipv4_stat;
  if_tcp_ecn_stat *if_ipv6_stat;
  struct
  {
    ns_token *slh_first;
  } if_netns_tokens;
  __attribute__((packed)) __attribute__((aligned(1))) if_lim_perf_stat if_lim_stat;
  uint32_t if_tcp_kao_max;
  uint32_t if_tcp_kao_cnt;
  netem *if_input_netem;
  netem *if_output_netem;
  ipv6_router_mode_t if_ipv6_router_mode;
  u_int8_t if_estimated_up_bucket;
  u_int8_t if_estimated_down_bucket;
  u_int8_t if_radio_type;
  u_int8_t if_radio_channel;
  uint8_t network_id[32];
  uint8_t network_id_len;
  uint32_t if_traffic_rule_count;
  uint32_t if_traffic_rule_genid;
};

/* 11078 */
typedef gss_1964_header_desc_struct *gss_1964_header;

/* 11079 */
typedef size_t (*ccpad_func)(const ccmode_cbc *, cccbc_ctx *, cccbc_iv *, size_t, const void *, void *);

/* 11080 */
typedef gss_buffer_desc_struct gss_buffer_desc;

/* 11081 */
typedef gss_1964_token_body_struct *gss_1964_token_body;

/* 11082 */
typedef gss_1964_token_body_struct gss_1964_token_body_desc;

/* 11083 */
typedef gss_1964_header_desc_struct gss_1964_header_desc;

/* 11084 */
typedef gss_cfx_wrap_token_desc_struct gss_cfx_wrap_token_desc;

/* 11085 */
typedef gss_cfx_mic_token_desc_struct gss_cfx_mic_token_desc;

/* 11086 */
struct nfs_export_net_args
{
  uint32_t nxna_flags;
  xucred nxna_cred;
  sockaddr_storage nxna_addr;
  sockaddr_storage nxna_mask;
  nfs_sec nxna_sec;
};

/* 11087 */
struct gss_ctx_id_desc_0
{
  lucid_context gss_lucid_ctx;
  crypto_ctx_0 gss_cryptor;
};

/* 11088 */
struct nfsrvstats
{
  uint64_t srvrpccntv3[23];
  uint64_t srvrpc_errs;
  uint64_t srv_errs;
  uint64_t srvcache_inproghits;
  uint64_t srvcache_idemdonehits;
  uint64_t srvcache_nonidemdonehits;
  uint64_t srvcache_misses;
  uint64_t srvvop_writes;
};

/* 11089 */
struct nfsrv_reqcache_lru
{
  nfsrvcache *tqh_first;
  nfsrvcache **tqh_last;
};

/* 11090 */
struct nfsrv_expfs_list
{
  nfs_exportfs *lh_first;
};

/* 11091 */
struct nfsrv_sockhead
{
  nfsrv_sock *tqh_first;
  nfsrv_sock **tqh_last;
};

/* 11092 */
struct nfsd_head
{
  nfsd *tqh_first;
  nfsd **tqh_last;
};

/* 11093 */
struct __attribute__((aligned(8))) image_params_1
{
  user_addr_t_0 ip_user_fname;
  user_addr_t_0 ip_user_argv;
  user_addr_t_0 ip_user_envv;
  int ip_seg;
  vnode *ip_vp;
  vnode_attr *ip_vattr;
  vnode_attr *ip_origvattr;
  cpu_type_t ip_origcputype;
  cpu_subtype_t_0 ip_origcpusubtype;
  char *ip_vdata;
  int ip_flags;
  int ip_argc;
  int ip_envc;
  int ip_applec;
  char *ip_startargv;
  char *ip_endargv;
  char *ip_endenvv;
  char *ip_strings;
  char *ip_strendp;
  char *ip_subsystem_root_path;
  int ip_argspace;
  int ip_strspace;
  user_size_t ip_arch_offset;
  user_size_t ip_arch_size;
  char ip_interp_buffer[512];
  int ip_interp_sugid_fd;
  vfs_context *ip_vfs_context;
  nameidata *ip_ndp;
  thread_t_0 ip_new_thread;
  label *ip_execlabelp;
  label *ip_scriptlabelp;
  vnode *ip_scriptvp;
  unsigned int ip_csflags;
  int ip_mac_return;
  void *ip_px_sa;
  void *ip_px_sfa;
  void *ip_px_spa;
  ip_px_smpx_s ip_px_smpx;
  void *ip_px_persona;
  void *ip_px_pcred_info;
  void *ip_cs_error;
  char *ip_inherited_shared_region_id;
  uint64_t ip_dyld_fsid;
  uint64_t ip_dyld_fsobjid;
  uint64_t ip_inherited_jop_pid;
  unsigned int ip_simulator_binary;
};

/* 11094 */
struct nfs_user_stat_path_rec
{
  u_char rec_type;
  char path[1025];
};

/* 11095 */
struct __attribute__((packed)) __attribute__((aligned(1))) nfs_user_stat_user_rec
{
  u_char rec_type;
  uid_t uid;
  sockaddr_storage sock;
  uint64_t ops;
  uint64_t bytes_read;
  uint64_t bytes_written;
  time_t tm_start;
  time_t tm_last;
};

/* 11096 */
struct nfs_user_stat_desc
{
  uint32_t rec_vers;
  uint32_t rec_count;
};

/* 11097 */
struct __attribute__((packed)) __attribute__((aligned(1))) nfs_export_stat_rec
{
  char path[1025];
  uint64_t ops;
  uint64_t bytes_read;
  uint64_t bytes_written;
};

/* 11098 */
struct __attribute__((packed)) __attribute__((aligned(4))) nfs_export_stat_desc
{
  uint32_t rec_vers;
  uint64_t rec_count;
};

/* 11099 */
struct nfs_export_args
{
  uint32_t nxa_fsid;
  uint32_t nxa_expid;
  user32_addr_t nxa_fspath;
  user32_addr_t nxa_exppath;
  uint32_t nxa_flags;
  uint32_t nxa_netcount;
  user32_addr_t nxa_nets;
};

/* 11100 */
struct nfsd_args
{
  int sock;
  user32_addr_t name;
  int namelen;
};

/* 11101 */
struct __attribute__((aligned(8))) user_nfsd_args
{
  int sock;
  user_addr_t_0 name;
  int namelen;
};

/* 11102 */
struct vnode_resolve_7
{
  lck_mtx_t vr_lock;
  trigger_vnode_resolve_callback_t_7 vr_resolve_func;
  trigger_vnode_unresolve_callback_t_0 vr_unresolve_func;
  trigger_vnode_rearm_callback_t vr_rearm_func;
  trigger_vnode_reclaim_callback_t_0 vr_reclaim_func;
  void *vr_data;
  uint32_t vr_flags;
  uint32_t vr_lastseq;
};

/* 11103 */
struct vfstable_10
{
  const vfsops *vfc_vfsops;
  char vfc_name[15];
  int vfc_typenum;
  int vfc_refcount;
  int vfc_flags;
  int (*vfc_mountroot)(mount_t, vnode_t, vfs_context_t);
  vfstable *vfc_next;
  int32_t vfc_reserved1;
  int32_t vfc_reserved2;
  int vfc_vfsflags;
  void *vfc_descptr;
  uint32_t vfc_descsize;
  sysctl_oid_0 *vfc_sysctl;
};

/* 11104 */
struct uthread_2
{
  u_int64_t uu_arg[8];
  int uu_rval[2];
  char uu_cursig;
  bool uu_workq_pthread_kill_allowed;
  uint16_t syscall_code;
  int uu_exception;
  mach_exception_code_t uu_code;
  mach_exception_subcode_t uu_subcode;
  union
  {
    _select_data uus_select_data;
    kevent_ctx_s uus_kevent;
    _kevent_register uus_kevent_register;
    _kauth uus_kauth;
    ksyn_waitq_element uus_kwe;
    _waitid_data uus_waitid_data;
    _wait4_data uus_wait4_data;
    _workq_park_data uus_workq_park_data;
    _ulock_wait_data uus_ulock_wait_data;
    _bsdthread_terminate_0 uus_bsdthread_terminate;
    _exec_data uus_exec_data;
  } uu_save;
  _select uu_select;
  void *uu_userstate;
  select_set *uu_selset;
  int uu_flag;
  sigset_t uu_siglist;
  sigset_t uu_sigwait;
  sigset_t uu_sigmask;
  sigset_t uu_oldmask;
  user_addr_t_0 uu_sigreturn_token;
  uint32_t uu_sigreturn_diversifier;
  int uu_pending_sigreturn;
  struct
  {
    uthread *tqe_next;
    uthread **tqe_prev;
  } uu_list;
  kaudit_record *uu_ar;
  task *uu_aio_task;
  union
  {
    lck_mtx_t *uu_mtx;
    knote_lock_ctx *uu_knlock;
  };
  lck_spin_t uu_rethrottle_lock;
  struct
  {
    uthread *tqe_next;
    uthread **tqe_prev;
  } uu_throttlelist;
  void *uu_throttle_info;
  int8_t uu_on_throttlelist;
  bool uu_lowpri_window;
  bool uu_was_rethrottled;
  bool uu_is_throttled;
  bool uu_throttle_bc;
  bool uu_defer_reclaims;
  uint16_t uu_pri;
  caddr_t uu_wchan;
  int (*uu_continuation)(int);
  const char *uu_wmesg;
  kern_sigaltstack uu_sigstk;
  vnode_t uu_vreclaims;
  vnode_t uu_cdir;
  int uu_dupfd;
  u_int32_t uu_network_marks;
  workq_threadreq_s *uu_kqr_bound;
  struct
  {
    uthread *tqe_next;
    uthread **tqe_prev;
  } uu_workq_entry;
  vm_offset_t_0 uu_workq_stackaddr;
  mach_port_name_t uu_workq_thport;
  uu_workq_policy uu_workq_pri;
  uint16_t uu_workq_flags;
  kq_index_t uu_kqueue_override;
  int uu_proc_refcount;
  uint32_t t_dtrace_errno;
  siginfo_t t_dtrace_siginfo;
  uint64_t t_dtrace_resumepid;
  uint8_t t_dtrace_stop;
  uint8_t t_dtrace_sig;
  __tdu _tdu;
  user_addr_t_0 t_dtrace_pc;
  user_addr_t_0 t_dtrace_npc;
  user_addr_t_0 t_dtrace_scrpc;
  user_addr_t_0 t_dtrace_astpc;
  dtrace_ptss_page_entry *t_dtrace_scratch;
  uint64_t t_dtrace_regv;
  void *t_dtrace_syscall_args;
  char *pth_name;
  doc_tombstone *t_tombstone;
  uint64_t t_fs_private;
  os_reason *uu_exit_reason;
};

/* 11105 */
struct thread_ro_1
{
  thread *tro_owner;
  ucred *tro_cred;
  proc *tro_proc;
  proc_ro *tro_proc_ro;
  task *tro_task;
  __attribute__((aligned(16))) ipc_port *tro_self_port;
  ipc_port *tro_settable_self_port;
  ipc_port *tro_ports[3];
  exception_action *tro_exc_actions;
};

/* 11106 */
struct task_0
{
  lck_mtx_t_0 lock;
  os_refcnt_t ref_count;
  bool active;
  bool ipc_active;
  bool halting;
  bool message_app_suspended;
  uint32_t vtimers;
  uint32_t loadTag;
  uint64_t task_uniqueid;
  __attribute__((aligned(16))) queue_chain_t_0 tasks;
  task_watchports *watchports;
  turnstile_inheritor_t returnwait_inheritor;
  sched_group_t sched_group;
  queue_head_t_0 threads;
  restartable_ranges *t_rr_ranges;
  processor_set_t pset_hint;
  affinity_space *affinity_space;
  int thread_count;
  uint32_t active_thread_count;
  int suspend_count;
  integer_t user_stop_count;
  integer_t legacy_stop_count;
  int16_t priority;
  int16_t max_priority;
  integer_t importance;
  uint64_t total_runnable_time;
  recount_task tk_recount;
  lck_mtx_t_0 itk_lock_data;
  _BYTE gapC8[48];
  exception_action exc_actions[14];
  _BYTE gap2B8[80];
  ledger_t ledger;
  queue_head_t_0 semaphore_list;
  int semaphores_owned;
  unsigned int priv_flags;
  __attribute__((aligned(16))) uint64_t rop_pid;
  uint64_t jop_pid;
  uint8_t disable_user_jop;
  arm64_uexc_region_t uexc;
  bool preserve_x18;
  counter_t faults;
  counter_t pageins;
  counter_t cow_faults;
  counter_t messages_sent;
  counter_t messages_received;
  uint32_t decompressions;
  uint32_t syscalls_mach;
  uint32_t syscalls_unix;
  uint32_t c_switch;
  uint32_t p_switch;
  uint32_t ps_switch;
  proc_ro *bsd_info_ro;
  kcdata_descriptor_t corpse_info;
  uint64_t crashed_thread_id;
  queue_chain_t_0 corpse_tasks;
  label *crash_label;
  volatile uint32_t t_flags;
  uint32_t t_procflags;
  mach_vm_address_t_0 all_image_info_addr;
  mach_vm_size_t_0 all_image_info_size;
  uint32_t t_kpc;
  bool pidsuspended;
  bool frozen;
  bool changing_freeze_state;
  bool is_large_corpse;
  _BYTE gap400[2];
  uint8_t rusage_cpu_flags;
  uint8_t rusage_cpu_percentage;
  uint8_t rusage_cpu_perthr_percentage;
  uint8_t t_returnwaitflags;
  bool shared_region_auth_remapped;
  char *shared_region_id;
  vm_shared_region *shared_region;
  uint64_t rusage_cpu_interval;
  uint64_t rusage_cpu_perthr_interval;
  uint64_t rusage_cpu_deadline;
  thread_call_t rusage_cpu_callt;
  queue_head_t_0 task_watchers;
  int num_taskwatchers;
  int watchapplying;
  bank_task *bank_context;
  ipc_importance_task *task_imp_base;
  vm_extmod_statistics_data_t extmod_statistics;
  task_requested_policy requested_policy;
  task_effective_policy effective_policy;
  _BYTE gap4A0[8];
  io_stat_info_t task_io_stats;
  task_writes_counters task_writes_counters_internal;
  task_writes_counters task_writes_counters_external;
  _cpu_time_qos_stats cpu_time_eqos_stats;
  _cpu_time_qos_stats cpu_time_rqos_stats;
  uint32_t task_timer_wakeups_bin_1;
  uint32_t task_timer_wakeups_bin_2;
  uint64_t task_gpu_ns;
  uint8_t task_can_transfer_memory_ownership;
  uint8_t task_objects_disowning;
  uint8_t task_objects_disowned;
  int task_volatile_objects;
  int task_nonvolatile_objects;
  int task_owned_objects;
  queue_head_t_0 task_objq;
  lck_mtx_t_0 task_objq_lock;
  _BYTE gap5A0[8];
  coalition_t coalition[2];
  queue_chain_t_0 task_coalition[2];
  uint64_t dispatchqueue_offset;
  task_exc_guard_behavior_t task_exc_guard;
  mach_vm_address_t_0 mach_header_vm_address;
  queue_head_t_0 io_user_clients;
  boolean_t donates_own_pages;
  uint32_t task_shared_region_slide;
  uint64_t task_fs_metadata_writes;
  uuid_t_0 task_shared_region_uuid;
  uint64_t memstat_dirty_start;
  vmobject_list_output_t corpse_vmobject_list;
  uint64_t corpse_vmobject_list_size;
  vm_deferred_reclamation_metadata_t deferred_reclamation_metadata;
};

/* 11107 */
struct thread_call_0
{
  uint64_t tc_soft_deadline;
  priority_queue_entry_deadline tc_pqlink;
  queue_head_t_0 *tc_queue;
  queue_chain_t_0 tc_qlink;
  _BYTE gap40[4];
  int32_t tc_refs;
  uint64_t tc_ttd;
  uint64_t tc_pending_timestamp;
  thread_call_func_t tc_func;
  thread_call_param_t tc_param0;
  thread_call_param_t tc_param1;
  uint64_t tc_submit_count;
  uint64_t tc_finish_count;
};

/* 11108 */
struct __attribute__((aligned(4))) turnstile_0
{
  union
  {
    struct
    {
      _BYTE gap0[4];
    };
    waitq_0 ts_waitq;
  };
  union
  {
    turnstile_list ts_free_turnstiles;
    struct
    {
      turnstile *sle_next;
    } ts_free_elm;
    mpsc_queue_chain ts_deallocate_link;
  };
  priority_queue_sched_max ts_inheritor_queue;
  priority_queue_entry_sched ts_inheritor_links;
  struct
  {
    turnstile *sle_next;
  } ts_htable_link;
  uintptr_t ts_proprietor;
  os_ref_atomic_t ts_refcount;
  uint32_t ts_type_gencount;
  uint32_t ts_prim_count;
  turnstile_update_flags_t ts_inheritor_flags;
  uint8_t ts_priority;
};

/* 11109 */
struct __attribute__((aligned(16))) ipc_port_0
{
  ipc_object ip_object;
  union
  {
    struct
    {
      _BYTE gap0[4];
    };
    waitq_0 ip_waitq;
  };
  ipc_mqueue_0 ip_messages;
  _BYTE gap40[8];
  union
  {
    uintptr_t ip_kobject;
    ipc_importance_task_t ip_imp_task;
    ipc_port *ip_sync_inheritor_port;
    knote *ip_sync_inheritor_knote;
    turnstile *ip_sync_inheritor_ts;
  };
  _BYTE gap50[8];
  ipc_port *ip_nsrequest;
  _BYTE gap60[16];
  mach_vm_address_t_0 ip_context;
  natural_t ip_impcount;
  mach_port_mscount_t ip_mscount;
  mach_port_rights_t ip_srights;
  mach_port_rights_t ip_sorights;
};

/* 11110 */
struct thread_0
{
  union
  {
    queue_chain_t_0 runq_links;
    queue_chain_t_0 wait_links;
    mpsc_queue_chain mpsc_links;
    priority_queue_entry_sched wait_prioq_links;
  };
  event64_t wait_event;
  processor_t runq;
  waitq_t waitq;
  turnstile *turnstile;
  void *inheritor;
  priority_queue_sched_max sched_inheritor_queue;
  priority_queue_sched_max base_inheritor_queue;
  priority_queue_entry_stable th_clutch_runq_link;
  priority_queue_entry_sched th_clutch_pri_link;
  queue_chain_t_0 th_clutch_timeshare_link;
  simple_lock_data_t_0 sched_lock;
  simple_lock_data_t_0 wake_lock;
  uint16_t options;
  bool wake_active;
  bool at_safe_point;
  uint8_t sched_saved_run_weight;
  ast_t reason;
  uint32_t quantum_remaining;
  wait_result_t wait_result;
  thread_rr_state_t t_rr_state;
  thread_continue_t continuation;
  void *parameter;
  vm_offset_t kernel_stack;
  vm_offset_t reserved_stack;
  machine_thread machine;
  int state;
  sched_mode_t sched_mode;
  sched_mode_t saved_mode;
  sched_bucket_t th_sched_bucket;
  sfi_class_id_t sfi_class;
  sfi_class_id_t sfi_wait_class;
  uint32_t sched_flags;
  int16_t sched_pri;
  int16_t base_pri;
  int16_t req_base_pri;
  int16_t max_priority;
  int16_t task_priority;
  int16_t promotion_priority;
  uint16_t priority_floor_count;
  int16_t suspend_count;
  int iotier_override;
  os_ref_atomic_t ref_count;
  uint32_t rwlock_count;
  integer_t importance;
  integer_t depress_timer_active;
  timer_call_t depress_timer;
  struct
  {
    uint32_t period;
    uint32_t computation;
    uint32_t constraint;
    bool preemptible;
    uint8_t priority_offset;
    uint64_t deadline;
  } realtime;
  uint64_t last_run_time;
  uint64_t last_made_runnable_time;
  uint64_t last_basepri_change_time;
  uint64_t same_pri_latency;
  uint64_t workq_quantum_deadline;
  thread_group *thread_group;
  sched_group_t sched_group;
  processor_t bound_processor;
  processor_t last_processor;
  processor_t chosen_processor;
  uint64_t computation_metered;
  uint64_t computation_epoch;
  uint64_t safe_release;
  void (*sched_call)(int, thread_t_0);
  natural_t sched_stamp;
  natural_t sched_usage;
  natural_t pri_shift;
  natural_t cpu_usage;
  natural_t cpu_delta;
  uint32_t c_switch;
  uint32_t p_switch;
  uint32_t ps_switch;
  integer_t mutex_count;
  uint64_t sched_time_save;
  uint64_t vtimer_user_save;
  uint64_t vtimer_prof_save;
  uint64_t vtimer_rlim_save;
  uint64_t vtimer_qos_save;
  timer_data_t runnable_timer;
  recount_thread th_recount;
  uint64_t wait_sfi_begin_time;
  queue_chain_t_0 affinity_threads;
  affinity_set_t affinity_set;
  task_watch_t *taskwatch;
  union
  {
    struct
    {
      mach_msg_return_t state;
      mach_port_seqno_t seqno;
      ipc_object_t object;
      mach_vm_address_t_0 msg_addr;
      mach_vm_address_t_0 aux_addr;
      mach_msg_size_t max_msize;
      mach_msg_size_t max_asize;
      mach_msg_size_t msize;
      mach_msg_size_t asize;
      _BYTE gap30[8];
      mach_port_name_t_0 receiver_name;
      union
      {
        ipc_kmsg *kmsg;
        ipc_mqueue *peekq;
      };
    } receive;
    struct
    {
      semaphore *waitsemaphore;
      semaphore *signalsemaphore;
      int options;
      kern_return_t result;
      mach_msg_continue_t continuation;
    } sema;
    struct
    {
      void *tls[8];
    } iokit;
  } saved;
  union
  {
    thread_call_thread_state *thc_state;
    struct
    {
      mach_exception_code_t code;
      mach_exception_subcode_t subcode;
    } guard_exc_info;
  };
  int32_t user_stop_count;
  natural_t ith_assertions;
  circle_queue_head_t ith_messages;
  mach_port_t_2 ith_kernel_reply_port;
  volatile ast_t ast;
  vm_offset_t recover;
  queue_chain_t_0 threads;
  queue_chain_t_0 task_threads;
  thread_ro *t_tro;
  vm_map_t_0 map;
  thread_t_0 handoff_thread;
  timer_call_t wait_timer;
  uint16_t wait_timer_active;
  bool wait_timer_armed;
  lck_mtx_t_0 mutex;
  ipc_port *ith_special_reply_port;
  uint16_t t_dtrace_flags;
  uint16_t t_dtrace_inprobe;
  uint32_t t_dtrace_predcache;
  int64_t t_dtrace_tracing;
  int64_t t_dtrace_vtime;
  clock_sec_t t_page_creation_time;
  uint32_t t_page_creation_count;
  uint32_t t_page_creation_throttled;
  int t_pagein_error;
  uint32_t kperf_ast;
  uint32_t kperf_pet_gen;
  uint32_t kperf_c_switch;
  uint32_t kperf_pet_cnt;
  uint64_t *kpc_buf;
  uint32_t syscalls_unix;
  uint32_t syscalls_mach;
  ledger_t t_ledger;
  ledger_t t_threadledger;
  ledger_t t_bankledger;
  uint64_t t_deduct_bank_ledger_time;
  uint64_t t_deduct_bank_ledger_energy;
  uint64_t thread_id;
  uint32_t ctid;
  uint32_t ctsid;
  thread_requested_policy requested_policy;
  thread_effective_policy effective_policy;
  thread_qos_override *overrides;
  uint32_t kevent_overrides;
  uint8_t user_promotion_basepri;
  uint8_t kern_promotion_schedpri;
  uint16_t kevent_ast_bits;
  io_stat_info_t thread_io_stats;
  uint32_t thread_callout_interrupt_wakeups;
  uint32_t thread_callout_platform_idle_wakeups;
  uint32_t thread_timer_wakeups_bin_1;
  uint32_t thread_timer_wakeups_bin_2;
  _BYTE gap4A8[4];
  mach_port_name_t_0 ith_voucher_name;
  ipc_voucher_t ith_voucher;
  thread_group *preadopt_thread_group;
  thread_group *old_preadopt_thread_group;
  thread_group *bank_thread_group;
  union
  {
    thread_group *auto_join_thread_group;
    thread_group *work_interval_thread_group;
  };
  work_interval *th_work_interval;
  _BYTE gap4E0[4];
  uint32_t th_bound_cluster_id;
  turnstile_update_flags_t inheritor_flags;
  block_hint_t pending_block_hint;
  block_hint_t block_hint;
  uint32_t decompressions;
  int thread_region_page_shift;
  void *decmp_upl;
  knote *ith_knote;
};

/* 11111 */
struct semaphore_0
{
  queue_chain_t_0 task_link;
  waitq_0 waitq;
  task_t_0 owner;
  ipc_port_t_1 port;
  os_ref_atomic_t ref_count;
  int count;
};

/* 11112 */
struct memory_object_3
{
  mo_ipc_object_bits_t mo_ikot;
  os_ref_atomic_t mo_ref;
  const memory_object_pager_ops_3 *mo_pager_ops;
  memory_object_control_t mo_control;
};

/* 11113 */
struct task_1
{
  lck_mtx_t_0 lock;
  os_refcnt_t ref_count;
  bool active;
  bool ipc_active;
  bool halting;
  bool message_app_suspended;
  uint32_t vtimers;
  uint32_t loadTag;
  uint64_t task_uniqueid;
  __attribute__((aligned(16))) queue_chain_t_0 tasks;
  task_watchports *watchports;
  turnstile_inheritor_t returnwait_inheritor;
  sched_group_t sched_group;
  queue_head_t_0 threads;
  restartable_ranges *t_rr_ranges;
  processor_set_t pset_hint;
  affinity_space *affinity_space;
  int thread_count;
  uint32_t active_thread_count;
  int suspend_count;
  integer_t user_stop_count;
  integer_t legacy_stop_count;
  int16_t priority;
  int16_t max_priority;
  integer_t importance;
  uint64_t total_runnable_time;
  recount_task_0 tk_recount;
  lck_mtx_t_0 itk_lock_data;
  _BYTE gapC8[48];
  exception_action exc_actions[14];
  _BYTE gap2B8[80];
  ledger_t ledger;
  queue_head_t_0 semaphore_list;
  int semaphores_owned;
  unsigned int priv_flags;
  __attribute__((aligned(16))) uint64_t rop_pid;
  uint64_t jop_pid;
  uint8_t disable_user_jop;
  arm64_uexc_region_t uexc;
  bool preserve_x18;
  counter_t faults;
  counter_t pageins;
  counter_t cow_faults;
  counter_t messages_sent;
  counter_t messages_received;
  uint32_t decompressions;
  uint32_t syscalls_mach;
  uint32_t syscalls_unix;
  uint32_t c_switch;
  uint32_t p_switch;
  uint32_t ps_switch;
  proc_ro *bsd_info_ro;
  kcdata_descriptor_t corpse_info;
  uint64_t crashed_thread_id;
  queue_chain_t_0 corpse_tasks;
  label *crash_label;
  volatile uint32_t t_flags;
  uint32_t t_procflags;
  mach_vm_address_t_0 all_image_info_addr;
  mach_vm_size_t_0 all_image_info_size;
  uint32_t t_kpc;
  bool pidsuspended;
  bool frozen;
  bool changing_freeze_state;
  bool is_large_corpse;
  _BYTE gap400[2];
  uint8_t rusage_cpu_flags;
  uint8_t rusage_cpu_percentage;
  uint8_t rusage_cpu_perthr_percentage;
  uint8_t t_returnwaitflags;
  bool shared_region_auth_remapped;
  char *shared_region_id;
  vm_shared_region *shared_region;
  uint64_t rusage_cpu_interval;
  uint64_t rusage_cpu_perthr_interval;
  uint64_t rusage_cpu_deadline;
  thread_call_t rusage_cpu_callt;
  queue_head_t_0 task_watchers;
  int num_taskwatchers;
  int watchapplying;
  bank_task *bank_context;
  ipc_importance_task *task_imp_base;
  vm_extmod_statistics_data_t extmod_statistics;
  task_requested_policy requested_policy;
  task_effective_policy effective_policy;
  _BYTE gap4A0[8];
  io_stat_info_t task_io_stats;
  task_writes_counters task_writes_counters_internal;
  task_writes_counters task_writes_counters_external;
  _cpu_time_qos_stats cpu_time_eqos_stats;
  _cpu_time_qos_stats cpu_time_rqos_stats;
  uint32_t task_timer_wakeups_bin_1;
  uint32_t task_timer_wakeups_bin_2;
  uint64_t task_gpu_ns;
  uint8_t task_can_transfer_memory_ownership;
  uint8_t task_objects_disowning;
  uint8_t task_objects_disowned;
  int task_volatile_objects;
  int task_nonvolatile_objects;
  int task_owned_objects;
  queue_head_t_0 task_objq;
  lck_mtx_t_0 task_objq_lock;
  _BYTE gap5A0[8];
  coalition_t coalition[2];
  queue_chain_t_0 task_coalition[2];
  uint64_t dispatchqueue_offset;
  task_exc_guard_behavior_t task_exc_guard;
  mach_vm_address_t_0 mach_header_vm_address;
  queue_head_t_0 io_user_clients;
  boolean_t donates_own_pages;
  uint32_t task_shared_region_slide;
  uint64_t task_fs_metadata_writes;
  uuid_t_0 task_shared_region_uuid;
  uint64_t memstat_dirty_start;
  vmobject_list_output_t corpse_vmobject_list;
  uint64_t corpse_vmobject_list_size;
  vm_deferred_reclamation_metadata_t deferred_reclamation_metadata;
};

/* 11114 */
typedef ml_processor_info_1 ml_processor_info_t_1;

/* 11115 */
enum ml_page_protection_t : __int32
{
  ML_PAGE_PROT_KERNEL = 0x0,
  ML_PAGE_PROT_PPL = 0x1,
  ML_PAGE_PROT_SPTM = 0x2,
};

/* 11116 */
struct lck_mtx_startup_spec_1
{
  lck_mtx_t *lck;
  lck_grp_t *lck_grp;
  lck_attr_t *lck_attr;
};

/* 11117 */
union arm_cpuid_id_aa64dfr0_el1
{
  struct
  {
    _BYTE gap0[8];
  } debug_feature;
  uint64_t value;
};

/* 11118 */
struct arm_mvfp_info_t
{
  uint32_t neon;
  uint32_t neon_hpfp;
  uint32_t neon_fp16;
};

/* 11119 */
struct arm64_uexc_fault_frame_t
{
  uint64_t pc;
  uint64_t sp;
  uint64_t esr;
  uint64_t far;
  uint64_t refcon;
};

/* 11120 */
enum esr_exception_class_t : __int32
{
  ESR_EC_UNCATEGORIZED = 0x0,
  ESR_EC_WFI_WFE = 0x1,
  ESR_EC_MCR_MRC_CP15_TRAP = 0x3,
  ESR_EC_MCRR_MRRC_CP15_TRAP = 0x4,
  ESR_EC_MCR_MRC_CP14_TRAP = 0x5,
  ESR_EC_LDC_STC_CP14_TRAP = 0x6,
  ESR_EC_TRAP_SIMD_FP = 0x7,
  ESR_EC_PTRAUTH_INSTR_TRAP = 0x9,
  ESR_EC_MCRR_MRRC_CP14_TRAP = 0xC,
  ESR_EC_ILLEGAL_INSTR_SET = 0xE,
  ESR_EC_SVC_32 = 0x11,
  ESR_EC_HVC_32 = 0x12,
  ESR_EC_SVC_64 = 0x15,
  ESR_EC_HVC_64 = 0x16,
  ESR_EC_MSR_TRAP = 0x18,
  ESR_EC_PAC_FAIL = 0x1C,
  ESR_EC_IABORT_EL0 = 0x20,
  ESR_EC_IABORT_EL1 = 0x21,
  ESR_EC_PC_ALIGN = 0x22,
  ESR_EC_DABORT_EL0 = 0x24,
  ESR_EC_DABORT_EL1 = 0x25,
  ESR_EC_SP_ALIGN = 0x26,
  ESR_EC_FLOATING_POINT_32 = 0x28,
  ESR_EC_FLOATING_POINT_64 = 0x2C,
  ESR_EC_SERROR_INTERRUPT = 0x2F,
  ESR_EC_BKPT_REG_MATCH_EL0 = 0x30,
  ESR_EC_BKPT_REG_MATCH_EL1 = 0x31,
  ESR_EC_SW_STEP_DEBUG_EL0 = 0x32,
  ESR_EC_SW_STEP_DEBUG_EL1 = 0x33,
  ESR_EC_WATCHPT_MATCH_EL0 = 0x34,
  ESR_EC_WATCHPT_MATCH_EL1 = 0x35,
  ESR_EC_BKPT_AARCH32 = 0x38,
  ESR_EC_BRK_AARCH64 = 0x3C,
  ESR_EC_PRIV = 0x3F,
};

/* 11121 */
typedef kern_return_t (*perfCallback)(int, arm_saved_state *, int, int);

/* 11122 */
typedef lowglo_0 lowglo_1;

/* 11123 */
struct kmem_return_t_1
{
  kern_return_t kmr_return;
  union
  {
    vm_address_t_0 kmr_address;
    vm_size_t_0 kmr_size;
    void *kmr_ptr;
    vm_map_t_0 kmr_submap;
  };
};

/* 11124 */
typedef mach_header_64_2 kernel_mach_header_t_1;

/* 11125 */
typedef segment_command_64_1 kernel_segment_command_t_1;

/* 11126 */
typedef mach_header_64_3 kernel_mach_header_t_2;

/* 11127 */
union arm_cache_ccsidr_info_t
{
  arm_cache_ccsidr_t bits;
  uint32_t value;
};

/* 11128 */
union arm_cache_clidr_info_t
{
  arm_cache_clidr_t bits;
  uint32_t value;
};

/* 11129 */
struct lck_rw_startup_spec_0
{
  lck_rw_t *lck;
  lck_grp_t *lck_grp;
  lck_attr_t *lck_attr;
};

/* 11130 */
typedef processor_cpu_stat64 *processor_cpu_stat64_t;

/* 11131 */
typedef processor_cpu_stat *processor_cpu_stat_t;

/* 11132 */
struct percpu_base
{
  vm_address_t_0 start;
  vm_address_t_0 end;
  vm_offset_t size;
};

/* 11133 */
struct lck_rw_startup_spec_1
{
  lck_rw_t *lck;
  lck_grp_t *lck_grp;
  lck_attr_t *lck_attr;
};

/* 11134 */
typedef sysreg_restore sysreg_restore_t;

/* 11135 */
enum pv_alloc_return_t : __int32
{
  PV_ALLOC_SUCCESS = 0x0,
  PV_ALLOC_RETRY = 0x1,
  PV_ALLOC_FAIL = 0x2,
};

/* 11136 */
typedef cpu_data_0 cpu_data_t_0;

/* 11137 */
typedef pmap_cpu_data_0 pmap_cpu_data_t_0;

/* 11138 */
struct __attribute__((aligned(8))) pmap_0
{
  tt_entry_t *tte;
  pmap_paddr_t ttep;
  vm_map_address_t min;
  vm_map_address_t max;
  const page_table_attr *pmap_pt_attr;
  ledger_t ledger;
  lck_rw_t_0 rwlock;
  queue_chain_t_0 pmaps;
  tt_entry_t *tt_entry_free;
  pmap *nested_pmap;
  vm_map_address_t nested_region_addr;
  vm_map_offset_t nested_region_size;
  vm_map_offset_t nested_region_true_start;
  vm_map_offset_t nested_region_true_end;
  unsigned int *nested_region_asid_bitmap;
  unsigned int nested_region_asid_bitmap_size;
  int32_t ref_count;
  uint32_t nested_no_bounds_refcnt;
  uint16_t hw_asid;
  uint8_t sw_asid;
  bool pmap_vm_map_cs_enforced;
  bool is_x86_64;
  unsigned int lpai1;
  unsigned int lpai2;
  bool is_rosetta;
  bool nx_enabled;
  bool is_64bit;
  bool nested_has_no_bounds_ref;
  bool nested_bounds_set;
  bool disable_jop;
  uint8_t type;
};

/* 11139 */
struct __attribute__((aligned(8))) usimple_lock_startup_spec_0
{
  usimple_lock_t_0 lck;
  unsigned __int16 lck_init_arg;
};

/* 11140 */
typedef _TrustCacheQueryToken_0 TrustCacheQueryToken_t_0;

/* 11141 */
struct pmap_iommu_ret
{
  uint32_t kr;
  uint32_t pages_needed;
};

/* 11142 */
struct zone_0
{
  zone *z_self;
  zone_stats_t z_stats;
  const char *z_name;
  zone_view *z_views;
  zone_expand *z_expander;
  uint64_t z_quo_magic;
  uint32_t z_align_magic;
  uint16_t z_elem_size;
  uint16_t z_elem_offs;
  uint16_t z_chunk_pages;
  uint16_t z_chunk_elems;
  zone_cache *z_pcpu_cache;
  zone_depot z_recirc;
  hw_lck_ticket_t z_recirc_lock;
  uint32_t z_recirc_full_min;
  uint32_t z_recirc_full_wma;
  union
  {
    uint32_t z_recirc_empty_min;
    uint32_t z_elems_free_min;
  };
  union
  {
    uint32_t z_recirc_empty_wma;
    uint32_t z_elems_free_wma;
  };
  uint32_t z_recirc_cont_cur;
  uint32_t z_recirc_cont_wma;
  uint16_t z_depot_size;
  uint16_t z_depot_limit;
  hw_lck_ticket_t z_lock;
  uint32_t z_wired_max;
  uint32_t z_wired_hwm;
  uint32_t z_wired_cur;
  uint32_t z_wired_empty;
  uint32_t z_va_cur;
  zone_pva_t z_pageq_empty;
  zone_pva_t z_pageq_partial;
  zone_pva_t z_pageq_full;
  zone_pva_t z_pageq_va;
  uint32_t z_elems_free;
  uint32_t z_elems_avail;
  uint32_t z_elems_rsv;
  uint32_t z_array_size_class;
  zone *z_kt_next;
  uint8_t z_cacheline3[];
};

/* 11143 */
typedef memory_object_attr_info memory_object_attr_info_data_t;

/* 11144 */
typedef fourk_pager_backing *fourk_pager_backing_t;

/* 11145 */
typedef upl_page_info_1 upl_page_info_t_1;

/* 11146 */
typedef health_test_result health_test_result_t;

/* 11147 */
typedef entropy_data entropy_data_t;

/* 11148 */
struct user32_dyld_all_image_infos_0
{
  uint32_t version;
  uint32_t infoArrayCount;
  user32_addr_t infoArray;
  user32_addr_t notification;
  dyld_bool processDetachedFromSharedRegion;
  dyld_bool libSystemInitialized;
  user32_addr_t dyldImageLoadAddress;
  user32_addr_t jitInfo;
  user32_addr_t dyldVersion;
  user32_addr_t errorMessage;
  user32_addr_t terminationFlags;
  user32_addr_t coreSymbolicationShmPage;
  user32_addr_t systemOrderFlag;
  user32_size_t uuidArrayCount;
  user32_addr_t uuidArray;
  user32_addr_t dyldAllImageInfosAddress;
  user32_addr_t initialImageCount;
  user32_addr_t errorKind;
  user32_addr_t errorClientOfDylibPath;
  user32_addr_t errorTargetDylibPath;
  user32_addr_t errorSymbol;
  user32_addr_t sharedCacheSlide;
  uint8_t sharedCacheUUID[16];
  user32_addr_t sharedCacheBaseAddress;
  uint64_t timestamp;
  user32_addr_t dyldpath;
  mach_port_name_t_0 notifyMachPorts[8];
  user32_addr_t reserved[5];
  user32_addr_t compact_dyld_image_info_addr;
  user32_size_t compact_dyld_image_info_size;
};

/* 11149 */
struct user64_dyld_all_image_infos_0
{
  uint32_t version;
  uint32_t infoArrayCount;
  user64_addr_t infoArray;
  user64_addr_t notification;
  dyld_bool processDetachedFromSharedRegion;
  dyld_bool libSystemInitialized;
  user64_addr_t dyldImageLoadAddress;
  user64_addr_t jitInfo;
  user64_addr_t dyldVersion;
  user64_addr_t errorMessage;
  user64_addr_t terminationFlags;
  user64_addr_t coreSymbolicationShmPage;
  user64_addr_t systemOrderFlag;
  user64_size_t uuidArrayCount;
  user64_addr_t uuidArray;
  user64_addr_t dyldAllImageInfosAddress;
  user64_addr_t initialImageCount;
  user64_addr_t errorKind;
  user64_addr_t errorClientOfDylibPath;
  user64_addr_t errorTargetDylibPath;
  user64_addr_t errorSymbol;
  user64_addr_t sharedCacheSlide;
  uint8_t sharedCacheUUID[16];
  user64_addr_t sharedCacheBaseAddress;
  uint64_t timestamp;
  user64_addr_t dyldPath;
  mach_port_name_t_0 notifyMachPorts[8];
  user64_addr_t reserved[9];
  user64_addr_t compact_dyld_image_info_addr;
  user64_size_t compact_dyld_image_info_size;
  uint32_t platform;
  uint32_t aotInfoArrayCount;
  user64_addr_t aotInfoArray;
  uint64_t aotTimestamp;
};

/* 11150 */
struct __attribute__((aligned(8))) processor_0
{
  processor_state_t state;
  bool is_SMT;
  bool is_recommended;
  bool current_is_NO_SMT;
  bool current_is_bound;
  bool current_is_eagerpreempt;
  thread *active_thread;
  thread *idle_thread;
  thread *startup_thread;
  processor_set_t processor_set;
  int current_pri;
  sfi_class_id_t current_sfi_class;
  perfcontrol_class_t current_perfctl_class;
  pset_cluster_type_t current_recommended_pset_type;
  thread_urgency_t current_urgency;
  int runq_bound_count;
  thread_group *current_thread_group;
  int starting_pri;
  int cpu_id;
  uint64_t quantum_end;
  uint64_t last_dispatch;
  uint64_t kperf_last_sample_time;
  uint64_t deadline;
  bool first_timeslice;
  bool processor_offlined;
  bool must_idle;
  bool running_timers_active;
  timer_call_1 running_timers[2];
  run_queue runq;
  recount_processor pr_recount;
  processor_t processor_primary;
  processor_t processor_secondary;
  ipc_port *processor_self;
  processor_t processor_list;
  uint64_t timer_call_ttd;
  simple_lock_data_t_0 start_state_lock;
  processor_reason_t last_startup_reason;
  processor_reason_t last_shutdown_reason;
  processor_reason_t last_recommend_reason;
  processor_reason_t last_derecommend_reason;
  bool shutdown_temporary;
  bool shutdown_locked;
};

/* 11151 */
enum vt100state_e : __int32
{
  vt100state_e::ESnormal = 0x0,
  vt100state_e::ESesc = 0x1,
  vt100state_e::ESsquare = 0x2,
  vt100state_e::ESgetpars = 0x3,
  vt100state_e::ESgotpars = 0x4,
  vt100state_e::ESfunckey = 0x5,
  vt100state_e::EShash = 0x6,
  vt100state_e::ESsetG0 = 0x7,
  vt100state_e::ESsetG1 = 0x8,
  vt100state_e::ESask = 0x9,
  vt100state_e::EScharsize = 0xA,
  vt100state_e::ESignore = 0xB,
};

/* 11152 */
struct kperf_context_0
{
  int cur_pid;
  thread_t_1 cur_thread;
  task_t_0 cur_task;
  uintptr_t *starting_fp;
  unsigned int trigger_type;
  unsigned int trigger_id;
};

/* 11153 */
struct task_watchports_0
{
  os_refcnt_t tw_refcount;
  task_t_0 tw_task;
  thread_t_1 tw_thread;
  uint32_t tw_elem_array_count;
  task_watchport_elem tw_elem[];
};

/* 11154 */
struct ipc_space_0
{
  lck_ticket_t_0 is_lock;
  os_ref_atomic_t is_bits;
  ipc_entry_num_t is_table_hashed;
  ipc_entry_num_t is_table_free;
  struct
  {
    __attribute__((aligned(8))) _BYTE gap0[8];
  } is_table;
  _BYTE gap28[8];
  thread_t_1 is_grower;
  ipc_label_t is_label;
  ipc_entry_num_t is_low_mod;
  ipc_entry_num_t is_high_mod;
  bool_gen bool_gen;
  unsigned int is_entropy[1];
  int is_node_id;
};

/* 11155 */
struct __attribute__((aligned(16))) ipc_port_1
{
  ipc_object ip_object;
  union
  {
    struct
    {
      _BYTE gap0[4];
    };
    waitq_0 ip_waitq;
  };
  ipc_mqueue ip_messages;
  _BYTE gap40[8];
  union
  {
    uintptr_t ip_kobject;
    ipc_importance_task_t ip_imp_task;
    ipc_port *ip_sync_inheritor_port;
    knote *ip_sync_inheritor_knote;
    turnstile *ip_sync_inheritor_ts;
  };
  _BYTE gap50[8];
  ipc_port *ip_nsrequest;
  _BYTE gap60[16];
  mach_vm_address_t_0 ip_context;
  natural_t ip_impcount;
  mach_port_mscount_t ip_mscount;
  mach_port_rights_t ip_srights;
  mach_port_rights_t ip_sorights;
};

/* 11156 */
struct thread_1
{
  union
  {
    queue_chain_t_0 runq_links;
    queue_chain_t_0 wait_links;
    mpsc_queue_chain mpsc_links;
    priority_queue_entry_sched wait_prioq_links;
  };
  event64_t wait_event;
  processor_t runq;
  waitq_t waitq;
  turnstile *turnstile;
  void *inheritor;
  priority_queue_sched_max sched_inheritor_queue;
  priority_queue_sched_max base_inheritor_queue;
  priority_queue_entry_stable th_clutch_runq_link;
  priority_queue_entry_sched th_clutch_pri_link;
  queue_chain_t_0 th_clutch_timeshare_link;
  simple_lock_data_t_0 sched_lock;
  simple_lock_data_t_0 wake_lock;
  uint16_t options;
  bool wake_active;
  bool at_safe_point;
  uint8_t sched_saved_run_weight;
  ast_t reason;
  uint32_t quantum_remaining;
  wait_result_t wait_result;
  thread_rr_state_t t_rr_state;
  thread_continue_t continuation;
  void *parameter;
  vm_offset_t kernel_stack;
  vm_offset_t reserved_stack;
  machine_thread machine;
  int state;
  sched_mode_t sched_mode;
  sched_mode_t saved_mode;
  sched_bucket_t th_sched_bucket;
  sfi_class_id_t sfi_class;
  sfi_class_id_t sfi_wait_class;
  uint32_t sched_flags;
  int16_t sched_pri;
  int16_t base_pri;
  int16_t req_base_pri;
  int16_t max_priority;
  int16_t task_priority;
  int16_t promotion_priority;
  uint16_t priority_floor_count;
  int16_t suspend_count;
  int iotier_override;
  os_ref_atomic_t ref_count;
  uint32_t rwlock_count;
  integer_t importance;
  integer_t depress_timer_active;
  timer_call_t depress_timer;
  struct
  {
    uint32_t period;
    uint32_t computation;
    uint32_t constraint;
    bool preemptible;
    uint8_t priority_offset;
    uint64_t deadline;
  } realtime;
  uint64_t last_run_time;
  uint64_t last_made_runnable_time;
  uint64_t last_basepri_change_time;
  uint64_t same_pri_latency;
  uint64_t workq_quantum_deadline;
  thread_group *thread_group;
  sched_group_t sched_group;
  processor_t bound_processor;
  processor_t last_processor;
  processor_t chosen_processor;
  uint64_t computation_metered;
  uint64_t computation_epoch;
  uint64_t safe_release;
  void (*sched_call)(int, thread_t_0);
  natural_t sched_stamp;
  natural_t sched_usage;
  natural_t pri_shift;
  natural_t cpu_usage;
  natural_t cpu_delta;
  uint32_t c_switch;
  uint32_t p_switch;
  uint32_t ps_switch;
  integer_t mutex_count;
  uint64_t sched_time_save;
  uint64_t vtimer_user_save;
  uint64_t vtimer_prof_save;
  uint64_t vtimer_rlim_save;
  uint64_t vtimer_qos_save;
  timer_data_t runnable_timer;
  recount_thread th_recount;
  uint64_t wait_sfi_begin_time;
  queue_chain_t_0 affinity_threads;
  affinity_set_t affinity_set;
  task_watch_t *taskwatch;
  union
  {
    struct
    {
      mach_msg_return_t state;
      mach_port_seqno_t seqno;
      ipc_object_t object;
      mach_vm_address_t_0 msg_addr;
      mach_vm_address_t_0 aux_addr;
      mach_msg_size_t max_msize;
      mach_msg_size_t max_asize;
      mach_msg_size_t msize;
      mach_msg_size_t asize;
      _BYTE gap30[8];
      mach_port_name_t_0 receiver_name;
      union
      {
        ipc_kmsg *kmsg;
        ipc_mqueue *peekq;
      };
    } receive;
    struct
    {
      semaphore *waitsemaphore;
      semaphore *signalsemaphore;
      int options;
      kern_return_t result;
      mach_msg_continue_t continuation;
    } sema;
    struct
    {
      void *tls[8];
    } iokit;
  } saved;
  union
  {
    thread_call_thread_state *thc_state;
    struct
    {
      mach_exception_code_t code;
      mach_exception_subcode_t subcode;
    } guard_exc_info;
  };
  int32_t user_stop_count;
  natural_t ith_assertions;
  circle_queue_head_t ith_messages;
  mach_port_t_2 ith_kernel_reply_port;
  volatile ast_t ast;
  vm_offset_t recover;
  queue_chain_t_0 threads;
  queue_chain_t_0 task_threads;
  thread_ro *t_tro;
  vm_map_t_0 map;
  thread_t_1 handoff_thread;
  timer_call_t wait_timer;
  uint16_t wait_timer_active;
  bool wait_timer_armed;
  lck_mtx_t_0 mutex;
  ipc_port *ith_special_reply_port;
  uint16_t t_dtrace_flags;
  uint16_t t_dtrace_inprobe;
  uint32_t t_dtrace_predcache;
  int64_t t_dtrace_tracing;
  int64_t t_dtrace_vtime;
  clock_sec_t t_page_creation_time;
  uint32_t t_page_creation_count;
  uint32_t t_page_creation_throttled;
  int t_pagein_error;
  uint32_t kperf_ast;
  uint32_t kperf_pet_gen;
  uint32_t kperf_c_switch;
  uint32_t kperf_pet_cnt;
  uint64_t *kpc_buf;
  uint32_t syscalls_unix;
  uint32_t syscalls_mach;
  ledger_t t_ledger;
  ledger_t t_threadledger;
  ledger_t t_bankledger;
  uint64_t t_deduct_bank_ledger_time;
  uint64_t t_deduct_bank_ledger_energy;
  uint64_t thread_id;
  uint32_t ctid;
  uint32_t ctsid;
  thread_requested_policy requested_policy;
  thread_effective_policy effective_policy;
  thread_qos_override *overrides;
  uint32_t kevent_overrides;
  uint8_t user_promotion_basepri;
  uint8_t kern_promotion_schedpri;
  uint16_t kevent_ast_bits;
  io_stat_info_t thread_io_stats;
  uint32_t thread_callout_interrupt_wakeups;
  uint32_t thread_callout_platform_idle_wakeups;
  uint32_t thread_timer_wakeups_bin_1;
  uint32_t thread_timer_wakeups_bin_2;
  _BYTE gap4A8[4];
  mach_port_name_t_0 ith_voucher_name;
  ipc_voucher_t ith_voucher;
  thread_group *preadopt_thread_group;
  thread_group *old_preadopt_thread_group;
  thread_group *bank_thread_group;
  union
  {
    thread_group *auto_join_thread_group;
    thread_group *work_interval_thread_group;
  };
  work_interval *th_work_interval;
  _BYTE gap4E0[4];
  uint32_t th_bound_cluster_id;
  turnstile_update_flags_t inheritor_flags;
  block_hint_t pending_block_hint;
  block_hint_t block_hint;
  uint32_t decompressions;
  int thread_region_page_shift;
  void *decmp_upl;
  knote *ith_knote;
};

/* 11157 */
enum kperf_sampling : __int32
{
  kperf_sampling::KPERF_SAMPLING_OFF = 0x0,
  kperf_sampling::KPERF_SAMPLING_SHUTDOWN = 0x1,
  kperf_sampling::KPERF_SAMPLING_ON = 0x2,
};

/* 11158 */
struct ipc_voucher_0
{
  os_ref_atomic_t iv_refs;
  iv_index_t iv_table[8];
  ipc_port_t_0 iv_port;
  smrq_slink iv_hash_link;
};

/* 11159 */
struct task_watchports_1
{
  os_refcnt_t tw_refcount;
  task_t_1 tw_task;
  thread_t_1 tw_thread;
  uint32_t tw_elem_array_count;
  task_watchport_elem_1 tw_elem[];
};

/* 11160 */
struct thread_2
{
  union
  {
    queue_chain_t_0 runq_links;
    queue_chain_t_0 wait_links;
    mpsc_queue_chain mpsc_links;
    priority_queue_entry_sched wait_prioq_links;
  };
  event64_t wait_event;
  processor_t runq;
  waitq_t waitq;
  turnstile *turnstile;
  void *inheritor;
  priority_queue_sched_max sched_inheritor_queue;
  priority_queue_sched_max base_inheritor_queue;
  priority_queue_entry_stable th_clutch_runq_link;
  priority_queue_entry_sched th_clutch_pri_link;
  queue_chain_t_0 th_clutch_timeshare_link;
  simple_lock_data_t_0 sched_lock;
  simple_lock_data_t_0 wake_lock;
  uint16_t options;
  bool wake_active;
  bool at_safe_point;
  uint8_t sched_saved_run_weight;
  ast_t reason;
  uint32_t quantum_remaining;
  wait_result_t wait_result;
  thread_rr_state_t t_rr_state;
  thread_continue_t continuation;
  void *parameter;
  vm_offset_t kernel_stack;
  vm_offset_t reserved_stack;
  machine_thread machine;
  int state;
  sched_mode_t sched_mode;
  sched_mode_t saved_mode;
  sched_bucket_t th_sched_bucket;
  sfi_class_id_t sfi_class;
  sfi_class_id_t sfi_wait_class;
  uint32_t sched_flags;
  int16_t sched_pri;
  int16_t base_pri;
  int16_t req_base_pri;
  int16_t max_priority;
  int16_t task_priority;
  int16_t promotion_priority;
  uint16_t priority_floor_count;
  int16_t suspend_count;
  int iotier_override;
  os_ref_atomic_t ref_count;
  uint32_t rwlock_count;
  integer_t importance;
  integer_t depress_timer_active;
  timer_call_t depress_timer;
  struct
  {
    uint32_t period;
    uint32_t computation;
    uint32_t constraint;
    bool preemptible;
    uint8_t priority_offset;
    uint64_t deadline;
  } realtime;
  uint64_t last_run_time;
  uint64_t last_made_runnable_time;
  uint64_t last_basepri_change_time;
  uint64_t same_pri_latency;
  uint64_t workq_quantum_deadline;
  thread_group *thread_group;
  sched_group_t sched_group;
  processor_t bound_processor;
  processor_t last_processor;
  processor_t chosen_processor;
  uint64_t computation_metered;
  uint64_t computation_epoch;
  uint64_t safe_release;
  void (*sched_call)(int, thread_t_0);
  natural_t sched_stamp;
  natural_t sched_usage;
  natural_t pri_shift;
  natural_t cpu_usage;
  natural_t cpu_delta;
  uint32_t c_switch;
  uint32_t p_switch;
  uint32_t ps_switch;
  integer_t mutex_count;
  uint64_t sched_time_save;
  uint64_t vtimer_user_save;
  uint64_t vtimer_prof_save;
  uint64_t vtimer_rlim_save;
  uint64_t vtimer_qos_save;
  timer_data_t runnable_timer;
  recount_thread th_recount;
  uint64_t wait_sfi_begin_time;
  queue_chain_t_0 affinity_threads;
  affinity_set_t affinity_set;
  task_watch_t *taskwatch;
  union
  {
    struct
    {
      mach_msg_return_t state;
      mach_port_seqno_t seqno;
      ipc_object_t object;
      mach_vm_address_t_0 msg_addr;
      mach_vm_address_t_0 aux_addr;
      mach_msg_size_t max_msize;
      mach_msg_size_t max_asize;
      mach_msg_size_t msize;
      mach_msg_size_t asize;
      _BYTE gap30[8];
      mach_port_name_t_0 receiver_name;
      union
      {
        ipc_kmsg *kmsg;
        ipc_mqueue *peekq;
      };
    } receive;
    struct
    {
      semaphore *waitsemaphore;
      semaphore *signalsemaphore;
      int options;
      kern_return_t result;
      mach_msg_continue_t continuation;
    } sema;
    struct
    {
      void *tls[8];
    } iokit;
  } saved;
  union
  {
    thread_call_thread_state *thc_state;
    struct
    {
      mach_exception_code_t code;
      mach_exception_subcode_t subcode;
    } guard_exc_info;
  };
  int32_t user_stop_count;
  natural_t ith_assertions;
  circle_queue_head_t ith_messages;
  mach_port_t_1 ith_kernel_reply_port;
  volatile ast_t ast;
  vm_offset_t recover;
  queue_chain_t_0 threads;
  queue_chain_t_0 task_threads;
  thread_ro *t_tro;
  vm_map_t_0 map;
  thread_t_1 handoff_thread;
  timer_call_t wait_timer;
  uint16_t wait_timer_active;
  bool wait_timer_armed;
  lck_mtx_t_0 mutex;
  ipc_port *ith_special_reply_port;
  uint16_t t_dtrace_flags;
  uint16_t t_dtrace_inprobe;
  uint32_t t_dtrace_predcache;
  int64_t t_dtrace_tracing;
  int64_t t_dtrace_vtime;
  clock_sec_t t_page_creation_time;
  uint32_t t_page_creation_count;
  uint32_t t_page_creation_throttled;
  int t_pagein_error;
  uint32_t kperf_ast;
  uint32_t kperf_pet_gen;
  uint32_t kperf_c_switch;
  uint32_t kperf_pet_cnt;
  uint64_t *kpc_buf;
  uint32_t syscalls_unix;
  uint32_t syscalls_mach;
  ledger_t t_ledger;
  ledger_t t_threadledger;
  ledger_t t_bankledger;
  uint64_t t_deduct_bank_ledger_time;
  uint64_t t_deduct_bank_ledger_energy;
  uint64_t thread_id;
  uint32_t ctid;
  uint32_t ctsid;
  thread_requested_policy requested_policy;
  thread_effective_policy effective_policy;
  thread_qos_override *overrides;
  uint32_t kevent_overrides;
  uint8_t user_promotion_basepri;
  uint8_t kern_promotion_schedpri;
  uint16_t kevent_ast_bits;
  io_stat_info_t thread_io_stats;
  uint32_t thread_callout_interrupt_wakeups;
  uint32_t thread_callout_platform_idle_wakeups;
  uint32_t thread_timer_wakeups_bin_1;
  uint32_t thread_timer_wakeups_bin_2;
  _BYTE gap4A8[4];
  mach_port_name_t_0 ith_voucher_name;
  ipc_voucher_t ith_voucher;
  thread_group *preadopt_thread_group;
  thread_group *old_preadopt_thread_group;
  thread_group *bank_thread_group;
  union
  {
    thread_group *auto_join_thread_group;
    thread_group *work_interval_thread_group;
  };
  work_interval *th_work_interval;
  _BYTE gap4E0[4];
  uint32_t th_bound_cluster_id;
  turnstile_update_flags_t inheritor_flags;
  block_hint_t pending_block_hint;
  block_hint_t block_hint;
  uint32_t decompressions;
  int thread_region_page_shift;
  void *decmp_upl;
  knote *ith_knote;
};

/* 11161 */
typedef __Request__io_service_wait_quiet_with_options_t _Xio_service_wait_quiet_with_options::__Request;

/* 11162 */
typedef __Request__io_registry_entry_get_property_bin_buf_t _Xio_registry_entry_get_property_bin_buf::__Request;

/* 11163 */
typedef __Request__io_registry_entry_get_properties_bin_buf_t _Xio_registry_entry_get_properties_bin_buf::__Request;

/* 11164 */
typedef __Request__io_device_tree_entry_exists_with_name_t _Xio_device_tree_entry_exists_with_name::__Request;

/* 11165 */
typedef __Request__io_registry_entry_from_path_ool_t __Request_0;

/* 11166 */
typedef __Request__io_registry_entry_from_path_ool_t _Xio_registry_entry_from_path_ool::__Request;

/* 11167 */
typedef __Request__io_registry_entry_get_path_ool_t _Xio_registry_entry_get_path_ool::__Request;

/* 11168 */
typedef __Request__io_service_add_notification_bin_64_t __Request_1;

/* 11169 */
typedef __Request__io_service_add_notification_bin_64_t _Xio_service_add_notification_bin_64::__Request;

/* 11170 */
typedef __Request__io_service_add_notification_bin_t __Request_2;

/* 11171 */
typedef __Request__io_service_add_notification_bin_t _Xio_service_add_notification_bin::__Request;

/* 11172 */
typedef __Request__io_service_match_property_table_bin_t _Xio_service_match_property_table_bin::__Request;

/* 11173 */
typedef __Request__io_service_get_matching_services_bin_t _Xio_service_get_matching_services_bin::__Request;

/* 11174 */
typedef __Request__io_service_get_matching_service_bin_t _Xio_service_get_matching_service_bin::__Request;

/* 11175 */
typedef __Request__io_registry_entry_get_property_bin_t __Request_3;

/* 11176 */
typedef __Request__io_registry_entry_get_property_bin_t _Xio_registry_entry_get_property_bin::__Request;

/* 11177 */
typedef __Request__io_registry_entry_get_properties_bin_t _Xio_registry_entry_get_properties_bin::__Request;

/* 11178 */
typedef __Request__io_server_version_t _Xio_server_version::__Request;

/* 11179 */
typedef __Request__io_service_set_authorization_id_t _Xio_service_set_authorization_id::__Request;

/* 11180 */
typedef __Request__io_service_get_authorization_id_t _Xio_service_get_authorization_id::__Request;

/* 11181 */
typedef __Request__io_service_get_matching_service_ool_t _Xio_service_get_matching_service_ool::__Request;

/* 11182 */
typedef __Request__io_service_get_matching_service_t _Xio_service_get_matching_service::__Request;

/* 11183 */
typedef __Request__io_connect_method_var_output_t __Request_4;

/* 11184 */
typedef __Request__io_connect_method_var_output_t _Xio_connect_method_var_output::__Request;

/* 11185 */
typedef __Request__io_registry_entry_get_registry_entry_id_t _Xio_registry_entry_get_registry_entry_id::__Request;

/* 11186 */
typedef __Request__io_service_add_notification_ool_64_t __Request_5;

/* 11187 */
typedef __Request__io_service_add_notification_ool_64_t _Xio_service_add_notification_ool_64::__Request;

/* 11188 */
typedef __Request__io_service_add_interest_notification_64_t __Request_6;

/* 11189 */
typedef __Request__io_service_add_interest_notification_64_t _Xio_service_add_interest_notification_64::__Request;

/* 11190 */
typedef __Request__io_service_add_notification_64_t __Request_7;

/* 11191 */
typedef __Request__io_service_add_notification_64_t _Xio_service_add_notification_64::__Request;

/* 11192 */
typedef __Request__io_connect_set_notification_port_64_t _Xio_connect_set_notification_port_64::__Request;

/* 11193 */
typedef __Request__io_connect_async_method_t __Request_8;

/* 11194 */
typedef __Request__io_connect_async_method_t _Xio_connect_async_method::__Request;

/* 11195 */
typedef __Request__io_connect_method_t __Request_9;

/* 11196 */
typedef __Request__io_connect_method_t _Xio_connect_method::__Request;

/* 11197 */
typedef __Request__io_connect_unmap_memory_from_task_t _Xio_connect_unmap_memory_from_task::__Request;

/* 11198 */
typedef __Request__io_connect_map_memory_into_task_t _Xio_connect_map_memory_into_task::__Request;

/* 11199 */
typedef __Request__io_service_open_extended_t _Xio_service_open_extended::__Request;

/* 11200 */
typedef __Request__io_object_get_bundle_identifier_t _Xio_object_get_bundle_identifier::__Request;

/* 11201 */
typedef __Request__io_object_get_superclass_t _Xio_object_get_superclass::__Request;

/* 11202 */
typedef __Request__io_service_add_notification_ool_t __Request_10;

/* 11203 */
typedef __Request__io_service_add_notification_ool_t _Xio_service_add_notification_ool::__Request;

/* 11204 */
typedef __Request__io_service_match_property_table_ool_t _Xio_service_match_property_table_ool::__Request;

/* 11205 */
typedef __Request__io_service_get_matching_services_ool_t _Xio_service_get_matching_services_ool::__Request;

/* 11206 */
typedef __Request__io_service_get_state_t _Xio_service_get_state::__Request;

/* 11207 */
typedef __Request__io_registry_entry_get_property_recursively_t __Request_11;

/* 11208 */
typedef __Request__io_registry_entry_get_property_recursively_t _Xio_registry_entry_get_property_recursively::__Request;

/* 11209 */
typedef __Request__io_registry_entry_get_location_in_plane_t _Xio_registry_entry_get_location_in_plane::__Request;

/* 11210 */
typedef __Request__io_connect_unmap_memory_t _Xio_connect_unmap_memory::__Request;

/* 11211 */
typedef __Request__io_connect_get_notification_semaphore_t _Xio_connect_get_notification_semaphore::__Request;

/* 11212 */
typedef __Request__io_service_acknowledge_notification_t _Xio_service_acknowledge_notification::__Request;

/* 11213 */
typedef __Request__io_service_add_interest_notification_t __Request_12;

/* 11214 */
typedef __Request__io_service_add_interest_notification_t _Xio_service_add_interest_notification::__Request;

/* 11215 */
typedef __Request__io_service_add_notification_t __Request_13;

/* 11216 */
typedef __Request__io_service_add_notification_t _Xio_service_add_notification::__Request;

/* 11217 */
typedef __Request__io_async_method_structureI_structureO_t __Request_14;

/* 11218 */
typedef __Request__io_async_method_structureI_structureO_t _Xio_async_method_structureI_structureO::__Request;

/* 11219 */
typedef __Request__io_async_method_scalarI_structureI_t __Request_15;

/* 11220 */
typedef __Request__io_async_method_scalarI_structureI_t _Xio_async_method_scalarI_structureI::__Request;

/* 11221 */
typedef __Request__io_async_method_scalarI_structureO_t __Request_16;

/* 11222 */
typedef __Request__io_async_method_scalarI_structureO_t _Xio_async_method_scalarI_structureO::__Request;

/* 11223 */
typedef __Request__io_async_method_scalarI_scalarO_t __Request_17;

/* 11224 */
typedef __Request__io_async_method_scalarI_scalarO_t _Xio_async_method_scalarI_scalarO::__Request;

/* 11225 */
typedef __Request__io_service_match_property_table_t _Xio_service_match_property_table::__Request;

/* 11226 */
typedef __Request__io_registry_entry_get_name_in_plane_t _Xio_registry_entry_get_name_in_plane::__Request;

/* 11227 */
typedef __Request__io_service_request_probe_t _Xio_service_request_probe::__Request;

/* 11228 */
typedef __Request__io_catalog_reset_t _Xio_catalog_reset::__Request;

/* 11229 */
typedef __Request__io_catalog_module_loaded_t _Xio_catalog_module_loaded::__Request;

/* 11230 */
typedef __Request__io_catalog_get_gen_count_t _Xio_catalog_get_gen_count::__Request;

/* 11231 */
typedef __Request__io_catalog_get_data_t _Xio_catalog_get_data::__Request;

/* 11232 */
typedef __Request__io_catalog_terminate_t _Xio_catalog_terminate::__Request;

/* 11233 */
typedef __Request__io_catalog_send_data_t _Xio_catalog_send_data::__Request;

/* 11234 */
typedef __Request__io_iterator_is_valid_t _Xio_iterator_is_valid::__Request;

/* 11235 */
typedef __Request__io_registry_entry_create_iterator_t __Request_18;

/* 11236 */
typedef __Request__io_registry_entry_create_iterator_t _Xio_registry_entry_create_iterator::__Request;

/* 11237 */
typedef __Request__io_service_wait_quiet_t _Xio_service_wait_quiet::__Request;

/* 11238 */
typedef __Request__io_service_get_busy_state_t _Xio_service_get_busy_state::__Request;

/* 11239 */
typedef __Request__io_object_get_retain_count_t _Xio_object_get_retain_count::__Request;

/* 11240 */
typedef __Request__io_registry_entry_in_plane_t _Xio_registry_entry_in_plane::__Request;

/* 11241 */
typedef __Request__io_registry_entry_set_properties_t _Xio_registry_entry_set_properties::__Request;

/* 11242 */
typedef __Request__io_registry_get_root_entry_t _Xio_registry_get_root_entry::__Request;

/* 11243 */
typedef __Request__io_registry_entry_get_path_t _Xio_registry_entry_get_path::__Request;

/* 11244 */
typedef __Request__io_connect_method_structureI_structureO_t __Request_19;

/* 11245 */
typedef __Request__io_connect_method_structureI_structureO_t _Xio_connect_method_structureI_structureO::__Request;

/* 11246 */
typedef __Request__io_connect_method_scalarI_structureI_t __Request_20;

/* 11247 */
typedef __Request__io_connect_method_scalarI_structureI_t _Xio_connect_method_scalarI_structureI::__Request;

/* 11248 */
typedef __Request__io_connect_method_scalarI_structureO_t __Request_21;

/* 11249 */
typedef __Request__io_connect_method_scalarI_structureO_t _Xio_connect_method_scalarI_structureO::__Request;

/* 11250 */
typedef __Request__io_connect_method_scalarI_scalarO_t __Request_22;

/* 11251 */
typedef __Request__io_connect_method_scalarI_scalarO_t _Xio_connect_method_scalarI_scalarO::__Request;

/* 11252 */
typedef __Request__io_connect_set_properties_t _Xio_connect_set_properties::__Request;

/* 11253 */
typedef __Request__io_connect_add_client_t _Xio_connect_add_client::__Request;

/* 11254 */
typedef __Request__io_connect_map_memory_t _Xio_connect_map_memory::__Request;

/* 11255 */
typedef __Request__io_connect_set_notification_port_t _Xio_connect_set_notification_port::__Request;

/* 11256 */
typedef __Request__io_connect_get_service_t _Xio_connect_get_service::__Request;

/* 11257 */
typedef __Request__io_service_close_t _Xio_service_close::__Request;

/* 11258 */
typedef __Request__io_registry_entry_get_parent_iterator_t _Xio_registry_entry_get_parent_iterator::__Request;

/* 11259 */
typedef __Request__io_registry_entry_get_child_iterator_t _Xio_registry_entry_get_child_iterator::__Request;

/* 11260 */
typedef __Request__io_registry_entry_get_property_bytes_t __Request_23;

/* 11261 */
typedef __Request__io_registry_entry_get_property_bytes_t _Xio_registry_entry_get_property_bytes::__Request;

/* 11262 */
typedef __Request__io_registry_entry_get_properties_t _Xio_registry_entry_get_properties::__Request;

/* 11263 */
typedef __Request__io_registry_entry_get_name_t _Xio_registry_entry_get_name::__Request;

/* 11264 */
typedef __Request__io_registry_entry_from_path_t _Xio_registry_entry_from_path::__Request;

/* 11265 */
typedef __Request__io_registry_iterator_exit_entry_t _Xio_registry_iterator_exit_entry::__Request;

/* 11266 */
typedef __Request__io_registry_iterator_enter_entry_t _Xio_registry_iterator_enter_entry::__Request;

/* 11267 */
typedef __Request__io_registry_create_iterator_t __Request_24;

/* 11268 */
typedef __Request__io_registry_create_iterator_t _Xio_registry_create_iterator::__Request;

/* 11269 */
typedef __Request__io_registry_entry_get_property_t _Xio_registry_entry_get_property::__Request;

/* 11270 */
typedef __Request__io_service_get_matching_services_t _Xio_service_get_matching_services::__Request;

/* 11271 */
typedef __Request__io_iterator_reset_t _Xio_iterator_reset::__Request;

/* 11272 */
typedef __Request__io_iterator_next_t _Xio_iterator_next::__Request;

/* 11273 */
typedef __Request__io_object_conforms_to_t _Xio_object_conforms_to::__Request;

/* 11274 */
typedef __Request__io_object_get_class_t _Xio_object_get_class::__Request;

/* 11275 */
struct task_watchports_2
{
  os_refcnt_t tw_refcount;
  task_t_0 tw_task;
  thread_t_1 tw_thread;
  uint32_t tw_elem_array_count;
  task_watchport_elem_0 tw_elem[];
};

/* 11276 */
struct semaphore_1
{
  queue_chain_t_0 task_link;
  waitq_0 waitq;
  task_t_0 owner;
  ipc_port_t_0 port;
  os_ref_atomic_t ref_count;
  int count;
};

/* 11277 */
struct thread_3
{
  union
  {
    queue_chain_t_0 runq_links;
    queue_chain_t_0 wait_links;
    mpsc_queue_chain mpsc_links;
    priority_queue_entry_sched wait_prioq_links;
  };
  event64_t wait_event;
  processor_t runq;
  waitq_t waitq;
  turnstile *turnstile;
  void *inheritor;
  priority_queue_sched_max sched_inheritor_queue;
  priority_queue_sched_max base_inheritor_queue;
  priority_queue_entry_stable th_clutch_runq_link;
  priority_queue_entry_sched th_clutch_pri_link;
  queue_chain_t_0 th_clutch_timeshare_link;
  simple_lock_data_t_0 sched_lock;
  simple_lock_data_t_0 wake_lock;
  uint16_t options;
  bool wake_active;
  bool at_safe_point;
  uint8_t sched_saved_run_weight;
  ast_t reason;
  uint32_t quantum_remaining;
  wait_result_t wait_result;
  thread_rr_state_t t_rr_state;
  thread_continue_t continuation;
  void *parameter;
  vm_offset_t kernel_stack;
  vm_offset_t reserved_stack;
  machine_thread machine;
  int state;
  sched_mode_t sched_mode;
  sched_mode_t saved_mode;
  sched_bucket_t th_sched_bucket;
  sfi_class_id_t sfi_class;
  sfi_class_id_t sfi_wait_class;
  uint32_t sched_flags;
  int16_t sched_pri;
  int16_t base_pri;
  int16_t req_base_pri;
  int16_t max_priority;
  int16_t task_priority;
  int16_t promotion_priority;
  uint16_t priority_floor_count;
  int16_t suspend_count;
  int iotier_override;
  os_ref_atomic_t ref_count;
  uint32_t rwlock_count;
  integer_t importance;
  integer_t depress_timer_active;
  timer_call_t depress_timer;
  struct
  {
    uint32_t period;
    uint32_t computation;
    uint32_t constraint;
    bool preemptible;
    uint8_t priority_offset;
    uint64_t deadline;
  } realtime;
  uint64_t last_run_time;
  uint64_t last_made_runnable_time;
  uint64_t last_basepri_change_time;
  uint64_t same_pri_latency;
  uint64_t workq_quantum_deadline;
  thread_group *thread_group;
  sched_group_t sched_group;
  processor_t bound_processor;
  processor_t last_processor;
  processor_t chosen_processor;
  uint64_t computation_metered;
  uint64_t computation_epoch;
  uint64_t safe_release;
  void (*sched_call)(int, thread_t_0);
  natural_t sched_stamp;
  natural_t sched_usage;
  natural_t pri_shift;
  natural_t cpu_usage;
  natural_t cpu_delta;
  uint32_t c_switch;
  uint32_t p_switch;
  uint32_t ps_switch;
  integer_t mutex_count;
  uint64_t sched_time_save;
  uint64_t vtimer_user_save;
  uint64_t vtimer_prof_save;
  uint64_t vtimer_rlim_save;
  uint64_t vtimer_qos_save;
  timer_data_t runnable_timer;
  recount_thread th_recount;
  uint64_t wait_sfi_begin_time;
  queue_chain_t_0 affinity_threads;
  affinity_set_t affinity_set;
  task_watch_t *taskwatch;
  union
  {
    struct
    {
      mach_msg_return_t state;
      mach_port_seqno_t seqno;
      ipc_object_t object;
      mach_vm_address_t_0 msg_addr;
      mach_vm_address_t_0 aux_addr;
      mach_msg_size_t max_msize;
      mach_msg_size_t max_asize;
      mach_msg_size_t msize;
      mach_msg_size_t asize;
      _BYTE gap30[8];
      mach_port_name_t_0 receiver_name;
      union
      {
        ipc_kmsg *kmsg;
        ipc_mqueue *peekq;
      };
    } receive;
    struct
    {
      semaphore *waitsemaphore;
      semaphore *signalsemaphore;
      int options;
      kern_return_t result;
      mach_msg_continue_t continuation;
    } sema;
    struct
    {
      void *tls[8];
    } iokit;
  } saved;
  union
  {
    thread_call_thread_state *thc_state;
    struct
    {
      mach_exception_code_t code;
      mach_exception_subcode_t subcode;
    } guard_exc_info;
  };
  int32_t user_stop_count;
  natural_t ith_assertions;
  circle_queue_head_t ith_messages;
  mach_port_t_0 ith_kernel_reply_port;
  volatile ast_t ast;
  vm_offset_t recover;
  queue_chain_t_0 threads;
  queue_chain_t_0 task_threads;
  thread_ro *t_tro;
  vm_map_t_0 map;
  thread_t_1 handoff_thread;
  timer_call_t wait_timer;
  uint16_t wait_timer_active;
  bool wait_timer_armed;
  lck_mtx_t_0 mutex;
  ipc_port *ith_special_reply_port;
  uint16_t t_dtrace_flags;
  uint16_t t_dtrace_inprobe;
  uint32_t t_dtrace_predcache;
  int64_t t_dtrace_tracing;
  int64_t t_dtrace_vtime;
  clock_sec_t t_page_creation_time;
  uint32_t t_page_creation_count;
  uint32_t t_page_creation_throttled;
  int t_pagein_error;
  uint32_t kperf_ast;
  uint32_t kperf_pet_gen;
  uint32_t kperf_c_switch;
  uint32_t kperf_pet_cnt;
  uint64_t *kpc_buf;
  uint32_t syscalls_unix;
  uint32_t syscalls_mach;
  ledger_t t_ledger;
  ledger_t t_threadledger;
  ledger_t t_bankledger;
  uint64_t t_deduct_bank_ledger_time;
  uint64_t t_deduct_bank_ledger_energy;
  uint64_t thread_id;
  uint32_t ctid;
  uint32_t ctsid;
  thread_requested_policy requested_policy;
  thread_effective_policy effective_policy;
  thread_qos_override *overrides;
  uint32_t kevent_overrides;
  uint8_t user_promotion_basepri;
  uint8_t kern_promotion_schedpri;
  uint16_t kevent_ast_bits;
  io_stat_info_t thread_io_stats;
  uint32_t thread_callout_interrupt_wakeups;
  uint32_t thread_callout_platform_idle_wakeups;
  uint32_t thread_timer_wakeups_bin_1;
  uint32_t thread_timer_wakeups_bin_2;
  _BYTE gap4A8[4];
  mach_port_name_t_0 ith_voucher_name;
  ipc_voucher_t ith_voucher;
  thread_group *preadopt_thread_group;
  thread_group *old_preadopt_thread_group;
  thread_group *bank_thread_group;
  union
  {
    thread_group *auto_join_thread_group;
    thread_group *work_interval_thread_group;
  };
  work_interval *th_work_interval;
  _BYTE gap4E0[4];
  uint32_t th_bound_cluster_id;
  turnstile_update_flags_t inheritor_flags;
  block_hint_t pending_block_hint;
  block_hint_t block_hint;
  uint32_t decompressions;
  int thread_region_page_shift;
  void *decmp_upl;
  knote *ith_knote;
};

/* 11278 */
typedef io_object_t_1 io_ident_t;

/* 11279 */
typedef io_object_t_1 io_connect_t_0;

/* 11280 */
typedef vm_region_submap_info_64 vm_region_submap_info_data_64_t;

/* 11281 */
typedef vm_region_submap_info *vm_region_submap_info_t;

/* 11282 */
struct upl_0
{
  lck_mtx_t_0 Lock;
  int ref_count;
  int ext_ref_count;
  int flags;
  vm_object_offset_t u_offset;
  upl_size_t u_size;
  upl_size_t u_mapped_size;
  vm_offset_t kaddr;
  vm_object_t map_object;
  vector_upl_t vector_upl;
  upl_t associated_upl;
  upl_io_completion *upl_iodone;
  ppnum_t_0 highest_page;
  int upl_priority;
  uint64_t *upl_reprio_info;
  void *decmp_io_upl;
  thread_t_1 upl_creator;
  queue_chain_t_0 uplq;
  bitmap_t *lite_list;
  upl_page_info_1 page_list[];
};

/* 11283 */
typedef shared_region_jop_key_map *shared_region_jop_key_map_t;

/* 11284 */
struct _aot_cache_header
{
  char magic[8];
  uint8_t uuid[16];
  uint8_t x86_uuid[16];
  uint8_t cambria_version[32];
  uint64_t code_signature_offset;
  uint64_t code_signature_size;
  uint32_t num_code_fragments;
  uint32_t header_size;
};

/* 11285 */
struct __attribute__((aligned(8))) _dyld_cache_header
{
  char magic[16];
  uint32_t mappingOffset;
  uint32_t mappingCount;
  uint32_t imagesOffset;
  uint32_t imagesCount;
  uint64_t dyldBaseAddress;
  uint64_t codeSignatureOffset;
  uint64_t codeSignatureSize;
  uint64_t slideInfoOffset;
  uint64_t slideInfoSize;
  uint64_t localSymbolsOffset;
  uint64_t localSymbolsSize;
  uint8_t uuid[16];
  uint64_t cacheType;
  uint32_t branchPoolsOffset;
  uint32_t branchPoolsCount;
  uint64_t accelerateInfoAddr;
  uint64_t accelerateInfoSize;
  uint64_t imagesTextOffset;
  uint64_t imagesTextCount;
  uint64_t dylibsImageGroupAddr;
  uint64_t dylibsImageGroupSize;
  uint64_t otherImageGroupAddr;
  uint64_t otherImageGroupSize;
  uint64_t progClosuresAddr;
  uint64_t progClosuresSize;
  uint64_t progClosuresTrieAddr;
  uint64_t progClosuresTrieSize;
  uint32_t platform;
};

/* 11286 */
typedef slide_info_entry_toc *slide_info_entry_toc_t;

/* 11287 */
struct vm_object_0
{
  vm_page_queue_head_t memq;
  lck_rw_t_0 Lock;
  union
  {
    vm_object_size_t vou_size;
    int vou_cache_pages_to_scan;
  } vo_un1;
  vm_page *memq_hint;
  int ref_count;
  unsigned int resident_page_count;
  unsigned int wired_page_count;
  unsigned int reusable_page_count;
  vm_object *copy;
  vm_object *shadow;
  memory_object_t pager;
  union
  {
    vm_object_offset_t vou_shadow_offset;
    clock_sec_t vou_cache_ts;
    task_t_1 vou_owner;
  } vo_un2;
  vm_object_offset_t paging_offset;
  memory_object_control_t pager_control;
  memory_object_copy_strategy_t copy_strategy;
  unsigned __int16 paging_in_progress;
  unsigned __int16 vo_size_delta;
  unsigned int activity_in_progress;
  queue_chain_t_0 cached_list;
  vm_object_offset_t last_alloc;
  vm_offset_t cow_hint;
  int sequential;
  uint32_t pages_created;
  uint32_t pages_used;
  __attribute__((aligned(8))) uint8_t scan_collisions;
  uint8_t __object4_unused_bits[1];
  vm_tag_t wire_tag;
  queue_head_t_0 uplq;
  queue_chain_t_0 objq;
  queue_chain_t_0 task_objq;
};

/* 11288 */
struct __attribute__((aligned(16))) cpu_data_1
{
  short cpu_number;
  unsigned __int16 cpu_flags;
  int cpu_type;
  int cpu_subtype;
  int cpu_threadtype;
  vm_offset_t istackptr;
  vm_offset_t intstack_top;
  vm_offset_t excepstackptr;
  vm_offset_t excepstack_top;
  thread_t_1 cpu_active_thread;
  vm_offset_t cpu_active_stack;
  cpu_id_t_0 cpu_id;
  volatile unsigned int cpu_signal;
  ast_t cpu_pending_ast;
  cache_dispatch_t cpu_cache_dispatch;
  uint64_t cpu_base_timebase;
  uint64_t cpu_timebase;
  bool cpu_hibernate;
  bool cpu_running;
  bool cluster_master;
  bool sync_on_cswitch;
  bool in_state_transition;
  uint32_t cpu_decrementer;
  get_decrementer_t cpu_get_decrementer_func;
  set_decrementer_t cpu_set_decrementer_func;
  fiq_handler_t cpu_get_fiq_handler;
  void *cpu_tbd_hardware_addr;
  void *cpu_tbd_hardware_val;
  processor_idle_t_0 cpu_idle_notify;
  uint64_t cpu_idle_latency;
  uint64_t cpu_idle_pop;
  vm_offset_t cpu_reset_handler;
  uintptr_t cpu_reset_assist;
  uint32_t cpu_reset_type;
  unsigned int interrupt_source;
  void *cpu_int_state;
  IOInterruptHandler_0 interrupt_handler;
  void *interrupt_nub;
  void *interrupt_target;
  void *interrupt_refCon;
  idle_timer_t_0 idle_timer_notify;
  void *idle_timer_refcon;
  uint64_t idle_timer_deadline;
  uint64_t rtcPop;
  rtclock_timer_t rtclock_timer;
  _rtclock_data_ *rtclock_datap;
  arm_debug_state_t *cpu_user_debug;
  vm_offset_t cpu_debug_interface_map;
  volatile int debugger_active;
  volatile int PAB_active;
  void *cpu_xcall_p0;
  void *cpu_xcall_p1;
  void *cpu_imm_xcall_p0;
  void *cpu_imm_xcall_p1;
  vm_offset_t coresight_base[4];
  uint64_t cpu_regmap_paddr;
  uint32_t cpu_phys_id;
  uint32_t cpu_l2_access_penalty;
  platform_error_handler_t_0 platform_error_handler;
  int cpu_mcount_off;
  volatile unsigned int cpu_sleep_token;
  unsigned int cpu_sleep_token_last;
  cluster_type_t_0 cpu_cluster_type;
  uint32_t cpu_cluster_id;
  uint32_t cpu_l2_id;
  uint32_t cpu_l2_size;
  uint32_t cpu_l3_id;
  uint32_t cpu_l3_size;
  enum : __int32
  {
    CPU_NOT_HALTED = 0x0,
    CPU_HALTED = 0x1,
    CPU_HALTED_WITH_STATE = 0x2,
  } halt_status;
  uint64_t rop_key;
  uint64_t jop_key;
  uint64_t *cpu_kpc_buf[2];
  uint64_t *cpu_kpc_shadow;
  uint64_t *cpu_kpc_reload;
  cpu_stat_t cpu_stat;
  pmap_cpu_data cpu_pmap_cpu_data;
  dbgwrap_thread_state_t halt_state;
  uint64_t ipi_pc;
  uint64_t ipi_lr;
  uint64_t ipi_fp;
};

/* 11289 */
struct vm_shared_region_0
{
  uint32_t sr_ref_count;
  uint32_t sr_slide;
  queue_chain_t_0 sr_q;
  void *sr_root_dir;
  cpu_type_t_0 sr_cpu_type;
  cpu_subtype_t_0 sr_cpu_subtype;
  ipc_port_t_0 sr_mem_entry;
  mach_vm_offset_t sr_first_mapping;
  mach_vm_offset_t sr_base_address;
  mach_vm_size_t_0 sr_size;
  mach_vm_offset_t sr_pmap_nesting_start;
  mach_vm_size_t_0 sr_pmap_nesting_size;
  thread_call_t sr_timer_call;
  uuid_t_0 sr_uuid;
  uint8_t sr_page_shift;
  bool sr_mapping_in_progress;
  bool sr_slide_in_progress;
  bool sr_64bit;
  bool sr_persists;
  bool sr_uuid_copied;
  bool sr_stale;
  bool sr_driverkit;
  bool sr_reslide;
  uint_t sr_num_auth_section;
  uint_t sr_next_auth_section;
  vm_shared_region_slide_info_t *sr_auth_section;
  uint32_t sr_rsr_version;
  uint64_t sr_install_time;
  uint32_t sr_id;
  uint32_t sr_images_count;
  dyld_uuid_info_64 *sr_images;
  uuid_t_0 sr_aot_uuid;
  boolean_t sr_aot_uuid_copied;
  mach_vm_offset_t sr_aot_mapping;
};

/* 11290 */
struct __block_literal_2_13
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(zone_t);
  __block_descriptor *__descriptor;
};

/* 11291 */
struct vm_page_stats_reusable
{
  SInt32 reusable_count;
  uint64_t reusable;
  uint64_t reused;
  uint64_t reused_wire;
  uint64_t reused_remove;
  uint64_t all_reusable_calls;
  uint64_t partial_reusable_calls;
  uint64_t all_reuse_calls;
  uint64_t partial_reuse_calls;
  uint64_t reusable_pages_success;
  uint64_t reusable_pages_failure;
  uint64_t reusable_pages_shared;
  uint64_t reuse_pages_success;
  uint64_t reuse_pages_failure;
  uint64_t can_reuse_success;
  uint64_t can_reuse_failure;
  uint64_t reusable_reclaimed;
  uint64_t reusable_nonwritable;
  uint64_t reusable_shared;
  uint64_t free_shared;
};

/* 11292 */
typedef vm_locks_array vm_locks_array_t;

/* 11293 */
struct lck_spin_startup_spec_0
{
  lck_spin_t *lck;
  lck_grp_t *lck_grp;
  lck_attr_t *lck_attr;
};

/* 11294 */
typedef host_basic_info_0 host_basic_info_data_t_0;

/* 11295 */
struct vm_config
{
  boolean_t compressor_is_present;
  boolean_t compressor_is_active;
  boolean_t swap_is_present;
  boolean_t swap_is_active;
  boolean_t freezer_swap_is_active;
};

/* 11296 */
struct vm_pageout_state
{
  boolean_t vm_pressure_thread_running;
  boolean_t vm_pressure_changed;
  boolean_t vm_restricted_to_single_processor;
  int vm_compressor_thread_count;
  unsigned int vm_page_speculative_q_age_ms;
  unsigned int vm_page_speculative_percentage;
  unsigned int vm_page_speculative_target;
  unsigned int vm_pageout_swap_wait;
  unsigned int vm_pageout_idle_wait;
  unsigned int vm_pageout_empty_wait;
  unsigned int vm_pageout_burst_wait;
  unsigned int vm_pageout_deadlock_wait;
  unsigned int vm_pageout_deadlock_relief;
  unsigned int vm_pageout_burst_inactive_throttle;
  unsigned int vm_pageout_inactive;
  unsigned int vm_pageout_inactive_used;
  unsigned int vm_pageout_inactive_clean;
  uint32_t vm_page_filecache_min;
  uint32_t vm_page_filecache_min_divisor;
  uint32_t vm_page_xpmapped_min;
  uint32_t vm_page_xpmapped_min_divisor;
  uint64_t vm_pageout_considered_page_last;
  int vm_page_free_count_init;
  unsigned int vm_memory_pressure;
  int memorystatus_purge_on_critical;
  int memorystatus_purge_on_warning;
  int memorystatus_purge_on_urgent;
  thread_t_0 vm_pageout_early_swapout_iothread;
};

/* 11297 */
struct vm_pageout_vminfo
{
  unsigned __int64 vm_pageout_considered_page;
  unsigned __int64 vm_pageout_considered_bq_internal;
  unsigned __int64 vm_pageout_considered_bq_external;
  unsigned __int64 vm_pageout_skipped_external;
  unsigned __int64 vm_pageout_skipped_internal;
  unsigned __int64 vm_pageout_pages_evicted;
  unsigned __int64 vm_pageout_pages_purged;
  unsigned __int64 vm_pageout_freed_cleaned;
  unsigned __int64 vm_pageout_freed_speculative;
  unsigned __int64 vm_pageout_freed_external;
  unsigned __int64 vm_pageout_freed_internal;
  unsigned __int64 vm_pageout_inactive_dirty_internal;
  unsigned __int64 vm_pageout_inactive_dirty_external;
  unsigned __int64 vm_pageout_inactive_referenced;
  unsigned __int64 vm_pageout_reactivation_limit_exceeded;
  unsigned __int64 vm_pageout_inactive_force_reclaim;
  unsigned __int64 vm_pageout_inactive_nolock;
  unsigned __int64 vm_pageout_filecache_min_reactivated;
  unsigned __int64 vm_pageout_scan_inactive_throttled_internal;
  unsigned __int64 vm_pageout_scan_inactive_throttled_external;
  uint64_t vm_pageout_compressions;
  uint64_t vm_compressor_pages_grabbed;
  unsigned __int64 vm_compressor_failed;
  unsigned __int64 vm_page_pages_freed;
  unsigned __int64 vm_phantom_cache_found_ghost;
  unsigned __int64 vm_phantom_cache_added_ghost;
  unsigned __int64 vm_pageout_protected_sharedcache;
  unsigned __int64 vm_pageout_forcereclaimed_sharedcache;
  unsigned __int64 vm_pageout_protected_realtime;
  unsigned __int64 vm_pageout_forcereclaimed_realtime;
};

/* 11298 */
typedef io_reprioritize_req *io_reprioritize_req_t;

/* 11299 */
struct vm_counters
{
  unsigned int do_collapse_compressor;
  unsigned int do_collapse_compressor_pages;
  unsigned int do_collapse_terminate;
  unsigned int do_collapse_terminate_failure;
  unsigned int should_cow_but_wired;
  unsigned int create_upl_extra_cow;
  unsigned int create_upl_extra_cow_pages;
  unsigned int create_upl_lookup_failure_write;
  unsigned int create_upl_lookup_failure_copy;
};

/* 11300 */
typedef vm_region_extended_info vm_region_extended_info_data_t;

/* 11301 */
typedef vm_page_info_basic *vm_page_info_basic_t_0;

/* 11302 */
typedef vm_region_basic_info_64 *vm_region_basic_info_64_t;

/* 11303 */
typedef vm_region_basic_info *vm_region_basic_info_t;

/* 11304 */
typedef vm_region_submap_short_info_64 *vm_region_submap_short_info_64_t;

/* 11305 */
struct __block_literal_1_28
{
  void *__isa;
  int __flags;
  int __reserved;
  _BYTE gap10[8];
  __block_descriptor *__descriptor;
  ppnum_t_0 max_pnum;
  ppnum_t_0 pnum_mask;
};

/* 11306 */
typedef kern_return_t vm_fault_return_t;

/* 11307 */
struct os_reason_1
{
  lck_mtx_t_0 osr_lock;
  os_refcnt_t osr_refcount;
  uint32_t osr_namespace;
  uint64_t osr_code;
  uint64_t osr_flags;
  uint32_t osr_bufsize;
  kcdata_descriptor_0 osr_kcd_descriptor;
  char *osr_kcd_buf;
};

/* 11308 */
struct vmrtfr
{
  int vmrtfr_maxi;
  int vmrtfr_curi;
  int64_t vmrtf_total;
  vm_rtfault_record_t *vm_rtf_records;
};

/* 11309 */
typedef int memory_object_lock_result_t;

/* 11310 */
typedef memory_object_attr_info *memory_object_attr_info_t;

/* 11311 */
typedef old_memory_object_attr_info *old_memory_object_attr_info_t;

/* 11312 */
typedef memory_object_perf_info *memory_object_perf_info_t;

/* 11313 */
typedef memory_object_behave_info *memory_object_behave_info_t;

/* 11314 */
typedef old_memory_object_behave_info *old_memory_object_behave_info_t;

/* 11315 */
enum compressor_preselect_t : __int32
{
  compressor_preselect_t::CPRESELLZ4 = 0x0,
  compressor_preselect_t::CSKIPLZ4 = 0x1,
  compressor_preselect_t::CPRESELWK = 0x2,
};

/* 11316 */
struct compressor_stats_t
{
  uint64_t lz4_compressions;
  uint64_t lz4_compression_failures;
  uint64_t lz4_compressed_bytes;
  uint64_t lz4_wk_compression_delta;
  uint64_t lz4_wk_compression_negative_delta;
  uint64_t lz4_post_wk_compressions;
  uint64_t wk_compressions;
  uint64_t wk_cabstime;
  uint64_t wk_sv_compressions;
  uint64_t wk_mzv_compressions;
  uint64_t wk_compression_failures;
  uint64_t wk_compressed_bytes_total;
  uint64_t wk_compressions_exclusive;
  uint64_t wk_compressed_bytes_exclusive;
  uint64_t wkh_compressions;
  uint64_t wkh_cabstime;
  uint64_t wks_compressions;
  uint64_t wks_cabstime;
  uint64_t wks_compressed_bytes;
  uint64_t wks_compression_failures;
  uint64_t wks_sv_compressions;
  uint64_t lz4_decompressions;
  uint64_t lz4_decompressed_bytes;
  uint64_t uc_decompressions;
  uint64_t wk_decompressions;
  uint64_t wk_dabstime;
  uint64_t wkh_decompressions;
  uint64_t wkh_dabstime;
  uint64_t wks_decompressions;
  uint64_t wks_dabstime;
  uint64_t wk_decompressed_bytes;
  uint64_t wk_sv_decompressions;
};

/* 11317 */
enum vm_compressor_mode_t : __int32
{
  CMODE_WK = 0x0,
  CMODE_LZ4 = 0x1,
  CMODE_HYB = 0x2,
  VM_COMPRESSOR_DEFAULT_CODEC = 0x3,
  CMODE_INVALID = 0x4,
};

/* 11318 */
struct compressor_state_t
{
  uint16_t lz4_selection_run;
  uint16_t lz4_run_length;
  uint16_t lz4_preselects;
  uint32_t lz4_total_preselects;
  uint16_t lz4_failure_skips;
  uint32_t lz4_total_failure_skips;
  uint16_t lz4_failure_run_length;
  uint16_t lz4_total_unprofitables;
  uint32_t lz4_total_negatives;
  uint32_t lz4_total_failures;
};

/* 11319 */
struct compressor_tuneables_t
{
  uint32_t lz4_selection_max;
  int32_t wkdm_reeval_threshold;
  int32_t lz4_threshold;
  uint32_t lz4_max_failure_skips;
  uint32_t lz4_max_failure_run_length;
  uint32_t lz4_max_preselects;
  uint32_t lz4_run_preselection_threshold;
  uint32_t lz4_run_continue_bytes;
  uint32_t lz4_profitable_bytes;
};

/* 11320 */
typedef int vm_external_state_t;

/* 11321 */
struct vm_compressor_swapper_stats
{
  uint64_t unripe_under_30s;
  uint64_t unripe_under_60s;
  uint64_t unripe_under_300s;
  uint64_t reclaim_swapins;
  uint64_t defrag_swapins;
  uint64_t compressor_swap_threshold_exceeded;
  uint64_t external_q_throttled;
  uint64_t free_count_below_reserve;
  uint64_t thrashing_detected;
  uint64_t fragmentation_detected;
};

/* 11322 */
typedef const memory_object_pager_ops *memory_object_pager_ops_t;

/* 11323 */
typedef vm_region_top_info vm_region_top_info_data_t;

/* 11324 */
struct upl_1
{
  lck_mtx_t_0 Lock;
  int ref_count;
  int ext_ref_count;
  int flags;
  vm_object_offset_t u_offset;
  upl_size_t u_size;
  upl_size_t u_mapped_size;
  vm_offset_t kaddr;
  vm_object_t map_object;
  vector_upl_t vector_upl;
  upl_t associated_upl;
  upl_io_completion *upl_iodone;
  ppnum_t_0 highest_page;
  int upl_priority;
  uint64_t *upl_reprio_info;
  void *decmp_io_upl;
  thread_t_0 upl_creator;
  queue_chain_t_0 uplq;
  bitmap_t *lite_list;
  upl_page_info_1 page_list[];
};

/* 11325 */
typedef mach_port_t_0 mem_entry_name_port_t_0;

/* 11326 */
typedef __Request___map_exec_lockdown_t _X_map_exec_lockdown::__Request;

/* 11327 */
typedef __Request__purgable_control_t _Xpurgable_control::__Request;

/* 11328 */
typedef __Request__map_64_t _Xmap_64::__Request;

/* 11329 */
typedef __Request__make_memory_entry_64_t _Xmake_memory_entry_64::__Request;

/* 11330 */
typedef __Request__region_64_t _Xregion_64::__Request;

/* 11331 */
typedef __Request__region_info_64_t _Xregion_info_64::__Request;

/* 11332 */
typedef __Request__region_recurse_64_t _Xregion_recurse_64::__Request;

/* 11333 */
typedef __Request__region_recurse_t _Xregion_recurse::__Request;

/* 11334 */
typedef __Request__mapped_pages_info_t _Xmapped_pages_info::__Request;

/* 11335 */
typedef __Request__region_info_t _Xregion_info::__Request;

/* 11336 */
typedef __Request__map_page_query_t _Xmap_page_query::__Request;

/* 11337 */
typedef __Request__make_memory_entry_t _Xmake_memory_entry::__Request;

/* 11338 */
typedef __Request___task_wire_t _X_task_wire::__Request;

/* 11339 */
typedef __Request__remap_t _Xremap::__Request;

/* 11340 */
typedef __Request__machine_attribute_t _Xmachine_attribute::__Request;

/* 11341 */
typedef __Request__map_t _Xmap::__Request;

/* 11342 */
typedef __Request__behavior_set_t _Xbehavior_set::__Request;

/* 11343 */
typedef __Request__msync_t _Xmsync::__Request;

/* 11344 */
typedef __Request__read_overwrite_t _Xread_overwrite::__Request;

/* 11345 */
typedef __Request__copy_t _Xcopy::__Request;

/* 11346 */
typedef __Request__write_t _Xwrite::__Request;

/* 11347 */
typedef struct {char data[2048];}; *_Xread_list::sp;

/* 11348 */
typedef __Request__read_list_t _Xread_list::__Request;

/* 11349 */
typedef __Request__read_t _Xread::__Request;

/* 11350 */
typedef __Request__inherit_t _Xinherit::__Request;

/* 11351 */
typedef __Request__protect_t _Xprotect::__Request;

/* 11352 */
typedef __Request__deallocate_t _Xdeallocate::__Request;

/* 11353 */
typedef __Request__allocate_t _Xallocate::__Request;

/* 11354 */
typedef __Request__region_t _Xregion::__Request;

/* 11355 */
typedef __Request__thread_get_exception_ports_info_t _Xthread_get_exception_ports_info::__Request;

/* 11356 */
typedef __Request__thread_raise_exception_t _Xthread_raise_exception::__Request;

/* 11357 */
typedef __Request__thread_convert_thread_state_t __Request_25;

/* 11358 */
typedef __Request__thread_convert_thread_state_t _Xthread_convert_thread_state::__Request;

/* 11359 */
typedef __Request__thread_swap_mach_voucher_t _Xthread_swap_mach_voucher::__Request;

/* 11360 */
typedef __Request__thread_set_mach_voucher_t _Xthread_set_mach_voucher::__Request;

/* 11361 */
typedef __Request__thread_get_mach_voucher_t _Xthread_get_mach_voucher::__Request;

/* 11362 */
typedef __Request__thread_set_policy_t __Request_26;

/* 11363 */
typedef __Request__thread_set_policy_t _Xthread_set_policy::__Request;

/* 11364 */
typedef __Request__thread_policy_get_t _Xthread_policy_get::__Request;

/* 11365 */
typedef __Request__thread_policy_set_t _Xthread_policy_set::__Request;

/* 11366 */
typedef __Request__thread_policy_t __Request_27;

/* 11367 */
typedef __Request__thread_policy_t _Xthread_policy::__Request;

/* 11368 */
typedef __Request__thread_swap_exception_ports_t _Xthread_swap_exception_ports::__Request;

/* 11369 */
typedef __Request__thread_get_exception_ports_from_user_t _Xthread_get_exception_ports_from_user::__Request;

/* 11370 */
typedef __Request__thread_set_exception_ports_t _Xthread_set_exception_ports::__Request;

/* 11371 */
typedef __Request__thread_info_t _Xthread_info::__Request;

/* 11372 */
typedef __Request__thread_set_special_port_t _Xthread_set_special_port::__Request;

/* 11373 */
typedef __Request__thread_get_special_port_from_user_t _Xthread_get_special_port_from_user::__Request;

/* 11374 */
typedef __Request__thread_depress_abort_from_user_t _Xthread_depress_abort_from_user::__Request;

/* 11375 */
typedef __Request__thread_abort_safely_t _Xthread_abort_safely::__Request;

/* 11376 */
typedef __Request__thread_abort_t _Xthread_abort::__Request;

/* 11377 */
typedef __Request__thread_resume_t _Xthread_resume::__Request;

/* 11378 */
typedef __Request__thread_suspend_t _Xthread_suspend::__Request;

/* 11379 */
typedef __Request__thread_set_state_from_user_t _Xthread_set_state_from_user::__Request;

/* 11380 */
typedef __Request__thread_get_state_to_user_t _Xthread_get_state_to_user::__Request;

/* 11381 */
typedef __Request__act_set_state_from_user_t _Xact_set_state_from_user::__Request;

/* 11382 */
typedef __Request__act_get_state_to_user_t _Xact_get_state_to_user::__Request;

/* 11383 */
typedef __Request__thread_terminate_from_user_t _Xthread_terminate_from_user::__Request;

/* 11384 */
typedef __Request__task_map_kcdata_object_64_t _Xtask_map_kcdata_object_64::__Request;

/* 11385 */
typedef __Request__task_test_async_upcall_propagation_t _Xtask_test_async_upcall_propagation::__Request;

/* 11386 */
typedef __Request__task_set_corpse_forking_behavior_t _Xtask_set_corpse_forking_behavior::__Request;

/* 11387 */
typedef __Request__task_test_sync_upcall_t _Xtask_test_sync_upcall::__Request;

/* 11388 */
typedef __Request__task_get_exception_ports_info_t _Xtask_get_exception_ports_info::__Request;

/* 11389 */
typedef __Request__task_dyld_process_info_notify_deregister_t _Xtask_dyld_process_info_notify_deregister::__Request;

/* 11390 */
typedef __Request__task_identity_token_get_task_port_t _Xtask_identity_token_get_task_port::__Request;

/* 11391 */
typedef __Request__task_create_identity_token_t _Xtask_create_identity_token::__Request;

/* 11392 */
typedef __Request__task_dyld_process_info_notify_register_t _Xtask_dyld_process_info_notify_register::__Request;

/* 11393 */
typedef __Request__mach_task_is_self_t _Xmach_task_is_self::__Request;

/* 11394 */
typedef __Request__task_set_exc_guard_behavior_t _Xtask_set_exc_guard_behavior::__Request;

/* 11395 */
typedef __Request__task_get_exc_guard_behavior_t _Xtask_get_exc_guard_behavior::__Request;

/* 11396 */
typedef __Request__task_inspect_t _Xtask_inspect::__Request;

/* 11397 */
typedef __Request__task_map_corpse_info_64_t _Xtask_map_corpse_info_64::__Request;

/* 11398 */
typedef __Request__task_register_dyld_get_process_state_t _Xtask_register_dyld_get_process_state::__Request;

/* 11399 */
typedef __Request__task_register_dyld_set_dyld_state_t _Xtask_register_dyld_set_dyld_state::__Request;

/* 11400 */
typedef __Request__task_register_dyld_shared_cache_image_info_t _Xtask_register_dyld_shared_cache_image_info::__Request;

/* 11401 */
typedef __Request__task_get_dyld_image_infos_t _Xtask_get_dyld_image_infos::__Request;

/* 11402 */
typedef __Request__task_unregister_dyld_image_infos_t _Xtask_unregister_dyld_image_infos::__Request;

/* 11403 */
typedef __Request__task_register_dyld_image_infos_t _Xtask_register_dyld_image_infos::__Request;

/* 11404 */
typedef __Request__task_map_corpse_info_t _Xtask_map_corpse_info::__Request;

/* 11405 */
typedef __Request__task_generate_corpse_t _Xtask_generate_corpse::__Request;

/* 11406 */
typedef __Request__task_swap_mach_voucher_t _Xtask_swap_mach_voucher::__Request;

/* 11407 */
typedef __Request__task_set_mach_voucher_t _Xtask_set_mach_voucher::__Request;

/* 11408 */
typedef __Request__task_get_mach_voucher_t _Xtask_get_mach_voucher::__Request;

/* 11409 */
typedef __Request__task_purgable_info_t _Xtask_purgable_info::__Request;

/* 11410 */
typedef __Request__task_resume2_mig_t _Xtask_resume2_mig::__Request;

/* 11411 */
typedef __Request__task_suspend2_mig_t _Xtask_suspend2_mig::__Request;

/* 11412 */
typedef __Request__task_set_phys_footprint_limit_t _Xtask_set_phys_footprint_limit::__Request;

/* 11413 */
typedef __Request__task_set_state_t _Xtask_set_state::__Request;

/* 11414 */
typedef __Request__task_get_state_t _Xtask_get_state::__Request;

/* 11415 */
typedef __Request__task_policy_get_t _Xtask_policy_get::__Request;

/* 11416 */
typedef __Request__task_policy_set_t _Xtask_policy_set::__Request;

/* 11417 */
typedef __Request__semaphore_destroy_t _Xsemaphore_destroy::__Request;

/* 11418 */
typedef __Request__semaphore_create_t _Xsemaphore_create::__Request;

/* 11419 */
typedef __Request__task_swap_exception_ports_t _Xtask_swap_exception_ports::__Request;

/* 11420 */
typedef __Request__task_get_exception_ports_from_user_t _Xtask_get_exception_ports_from_user::__Request;

/* 11421 */
typedef __Request__task_set_exception_ports_t _Xtask_set_exception_ports::__Request;

/* 11422 */
typedef __Request__thread_create_running_from_user_t _Xthread_create_running_from_user::__Request;

/* 11423 */
typedef __Request__thread_create_from_user_t _Xthread_create_from_user::__Request;

/* 11424 */
typedef __Request__task_set_special_port_from_user_t _Xtask_set_special_port_from_user::__Request;

/* 11425 */
typedef __Request__task_get_special_port_from_user_t _Xtask_get_special_port_from_user::__Request;

/* 11426 */
typedef __Request__task_resume_t _Xtask_resume::__Request;

/* 11427 */
typedef __Request__task_suspend_t _Xtask_suspend::__Request;

/* 11428 */
typedef __Request__task_set_info_t _Xtask_set_info::__Request;

/* 11429 */
typedef __Request__task_info_from_user_t _Xtask_info_from_user::__Request;

/* 11430 */
typedef __Request__mach_ports_lookup_t _Xmach_ports_lookup::__Request;

/* 11431 */
typedef __Request__mach_ports_register_t _Xmach_ports_register::__Request;

/* 11432 */
typedef __Request__task_threads_from_user_t _Xtask_threads_from_user::__Request;

/* 11433 */
typedef __Request__task_terminate_t _Xtask_terminate::__Request;

/* 11434 */
typedef __Request__processor_set_tasks_with_flavor_t _Xprocessor_set_tasks_with_flavor::__Request;

/* 11435 */
typedef __Request__processor_set_info_t _Xprocessor_set_info::__Request;

/* 11436 */
typedef __Request__processor_set_stack_usage_t _Xprocessor_set_stack_usage::__Request;

/* 11437 */
typedef __Request__processor_set_threads_t _Xprocessor_set_threads::__Request;

/* 11438 */
typedef __Request__processor_set_tasks_t _Xprocessor_set_tasks::__Request;

/* 11439 */
typedef __Request__processor_set_statistics_t _Xprocessor_set_statistics::__Request;

/* 11440 */
typedef __Request__processor_get_assignment_t _Xprocessor_get_assignment::__Request;

/* 11441 */
typedef __Request__processor_assign_t _Xprocessor_assign::__Request;

/* 11442 */
typedef __Request__processor_control_t _Xprocessor_control::__Request;

/* 11443 */
typedef __Request__processor_info_t _Xprocessor_info::__Request;

/* 11444 */
typedef __Request__processor_exit_from_user_t _Xprocessor_exit_from_user::__Request;

/* 11445 */
typedef __Request__processor_start_from_user_t _Xprocessor_start_from_user::__Request;

/* 11446 */
typedef __Request__arcade_register_new_upcall_t __Request_28;

/* 11447 */
struct __attribute__((packed)) __attribute__((aligned(4))) Request_2
{
  mach_msg_header_t_0 Head;
  mach_msg_body_t_0 msgh_body;
  mach_msg_port_descriptor_t arcade_upcall;
  mach_msg_trailer_t trailer;
};

/* 11448 */
struct persona_modify_info
{
  uint32_t persona_id;
  uint64_t unique_pid;
};

/* 11449 */
typedef bank_element *bank_element_t;

/* 11450 */
struct _bank_ledger_indices
{
  int cpu_time;
  int energy;
};

/* 11451 */
struct _uint32_with_description_data
{
  char desc[32];
  uint32_t data;
};

/* 11452 */
struct _uint64_with_description_data
{
  char desc[32];
  uint64_t data;
};

/* 11453 */
typedef exception_handler_t_1 exception_port_t_0;

/* 11454 */
union corpse_creation_gate
{
  struct
  {
    uint16_t user_faults;
    uint16_t corpses;
  };
  uint32_t value;
};

/* 11455 */
struct kcdata_object_0
{
  kcdata_descriptor_t ko_data;
  __attribute__((aligned(16))) ipc_port_t_1 ko_port;
  uint32_t ko_alloc_size;
  os_refcnt_t ko_refs;
};

/* 11456 */
typedef __Request__task_restartable_ranges_synchronize_t _Xtask_restartable_ranges_synchronize::__Request;

/* 11457 */
typedef __Request__task_restartable_ranges_register_t _Xtask_restartable_ranges_register::__Request;

/* 11458 */
typedef struct *send_disk_writes_violation::sp;

/* 11459 */
typedef struct *send_disk_writes_violation::sp_0;

/* 11460 */
typedef struct *send_cpu_wakes_violation::sp;

/* 11461 */
typedef struct *send_cpu_wakes_violation::sp_0;

/* 11462 */
typedef struct *send_cpu_usage_violation::sp;

/* 11463 */
typedef struct *send_cpu_usage_violation::sp_0;

/* 11464 */
typedef __Request__mach_memory_entry_ownership_from_user_t _Xmach_memory_entry_ownership_from_user::__Request;

/* 11465 */
typedef __Request__mach_memory_entry_access_tracking_t _Xmach_memory_entry_access_tracking::__Request;

/* 11466 */
typedef __Request__mach_memory_entry_purgable_control_t _Xmach_memory_entry_purgable_control::__Request;

/* 11467 */
typedef __Request__mach_voucher_debug_info_t _Xmach_voucher_debug_info::__Request;

/* 11468 */
typedef __Request__mach_voucher_attr_command_t __Request_29;

/* 11469 */
typedef __Request__mach_voucher_attr_command_t _Xmach_voucher_attr_command::__Request;

/* 11470 */
typedef __Request__mach_voucher_extract_all_attr_recipes_t _Xmach_voucher_extract_all_attr_recipes::__Request;

/* 11471 */
typedef __Request__mach_voucher_extract_attr_recipe_t _Xmach_voucher_extract_attr_recipe::__Request;

/* 11472 */
typedef __Request__mach_voucher_extract_attr_content_t _Xmach_voucher_extract_attr_content::__Request;

/* 11473 */
typedef __Request__mach_vm_deferred_reclamation_buffer_update_reclaimable_bytes_t _Xmach_vm_deferred_reclamation_buffer_update_reclaimable_bytes::__Request;

/* 11474 */
typedef __Request__mach_vm_deferred_reclamation_buffer_synchronize_t _Xmach_vm_deferred_reclamation_buffer_synchronize::__Request;

/* 11475 */
typedef __Request__mach_vm_deferred_reclamation_buffer_init_t _Xmach_vm_deferred_reclamation_buffer_init::__Request;

/* 11476 */
typedef __Request__mach_vm_remap_new_external_t _Xmach_vm_remap_new_external::__Request;

/* 11477 */
typedef __Request__mach_vm_page_range_query_t _Xmach_vm_page_range_query::__Request;

/* 11478 */
typedef __Request__mach_vm_page_info_t _Xmach_vm_page_info::__Request;

/* 11479 */
typedef __Request__mach_vm_purgable_control_external_t _Xmach_vm_purgable_control_external::__Request;

/* 11480 */
typedef __Request___mach_make_memory_entry_t _X_mach_make_memory_entry::__Request;

/* 11481 */
typedef __Request__mach_vm_region_t _Xmach_vm_region::__Request;

/* 11482 */
typedef __Request__mach_vm_region_recurse_t _Xmach_vm_region_recurse::__Request;

/* 11483 */
typedef __Request__mach_vm_page_query_t _Xmach_vm_page_query::__Request;

/* 11484 */
typedef __Request__mach_vm_remap_external_t _Xmach_vm_remap_external::__Request;

/* 11485 */
typedef __Request__mach_vm_machine_attribute_t _Xmach_vm_machine_attribute::__Request;

/* 11486 */
typedef __Request__mach_vm_map_external_t _Xmach_vm_map_external::__Request;

/* 11487 */
typedef __Request__mach_vm_behavior_set_t _Xmach_vm_behavior_set::__Request;

/* 11488 */
typedef __Request__mach_vm_msync_t _Xmach_vm_msync::__Request;

/* 11489 */
typedef __Request__mach_vm_read_overwrite_t _Xmach_vm_read_overwrite::__Request;

/* 11490 */
typedef __Request__mach_vm_copy_t _Xmach_vm_copy::__Request;

/* 11491 */
typedef __Request__mach_vm_write_t _Xmach_vm_write::__Request;

/* 11492 */
typedef struct *_Xmach_vm_read_list::sp;

/* 11493 */
typedef __Request__mach_vm_read_list_t _Xmach_vm_read_list::__Request;

/* 11494 */
typedef __Request__mach_vm_read_t _Xmach_vm_read::__Request;

/* 11495 */
typedef __Request__mach_vm_inherit_t _Xmach_vm_inherit::__Request;

/* 11496 */
typedef __Request__mach_vm_protect_t _Xmach_vm_protect::__Request;

/* 11497 */
typedef __Request__mach_vm_deallocate_t _Xmach_vm_deallocate::__Request;

/* 11498 */
typedef __Request__mach_vm_allocate_external_t _Xmach_vm_allocate_external::__Request;

/* 11499 */
typedef __Request__mach_port_assert_attributes_t _Xmach_port_assert_attributes::__Request;

/* 11500 */
typedef __Request__mach_port_get_service_port_info_t _Xmach_port_get_service_port_info::__Request;

/* 11501 */
typedef __Request__mach_port_is_connection_for_service_t _Xmach_port_is_connection_for_service::__Request;

/* 11502 */
typedef __Request__mach_port_kobject_description_from_user_t _Xmach_port_kobject_description_from_user::__Request;

/* 11503 */
typedef __Request__mach_port_swap_guard_t _Xmach_port_swap_guard::__Request;

/* 11504 */
typedef __Request__mach_port_guard_with_flags_t _Xmach_port_guard_with_flags::__Request;

/* 11505 */
typedef __Request__mach_port_special_reply_port_reset_link_t _Xmach_port_special_reply_port_reset_link::__Request;

/* 11506 */
typedef __Request__mach_port_space_basic_info_t _Xmach_port_space_basic_info::__Request;

/* 11507 */
typedef __Request__mach_port_unguard_t _Xmach_port_unguard::__Request;

/* 11508 */
typedef __Request__mach_port_guard_t _Xmach_port_guard::__Request;

/* 11509 */
typedef __Request__mach_port_destruct_t _Xmach_port_destruct::__Request;

/* 11510 */
typedef __Request__mach_port_construct_t _Xmach_port_construct::__Request;

/* 11511 */
typedef __Request__mach_port_kobject_from_user_t _Xmach_port_kobject_from_user::__Request;

/* 11512 */
typedef __Request__mach_port_set_context_t _Xmach_port_set_context::__Request;

/* 11513 */
typedef __Request__mach_port_get_context_from_user_t _Xmach_port_get_context_from_user::__Request;

/* 11514 */
typedef __Request__mach_port_extract_member_t _Xmach_port_extract_member::__Request;

/* 11515 */
typedef __Request__mach_port_insert_member_t _Xmach_port_insert_member::__Request;

/* 11516 */
typedef __Request__mach_port_dnrequest_info_t _Xmach_port_dnrequest_info::__Request;

/* 11517 */
typedef __Request__mach_port_space_info_from_user_t _Xmach_port_space_info_from_user::__Request;

/* 11518 */
typedef __Request__mach_port_get_srights_t _Xmach_port_get_srights::__Request;

/* 11519 */
typedef __Request__task_set_port_space_t _Xtask_set_port_space::__Request;

/* 11520 */
typedef __Request__mach_port_allocate_full_t _Xmach_port_allocate_full::__Request;

/* 11521 */
typedef __Request__mach_port_allocate_qos_t _Xmach_port_allocate_qos::__Request;

/* 11522 */
typedef __Request__mach_port_set_attributes_t _Xmach_port_set_attributes::__Request;

/* 11523 */
typedef __Request__mach_port_get_attributes_from_user_t _Xmach_port_get_attributes_from_user::__Request;

/* 11524 */
typedef __Request__mach_port_set_seqno_t _Xmach_port_set_seqno::__Request;

/* 11525 */
typedef __Request__mach_port_extract_right_t _Xmach_port_extract_right::__Request;

/* 11526 */
typedef __Request__mach_port_insert_right_t _Xmach_port_insert_right::__Request;

/* 11527 */
typedef __Request__mach_port_request_notification_t _Xmach_port_request_notification::__Request;

/* 11528 */
typedef __Request__mach_port_move_member_t _Xmach_port_move_member::__Request;

/* 11529 */
typedef __Request__mach_port_get_set_status_from_user_t _Xmach_port_get_set_status_from_user::__Request;

/* 11530 */
typedef __Request__mach_port_set_mscount_t _Xmach_port_set_mscount::__Request;

/* 11531 */
typedef __Request__mach_port_peek_t _Xmach_port_peek::__Request;

/* 11532 */
typedef __Request__mach_port_mod_refs_t _Xmach_port_mod_refs::__Request;

/* 11533 */
typedef __Request__mach_port_get_refs_t _Xmach_port_get_refs::__Request;

/* 11534 */
typedef __Request__mach_port_deallocate_t _Xmach_port_deallocate::__Request;

/* 11535 */
typedef __Request__mach_port_destroy_t _Xmach_port_destroy::__Request;

/* 11536 */
typedef __Request__mach_port_allocate_t _Xmach_port_allocate::__Request;

/* 11537 */
typedef __Request__mach_port_allocate_name_t _Xmach_port_allocate_name::__Request;

/* 11538 */
typedef __Request__mach_port_type_t _Xmach_port_type::__Request;

/* 11539 */
typedef __Request__mach_port_names_t _Xmach_port_names::__Request;

/* 11540 */
typedef clock *clock_serv_t;

/* 11541 */
typedef __Request__mach_zone_get_btlog_records_t _Xmach_zone_get_btlog_records::__Request;

/* 11542 */
typedef __Request__mach_zone_get_zlog_zones_t _Xmach_zone_get_zlog_zones::__Request;

/* 11543 */
typedef __Request__mach_zone_info_for_largest_zone_t _Xmach_zone_info_for_largest_zone::__Request;

/* 11544 */
typedef __Request__mach_zone_info_for_zone_t _Xmach_zone_info_for_zone::__Request;

/* 11545 */
typedef __Request__host_set_multiuser_config_flags_t _Xhost_set_multiuser_config_flags::__Request;

/* 11546 */
typedef __Request__mach_memory_info_t _Xmach_memory_info::__Request;

/* 11547 */
typedef __Request__host_set_atm_diagnostic_flag_t _Xhost_set_atm_diagnostic_flag::__Request;

/* 11548 */
typedef __Request__host_create_mach_voucher_t _Xhost_create_mach_voucher::__Request;

/* 11549 */
typedef __Request__mach_zone_force_gc_t _Xmach_zone_force_gc::__Request;

/* 11550 */
typedef __Request__mach_zone_info_t _Xmach_zone_info::__Request;

/* 11551 */
typedef __Request__host_statistics64_from_user_t _Xhost_statistics64_from_user::__Request;

/* 11552 */
typedef __Request__host_lockgroup_info_t _Xhost_lockgroup_info::__Request;

/* 11553 */
typedef __Request__host_request_notification_t _Xhost_request_notification::__Request;

/* 11554 */
typedef __Request__host_statistics_from_user_t _Xhost_statistics_from_user::__Request;

/* 11555 */
typedef __Request__mach_memory_object_memory_entry_64_t _Xmach_memory_object_memory_entry_64::__Request;

/* 11556 */
typedef __Request__processor_set_default_t _Xprocessor_set_default::__Request;

/* 11557 */
typedef __Request__host_virtual_physical_table_info_t _Xhost_virtual_physical_table_info::__Request;

/* 11558 */
typedef __Request__kmod_get_info_t _Xkmod_get_info::__Request;

/* 11559 */
typedef __Request__host_get_clock_service_t _Xhost_get_clock_service::__Request;

/* 11560 */
typedef __Request__host_get_io_main_t _Xhost_get_io_main::__Request;

/* 11561 */
typedef __Request__host_processor_info_t _Xhost_processor_info::__Request;

/* 11562 */
typedef __Request__mach_memory_object_memory_entry_t _Xmach_memory_object_memory_entry::__Request;

/* 11563 */
typedef __Request__host_page_size_t _Xhost_page_size::__Request;

/* 11564 */
typedef __Request__host_kernel_version_t _Xhost_kernel_version::__Request;

/* 11565 */
typedef __Request__host_info_t _Xhost_info::__Request;

/* 11566 */
typedef __Request__mach_exception_raise_backtrace_t _Xmach_exception_raise_backtrace::__Request;

/* 11567 */
typedef __Request__mach_exception_raise_identity_protected_t _Xmach_exception_raise_identity_protected::__Request;

/* 11568 */
typedef __Request__mach_exception_raise_state_identity_t __Request_30;

/* 11569 */
typedef __Request__mach_exception_raise_state_identity_t _Xmach_exception_raise_state_identity::__Request;

/* 11570 */
typedef __Request__mach_exception_raise_state_t __Request_31;

/* 11571 */
typedef __Request__mach_exception_raise_state_t _Xmach_exception_raise_state::__Request;

/* 11572 */
typedef __Request__mach_exception_raise_t _Xmach_exception_raise::__Request;

/* 11573 */
typedef __Request__kext_request_t _Xkext_request::__Request;

/* 11574 */
typedef __Request__host_get_UNDServer_t _Xhost_get_UNDServer::__Request;

/* 11575 */
typedef __Request__host_set_UNDServer_t _Xhost_set_UNDServer::__Request;

/* 11576 */
typedef __Request__host_processor_set_priv_t _Xhost_processor_set_priv::__Request;

/* 11577 */
typedef __Request__host_processor_sets_t _Xhost_processor_sets::__Request;

/* 11578 */
typedef __Request__mach_vm_wire_external_t _Xmach_vm_wire_external::__Request;

/* 11579 */
typedef __Request__host_swap_exception_ports_t _Xhost_swap_exception_ports::__Request;

/* 11580 */
typedef __Request__host_get_exception_ports_t _Xhost_get_exception_ports::__Request;

/* 11581 */
typedef __Request__host_set_exception_ports_t _Xhost_set_exception_ports::__Request;

/* 11582 */
typedef __Request__host_set_special_port_from_user_t _Xhost_set_special_port_from_user::__Request;

/* 11583 */
typedef __Request__host_get_special_port_from_user_t _Xhost_get_special_port_from_user::__Request;

/* 11584 */
typedef __Request__host_processors_t _Xhost_processors::__Request;

/* 11585 */
typedef __Request__vm_allocate_cpm_t _Xvm_allocate_cpm::__Request;

/* 11586 */
typedef __Request__thread_wire_t _Xthread_wire::__Request;

/* 11587 */
typedef __Request__vm_wire_t _Xvm_wire::__Request;

/* 11588 */
typedef __Request__host_default_memory_manager_t _Xhost_default_memory_manager::__Request;

/* 11589 */
typedef __Request__host_priv_statistics_t _Xhost_priv_statistics::__Request;

/* 11590 */
typedef __Request__host_reboot_t _Xhost_reboot::__Request;

/* 11591 */
typedef __Request__host_get_boot_info_t _Xhost_get_boot_info::__Request;

/* 11592 */
typedef ipc_eventlink *ipc_eventlink_t;

/* 11593 */
typedef __Request__mach_eventlink_disassociate_t _Xmach_eventlink_disassociate::__Request;

/* 11594 */
typedef __Request__mach_eventlink_associate_t _Xmach_eventlink_associate::__Request;

/* 11595 */
typedef __Request__mach_eventlink_destroy_t _Xmach_eventlink_destroy::__Request;

/* 11596 */
typedef __Request__mach_eventlink_create_t _Xmach_eventlink_create::__Request;

/* 11597 */
typedef __Request__exception_raise_state_identity_t __Request_32;

/* 11598 */
typedef __Request__exception_raise_state_identity_t _Xexception_raise_state_identity::__Request;

/* 11599 */
typedef __Request__exception_raise_state_t __Request_33;

/* 11600 */
typedef __Request__exception_raise_state_t _Xexception_raise_state::__Request;

/* 11601 */
typedef __Request__exception_raise_t _Xexception_raise::__Request;

/* 11602 */
typedef __Request__clock_alarm_t _Xclock_alarm::__Request;

/* 11603 */
typedef __Request__clock_get_attributes_t _Xclock_get_attributes::__Request;

/* 11604 */
typedef __Request__clock_get_time_t _Xclock_get_time::__Request;

/* 11605 */
struct __attribute__((packed)) __attribute__((aligned(4))) socd_client_trace_entry_t
{
  uint64_t timestamp;
  uint32_t debugid;
  socd_client_trace_arg_t arg1;
  socd_client_trace_arg_t arg2;
  socd_client_trace_arg_t arg3;
  socd_client_trace_arg_t arg4;
};

/* 11606 */
struct __attribute__((packed)) __attribute__((aligned(4))) socd_client_hdr_t
{
  uint32_t version;
  uint64_t boot_time;
  uuid_t_0 kernel_uuid;
  uuid_t_0 primary_kernelcache_uuid;
};

/* 11607 */
struct __attribute__((aligned(8))) socd_client_cfg_t
{
  vm_offset_t trace_buff_offset;
  uint32_t trace_buff_len;
};

/* 11608 */
struct __block_literal_1_29
{
  void *__isa;
  int __flags;
  int __reserved;
  unsigned __int64 (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
};

/* 11609 */
struct __block_literal_3_10
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(zone_t);
  __block_descriptor *__descriptor;
};

/* 11610 */
struct kern_work_interval_create_args_0
{
  uint64_t wica_id;
  mach_port_name_t_0 wica_port;
  uint32_t wica_create_flags;
};

/* 11611 */
struct thread_4
{
  union
  {
    queue_chain_t_0 runq_links;
    queue_chain_t_0 wait_links;
    mpsc_queue_chain mpsc_links;
    priority_queue_entry_sched wait_prioq_links;
  };
  event64_t wait_event;
  processor_t runq;
  waitq_t waitq;
  turnstile *turnstile;
  void *inheritor;
  priority_queue_sched_max sched_inheritor_queue;
  priority_queue_sched_max base_inheritor_queue;
  priority_queue_entry_stable th_clutch_runq_link;
  priority_queue_entry_sched th_clutch_pri_link;
  queue_chain_t_0 th_clutch_timeshare_link;
  simple_lock_data_t_0 sched_lock;
  simple_lock_data_t_0 wake_lock;
  uint16_t options;
  bool wake_active;
  bool at_safe_point;
  uint8_t sched_saved_run_weight;
  ast_t reason;
  uint32_t quantum_remaining;
  wait_result_t wait_result;
  thread_rr_state_t t_rr_state;
  thread_continue_t continuation;
  void *parameter;
  vm_offset_t kernel_stack;
  vm_offset_t reserved_stack;
  machine_thread machine;
  int state;
  sched_mode_t sched_mode;
  sched_mode_t saved_mode;
  sched_bucket_t th_sched_bucket;
  sfi_class_id_t sfi_class;
  sfi_class_id_t sfi_wait_class;
  uint32_t sched_flags;
  int16_t sched_pri;
  int16_t base_pri;
  int16_t req_base_pri;
  int16_t max_priority;
  int16_t task_priority;
  int16_t promotion_priority;
  uint16_t priority_floor_count;
  int16_t suspend_count;
  int iotier_override;
  os_ref_atomic_t ref_count;
  uint32_t rwlock_count;
  integer_t importance;
  integer_t depress_timer_active;
  timer_call_t depress_timer;
  struct
  {
    uint32_t period;
    uint32_t computation;
    uint32_t constraint;
    bool preemptible;
    uint8_t priority_offset;
    uint64_t deadline;
  } realtime;
  uint64_t last_run_time;
  uint64_t last_made_runnable_time;
  uint64_t last_basepri_change_time;
  uint64_t same_pri_latency;
  uint64_t workq_quantum_deadline;
  thread_group *thread_group;
  sched_group_t sched_group;
  processor_t bound_processor;
  processor_t last_processor;
  processor_t chosen_processor;
  uint64_t computation_metered;
  uint64_t computation_epoch;
  uint64_t safe_release;
  void (*sched_call)(int, thread_t_0);
  natural_t sched_stamp;
  natural_t sched_usage;
  natural_t pri_shift;
  natural_t cpu_usage;
  natural_t cpu_delta;
  uint32_t c_switch;
  uint32_t p_switch;
  uint32_t ps_switch;
  integer_t mutex_count;
  uint64_t sched_time_save;
  uint64_t vtimer_user_save;
  uint64_t vtimer_prof_save;
  uint64_t vtimer_rlim_save;
  uint64_t vtimer_qos_save;
  timer_data_t runnable_timer;
  recount_thread th_recount;
  uint64_t wait_sfi_begin_time;
  queue_chain_t_0 affinity_threads;
  affinity_set_t affinity_set;
  task_watch_t *taskwatch;
  union
  {
    struct
    {
      mach_msg_return_t state;
      mach_port_seqno_t seqno;
      ipc_object_t object;
      mach_vm_address_t_0 msg_addr;
      mach_vm_address_t_0 aux_addr;
      mach_msg_size_t max_msize;
      mach_msg_size_t max_asize;
      mach_msg_size_t msize;
      mach_msg_size_t asize;
      _BYTE gap30[8];
      mach_port_name_t_0 receiver_name;
      union
      {
        ipc_kmsg *kmsg;
        ipc_mqueue *peekq;
      };
    } receive;
    struct
    {
      semaphore *waitsemaphore;
      semaphore *signalsemaphore;
      int options;
      kern_return_t result;
      mach_msg_continue_t continuation;
    } sema;
    struct
    {
      void *tls[8];
    } iokit;
  } saved;
  union
  {
    thread_call_thread_state *thc_state;
    struct
    {
      mach_exception_code_t code;
      mach_exception_subcode_t subcode;
    } guard_exc_info;
  };
  int32_t user_stop_count;
  natural_t ith_assertions;
  circle_queue_head_t ith_messages;
  mach_port_t_1 ith_kernel_reply_port;
  volatile ast_t ast;
  vm_offset_t recover;
  queue_chain_t_0 threads;
  queue_chain_t_0 task_threads;
  thread_ro *t_tro;
  vm_map_t_0 map;
  thread_t_1 handoff_thread;
  timer_call_t wait_timer;
  uint16_t wait_timer_active;
  bool wait_timer_armed;
  lck_mtx_t_0 mutex;
  ipc_port *ith_special_reply_port;
  uint16_t t_dtrace_flags;
  uint16_t t_dtrace_inprobe;
  uint32_t t_dtrace_predcache;
  int64_t t_dtrace_tracing;
  int64_t t_dtrace_vtime;
  clock_sec_t t_page_creation_time;
  uint32_t t_page_creation_count;
  uint32_t t_page_creation_throttled;
  int t_pagein_error;
  uint32_t kperf_ast;
  uint32_t kperf_pet_gen;
  uint32_t kperf_c_switch;
  uint32_t kperf_pet_cnt;
  uint64_t *kpc_buf;
  uint32_t syscalls_unix;
  uint32_t syscalls_mach;
  ledger_t t_ledger;
  ledger_t t_threadledger;
  ledger_t t_bankledger;
  uint64_t t_deduct_bank_ledger_time;
  uint64_t t_deduct_bank_ledger_energy;
  uint64_t thread_id;
  uint32_t ctid;
  uint32_t ctsid;
  thread_requested_policy requested_policy;
  thread_effective_policy effective_policy;
  thread_qos_override *overrides;
  uint32_t kevent_overrides;
  uint8_t user_promotion_basepri;
  uint8_t kern_promotion_schedpri;
  uint16_t kevent_ast_bits;
  io_stat_info_t thread_io_stats;
  uint32_t thread_callout_interrupt_wakeups;
  uint32_t thread_callout_platform_idle_wakeups;
  uint32_t thread_timer_wakeups_bin_1;
  uint32_t thread_timer_wakeups_bin_2;
  _BYTE gap4A8[4];
  mach_port_name_t_0 ith_voucher_name;
  ipc_voucher_t ith_voucher;
  thread_group *preadopt_thread_group;
  thread_group *old_preadopt_thread_group;
  thread_group *bank_thread_group;
  union
  {
    thread_group *auto_join_thread_group;
    thread_group *work_interval_thread_group;
  };
  work_interval *th_work_interval;
  _BYTE gap4E0[4];
  uint32_t th_bound_cluster_id;
  turnstile_update_flags_t inheritor_flags;
  block_hint_t pending_block_hint;
  block_hint_t block_hint;
  uint32_t decompressions;
  int thread_region_page_shift;
  void *decmp_upl;
  knote *ith_knote;
};

/* 11612 */
typedef priority_queue_entry_sched *priority_queue_entry_sched_t_0;

/* 11613 */
enum hw_lock_status_t : __int32
{
  HW_LOCK_INVALID = 0xFFFFFFFF,
  HW_LOCK_CONTENDED = 0x0,
  HW_LOCK_ACQUIRED = 0x1,
};

/* 11614 */
union turnstile_type_gencount
{
  uint32_t value;
  struct
  {
    _BYTE gap0[4];
  };
};

/* 11615 */
struct mpsc_daemon_queue_0
{
  _BYTE gap0[8];
  mpsc_daemon_invoke_fn_t_0 mpd_invoke;
  union
  {
    mpsc_daemon_queue_t mpd_target;
    thread *mpd_thread;
    thread_call *mpd_call;
  };
  mpsc_queue_head mpd_queue;
  mpsc_queue_chain mpd_chain;
};

/* 11616 */
struct __attribute__((aligned(16))) ipc_port_2
{
  ipc_object ip_object;
  union
  {
    struct
    {
      _BYTE gap0[4];
    };
    waitq_1 ip_waitq;
  };
  ipc_mqueue_1 ip_messages;
  _BYTE gap40[8];
  union
  {
    uintptr_t ip_kobject;
    ipc_importance_task_t ip_imp_task;
    ipc_port *ip_sync_inheritor_port;
    knote *ip_sync_inheritor_knote;
    turnstile *ip_sync_inheritor_ts;
  };
  _BYTE gap50[8];
  ipc_port *ip_nsrequest;
  _BYTE gap60[16];
  mach_vm_address_t_0 ip_context;
  natural_t ip_impcount;
  mach_port_mscount_t ip_mscount;
  mach_port_rights_t ip_srights;
  mach_port_rights_t ip_sorights;
};

/* 11617 */
struct processor_set_0
{
  int pset_id;
  int online_processor_count;
  int cpu_set_low;
  int cpu_set_hi;
  int cpu_set_count;
  int last_chosen;
  uint64_t load_average;
  uint64_t pset_load_average[6];
  uint64_t pset_load_last_update;
  cpumap_t cpu_bitmask;
  cpumap_t recommended_bitmask;
  cpumap_t cpu_state_map[7];
  cpumap_t primary_map;
  cpumap_t realtime_map;
  cpumap_t cpu_available_map;
  __attribute__((aligned(128))) lck_ticket_t_0 sched_lock;
  run_queue_0 pset_runq;
  rt_queue rt_runq;
  uint64_t stealable_rt_threads_earliest_deadline;
  sched_clutch_root pset_clutch_root;
  int pset_runq_bound_count;
  cpumap_t pending_AST_URGENT_cpu_mask;
  cpumap_t pending_AST_PREEMPT_cpu_mask;
  cpumap_t pending_deferred_AST_cpu_mask;
  cpumap_t pending_spill_cpu_mask;
  cpumap_t rt_pending_spill_cpu_mask;
  ipc_port *pset_self;
  ipc_port *pset_name_self;
  processor_set_t pset_list;
  pset_node_t node;
  uint32_t pset_cluster_id;
  pset_cluster_type_t pset_cluster_type;
  cluster_type_t_0 pset_type;
  bool is_SMT;
};

/* 11618 */
struct select_set_0
{
  struct
  {
    _BYTE gap0[4];
  };
  hw_lck_ticket_t selset_interlock;
  union
  {
    circle_queue_head_t_0 selset_queue;
    priority_queue_sched_max selset_prio_queue;
    turnstile *selset_ts;
  };
  union
  {
    circle_queue_head_t_0 selset_links;
    waitq_link_list_t selset_sellinks;
    void *selset_inheritor;
    mpsc_queue_chain selset_defer;
  };
  uint64_t selset_id;
};

/* 11619 */
struct waitq_set_0
{
  struct
  {
    _BYTE gap0[4];
  };
  hw_lck_ticket_t wqset_interlock;
  union
  {
    circle_queue_head_t_0 wqset_queue;
    priority_queue_sched_max wqset_prio_queue;
    turnstile *wqset_ts;
  };
  union
  {
    circle_queue_head_t_0 wqset_links;
    waitq_link_list_t wqset_sellinks;
    void *wqset_inheritor;
    mpsc_queue_chain wqset_defer;
  };
  circle_queue_head_t_0 wqset_preposts;
};

/* 11620 */
struct __attribute__((aligned(4))) turnstile_1
{
  union
  {
    struct
    {
      _BYTE gap0[4];
    };
    waitq_1 ts_waitq;
  };
  union
  {
    turnstile_list ts_free_turnstiles;
    struct
    {
      turnstile *sle_next;
    } ts_free_elm;
    mpsc_queue_chain ts_deallocate_link;
  };
  priority_queue_sched_max ts_inheritor_queue;
  priority_queue_entry_sched ts_inheritor_links;
  struct
  {
    turnstile *sle_next;
  } ts_htable_link;
  uintptr_t ts_proprietor;
  os_ref_atomic_t ts_refcount;
  uint32_t ts_type_gencount;
  uint32_t ts_prim_count;
  turnstile_update_flags_t ts_inheritor_flags;
  uint8_t ts_priority;
};

/* 11621 */
struct thread_5
{
  union
  {
    queue_chain_t_0 runq_links;
    queue_chain_t_0 wait_links;
    mpsc_queue_chain mpsc_links;
    priority_queue_entry_sched wait_prioq_links;
  };
  event64_t wait_event;
  processor_t runq;
  waitq_t waitq;
  turnstile *turnstile;
  void *inheritor;
  priority_queue_sched_max sched_inheritor_queue;
  priority_queue_sched_max base_inheritor_queue;
  priority_queue_entry_stable th_clutch_runq_link;
  priority_queue_entry_sched th_clutch_pri_link;
  queue_chain_t_0 th_clutch_timeshare_link;
  simple_lock_data_t_0 sched_lock;
  simple_lock_data_t_0 wake_lock;
  uint16_t options;
  bool wake_active;
  bool at_safe_point;
  uint8_t sched_saved_run_weight;
  ast_t reason;
  uint32_t quantum_remaining;
  wait_result_t wait_result;
  thread_rr_state_t t_rr_state;
  thread_continue_t continuation;
  void *parameter;
  vm_offset_t kernel_stack;
  vm_offset_t reserved_stack;
  machine_thread machine;
  int state;
  sched_mode_t sched_mode;
  sched_mode_t saved_mode;
  sched_bucket_t th_sched_bucket;
  sfi_class_id_t sfi_class;
  sfi_class_id_t sfi_wait_class;
  uint32_t sched_flags;
  int16_t sched_pri;
  int16_t base_pri;
  int16_t req_base_pri;
  int16_t max_priority;
  int16_t task_priority;
  int16_t promotion_priority;
  uint16_t priority_floor_count;
  int16_t suspend_count;
  int iotier_override;
  os_ref_atomic_t ref_count;
  uint32_t rwlock_count;
  integer_t importance;
  integer_t depress_timer_active;
  timer_call_t depress_timer;
  struct
  {
    uint32_t period;
    uint32_t computation;
    uint32_t constraint;
    bool preemptible;
    uint8_t priority_offset;
    uint64_t deadline;
  } realtime;
  uint64_t last_run_time;
  uint64_t last_made_runnable_time;
  uint64_t last_basepri_change_time;
  uint64_t same_pri_latency;
  uint64_t workq_quantum_deadline;
  thread_group *thread_group;
  sched_group_t sched_group;
  processor_t bound_processor;
  processor_t last_processor;
  processor_t chosen_processor;
  uint64_t computation_metered;
  uint64_t computation_epoch;
  uint64_t safe_release;
  void (*sched_call)(int, thread_t_0);
  natural_t sched_stamp;
  natural_t sched_usage;
  natural_t pri_shift;
  natural_t cpu_usage;
  natural_t cpu_delta;
  uint32_t c_switch;
  uint32_t p_switch;
  uint32_t ps_switch;
  integer_t mutex_count;
  uint64_t sched_time_save;
  uint64_t vtimer_user_save;
  uint64_t vtimer_prof_save;
  uint64_t vtimer_rlim_save;
  uint64_t vtimer_qos_save;
  timer_data_t runnable_timer;
  recount_thread th_recount;
  uint64_t wait_sfi_begin_time;
  queue_chain_t_0 affinity_threads;
  affinity_set_t affinity_set;
  task_watch_t *taskwatch;
  union
  {
    struct
    {
      mach_msg_return_t state;
      mach_port_seqno_t seqno;
      ipc_object_t object;
      mach_vm_address_t_0 msg_addr;
      mach_vm_address_t_0 aux_addr;
      mach_msg_size_t max_msize;
      mach_msg_size_t max_asize;
      mach_msg_size_t msize;
      mach_msg_size_t asize;
      _BYTE gap30[8];
      mach_port_name_t_0 receiver_name;
      union
      {
        ipc_kmsg *kmsg;
        ipc_mqueue *peekq;
      };
    } receive;
    struct
    {
      semaphore *waitsemaphore;
      semaphore *signalsemaphore;
      int options;
      kern_return_t result;
      mach_msg_continue_t continuation;
    } sema;
    struct
    {
      void *tls[8];
    } iokit;
  } saved;
  union
  {
    thread_call_thread_state *thc_state;
    struct
    {
      mach_exception_code_t code;
      mach_exception_subcode_t subcode;
    } guard_exc_info;
  };
  int32_t user_stop_count;
  natural_t ith_assertions;
  circle_queue_head_t_0 ith_messages;
  mach_port_t_2 ith_kernel_reply_port;
  volatile ast_t ast;
  vm_offset_t recover;
  queue_chain_t_0 threads;
  queue_chain_t_0 task_threads;
  thread_ro *t_tro;
  vm_map_t_0 map;
  thread_t_1 handoff_thread;
  timer_call_t wait_timer;
  uint16_t wait_timer_active;
  bool wait_timer_armed;
  lck_mtx_t_0 mutex;
  ipc_port *ith_special_reply_port;
  uint16_t t_dtrace_flags;
  uint16_t t_dtrace_inprobe;
  uint32_t t_dtrace_predcache;
  int64_t t_dtrace_tracing;
  int64_t t_dtrace_vtime;
  clock_sec_t t_page_creation_time;
  uint32_t t_page_creation_count;
  uint32_t t_page_creation_throttled;
  int t_pagein_error;
  uint32_t kperf_ast;
  uint32_t kperf_pet_gen;
  uint32_t kperf_c_switch;
  uint32_t kperf_pet_cnt;
  uint64_t *kpc_buf;
  uint32_t syscalls_unix;
  uint32_t syscalls_mach;
  ledger_t t_ledger;
  ledger_t t_threadledger;
  ledger_t t_bankledger;
  uint64_t t_deduct_bank_ledger_time;
  uint64_t t_deduct_bank_ledger_energy;
  uint64_t thread_id;
  uint32_t ctid;
  uint32_t ctsid;
  thread_requested_policy requested_policy;
  thread_effective_policy effective_policy;
  thread_qos_override *overrides;
  uint32_t kevent_overrides;
  uint8_t user_promotion_basepri;
  uint8_t kern_promotion_schedpri;
  uint16_t kevent_ast_bits;
  io_stat_info_t thread_io_stats;
  uint32_t thread_callout_interrupt_wakeups;
  uint32_t thread_callout_platform_idle_wakeups;
  uint32_t thread_timer_wakeups_bin_1;
  uint32_t thread_timer_wakeups_bin_2;
  _BYTE gap4A8[4];
  mach_port_name_t_0 ith_voucher_name;
  ipc_voucher_t ith_voucher;
  thread_group *preadopt_thread_group;
  thread_group *old_preadopt_thread_group;
  thread_group *bank_thread_group;
  union
  {
    thread_group *auto_join_thread_group;
    thread_group *work_interval_thread_group;
  };
  work_interval *th_work_interval;
  _BYTE gap4E0[4];
  uint32_t th_bound_cluster_id;
  turnstile_update_flags_t inheritor_flags;
  block_hint_t pending_block_hint;
  block_hint_t block_hint;
  uint32_t decompressions;
  int thread_region_page_shift;
  void *decmp_upl;
  knote *ith_knote;
};

/* 11622 */
struct __attribute__((aligned(8))) processor_1
{
  processor_state_t state;
  bool is_SMT;
  bool is_recommended;
  bool current_is_NO_SMT;
  bool current_is_bound;
  bool current_is_eagerpreempt;
  thread *active_thread;
  thread *idle_thread;
  thread *startup_thread;
  processor_set_t processor_set;
  int current_pri;
  sfi_class_id_t current_sfi_class;
  perfcontrol_class_t current_perfctl_class;
  pset_cluster_type_t current_recommended_pset_type;
  thread_urgency_t current_urgency;
  int runq_bound_count;
  thread_group *current_thread_group;
  int starting_pri;
  int cpu_id;
  uint64_t quantum_end;
  uint64_t last_dispatch;
  uint64_t kperf_last_sample_time;
  uint64_t deadline;
  bool first_timeslice;
  bool processor_offlined;
  bool must_idle;
  bool running_timers_active;
  timer_call_0 running_timers[2];
  run_queue_0 runq;
  recount_processor pr_recount;
  processor_t processor_primary;
  processor_t processor_secondary;
  ipc_port *processor_self;
  processor_t processor_list;
  uint64_t timer_call_ttd;
  simple_lock_data_t_0 start_state_lock;
  processor_reason_t last_startup_reason;
  processor_reason_t last_shutdown_reason;
  processor_reason_t last_recommend_reason;
  processor_reason_t last_derecommend_reason;
  bool shutdown_temporary;
  bool shutdown_locked;
};

/* 11623 */
struct timer_coalescing_priority_params_t
{
  uint32_t powergate_latency_abstime;
  uint32_t idle_entry_timer_processing_hdeadline_threshold_abstime;
  uint32_t interrupt_timer_coalescing_ilat_threshold_abstime;
  uint32_t timer_resort_threshold_abstime;
  int32_t timer_coalesce_rt_shift;
  int32_t timer_coalesce_bg_shift;
  int32_t timer_coalesce_kt_shift;
  int32_t timer_coalesce_fp_shift;
  int32_t timer_coalesce_ts_shift;
  uint64_t timer_coalesce_rt_abstime_max;
  uint64_t timer_coalesce_bg_abstime_max;
  uint64_t timer_coalesce_kt_abstime_max;
  uint64_t timer_coalesce_fp_abstime_max;
  uint64_t timer_coalesce_ts_abstime_max;
  uint32_t latency_qos_scale[6];
  uint64_t latency_qos_abstime_max[6];
  boolean_t latency_tier_rate_limited[6];
};

/* 11624 */
typedef thread_requested_qos_policy *thread_requested_qos_policy_t;

/* 11625 */
typedef thread_qos_policy *thread_qos_policy_t;

/* 11626 */
typedef thread_latency_qos_policy *thread_latency_qos_policy_t;

/* 11627 */
typedef thread_throughput_qos_policy *thread_throughput_qos_policy_t;

/* 11628 */
typedef thread_affinity_policy *thread_affinity_policy_t;

/* 11629 */
typedef thread_precedence_policy *thread_precedence_policy_t;

/* 11630 */
typedef thread_extended_policy *thread_extended_policy_t;

/* 11631 */
typedef thread_time_constraint_with_priority_policy *thread_time_constraint_with_priority_policy_t;

/* 11632 */
typedef sched_clutch *sched_clutch_t_0;

/* 11633 */
struct task_watchports_3
{
  os_refcnt_t tw_refcount;
  task_t_1 tw_task;
  thread_t_1 tw_thread;
  uint32_t tw_elem_array_count;
  task_watchport_elem_2 tw_elem[];
};

/* 11634 */
typedef thread_pri_floor_0 thread_pri_floor_t_0;

/* 11635 */
typedef thread_kernel_state *thread_kernel_state_t;

/* 11636 */
typedef thread_extended_info *thread_extended_info_t;

/* 11637 */
typedef policy_rr_info *policy_rr_info_t;

/* 11638 */
typedef policy_timeshare_info *policy_timeshare_info_t;

/* 11639 */
typedef thread_identifier_info *thread_identifier_info_t;

/* 11640 */
struct _thread_ledger_indices
{
  int cpu_time;
};

/* 11641 */
struct thread_6
{
  union
  {
    queue_chain_t_0 runq_links;
    queue_chain_t_0 wait_links;
    mpsc_queue_chain mpsc_links;
    priority_queue_entry_sched wait_prioq_links;
  };
  event64_t wait_event;
  processor_t runq;
  waitq_t waitq;
  turnstile *turnstile;
  void *inheritor;
  priority_queue_sched_max sched_inheritor_queue;
  priority_queue_sched_max base_inheritor_queue;
  priority_queue_entry_stable th_clutch_runq_link;
  priority_queue_entry_sched th_clutch_pri_link;
  queue_chain_t_0 th_clutch_timeshare_link;
  simple_lock_data_t_0 sched_lock;
  simple_lock_data_t_0 wake_lock;
  uint16_t options;
  bool wake_active;
  bool at_safe_point;
  uint8_t sched_saved_run_weight;
  ast_t reason;
  uint32_t quantum_remaining;
  wait_result_t wait_result;
  thread_rr_state_t t_rr_state;
  thread_continue_t continuation;
  void *parameter;
  vm_offset_t kernel_stack;
  vm_offset_t reserved_stack;
  machine_thread machine;
  int state;
  sched_mode_t sched_mode;
  sched_mode_t saved_mode;
  sched_bucket_t th_sched_bucket;
  sfi_class_id_t sfi_class;
  sfi_class_id_t sfi_wait_class;
  uint32_t sched_flags;
  int16_t sched_pri;
  int16_t base_pri;
  int16_t req_base_pri;
  int16_t max_priority;
  int16_t task_priority;
  int16_t promotion_priority;
  uint16_t priority_floor_count;
  int16_t suspend_count;
  int iotier_override;
  os_ref_atomic_t ref_count;
  uint32_t rwlock_count;
  integer_t importance;
  integer_t depress_timer_active;
  timer_call_t depress_timer;
  struct
  {
    uint32_t period;
    uint32_t computation;
    uint32_t constraint;
    bool preemptible;
    uint8_t priority_offset;
    uint64_t deadline;
  } realtime;
  uint64_t last_run_time;
  uint64_t last_made_runnable_time;
  uint64_t last_basepri_change_time;
  uint64_t same_pri_latency;
  uint64_t workq_quantum_deadline;
  thread_group *thread_group;
  sched_group_t sched_group;
  processor_t bound_processor;
  processor_t last_processor;
  processor_t chosen_processor;
  uint64_t computation_metered;
  uint64_t computation_epoch;
  uint64_t safe_release;
  void (*sched_call)(int, thread_t_0);
  natural_t sched_stamp;
  natural_t sched_usage;
  natural_t pri_shift;
  natural_t cpu_usage;
  natural_t cpu_delta;
  uint32_t c_switch;
  uint32_t p_switch;
  uint32_t ps_switch;
  integer_t mutex_count;
  uint64_t sched_time_save;
  uint64_t vtimer_user_save;
  uint64_t vtimer_prof_save;
  uint64_t vtimer_rlim_save;
  uint64_t vtimer_qos_save;
  timer_data_t runnable_timer;
  recount_thread th_recount;
  uint64_t wait_sfi_begin_time;
  queue_chain_t_0 affinity_threads;
  affinity_set_t affinity_set;
  task_watch_t *taskwatch;
  union
  {
    struct
    {
      mach_msg_return_t state;
      mach_port_seqno_t seqno;
      ipc_object_t object;
      mach_vm_address_t_0 msg_addr;
      mach_vm_address_t_0 aux_addr;
      mach_msg_size_t max_msize;
      mach_msg_size_t max_asize;
      mach_msg_size_t msize;
      mach_msg_size_t asize;
      _BYTE gap30[8];
      mach_port_name_t_0 receiver_name;
      union
      {
        ipc_kmsg *kmsg;
        ipc_mqueue *peekq;
      };
    } receive;
    struct
    {
      semaphore *waitsemaphore;
      semaphore *signalsemaphore;
      int options;
      kern_return_t result;
      mach_msg_continue_t continuation;
    } sema;
    struct
    {
      void *tls[8];
    } iokit;
  } saved;
  union
  {
    thread_call_thread_state *thc_state;
    struct
    {
      mach_exception_code_t code;
      mach_exception_subcode_t subcode;
    } guard_exc_info;
  };
  int32_t user_stop_count;
  natural_t ith_assertions;
  circle_queue_head_t ith_messages;
  mach_port_t_1 ith_kernel_reply_port;
  volatile ast_t ast;
  vm_offset_t recover;
  queue_chain_t_0 threads;
  queue_chain_t_0 task_threads;
  thread_ro *t_tro;
  vm_map_t_0 map;
  thread_t_1 handoff_thread;
  timer_call_t wait_timer;
  uint16_t wait_timer_active;
  bool wait_timer_armed;
  lck_mtx_t_0 mutex;
  ipc_port *ith_special_reply_port;
  uint16_t t_dtrace_flags;
  uint16_t t_dtrace_inprobe;
  uint32_t t_dtrace_predcache;
  int64_t t_dtrace_tracing;
  int64_t t_dtrace_vtime;
  clock_sec_t t_page_creation_time;
  uint32_t t_page_creation_count;
  uint32_t t_page_creation_throttled;
  int t_pagein_error;
  uint32_t kperf_ast;
  uint32_t kperf_pet_gen;
  uint32_t kperf_c_switch;
  uint32_t kperf_pet_cnt;
  uint64_t *kpc_buf;
  uint32_t syscalls_unix;
  uint32_t syscalls_mach;
  ledger_t t_ledger;
  ledger_t t_threadledger;
  ledger_t t_bankledger;
  uint64_t t_deduct_bank_ledger_time;
  uint64_t t_deduct_bank_ledger_energy;
  uint64_t thread_id;
  uint32_t ctid;
  uint32_t ctsid;
  thread_requested_policy requested_policy;
  thread_effective_policy effective_policy;
  thread_qos_override *overrides;
  uint32_t kevent_overrides;
  uint8_t user_promotion_basepri;
  uint8_t kern_promotion_schedpri;
  uint16_t kevent_ast_bits;
  io_stat_info_t thread_io_stats;
  uint32_t thread_callout_interrupt_wakeups;
  uint32_t thread_callout_platform_idle_wakeups;
  uint32_t thread_timer_wakeups_bin_1;
  uint32_t thread_timer_wakeups_bin_2;
  _BYTE gap4A8[4];
  mach_port_name_t_0 ith_voucher_name;
  ipc_voucher_t ith_voucher;
  thread_group *preadopt_thread_group;
  thread_group *old_preadopt_thread_group;
  thread_group *bank_thread_group;
  union
  {
    thread_group *auto_join_thread_group;
    thread_group *work_interval_thread_group;
  };
  work_interval *th_work_interval;
  _BYTE gap4E0[4];
  uint32_t th_bound_cluster_id;
  turnstile_update_flags_t inheritor_flags;
  block_hint_t pending_block_hint;
  block_hint_t block_hint;
  uint32_t decompressions;
  int thread_region_page_shift;
  void *decmp_upl;
  knote *ith_knote;
};

/* 11642 */
typedef task_policy_state *task_policy_state_t;

/* 11643 */
typedef task_suppression_policy *task_suppression_policy_t;

/* 11644 */
typedef task_category_policy *task_category_policy_t;

/* 11645 */
struct ipc_kmsg_0
{
  queue_chain_t_0 ikm_link;
  _BYTE gap10[16];
  ipc_importance_elem *ikm_importance;
  queue_chain_t_0 ikm_inheritance;
  mach_msg_size_t ikm_aux_size;
  uint32_t ikm_ppriority;
  union
  {
    struct
    {
      uint32_t ikm_sig_partial;
      uint32_t ikm_sig_full;
    };
    uint64_t ikm_signature;
  };
  _BYTE gap48[2];
  mach_msg_qos_t ikm_qos_override;
  mach_msg_size_t ikm_udata_size;
};

/* 11646 */
typedef task_flags_info *task_flags_info_t;

/* 11647 */
typedef task_wait_state_info *task_wait_state_info_t;

/* 11648 */
typedef task_vm_info *task_vm_info_t;

/* 11649 */
typedef task_events_info *task_events_info_t;

/* 11650 */
typedef policy_timeshare_base *policy_timeshare_base_t;

/* 11651 */
typedef policy_rr_base *policy_rr_base_t;

/* 11652 */
typedef task_kernelmemory_info *task_kernelmemory_info_t;

/* 11653 */
typedef task_extmod_info *task_extmod_info_t;

/* 11654 */
typedef task_dyld_info *task_dyld_info_t;

/* 11655 */
typedef task_absolutetime_info *task_absolutetime_info_t;

/* 11656 */
typedef task_thread_times_info *task_thread_times_info_t;

/* 11657 */
typedef mach_task_basic_info *mach_task_basic_info_t;

/* 11658 */
typedef task_basic_info_64_2 *task_basic_info_64_2_t;

/* 11659 */
typedef task_basic_info_32 *task_basic_info_32_t;

/* 11660 */
struct expired_task_statistics_t
{
  uint64_t total_user_time;
  uint64_t total_system_time;
  uint64_t task_interrupt_wakeups;
  uint64_t task_platform_idle_wakeups;
  uint64_t task_timer_wakeups_bin_1;
  uint64_t task_timer_wakeups_bin_2;
  uint64_t total_ptime;
  uint64_t total_pset_switches;
  uint64_t task_gpu_ns;
  uint64_t task_energy;
};

/* 11661 */
struct _task_ledger_indices
{
  int cpu_time;
  int tkm_private;
  int tkm_shared;
  int phys_mem;
  int wired_mem;
  int internal;
  int iokit_mapped;
  int external;
  int reusable;
  int alternate_accounting;
  int alternate_accounting_compressed;
  int page_table;
  int phys_footprint;
  int internal_compressed;
  int purgeable_volatile;
  int purgeable_nonvolatile;
  int purgeable_volatile_compressed;
  int purgeable_nonvolatile_compressed;
  int tagged_nofootprint;
  int tagged_footprint;
  int tagged_nofootprint_compressed;
  int tagged_footprint_compressed;
  int network_volatile;
  int network_nonvolatile;
  int network_volatile_compressed;
  int network_nonvolatile_compressed;
  int media_nofootprint;
  int media_footprint;
  int media_nofootprint_compressed;
  int media_footprint_compressed;
  int graphics_nofootprint;
  int graphics_footprint;
  int graphics_nofootprint_compressed;
  int graphics_footprint_compressed;
  int neural_nofootprint;
  int neural_footprint;
  int neural_nofootprint_compressed;
  int neural_footprint_compressed;
  int platform_idle_wakeups;
  int interrupt_wakeups;
  int sfi_wait_times[17];
  int cpu_time_billed_to_me;
  int cpu_time_billed_to_others;
  int physical_writes;
  int logical_writes;
  int logical_writes_to_external;
  int energy_billed_to_me;
  int energy_billed_to_others;
  int memorystatus_dirty_time;
  int fs_metadata_writes;
  int swapins;
};

/* 11662 */
typedef long smr_delta_t;

/* 11663 */
struct smrq_link_0
{
  __smrq_link_t next;
  __smrq_link_t *prev;
};

/* 11664 */
enum next_processor_type_t : __int32
{
  none = 0x0,
  backup = 0x1,
  followup = 0x2,
  spill = 0x3,
};

/* 11665 */
struct sched_statistics
{
  uint32_t csw_count;
  uint32_t preempt_count;
  uint32_t preempted_rt_count;
  uint32_t preempted_by_rt_count;
  uint32_t rt_sched_count;
  uint32_t interrupt_count;
  uint32_t ipi_count;
  uint32_t timer_pop_count;
  uint32_t idle_transitions;
  uint32_t quantum_timer_expirations;
};

/* 11666 */
typedef run_queue *run_queue_t_0;

/* 11667 */
typedef sched_average *sched_average_t;

/* 11668 */
struct task_2
{
  lck_mtx_t_0 lock;
  os_refcnt_t ref_count;
  bool active;
  bool ipc_active;
  bool halting;
  bool message_app_suspended;
  uint32_t vtimers;
  uint32_t loadTag;
  uint64_t task_uniqueid;
  __attribute__((aligned(16))) queue_chain_t_0 tasks;
  task_watchports *watchports;
  turnstile_inheritor_t returnwait_inheritor;
  sched_group_t sched_group;
  queue_head_t_0 threads;
  restartable_ranges *t_rr_ranges;
  processor_set_t pset_hint;
  affinity_space *affinity_space;
  int thread_count;
  uint32_t active_thread_count;
  int suspend_count;
  integer_t user_stop_count;
  integer_t legacy_stop_count;
  int16_t priority;
  int16_t max_priority;
  integer_t importance;
  uint64_t total_runnable_time;
  recount_task tk_recount;
  lck_mtx_t_0 itk_lock_data;
  _BYTE gapC8[48];
  exception_action exc_actions[14];
  _BYTE gap2B8[80];
  ledger_t ledger;
  queue_head_t_0 semaphore_list;
  int semaphores_owned;
  unsigned int priv_flags;
  __attribute__((aligned(16))) uint64_t rop_pid;
  uint64_t jop_pid;
  uint8_t disable_user_jop;
  arm64_uexc_region_t uexc;
  bool preserve_x18;
  counter_t faults;
  counter_t pageins;
  counter_t cow_faults;
  counter_t messages_sent;
  counter_t messages_received;
  uint32_t decompressions;
  uint32_t syscalls_mach;
  uint32_t syscalls_unix;
  uint32_t c_switch;
  uint32_t p_switch;
  uint32_t ps_switch;
  proc_ro *bsd_info_ro;
  kcdata_descriptor_t corpse_info;
  uint64_t crashed_thread_id;
  queue_chain_t_0 corpse_tasks;
  label *crash_label;
  volatile uint32_t t_flags;
  uint32_t t_procflags;
  mach_vm_address_t_0 all_image_info_addr;
  mach_vm_size_t_0 all_image_info_size;
  uint32_t t_kpc;
  bool pidsuspended;
  bool frozen;
  bool changing_freeze_state;
  bool is_large_corpse;
  _BYTE gap400[2];
  uint8_t rusage_cpu_flags;
  uint8_t rusage_cpu_percentage;
  uint8_t rusage_cpu_perthr_percentage;
  uint8_t t_returnwaitflags;
  bool shared_region_auth_remapped;
  char *shared_region_id;
  vm_shared_region *shared_region;
  uint64_t rusage_cpu_interval;
  uint64_t rusage_cpu_perthr_interval;
  uint64_t rusage_cpu_deadline;
  thread_call_t rusage_cpu_callt;
  queue_head_t_0 task_watchers;
  int num_taskwatchers;
  int watchapplying;
  bank_task *bank_context;
  ipc_importance_task *task_imp_base;
  vm_extmod_statistics_data_t extmod_statistics;
  task_requested_policy requested_policy;
  task_effective_policy effective_policy;
  _BYTE gap4A0[8];
  io_stat_info_t task_io_stats;
  task_writes_counters task_writes_counters_internal;
  task_writes_counters task_writes_counters_external;
  _cpu_time_qos_stats cpu_time_eqos_stats;
  _cpu_time_qos_stats cpu_time_rqos_stats;
  uint32_t task_timer_wakeups_bin_1;
  uint32_t task_timer_wakeups_bin_2;
  uint64_t task_gpu_ns;
  uint8_t task_can_transfer_memory_ownership;
  uint8_t task_objects_disowning;
  uint8_t task_objects_disowned;
  int task_volatile_objects;
  int task_nonvolatile_objects;
  int task_owned_objects;
  queue_head_t_0 task_objq;
  lck_mtx_t_0 task_objq_lock;
  _BYTE gap5A0[8];
  coalition_t coalition[2];
  queue_chain_t_0 task_coalition[2];
  uint64_t dispatchqueue_offset;
  task_exc_guard_behavior_t task_exc_guard;
  mach_vm_address_t_0 mach_header_vm_address;
  queue_head_t_0 io_user_clients;
  boolean_t donates_own_pages;
  uint32_t task_shared_region_slide;
  uint64_t task_fs_metadata_writes;
  uuid_t_0 task_shared_region_uuid;
  uint64_t memstat_dirty_start;
  vmobject_list_output_t corpse_vmobject_list;
  uint64_t corpse_vmobject_list_size;
  vm_deferred_reclamation_metadata_t deferred_reclamation_metadata;
};

/* 11669 */
struct recount_coalition_0
{
  recount_usage *rco_exited;
};

/* 11670 */
typedef processor_set_load_info *processor_set_load_info_t;

/* 11671 */
typedef processor_set_basic_info *processor_set_basic_info_t;

/* 11672 */
typedef processor_cpu_load_info *processor_cpu_load_info_t;

/* 11673 */
typedef processor_basic_info *processor_basic_info_t;

/* 11674 */
struct lck_ticket_startup_spec_0
{
  lck_ticket_t *lck;
  lck_grp_t *lck_grp;
};

/* 11675 */
typedef mk_timer_expire_msg mk_timer_expire_msg_t;

/* 11676 */
typedef policy_rr_limit policy_rr_limit_data_t;

/* 11677 */
typedef policy_fifo_limit policy_fifo_limit_data_t;

/* 11678 */
typedef policy_timeshare_limit policy_timeshare_limit_data_t;

/* 11679 */
typedef policy_timeshare_limit *policy_timeshare_limit_t;

/* 11680 */
typedef policy_fifo_limit *policy_fifo_limit_t;

/* 11681 */
typedef policy_fifo_base *policy_fifo_base_t;

/* 11682 */
typedef policy_rr_limit *policy_rr_limit_t;

/* 11683 */
struct machine_info
{
  integer_t major_version;
  integer_t minor_version;
  integer_t max_cpus;
  uint32_t memory_size;
  uint64_t max_mem;
  uint32_t physical_cpu;
  integer_t physical_cpu_max;
  uint32_t logical_cpu;
  integer_t logical_cpu_max;
};

/* 11684 */
struct __block_literal_31_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
};

/* 11685 */
struct __block_literal_32_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor_withcopydispose *__descriptor;
  struct *lck_rw_type;
  lck_rw_t *lock;
};

/* 11686 */
struct __block_literal_30_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor_withcopydispose *__descriptor;
  struct *lck_rw_type;
  lck_rw_t *lock;
};

/* 11687 */
struct __block_literal_29_0
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(ctid_t *);
  __block_descriptor *__descriptor;
  cond_swi_var_t cond;
  uint64_t check_mask;
  cond_swi_var64_s expected_cond;
};

/* 11688 */
struct __block_literal_21_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
};

/* 11689 */
struct __block_literal_26_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor_withcopydispose *__descriptor;
  struct *lck_rw_type;
  lck_rw_t *lock;
};

/* 11690 */
struct __block_literal_25_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_rw_t *lock;
};

/* 11691 */
struct __block_literal_24_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor_withcopydispose *__descriptor;
  struct *lck_rw_type;
  lck_rw_t *lock;
};

/* 11692 */
struct __block_literal_23_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor_withcopydispose *__descriptor;
  struct *lck_rw_type;
  lck_rw_t *lock;
};

/* 11693 */
struct __block_literal_22_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor_withcopydispose *__descriptor;
  struct *lck_rw_type;
  lck_rw_t *lock;
};

/* 11694 */
struct __block_literal_13_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
};

/* 11695 */
struct __block_literal_20_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_mtx_t *lock;
};

/* 11696 */
struct __block_literal_19_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_mtx_t *lock;
};

/* 11697 */
struct __block_literal_18_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_mtx_t *lock;
};

/* 11698 */
struct __block_literal_17_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_mtx_t *lock;
};

/* 11699 */
struct __block_literal_16_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_mtx_t *lock;
};

/* 11700 */
struct __block_literal_15_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_mtx_t *lock;
};

/* 11701 */
struct __block_literal_14_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_mtx_t *lock;
};

/* 11702 */
struct __block_literal_9_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
};

/* 11703 */
struct __block_literal_12_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_ticket_t *lock;
};

/* 11704 */
struct __block_literal_11_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_ticket_t *lock;
  lck_grp_t *grp;
};

/* 11705 */
struct __block_literal_10_0
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_ticket_t *lock;
};

/* 11706 */
struct __block_literal_8_2
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  hw_lck_ticket_t *lock;
};

/* 11707 */
struct __block_literal_7_4
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  hw_lck_ticket_t *lock;
};

/* 11708 */
struct __block_literal_1_30
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
};

/* 11709 */
struct __block_literal_4_11
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_spin_t *lock;
};

/* 11710 */
struct __block_literal_3_11
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_spin_t *lock;
};

/* 11711 */
struct __block_literal_2_14
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(void);
  __block_descriptor *__descriptor;
  lck_spin_t *lock;
};

/* 11712 */
enum gate_wait_result_t : __int32
{
  GATE_HANDOFF = 0x0,
  GATE_OPENED = 0x1,
  GATE_TIMED_OUT = 0x2,
  GATE_INTERRUPTED = 0x3,
};

/* 11713 */
typedef void (*void_func_void)(void);

/* 11714 */
enum lck_rw_drain_state_t : __int32
{
  LCK_RW_DRAIN_S_DRAINED = 0x0,
  LCK_RW_DRAIN_S_NOT_DRAINED = 0x1,
  LCK_RW_DRAIN_S_EARLY_RETURN = 0x2,
  LCK_RW_DRAIN_S_TIMED_OUT = 0x3,
};

/* 11715 */
enum lck_rw_grab_state_t : __int32
{
  LCK_RW_GRAB_S_NOT_LOCKED = 0x0,
  LCK_RW_GRAB_S_LOCKED = 0x1,
  LCK_RW_GRAB_S_EARLY_RETURN = 0x2,
  LCK_RW_GRAB_S_TIMED_OUT = 0x3,
};

/* 11716 */
typedef const hw_spin_policy *hw_spin_policy_t_0;

/* 11717 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_1_31
{
  void *__isa;
  int __flags;
  int __reserved;
  bool (*__FuncPtr)(lck_grp_t *);
  __block_descriptor_withcopydispose *__descriptor;
  struct *count;
  lockgroup_info_t *info;
  uint32_t needed;
};

/* 11718 */
struct lck_debug_state
{
  uint32_t lds_value;
  long lds_counts[2];
};

/* 11719 */
struct __attribute__((packed)) __attribute__((aligned(1))) __block_literal_1_32
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(zone_t);
  __block_descriptor *__descriptor;
  zone_id_t *kheap_zstart;
  uint32_t size;
  uint32_t i;
  _BYTE gap30;
};

/* 11720 */
union mach_msg_descriptor_t_0
{
  mach_msg_port_descriptor_t_0 port;
  mach_msg_ool_descriptor32_t out_of_line;
  mach_msg_ool_ports_descriptor32_t ool_ports;
  mach_msg_type_descriptor_t_0 type;
  mach_msg_guarded_port_descriptor32_t guarded_port;
};

/* 11721 */
struct __Request__host_calendar_set_t
{
  mach_msg_header_t_0 Head;
};

/* 11722 */
struct __Request__host_calendar_changed_t
{
  mach_msg_header_t_0 Head;
};

/* 11723 */
typedef vm_extmod_statistics *vm_extmod_statistics_t;

/* 11724 */
typedef task_power_info_v2 *task_power_info_v2_t_0;

/* 11725 */
typedef task_power_info *task_power_info_t_0;

/* 11726 */
typedef host_cpu_load_info *host_cpu_load_info_t;

/* 11727 */
typedef vm_statistics *vm_statistics_t;

/* 11728 */
typedef host_load_info *host_load_info_t;

/* 11729 */
typedef host_preferred_user_arch *host_preferred_user_arch_t;

/* 11730 */
typedef host_can_has_debugger_info *host_can_has_debugger_info_t;

/* 11731 */
typedef host_priority_info *host_priority_info_t;

/* 11732 */
typedef host_sched_info *host_sched_info_t;

/* 11733 */
typedef host_basic_info *host_basic_info_t;

/* 11734 */
typedef task_power_info_v2 task_power_info_v2_data_t;

/* 11735 */
typedef host_cpu_load_info host_cpu_load_info_data_t;

/* 11736 */
typedef vm_statistics vm_statistics_data_t;

/* 11737 */
typedef host_load_info host_load_info_data_t;

/* 11738 */
typedef host host_data_t;

/* 11739 */
typedef natural_t thread_state_data_t[1296];

/* 11740 */
struct lck_spin_startup_spec_1
{
  lck_spin_t *lck;
  lck_grp_t *lck_grp;
  lck_attr_t *lck_attr;
};

/* 11741 */
typedef int atomic_int;

/* 11742 */
struct zone_view_startup_spec_0
{
  zone_view_t zv_view;
  _BYTE gap8[8];
  vm_size_t_0 zv_size;
};

/* 11743 */
struct core_analytics_family_service;

/* 11744 */
struct coalition_ledger_indices
{
  int logical_writes;
};

/* 11745 */
struct latched_time
{
  uint64_t monotonic_time_usec;
  uint64_t mach_time;
};

/* 11746 */
typedef task_affinity_tag_info *task_affinity_tag_info_t;

/* 11747 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_1_33
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(waitq *);
  __block_descriptor_withcopydispose *__descriptor;
  struct *actual;
  mach_port_name_t_0 *names;
  ipc_entry_num_t maxnames;
};

/* 11748 */
struct mach_msg_user_base_t
{
  mach_msg_user_header_t header;
  mach_msg_body_t_0 body;
};

/* 11749 */
struct __attribute__((aligned(8))) ipc_importance_task_0
{
  ipc_importance_elem iit_elem;
  task_t_1 iit_task;
  queue_head_t_0 iit_inherits;
  queue_t iit_updateq;
  queue_chain_t_0 iit_updates;
  queue_chain_t_0 iit_props;
  uint64_t iit_updatetime;
  uint64_t iit_transitions;
  uint32_t iit_assertcnt;
  uint32_t iit_legacy_externcnt;
  uint32_t iit_legacy_externdrop;
};

/* 11750 */
struct task_watchports_4
{
  os_refcnt_t tw_refcount;
  task_t_1 tw_task;
  thread_t_0 tw_thread;
  uint32_t tw_elem_array_count;
  task_watchport_elem_2 tw_elem[];
};

/* 11751 */
typedef ipc_port_request *ipc_port_request_t;

/* 11752 */
typedef mach_msg_type_number_t mach_voucher_attr_recipe_size_t;

/* 11753 */
struct smr_shash_mut_cursor_t_0
{
  hw_lck_ptr_t *head;
  __smrq_slink_t *prev;
};

/* 11754 */
typedef ipc_voucher_attr_recipe_data_t *ipc_voucher_attr_recipe_t;

/* 11755 */
typedef mach_voucher_attr_recipe_data_t *mach_voucher_attr_recipe_t;

/* 11756 */
struct __attribute__((packed)) __attribute__((aligned(4))) __block_literal_1_34
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(ipc_object_t);
  __block_descriptor *__descriptor;
  mach_port_name_t_0 name;
};

/* 11757 */
struct __block_literal_1_35
{
  void *__isa;
  int __flags;
  int __reserved;
  void (*__FuncPtr)(ipc_object_t);
  __block_descriptor *__descriptor;
  ipc_space_t space;
  _BYTE gap28[4];
  mach_port_name_t_0 name;
};

/* 11758 */
typedef ipc_mqueue *ipc_mqueue_t_0;

/* 11759 */
typedef mach_port_name_t_0 mach_port_gen_t;

/* 11760 */
struct mach_header_0
{
  uint32_t magic;
  cpu_type_t_0 cputype;
  cpu_subtype_t_0 cpusubtype;
  uint32_t filetype;
  uint32_t ncmds;
  uint32_t sizeofcmds;
  uint32_t flags;
};

/* 11761 */
typedef main_bin_spec_note main_bin_spec_note_t;

/* 11762 */
typedef kern_return_t (*legacy_sw_vers_registered_cb)(void *, core_save_sw_vers_cb, void *);

/* 11763 */
typedef panic_context_note panic_context_note_t;

/* 11764 */
struct __attribute__((aligned(8))) kdp_core_out_state_0
{
  struct
  {
    kdp_output_stage *stqh_first;
    kdp_output_stage **stqh_last;
  } kcos_out_stage;
  kdp_output_stage *kcos_encryption_stage;
  bool kcos_enforce_encryption;
  uint64_t kcos_totalbytes;
  uint64_t kcos_bytes_written;
  uint64_t kcos_lastpercent;
  kern_return_t kcos_error;
};

/* 11765 */
struct kdp_manual_pkt
{
  unsigned __int8 data[128];
  unsigned int len;
  boolean_t input;
};

/* 11766 */
struct __attribute__((packed)) __attribute__((aligned(4))) stackshot_task_codesigning_info
{
  uint64_t csflags;
  uint32_t cs_trust_level;
};

/* 11767 */
struct stackshot_cpu_architecture
{
  int32_t cputype;
  int32_t cpusubtype;
};

/* 11768 */
struct dyld_shared_cache_loadinfo
{
  uint64_t sharedCacheSlide;
  uuid_t_0 sharedCacheUUID;
  uint64_t sharedCacheUnreliableSlidBaseAddress;
  uint64_t sharedCacheSlidFirstMapping;
};

/* 11769 */
struct dyld_aot_cache_uuid_info
{
  uint64_t x86SlidBaseAddress;
  uuid_t_0 x86UUID;
  uint64_t aotSlidBaseAddress;
  uuid_t_0 aotUUID;
};

/* 11770 */
struct dyld_shared_cache_loadinfo_v2
{
  uint64_t sharedCacheSlide;
  uuid_t_0 sharedCacheUUID;
  uint64_t sharedCacheUnreliableSlidBaseAddress;
  uint64_t sharedCacheSlidFirstMapping;
  uint32_t sharedCacheID;
  uint32_t sharedCacheFlags;
};

/* 11771 */
typedef os_log_s *os_log_t_0;

/* 11772 */
enum thread_classification : __int32
{
  thread_classification::tc_full_snapshot = 0x0,
  thread_classification::tc_delta_snapshot = 0x1,
};

/* 11773 */
struct _stackshot_validation_state
{
  vm_offset_t last_valid_page_kva;
  size_t last_valid_size;
};

/* 11774 */
struct __attribute__((packed)) __attribute__((aligned(1))) stackshot_fault_stats
{
  uint32_t sfs_pages_faulted_in;
  uint64_t sfs_time_spent_faulting;
  uint64_t sfs_system_max_fault_time;
  uint8_t sfs_stopped_faulting;
};

/* 11775 */
struct memory_object_4
{
  mo_ipc_object_bits_t mo_ikot;
  os_ref_atomic_t mo_ref;
  const memory_object_pager_ops_0 *mo_pager_ops;
  memory_object_control_t mo_control;
};

/* 11776 */
struct kdp_glob_t
{
  void *saved_state;
  thread_t_0 kdp_thread;
  int kdp_cpu;
  uint32_t session_key;
  unsigned int conn_seq;
  unsigned __int16 reply_port;
  unsigned __int16 exception_port;
  boolean_t is_conn;
  boolean_t is_halted;
  unsigned __int8 exception_seq;
  boolean_t exception_ack_needed;
};

/* 11777 */
enum kdp_req_t : __int32
{
  KDP_CONNECT = 0x0,
  KDP_DISCONNECT = 0x1,
  KDP_HOSTINFO = 0x2,
  KDP_VERSION = 0x3,
  KDP_MAXBYTES = 0x4,
  KDP_READMEM = 0x5,
  KDP_WRITEMEM = 0x6,
  KDP_READREGS = 0x7,
  KDP_WRITEREGS = 0x8,
  KDP_LOAD = 0x9,
  KDP_IMAGEPATH = 0xA,
  KDP_SUSPEND = 0xB,
  KDP_RESUMECPUS = 0xC,
  KDP_EXCEPTION = 0xD,
  KDP_TERMINATION = 0xE,
  KDP_BREAKPOINT_SET = 0xF,
  KDP_BREAKPOINT_REMOVE = 0x10,
  KDP_REGIONS = 0x11,
  KDP_REATTACH = 0x12,
  KDP_HOSTREBOOT = 0x13,
  KDP_READMEM64 = 0x14,
  KDP_WRITEMEM64 = 0x15,
  KDP_BREAKPOINT64_SET = 0x16,
  KDP_BREAKPOINT64_REMOVE = 0x17,
  KDP_KERNELVERSION = 0x18,
  KDP_READPHYSMEM64 = 0x19,
  KDP_WRITEPHYSMEM64 = 0x1A,
  KDP_READIOPORT = 0x1B,
  KDP_WRITEIOPORT = 0x1C,
  KDP_READMSR64 = 0x1D,
  KDP_WRITEMSR64 = 0x1E,
  KDP_DUMPINFO = 0x1F,
  KDP_INVALID_REQUEST = 0x20,
};

/* 11778 */
typedef uint32_t waitq_flags_t;

/* 11779 */
typedef __Request__UNDNotificationCreated_rpc_t _XUNDNotificationCreated_rpc::__Request;

/* 11780 */
typedef __Request__UNDAlertCompletedWithResult_rpc_t _XUNDAlertCompletedWithResult_rpc::__Request;

/* 11781 */
typedef struct {char data[64];}; *lockd_request::sp;

/* 11782 */
typedef struct {char data[76];}; *lockd_request::sp_0;

/* 11783 */
typedef struct *lockd_request::sp_1;

/* 11784 */
typedef __Reply__mach_gss_accept_sec_context_v2_t __Reply_0;

/* 11785 */
typedef __Reply__mach_gss_init_sec_context_v2_t __Reply_1;

/* 11786 */
typedef __Reply__mach_gss_accept_sec_context_t __Reply_2;

/* 11787 */
struct IOPMDriverCallEntry_0
{
  queue_chain_t_0 link;
  thread_t_0 thread;
  IOService_0 *target;
  const void *callMethod;
};

/* 11788 */
typedef IOVirtualRange_0 IOAddressRange_2;

/* 11789 */
typedef OSObject_0 OSContainer_0;

/* 11790 */
struct IOService::ExpansionData_1
{
  uint64_t authorizationID;
  IOLock_0 interruptStatisticsLock;
  IOInterruptAccountingReporter *interruptStatisticsArray;
  int interruptStatisticsArrayCount;
  OSObjectUserVars *uvars;
  IOServiceStateChangeVars *svars;
  IOInterruptSourcePrivate *interruptSourcesPrivate;
};

/* 11791 */
typedef OSSharedPtr<OSObject>_0 OSPtr<OSObject>_1;

/* 11792 */
typedef OSSharedPtr<OSSerialize> OSPtr<OSSerialize>_0;

/* 11793 */
typedef OSSharedPtr<OSCollectionIterator> OSPtr<OSCollectionIterator>_0;

/* 11794 */
typedef OSSharedPtr<OSBoolean> OSPtr<OSBoolean>_0;

/* 11795 */
typedef OSSharedPtr<OSNumber> OSPtr<OSNumber>_1;

/* 11796 */
typedef OSSharedPtr<OSKext> OSPtr<OSKext>_0;

/* 11797 */
struct OSKextAccount_1
{
  vm_allocation_site_t site;
  uint32_t loadTag;
  OSKext_0 *kext;
};

/* 11798 */
typedef kmod_info_0 kmod_info_t_2;

/* 11799 */
typedef OSTaggedPtr<const OSMetaClassBase>_0 OSArray::ArrayPtrType_2;

/* 11800 */
struct OSDictionary::dictEntry_1
{
  OSTaggedPtr<const OSSymbol>_0 key;
  OSTaggedPtr<const OSMetaClassBase>_0 value;
};

/* 11801 */
typedef OSSharedPtr<OSCollection> OSPtr<OSCollection>_0;

/* 11802 */
struct modctl_1
{
  modctl *mod_next;
  modctl *mod_stale;
  uint32_t mod_id;
  char mod_modname[64];
  int mod_loadcnt;
  char mod_loaded;
  uint16_t mod_flags;
  int mod_nenabled;
  vm_address_t_0 mod_address;
  vm_size_t_0 mod_size;
  UUID mod_uuid;
  dtrace_module_symbols *mod_user_symbols;
  int mod_sdtprobecnt;
  void *mod_sdtdesc;
};

/* 11803 */
typedef fbt_probe_0 fbt_probe_t_0;

/* 11806 */
struct $06D0163FE0D7AFE752A9F21F38483579
{
  unsigned __int8 var0;
  unsigned __int8 var1;
};

/* 11807 */
union $21A0B8C55E162B95726860E3902C60DF
{
  $06D0163FE0D7AFE752A9F21F38483579 var0;
  unsigned __int16 var1;
};

/* 11808 */
struct $61BBC7433AB937EC0F53BBAA789D64D2
{
  unsigned __int8 var0;
  __int32 var1 : 1;
  __int32 var2 : 1;
  __int32 var3 : 6;
  $21A0B8C55E162B95726860E3902C60DF var4;
};

/* 11809 */
union $313FAD88B60D472D7605E4B64B1271AA
{
  $61BBC7433AB937EC0F53BBAA789D64D2 var0;
  unsigned int var1;
};

/* 11810 */
union $72DC6413704F5B14E009C082116F69CD
{
  unsigned int var0;
  unsigned int var1;
};

/* 11811 */
struct $D913126095B9B499AEA3325DD5290A9D
{
  proc *var0;
  proc **var1;
};

/* 11812 */
struct $71D83D51AB0F57F7CF166351F850C832
{
  unsigned __int64 var0[2];
};

/* 11813 */
struct $812AD8FD76769878C97D29A36EA233D5
{
  proc *var0;
};

/* 11814 */
struct $000A64D9BEB15924FBECAF0C133B10A6
{
  uthread *var0;
  uthread **var1;
};

/* 11815 */
struct $C48B888A98C8538736DCABB21F85D3D0
{
  smrq_slink *var0;
};

/* 11816 */
struct $1CCF823CFDC2A51C60CCADDBBDE70FCA
{
  plimit *var0;
};

/* 11817 */
struct $EB391561F204C86BB773367EAEADC323
{
  pgrp *var0;
};

/* 11818 */
struct $16F5D149DC70348C10C3DF041714E0BB
{
  unsigned int var0;
  int var1;
  unsigned __int64 var2;
  vnode *var3;
  signed __int64 var4;
  unsigned int var5;
  unsigned int var6;
  unsigned int var7;
  unsigned __int8 var8;
  unsigned __int8 var9;
  char var10;
  unsigned __int8 var11;
  char var12[17];
  char var13[33];
  unsigned __int8 var14;
  int var15;
  unsigned int var16;
  unsigned __int8 var17[16];
  int var18;
  int var19;
};

/* 11819 */
union $235B9F39E090B34F340B5EA8B4244B28
{
  $16F5D149DC70348C10C3DF041714E0BB var0;
  proc_forkcopy_data var1;
};

/* 11820 */
struct $388508720E50061A2F9C6700BC3B948F
{
  aio_workq_entry *var0;
  aio_workq_entry **var1;
};

/* 11821 */
struct dictEntry
{
};

